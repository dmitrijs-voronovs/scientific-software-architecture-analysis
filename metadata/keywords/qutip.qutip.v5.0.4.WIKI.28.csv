id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.6/apidoc/classes.html:150116,Energy Efficiency,energy,energy,150116,"es; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of sigma-x for each of the qubits in the system. epsmax: int or list, optionalThe coefficients of sigma-z for each of the qubits in the system. w0: int, optionalThe base frequency of the resonator. eps: int or list, optionalThe epsilon for each of the qubits in the system. delta: int or list, optionalThe epsilon for each of the qubits in the system. g: int or list, optionalThe interaction strength for each of the qubit with the resonator. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. Attributes. sx_ops: listA list of sigmax Hamiltonians for each qubit. sz_ops: listA list of sigmaz Hamiltonians for each qubit. cavityqubit_ops: listA list of interacting Hamiltonians between cavity and each qubit. sx_u: arra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160307,Energy Efficiency,energy,energy,160307,"ol amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:175546,Energy Efficiency,schedul,schedule,175546,"ber of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If g",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:177688,Energy Efficiency,schedul,schedule,177688," match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: in",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:180355,Energy Efficiency,schedul,schedule,180355,"aved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181045,Energy Efficiency,Schedul,Scheduler,181045," A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware cons",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181122,Energy Efficiency,schedul,scheduler,181122," A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware cons",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181173,Energy Efficiency,schedul,schedules,181173,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181219,Energy Efficiency,reduce,reduce,181219,"te_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two inst",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181354,Energy Efficiency,schedul,scheduler,181354,"ionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Sinc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181548,Energy Efficiency,schedul,scheduler,181548,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181572,Energy Efficiency,schedul,schedule,181572,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181631,Energy Efficiency,reduce,reduce,181631,"pe (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:182725,Energy Efficiency,schedul,schedule,182725,"“ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instruct",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:182837,Energy Efficiency,Schedul,Schedule,182837,"“ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instruct",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:182916,Energy Efficiency,schedul,schedule,182916,"ubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183009,Energy Efficiency,schedul,scheduler,183009,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183708,Energy Efficiency,schedul,schedule,183708,"es_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183831,Energy Efficiency,schedul,schedule,183831," of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gat",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184191,Energy Efficiency,schedul,schedule,184191,"; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184268,Energy Efficiency,schedul,schedule,184268,"e of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit impo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184461,Energy Efficiency,schedul,schedule,184461," time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_g",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184540,Energy Efficiency,schedul,schedule,184540,"is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:184915,Energy Efficiency,schedul,schedule,184915,"ch instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185069,Energy Efficiency,schedul,scheduling,185069,"istance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185369,Energy Efficiency,schedul,scheduler,185369,"ction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185386,Energy Efficiency,Schedul,Scheduler,185386,"ction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185734,Energy Efficiency,schedul,scheduler,185734,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185746,Energy Efficiency,Schedul,Scheduler,185746,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185769,Energy Efficiency,schedul,scheduler,185769,"cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, ar",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:185779,Energy Efficiency,schedul,schedule,185779,"ains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly scuffled to explore; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. target",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186095,Energy Efficiency,reduce,reduce,186095,"re; larger search space. repeat_num: int, optionalRepeat the scheduling several times and use the best result.; Used together with random_shuffle=Ture. Returns. gate_cycle_indices or instruction_start_time: listThe cycle indices for each gate or; the start time for each instruction. Examples; >>> from qutip.qip.circuit import QubitCircuit; >>> from qutip.qip.scheduler import Scheduler; >>> circuit = QubitCircuit(7); >>> circuit.add_gate(""SNOT"", 3) # gate0; >>> circuit.add_gate(""CZ"", 5, 3) # gate1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[so",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:190229,Energy Efficiency,reduce,reduce,190229,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204424,Energy Efficiency,reduce,reduce,204424,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219317,Energy Efficiency,efficient,efficient,219317," This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_nor",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8346,Integrability,depend,dependent,8346,"sarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.Q",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8668,Integrability,depend,dependent,8668,"(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8739,Integrability,depend,dependent,8739,"in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:8844,Integrability,depend,dependent,8844,"e removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Notes; Experimental. static evaluate(qobj_list, t, args)[source]¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]. is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args). and. qobj_list = [H0, [H1, ‘sin(w * t)’]]. is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters. qobj_listlistA nested list of Qobj instances and corresponding time-dependent; coefficients. tfloatThe time for which to evaluate the time-dependent Qobj instance. argsdictionaryA dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns. outputqutip.QobjA Qobj instance that represents the value of qobj_list at time t. expm(method='dense')[source]¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters. methodstr {‘dense’, ‘sparse’}Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’. Since the; exponential of a matrix is nearly always dense, method=’dense’; is set as default.s. Returns. operqutip.QobjExponentiated quantum operator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17084,Integrability,depend,dependent,17084,"lues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t:",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17366,Integrability,depend,dependence,17366,"to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the strin",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17559,Integrability,depend,dependent,17559,"¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos ac",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17875,Integrability,depend,dependence,17875,"object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:17947,Integrability,depend,dependent,17947,"object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. Th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:20364,Integrability,depend,depending,20364,"not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous secti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:20759,Integrability,depend,dependent,20759,"when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21101,Integrability,depend,dependence,21101,"t state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of tim",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21575,Integrability,depend,dependences,21575,"at, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicate",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21833,Integrability,depend,dependence,21833,"e format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonbool",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23040,Integrability,depend,dependent,23040,"vers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used lik",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23315,Integrability,depend,dependent,23315,"piled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=F",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23595,Integrability,depend,dependent,23595,"t. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23796,Integrability,wrap,wrap,23796,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23818,Integrability,depend,dependences,23818,"ber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:23848,Integrability,depend,dependence,23848,"fePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, def",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:25240,Integrability,depend,dependence,25240,"s to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the same time-dependence, to reduce; the number of matrix multiplications and additions that need to be done; to evaluate this object.; Modifies the object inplace. conj()[source]¶; Return the matrix elementwise conjugation. copy()[source]¶; Return a copy of this object. dag()[source]¶; Return the matrix conjugate-transpose (dagger). expect(t, state, herm=False)[source]¶; Calculate the expectation value of this operator on the given; (time-independent) state at a particular time.; This is more efficient than expect(QobjEvo(t), state). Parameters. tfloatThe time to evaluate this operator at. stateQobj or np.ndarrayThe state to take the expectation value around. hermbool, default FalseWhether this operator and the state are both Hermitian. If True,; only the real part of the result will be returned. See also. expectGeneral-purpose expectation values. mul_mat(t, mat)[source]¶; Multiply this object evaluated at time t by a matrix (from the; right). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:27228,Integrability,depend,dependent,27228,"ight). Parameters. tfloatThe time to evaluate this object at. matQobj or np.ndarrayThe matrix that is multiplied by this object. Returns. mat: Qobj or np.ndarrayThe matrix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=1e-12)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5. Please use QobjEvo; for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponen",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:27360,Integrability,depend,dependence,27360,"rix result in the same type as the input. mul_vec(t, vec)[source]¶; Multiply this object evaluated at time t by a vector. Parameters. tfloatThe time to evaluate this object at. vecQobj or np.ndarrayThe state-vector to multiply this object by. Returns. vec: Qobj or np.ndarrayThe vector result in the same type as the input. permute(order)[source]¶; Permute the tensor structure of the underlying matrices into a new; format. See also. Qobj.permutethe same operation on constant quantum objects. tidyup(atol=1e-12)[source]¶; Removes small elements from this quantum object inplace. to_list()[source]¶; Return this operator in the list-like form used to initialised it, like; can be passed to mesolve. trans()[source]¶; Return the matrix transpose. eseries¶. class eseries(q=None, s=array([], dtype=float64))[source]¶; Class representation of an exponential-series expansion of; time-dependent quantum objects. Deprecated since version 4.6.0: eseries will be removed in QuTiP 5. Please use QobjEvo; for general time-dependence. Attributes. amplndarrayArray of amplitudes for exponential series. ratesndarrayArray of rates for exponential series. dimslistDimensions of exponential series components. shapelistShape corresponding to exponential series components. Methods. value(tlist); Evaluate an exponential series at the times listed in tlist. spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist. tidyup(); Returns a tidier version of the exponential series. spec(wlist)[source]¶; Evaluate the spectrum of an exponential series at frequencies; in wlist. Parameters. wlistarray_likeArray/list of frequenies. Returns. val_listndarrayValues of exponential series at frequencies in wlist. tidyup(*args)[source]¶; Returns a tidier version of exponential series. value(tlist)[source]¶; Evaluates an exponential series at the times listed in tlist. Parameters. tlistndarrayTimes at which to evaluate exponential series. Returns. val_listndarrayValues of exponential at times i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39192,Integrability,integrat,integrate,39192,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39654,Integrability,depend,depend,39654," If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40806,Integrability,integrat,integrator,40806,"pically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41719,Integrability,integrat,integratorstr,41719,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41758,Integrability,Integrat,Integrator,41758,"yCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41895,Integrability,integrat,integrator,41895,"e simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41969,Integrability,integrat,integrator,41969,"ed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). Returns. : complexexpectation value of field correlation function. outfieldpropagato",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46494,Integrability,Integrat,Integration,46494,"ults¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openm",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:46536,Integrability,integrat,integrator,46536,"]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after creation:; opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes. atolfloat {1e-8}Absolute tolerance. rtolfloat {1e-6}Relative tolerance. methodstr {‘adams’,’bdf’}Integration method. orderint {12}Order of integrator (<=12 ‘adams’, <=5 ‘bdf’). nstepsint {2500}Max. number of internal steps/call. first_stepfloat {0}Size of initial step (0 = automatic). min_stepfloat {0}Minimum step size (0 = automatic). max_stepfloat {0}Maximum step size (0 = automatic). tidybool {True,False}Tidyup Hamiltonian and initial state by removing small terms. num_cpusintNumber of cpus used by mcsolver (default = # of cpus). norm_tolfloatTolerance used when finding wavefunction norm in mcsolve. norm_stepsintMax. number of steps used to find wavefunction norm to within norm_tol; in mcsolve. average_statesbool {False}Average states values over trajectories in stochastic solvers. average_expectbool {True}Average expectation values over trajectories for stochastic solvers. mc_corr_epsfloat {1e-10}Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve. ntrajint {500}Number of trajectories in stochastic solvers. openmp_threadsintNumber of OPENMP threads to use. Default",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:50792,Integrability,message,message,50792,"ection called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:50928,Integrability,message,message,50928," add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will res",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51019,Integrability,message,messages,51019,"e in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `cla",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51122,Integrability,message,message,51122," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51155,Integrability,message,message,51155," that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:51299,Integrability,message,message,51299,"in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be an integer. Parameters. keystringkey for the section.counts dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the count, or added to an existing count. sectionstring or _StatsSectionSection which to add the count to.; If None given, the default (first) section will be used. add_message(key, value, section=None, sep=';')[source]¶; Add value to message. If key does not already exist in section then; it is created with this value.; If key already exists the value is added to the message; The value will be converted to a string. Parameters. keystringkey for the section.messages dictionary; reusing a key will result in concatenation of value. valueintInitial value of the message, or added to an existing message. sepstringMessage will be prefixed with this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper n",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52210,Integrability,message,messages,52210,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52356,Integrability,message,messages,52356,"given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, st",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52495,Integrability,message,messages,52495,"on_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class StochasticSolverOptions(me, H=None, c_ops=[], sc_ops=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54252,Integrability,depend,dependent,54252,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54314,Integrability,depend,dependent,54314,"=[], state0=None, e_ops=[], m_ops=None, store_all_expect=False, store_measurement=False, dW_factors=None, solver=None, method='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54369,Integrability,depend,dependent,54369,"od='homodyne', normalize=None, times=None, nsubsteps=1, ntraj=1, tol=None, generate_noise=None, noise=None, progress_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to ev",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:54527,Integrability,depend,dependent,54527,"s_bar=None, map_func=None, map_kwargs=None, args={}, options=None, noiseDepth=20)[source]¶; Class of options for stochastic solvers such as; qutip.stochastic.ssesolve, qutip.stochastic.smesolve, etc.; The stochastic solvers qutip.stochastic.general_stochastic,; qutip.stochastic.ssesolve, qutip.stochastic.smesolve,; qutip.stochastic.photocurrent_sesolve and; qutip.stochastic.photocurrent_mesolve; all take the same keyword arguments as; the constructor of these class, and internally they use these arguments to; construct an instance of this class, so it is rarely needed to explicitly; create an instance of this class.; Within the attribute list, a time_dependent_object is either. Qobj: a constant term; 2-element list of [Qobj, time_dependence]: a time-dependent term; where the Qobj will be multiplied by the time-dependent scalar. For more details on all allowed time-dependent objects, see the; documentation for QobjEvo. Attributes. Htime_dependent_object or list of time_dependent_objectSystem Hamiltonian in standard time-dependent list format. This is the; same as the argument that (e.g.) mesolve takes. If this is a; list of elements, they are summed. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The ex",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:55668,Integrability,depend,dependent,55668,"med. state0qutip.QobjInitial state vector (ket) or density matrix. timesarray_like of floatList of times for \(t\). Must be uniformly spaced. c_opslist of time_dependent_objectList of deterministic collapse operators. Each element of the list is; a separate operator; unlike the Hamiltonian, there is no implicit; summation over the terms. sc_opslist of time_dependent_objectList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the equation of motion according to how the d1 and d2 functions; are defined. Each element of the list is a separate operator, like; c_ops. e_opslist of qutip.QobjSingle operator or list of operators for which to evaluate; expectation values. m_opslist of qutip.QobjList of operators representing the measurement operators. The expected; format is a nested list with one measurement operator for each; stochastic increament, for each stochastic collapse operator. argsdictDictionary of parameters for time dependent systems. tolfloatTolerance of the solver for implicit methods. ntrajintNumber of trajectors. nsubstepsintNumber of sub steps between each time-spep given in times. dW_factorsarrayArray of length len(sc_ops), containing scaling factors for each; measurement operator in m_ops. solverstringName of the solver method to use for solving the stochastic; equations. Valid values are:. order 1/2 algorithms: ‘euler-maruyama’, ‘pc-euler’, ‘pc-euler-imp’; order 1 algorithms: ‘milstein’, ‘platen’, ‘milstein-imp’, ‘rouchon’; order 3/2 algorithms: ‘taylor1.5’, ‘taylor1.5-imp’, ‘explicit1.5’; order 2 algorithms: ‘taylor2.0’. See the documentation of stochastic_solvers; for a description of the solvers. Implicit methods can adjust; tolerance via the kw ‘tol’. Default is {‘tol’: 1e-6}. methodstring (‘homodyne’, ‘heterodyne’)The name of the type of measurement process that give rise to the; stochastic equation to solve. store_all_expectbool (default False)Whether or not to store the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:60871,Integrability,integrat,integrate,60871,"pled basis.; default: (nds, nds). c_ops()[source]¶; Build collapse operators in the full Hilbert space 2^N. Returns. c_ops_list: listThe list with the collapse operators in the 2^N Hilbert space. coefficient_matrix()[source]¶; Build coefficient matrix for ODE for a diagonal problem. Returns. M: ndarrayThe matrix M of the coefficients for the ODE dp/dt = Mp.; p is the vector of the diagonal matrix elements; of the density matrix rho in the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coeff",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:74462,Integrability,depend,depending,74462,"st of arrays that spans the space for each coordinate. xlabelslistList of labels for each coordinate. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; marginal distribution. Returns. dDistributionsA new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters. dimintThe dimension (coordinate index) along which to obtain the; projected distribution. Returns. dDistributionsA new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. figmatplotlib Figure instanceIf given, use this figure instance for the visualization,. axmatplotlib Axes instanceIf given, render the visualization using this axis instance. figsizetupleSize of the new Figure instance, if one needs to be created. colorbar: BoolWhether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instanceIf given, use this colormap for 2D visualizations. stylestringType of visualization: ‘colormap’ (default) or ‘surface’. Returns. fig, axtupleA tuple of matplotlib figure and axes instances. class WignerDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class QDistribution(rho=None, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. class TwoModeQuadratureCorrelation(state=None, theta1=0.0, theta2=0.0, extent=[[- 5, 5], [- 5, 5]], steps=250)[source]¶. update(state)[source]",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:97178,Integrability,depend,dependent,97178,"f analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:107927,Integrability,depend,dependent,107927,"rd arguments.; If analytical is True, calculate the propagator; with matrix exponentiation and return a list of matrices.; Noise will be neglected in this option. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: boolIf True, calculate the evolution with matrices exponentiation. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class ModelProcessor(N, correct_global_phase=True, t1=None, t2=None)[source]¶; The base class for a circuit processor simulating a physical device,; e.g cavityQED, spinchain.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It cannot be used alone, please refer to the sub-classes.; (Only additional attributes are documented here, for others please; refer to the parent class Processor). Parameters. N: intThe number of component systems. correct_global_phase: boolean, optionalIf true, the analytical solution will track the global phase. It; has no effect on the numerical solution. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:116717,Integrability,depend,dependent,116717,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:127547,Integrability,depend,dependent,127547,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:137979,Integrability,depend,dependent,137979,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor base",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:148421,Integrability,depend,dependent,148421,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:159605,Integrability,depend,dependent,159605,"tor; with matrix exponentiation and return a list of matrices. Parameters. init_state: QobjInitial density matrix or state vector (ket). analytical: booleanIf True, calculate the evolution with matrices exponentiation. qc: :class:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe ep",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:167725,Integrability,depend,dependent,167725,"tween two random amplitude. The coefficients; of the noise are the same within this time range. rand_gen: numpy.random, optionalA random generator in numpy.random, it has to take a size; parameter. indices: list of intThe indices of target pulse in the list of pulses. **kwargs:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:168289,Integrability,depend,dependent,168289,"ulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Example",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:168528,Integrability,depend,dependent,168528,"seThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:169403,Integrability,depend,dependent,169403,"shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] and coeff=[3,2], means that the coefficient; is 3 in t=[0,1) and 2 in t=[2,3). It requires; len(coeff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170057,Integrability,depend,dependent,170057,"ff)=len(tlist)-1 or len(coeff)=len(tlist), but; in the second case the last element of coeff has no effect.; -“cubic”:; Use cubic interpolation for the coefficient. It requires; len(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170218,Integrability,depend,dependent,170218,"en(coeff)=len(tlist). label: strThe label (name) of the pulse. Examples; Create a pulse that is turned off; >>> Pulse(sigmaz(), 0) ; >>> Pulse(sigmaz(), 0, None, None) . Create a time dependent pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170430,Integrability,depend,dependent,170430,"nt pulse; >>> tlist = np.array([0., 1., 2., 4.]) ; >>> coeff = np.array([0.5, 1.2, 0.8]) ; >>> spline_kind = ""step_func"" ; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=coeff, spline_kind=""step_func"") . Create a time independent pulse; >>> Pulse(sigmaz(), 0, coeff=True) . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170688,Integrability,depend,dependent,170688,") . Create a constant pulse with time range; >>> Pulse(sigmaz(), 0, tlist=tlist, coeff=True) . Create an dummy Pulse (H=0); >>> Pulse(None, None) . Attributes. ideal_pulse: :class:`._EvoElement`The ideal dynamic of the control pulse. coherent_noise: list of :class:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element short",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:170938,Integrability,depend,dependent,170938,"s:`._EvoElement`The coherent noise caused by the control pulse. Each dynamic element is; still characterized by a time-dependent Hamiltonian. lindblad_noise: list of :class:`._EvoElement`The dissipative noise of the control pulse. Each dynamic element; will be treated as a (time-dependent) lindblad operator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documenta",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171259,Integrability,depend,dependent,171259,"erator in the; master equation. spline_kind: strSee parameter spline_kind. label: strSee parameter label. add_coherent_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) Hamiltonian to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171547,Integrability,depend,dependent,171547,"e pulse. targets: listtarget qubits of the pulse; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:171798,Integrability,depend,dependent,171798,"r one element shorter compared to coeff. See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. add_lindblad_noise(qobj, targets, tlist=None, coeff=None)[source]¶; Add a new (time-dependent) lindblad noise to the coherent noise. Parameters. qobj: :class:’qutip.Qobj’The collapse operator of the lindblad noise. targets: listtarget qubits of the collapse operator; (or subquantum system of other dimensions). tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied.; tlist does not have to be equidistant, but must have the same; length; or one element shorter compared to coeff.; See documentation for; the parameter spline_kind of Pulse. coeff: array-like or bool, optionalTime-dependent coefficients of the pulse noise.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for; the parameter spline_kind of Pulse.; If a bool, the coefficient is a constant 1 or 0. property coeff¶; See parameter coeff. get_full_tlist(tol=1e-10)[source]¶; Return the full tlist of the pulses and noise. It means that if; different tlist are present, they will be merged to one with all; time points stored in a sorted array. Returns. full_tlist: array-like 1dThe full time sequence for the noisy evolution. get_ideal_qobj(dims)[source]¶; Get the Hamiltonian of the ideal pulse. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the sys",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:173463,Integrability,depend,dependent,173463,"ion of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. qobj: qutip.QobjThe Hamiltonian of the ideal pulse. get_ideal_qobjevo(dims)[source]¶; Get a QobjEvo representation of the ideal evolution. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. ideal_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution. get_noisy_qobjevo(dims)[source]¶; Get the QobjEvo representation of the noisy evolution. The; result can be used directly as input for the qutip solvers. Parameters. dims: int or listDimension of the system.; If int, we assume it is the number of qubits in the system.; If list, it is the dimension of the component systems. Returns. noisy_evo: qutip.QobjEvoA QobjEvo representing the ideal evolution and coherent noise. c_ops: list of qutip.QobjEvoA list of (time-dependent) lindbald operators. print_info()[source]¶; Print the information of the pulse, including the ideal dynamics,; the coherent noise and the lindblad noise. property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_in",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174639,Integrability,rout,routine,174639,". property qobj¶; See parameter qobj. property targets¶; See parameter targets. property tlist¶; See parameter tlist. class GateCompiler(N, params=None, pulse_dict=None)[source]¶; Base class. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174813,Integrability,rout,routine,174813,"lass. It compiles a QubitCircuit into; the pulse sequence for the processor. The core member function; compile calls compiling method from the sub-class and concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tli",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:174987,Integrability,rout,routines,174987,"concatenate; the compiled pulses. Parameters. N: intThe number of the component systems. params: dict, optionalA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc.; It will be saved in the class attributes and can be used to calculate; the control pulses. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. gate_compiler: dictThe Python dictionary in the form of {gate_name: compiler_function}.; It saves the compiling routine for each gate. See sub-classes; for implementation.; Note that for continuous pulse, the first coeff should always be 0. args: dictArguments for individual compiling routines.; It adds more flexibility in customizing compiler. compile(circuit, schedule_mode=None, args=None)[source]¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA dictionary of arguments used in a specific gate compiler; function. Returns. tlist: array_likeA NumPy array specifies the time of each coefficient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:176752,Integrability,rout,routine,176752,"ient. coeffs: array_likeA 2d NumPy array of the shape (len(ctrls), len(tlist)). Each; row corresponds to the control pulse sequence for; one Hamiltonian. globalphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. class CavityQEDCompiler(N, params, pulse_dict, global_phase=0.0)[source]¶; Decompose a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See DispersiveCavityQED.set_up_params for the definition. global_phase: float, optionalRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as soon as possible” or; ""ALAP"" for “as late as possible” or; False or None for no schedule.; Default is None. args: dict, optionalA d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:179288,Integrability,rout,routine,179288,"mpiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate; Notes; This version of sqrtiswap_compiler has very low fidelity, please use; iswap. class SpinChainCompiler(N, params, pulse_dict, setup='linear', global_phase=0.0)[source]¶; Compile a QubitCircuit into; the pulse sequence for the processor. Parameters. N: intThe number of qubits in the system. params: dictA Python dictionary contains the name and the value of the parameters.; See SpinChain.set_up_params for the definition. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. pulse_dict: dict, optionalA map between the pulse label and its index in the pulse list.; If given, the compiled pulse can be identified with; (pulse_label, coeff), instead of (pulse_index, coeff).; The number of key-value pairs should match the number of pulses; in the processor.; If it is empty, an integer pulse_index needs to be used; in the compiling routine saved under the attributes gate_compiler. Attributes. N: intThe number of the component systems. params: dictA Python dictionary contains the name and the value of the parameters,; such as laser frequency, detuning etc. pulse_dict: dictA map between the pulse label and its index in the pulse list. gate_compiler: dictThe Python dictionary in the form of {gate_name: decompose_function}.; It saves the decomposition scheme for each gate. setup: string“linear” or “circular” for two sub-classes. global_phase: boolRecord of the global phase change and will be returned. compile(circuit, schedule_mode=None, args=None)¶; Compile the the native gates into control pulse sequence.; It calls each compiling method and concatenates; the compiled pulses. Parameters. circuit: :class:`.QubitCircuit` or list ofGate; A list of elementary gates that can be implemented in the; corresponding hardware.; The gate names have to be in gate_compiler. schedule_mode: str, optional""ASAP"" for “as ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183051,Integrability,depend,dependency,183051,"e]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distan",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183235,Integrability,depend,dependent,183235,"nstruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate obje",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183400,Integrability,depend,dependency,183400,"universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commute with CNOT 0, 2. schedule(circuit, gates_schedule=False, return_cycles_list=False, random_shuffle=False, repeat_num=0)[source]¶; Schedule a QubitCircuit,; a list of Gates or a list of Instruction.; For pulse schedule, the execution time for each Instruction; is given in its duration attributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalT",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:183944,Integrability,depend,dependency,183944,"ttributes.; The scheduler first generates a quantum gates dependency graph,; containing information about; which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other,; even if they use the same qubits.; Next, it computes the longest distance of each node; to the start and end nodes.; The distance for each dependency arrow is defined; by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and; a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm; with hardware constraint and priority and; returns a list of cycles for gates/instructions.; For pulse schedule, an additional step is required; to compute the start time of each instruction.; It adds the additional dependency; caused by hardware constraint to the graph; and recomputes the distance of each node to the start and end node.; This distance is then converted to; the start time of each instruction. Parameters. circuit: QubitCircuit or listFor gate schedule,; it should be a QubitCircuit or a list of Gate objects.; For pulse schedule, it should be a list of Instruction objects,; each with an attribute duration; that indicates the execution time of this instruction. gates_schedule: bool, optionalTrue, if only gates schedule is needed.; This saves some computation; that is only useful to pulse schedule.; If the input circuit is a QubitCircuit,; it will be assigned to True automatically.; Otherwise, the default is False. return_cycles_list: bool, optionalIf True, the method returns the cycles_list,; e.g. [{0, 2}, {1, 3}],; which means that the first cycle contains gates0 and gates2; while the second cycle contains gates1 and gates3.; It is only usefull for gates schedule. random_shuffle: bool, optionalIf the commuting gates are randomly sc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186521,Integrability,depend,dependent,186521,"1; >>> circuit.add_gate(""CZ"", 4, 3) # gate2; >>> circuit.add_gate(""CZ"", 2, 3) # gate3; >>> circuit.add_gate(""CZ"", 6, 5) # gate4; >>> circuit.add_gate(""CZ"", 2, 6) # gate5; >>> circuit.add_gate(""SWAP"", [0, 2]) # gate6; >>>; >>> scheduler = Scheduler(""ASAP""); >>> scheduler.schedule(circuit, gates_schedule=True); [0, 1, 3, 2, 2, 3, 4]. The result list is the cycle indices for each gate.; It means that the circuit can be executed in 5 gate cycles:; [gate0, gate1, (gate3, gate4), (gate2, gate5), gate6]; Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.loggin",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188279,Integrability,message,message,188279," instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194027,Integrability,wrap,wrapper,194027,"ation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195570,Integrability,wrap,wrapper,195570,"all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197026,Integrability,wrap,wrapper,197026,"thm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198350,Integrability,wrap,wrapper,198350,"tions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter ter",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198775,Integrability,wrap,wrapper,198775,"ied; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration n",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:214551,Integrability,message,message,214551,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242407,Integrability,depend,depends,242407,grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. ,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:24231,Modifiability,variab,variables,24231,"None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x + str_mod[1]. inplace_npbool, default FalseWhether this function should modify Numpy arrays inplace, or be; used like a regular decorator. Some decorators create incorrect; arrays as some transformations f'(t) = f(g(t)) create a; mismatch between the array and the associated time list. arguments(new_args)[source]¶; Update the scoped variables that were passed as args to new values. compile(code=False, matched=False, dense=False, omp=0)[source]¶; Create an associated Cython object for faster usage. This function is; called automatically by the solvers. Parameters. codebool, default FalseReturn the code string generated by compilation of any strings. matchedbool, default FalseIf True, the underlying sparse matrices used to represent each; element of the type will have their structures unified. This may; include adding explicit zeros to sparse matrices, but can be faster; in some cases due to not having to deal with repeated structural; mismatches. densebool, default FalseWhether to swap to using dense matrices to back the data. ompint, optionalThe number of OpenMP threads to use when doing matrix; multiplications, if QuTiP was compiled with OpenMP. Returns. compiled_strstr(Only if code was set to True). The code-generated string of; compiled calling code. compress()[source]¶; Merge together elements that share the s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37224,Modifiability,coupling,coupling,37224,"this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38118,Modifiability,config,configure,38118,"g strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38304,Modifiability,Config,Configure,38304,"g strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39184,Modifiability,config,config,39184,"=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=N",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:39971,Modifiability,coupling,coupling,39971,"s will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40107,Modifiability,config,configure,40107,"lt values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40309,Modifiability,config,configure,40309,"lt values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40647,Modifiability,evolve,evolves,40647," exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conve",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41101,Modifiability,coupling,coupling,41101," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41234,Modifiability,coupling,coupling,41234,"x=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:61311,Modifiability,evolve,evolves,61311,"n the Dicke basis. lindbladian()[source]¶; Build the Lindbladian superoperator of the dissipative dynamics. Returns. lindbladianqutip.QobjThe Lindbladian matrix as a qutip.Qobj. liouvillian()[source]¶; Build the total Liouvillian using the Dicke basis. Returns. liouvqutip.QobjThe Liouvillian matrix for the system. pisolve(initial_state, tlist, options=None)[source]¶; Solve for diagonal Hamiltonians and initial states faster. Parameters. initial_statequtip.QobjAn initial state specified as a density matrix of; qutip.Qbj type. tlist: ndarrayA 1D numpy array of list of timesteps to integrate. optionsqutip.solver.OptionsThe options for the solver. Returns. result: listA dictionary of the type qutip.solver.Result which holds the; results of the evolution. class Pim(N, emission=0.0, dephasing=0, pumping=0, collective_emission=0, collective_pumping=0, collective_dephasing=0)[source]¶; The Permutation Invariant Matrix class.; Initialize the class with the parameters for generating a Permutation; Invariant matrix which evolves a given diagonal initial state p as:. dp/dt = Mp. Parameters. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. Attributes. N: intThe number of two-level systems. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:65790,Modifiability,coupling,coupling,65790," be checked. Returns. taus: dictA dictionary of key, val as {tau: value} consisting of the valid; taus for this row and column of the Dicke space element. One-Dimensional Lattice¶. class Lattice1d(num_cell=10, boundary='periodic', cell_num_site=1, cell_site_dof=[1], Hamiltonian_of_cell=None, inter_hop=None)[source]¶; A class for representing a 1d crystal.; The Lattice1d class can be defined with any specific unit cells and a; specified number of unit cells in the crystal. It can return dispersion; relationship, position operators, Hamiltonian in the position represention; etc. Parameters. num_cellintThe number of cells in the crystal. boundarystrSpecification of the type of boundary the crystal is defined with. cell_num_siteintThe number of sites in the unit cell. cell_site_doflist of int/ intThe tensor structure of the degrees of freedom at each site of a unit; cell. Hamiltonian_of_cellqutip.QobjThe Hamiltonian of the unit cell. inter_hopqutip.Qobj / list of QobjThe coupling between the unit cell at i and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:66810,Modifiability,coupling,coupling,66810,"and at (i+unit vector). Attributes. num_cellintThe number of unit cells in the crystal. cell_num_siteintThe nuber of sites in a unit cell. length_for_siteintThe length of the dimension per site of a unit cell. cell_tensor_configlist of intThe tensor structure of the cell in the form; [cell_num_site,cell_site_dof[:][0] ]. lattice_tensor_configlist of intThe tensor structure of the crystal in the; form [num_cell,cell_num_site,cell_site_dof[:][0]]. length_of_unit_cellintThe length of the dimension for a unit cell. period_bnd_cond_xint1 indicates “periodic” and 0 indicates “hardwall” boundary condition. inter_vec_listlist of listThe list of list of coefficients of inter unitcell vectors’ components; along Cartesian uit vectors. lattice_vectors_listlist of listThe list of list of coefficients of lattice basis vectors’ components; along Cartesian unit vectors. H_intraqutip.QobjThe Qobj storing the Hamiltonian of the unnit cell. H_inter_listlist of Qobj/ qutip.QobjThe list of coupling terms between unit cells of the lattice. is_realboolIndicates if the Hamiltonian is real or not. Hamiltonian()[source]¶; Returns the lattice Hamiltonian for the instance of Lattice1d. Returns. Qobj(Hamil)qutip.Qobjoper type Quantum object representing the lattice Hamiltonian. basis(cell, site, dof_ind)[source]¶; Returns a single particle wavefunction ket with the particle localized; at a specified dof at a specified site of a specified cell. Parameters. cell (int) – The cell at which the particle is to be localized.; site (int) – The site of the cell at which the particle is to be localized.; dof_ind (int/ list of int) – The index of the degrees of freedom with which the sigle particle; is to be localized. Returns. vec_iqutip.Qobjket type Quantum object representing the localized particle. bloch_wave_functions()[source]¶; Returns eigenvectors ($psi_n(k)$) of the Hamiltonian in a; numpy.ndarray for translationally symmetric lattices with periodic; boundary condition. \begin{eqnarray}; |\psi_n(k",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:69707,Modifiability,coupling,coupling,69707,"od quantum number k. cell_periodic_parts()[source]¶; Returns eigenvectors of the bulk Hamiltonian, i.e. the cell periodic; part($u_n(k)$) of the Bloch wavefunctios in a numpy.ndarray for; translationally symmetric lattices with periodic boundary condition. \begin{eqnarray}; |\psi_n(k) \rangle = |k \rangle \otimes | u_{n}(k) \rangle \\; | u_{n}(k) \rangle = a_n(k)|a\rangle + b_n(k)|b\rangle \\; \end{eqnarray}Please see section 1.2 of Asbóth, J. K., Oroszlány, L., & Pályi, A.; (2016). A short course on topological insulators. Lecture notes in; physics, 919 for a review. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. vec_knsnp.ndarray of Qobj’svec_kns[j] is the Oobj of type ket that holds an eigenvector of the; bulk Hamiltonian of the lattice. display_lattice()[source]¶; Produces a graphic portraying the lattice symbolically with a unit cell; marked in it. Returns. inter_TQobjThe coefficient of $psi_{i,N}^{dagger}psi_{0,i+1}$, i.e. the; coupling between the two boundary sites of the two unit cells i and; i+1. display_unit_cell(label_on=False)[source]¶; Produces a graphic displaying the unit cell features with labels on if; defined by user. Also returns a dict of Qobj’s corresponding to the; labeled elements on the display. Returns. HcelldictHcell[i][j] is the Hamiltonian segment for $H_{i,j}$ labeled on the; graphic. distribute_operator(op)[source]¶; A function that returns an operator matrix that applies op to all the; cells in the 1d lattice. Parameters; op (qutip.Qobj) – Qobj representing the operator to be applied at all cells. Returns. op_Hqutip.QobjQuantum object representing the operator with op applied at all; cells. get_dispersion(knpoints=0)[source]¶; Returns dispersion relationship for the lattice with the specified; number of unit cells with a k array and a band energy array. Returns. knxanp.arrayknxA[j][0] is the jth good Quantum number k. val_knsnp.arrayval_kns[j][:] is the array of band energies of the jth band good at; all the good Qua",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:78948,Modifiability,variab,variable,78948,"cified by the index. class QubitCircuit(N, input_states=None, output_states=None, reverse_states=True, user_gates=None, dims=None, num_cbits=0)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates. Parameters. NintNumber of qubits in the system. user_gatesdictDefine a dictionary of the custom gates. See examples for detail. input_stateslistA list of string such as 0,’+’, “A”, “Y”. Only used for latex. dimslistA list of integer for the dimension of each composite system.; e.g [2,2,2,2,2] for 5 qubits system. If None, qubits system; will be the default option. num_cbitsintNumber of classical bits in the system. Examples; >>> def user_gate():; ... mat = np.array([[1., 0],; ... [0., 1.j]]); ... return Qobj(mat, dims=[[2], [2]]); >>> qubit_circuit = QubitCircuit(2, user_gates={""T"":user_gate}); >>> qubit_circuit.add_gate(""T"", targets=[0]). add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None, classical_controls=None, control_value=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters. namestringGate name. startintStarting location of qubits. endintLast qubit for the gate. qubitslistSpecific qubits for applying gates. arg_valuefloatArgument value(phi). arg_labelstringLabel for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters. qcQubitCircuitThe circuit block to be added to the main circuit. startintThe qubit on which the first gate is applied. add_gate(gate, targets=None, controls=None, arg_value=None, arg_label=None, index=None, classical_controls=None, control_value=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters. gate: string or :class:`.Gate`Gate name. If gate is an instance of Gate, parameters are; unpacked and added. targets:",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:86262,Modifiability,variab,variables,86262,"t(final_states, probabilities, cbits=None)[source]¶. get_cbits(index=None)[source]¶; Return list of classical bit outputs corresponding to the results. Parameters. index: intIndicates i-th output, probability pair to be returned. Returns. cbits: list of int or list of list of intlist of classical bit outputs. get_final_states(index=None)[source]¶; Return list of output states. Parameters. index: intIndicates i-th state to be returned. Returns. final_states: Qobj or list of Qobj.List of output kets or density matrices. get_probabilities(index=None)[source]¶; Return list of probabilities corresponding to the output states. Parameters. index: intIndicates i-th probability to be returned. Returns. probabilities: float or list of floatProbabilities associated with each output state. class CircuitSimulator(qc, state=None, cbits=None, U_list=None, measure_results=None, mode='state_vector_simulator', precompute_unitary=False)[source]¶. initialize(state=None, cbits=None, measure_results=None)[source]¶; Reset Simulator state variables to start a new run. Parameters. state: ket or operket or density matrix. cbits: list of int, optionalinitial value of classical bits. U_list: list of Qobj, optionallist of predefined unitaries corresponding to circuit. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. run(state, cbits=None, measure_results=None)[source]¶; Calculate the result of one instance of circuit run. Parameters. stateket or operstate vector or density matrix input. cbitsList of ints, optionalinitialization of the classical bits. measure_resultstuple of ints, optionaloptional specification of each measurement result to enable; post-selection. If specified, the measurement results are; set to the tuple of bits (sequentially) instead of being; chosen at random. Returns. result: CircuitResultRetu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:128015,Modifiability,coupling,coupling,128015," an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:138453,Modifiability,coupling,coupling,138453,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe e",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:148895,Modifiability,coupling,coupling,148895,"stance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_ph",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160140,Modifiability,coupling,coupling,160140,"lytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dumm",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:167943,Modifiability,variab,variables,167943,"s:Key word arguments for the random number generator. get_noisy_dynamics(dims=None, pulses=None, systematic_noise=None)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class Pulse(qobj, targets, tlist=None, coeff=None, spline_kind=None, label='')[source]¶; Representation of a control pulse and the pulse dependent noise.; The pulse is characterized by the ideal control pulse, the coherent; noise and the lindblad noise. The later two are lists of; noisy evolution dynamics.; Each dynamic element is characterized by four variables:; qobj, targets, tlist and coeff.; See examples for different construction behavior. Parameters. qobj: :class:’qutip.Qobj’The Hamiltonian of the ideal pulse. targets: listtarget qubits of the ideal pulse; (or subquantum system of other dimensions). tlist: array-like, optionaltlist of the ideal pulse.; A list of time at which the time-dependent coefficients are applied.; tlist does not have to be equidistant, but must have the same length; or one element shorter compared to coeff. See documentation for; the parameter spline_kind. coeff: array-like or bool, optionalTime-dependent coefficients of the ideal control pulse.; If an array, the length; must be the same or one element longer compared to tlist.; See documentation for the parameter spline_kind.; If a bool, the coefficient is a constant 1 or 0. spline_kind: str, optionalType of the coefficient interpolation:; “step_func” or “cubic”.; -“step_func”:; The coefficient will be treated as a step function.; E.g. tlist=[0,1,2] ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186980,Modifiability,config,config,186980,"Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:187283,Modifiability,config,configuration,187283,"hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:189795,Modifiability,config,configOptimConfig,189795,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:189829,Modifiability,config,configuration,189829,"rapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192501,Modifiability,variab,variable,192501,"imize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192905,Modifiability,variab,variables,192905,"f they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193059,Modifiability,variab,variables,193059,"lt); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default fu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193099,Modifiability,variab,variable,193099,"dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:193761,Modifiability,config,configuration,193761,"get, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195093,Modifiability,config,config,195093,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195926,Modifiability,config,config,195926," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196087,Modifiability,variab,variable,196087,", dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196535,Modifiability,config,configuration,196535,"l minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which inclu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197590,Modifiability,config,config,197590,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198155,Modifiability,config,configuration,198155,"ablished implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198194,Modifiability,config,config,198194,"SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:212871,Modifiability,config,configuration,212871,"ion operators (Qobj) from the initial to the given; timeslot. get_ctrl_dyn_gen(j)[source]¶; Get the dynamics generator for the control; Not implemented in the base class. Choose a subclass. get_drift_dim()[source]¶; Returns the size of the matrix that defines the drift dynamics; that is assuming the drift is NxN, then this returns N. get_dyn_gen(k)[source]¶; Get the combined dynamics generator for the timeslot; Not implemented in the base class. Choose a subclass. get_num_ctrls()[source]¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. init_timeslots()[source]¶; Generate the timeslot duration array ‘tau’ based on the evo_time; and num_tslots attributes, unless the tau attribute is already set; in which case this step in ignored; Generate the cumulative time array ‘time’ based on the tau values. initialize_controls(amps, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. property onto_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property onwd_evo¶; List of evolution operators (Qobj) from the initial to the given; timeslot. property phase_application¶; scalar(string), default=’preop’; Determines how the phase is applied to the dynamics generators. ‘preop’ : P = expm(phase*dyn_gen); ‘postop’ : P = expm(dyn_gen*phase); ‘custom’ : Customised phase application. The ‘custom’ option assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:216255,Modifiability,config,configuration,216255,"amics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian for unitary dynamics; It is mapped to drift_dyn_gen during initialize_controls. ctrl_hamList of QobjThese are the control Hamiltonians for unitary dynamics; It is mapped to ctrl_dyn_gen during initialize_controls. HList of QobjThe combined drift and control Hamiltonians for each timeslot; These are the dynamics generators for unitary dynamics.; It is mapped to dyn_gen during initialize_controls. check_unitarity()[source]¶; Checks whether all propagators are unitary; For propagators found not to be unitary, the potential underlying; causes are investigated. initialize_controls(amplitudes, init_tslots=True)[source]¶; Set the initial control amplitudes and time slices; Note this must be called after the configuration is complete; before any dynamics can be calculated. property num_ctrls¶; calculate the of controls from the length of the control list; sets the num_ctrls property, which can be used alternatively; subsequently. class DynamicsSymplectic(optimconfig, params=None)[source]¶; Symplectic systems; This is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218520,Modifiability,config,configuration,218520,"cation. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218796,Modifiability,config,configuration,218796,"iet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attribute",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218989,Modifiability,config,configuration,218989,"es whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219356,Modifiability,config,configuration,219356,"ey value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222115,Modifiability,config,configuration,222115," fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradie",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222174,Modifiability,config,configuration,222174," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223759,Modifiability,config,config,223759,"fore it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223997,Modifiability,config,configuration,223997,"culates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phas",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:224861,Modifiability,config,configuration,224861,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226607,Modifiability,config,configuration,226607,"erik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelinteg",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226714,Modifiability,config,configuration,226714,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227310,Modifiability,config,configuration,227310,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239392,Modifiability,config,configurations,239392,"om the optimisation method; Typically this will be the basis coefficients. class PulseGenCrabFourier(dyn=None, num_coeffs=None, params=None)[source]¶; Generates a pulse using the Fourier basis functions, i.e. sin and cos. Attributes. freqsfloat array[num_coeffs]Frequencies for the basis functions. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242970,Modifiability,config,configured,242970,"ged. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dum",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:4133,Performance,perform,performing,4133,"rator. dual_chan(); Dual channel of quantum object representing a CP map. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQuantum object is not ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:4403,Performance,Perform,Performs,4403,"nd eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(order=’C’); Returns dense array of quantum object data attribute. groundstate(sparse=False, tol=0, maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. inv(); Return a Qobj corresponding to the matrix inverse of the operator. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. proj(); Computes the projector for a ket or bra vector. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sinm(); Sine of quantum object. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. trunc_neg(method=’clip’); Removes negative eigenvalues and returns a new Qobj that is a valid density operator. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. check_herm()[source]¶; Check if the quantum object is hermitian. Returns. ishermboolReturns the new value of isherm property. check_isunitary()[source]¶; Checks whether qobj is a unitary matrix. conj()[source]¶; Conjugate operator of quantum object. copy()[source]¶; Create identical copy. cosm()[source]¶; Cosine of a quantum operator.; Operator must be square. Returns. operqutip.QobjMatrix cosine of operator. Raises. TypeErrorQuantum object is not square. Notes; Uses the Q.expm() method. dag()[source]¶; Adjoint operator of quantum object. diag()[source]¶; Diagonal elements of quantum object. Returns. diagsarrayReturns array of real values if operators is Hermitian,; otherwise complex values are returned. dnorm(B=None)[source]¶; Calculates the d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:6387,Performance,perform,performed,6387,"e)[source]¶; Calculates the diamond norm, or the diamond distance to another; operator. Parameters. Bqutip.Qobj or NoneIf B is not None, the diamond distance d(A, B) = dnorm(A - B); between this operator and B is returned instead of the diamond; norm. Returns. dfloatEither the diamond norm of this operator, or the diamond distance; from this operator to B. dual_chan()[source]¶; Dual channel of quantum object representing a completely positive; map. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)[source]¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:7179,Performance,perform,performed,7179,"lues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). Returns. eigvalsarrayArray of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000, phase_fix=None)[source]¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters. sparseboolUse sparse Eigensolver. sortstrSort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvalsintNumber of requested eigenvalues. Default is all eigenvalues. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). phase_fixint, NoneIf not None, set the phase of each kets so that ket[phase_fix,0]; is real positive. Returns. eigvalsarrayArray of eigenvalues for operator. eigvecsarrayArray of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)[source]¶; Creates a new quantum object with states in state_inds eliminated. Parameters. states_indslist of integerThe states that should be removed. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10698,Performance,perform,performed,10698,"represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=1",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:12310,Performance,perform,performed,12310,"e matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm for kets and trace-norm for operators.; Other ket and operator norms may be specified using the norm and; argument. Parameters. normstrWhich norm to use for ket/bra vectors: L2 ‘l2’, max norm ‘max’,; or for operators: trace ‘tr’, Frobius ‘fro’, one ‘one’, or max; ‘max’. sparseboolUse sparse eigenvalue solver for trace norm. Other norms are not; affected by this parameter. tolfloatTolerance for sparse solver (if used) for trace norm. The sparse; solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used); for trace norm. Returns. normfloatThe requested norm of the operator or state quantum object. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. overlap(other)[source]¶; Overlap between two state vectors or two operators.; Gives the overlap (inner product) between the current bra or ket Qobj; and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap; when one of the Qobj is an operator/density matrix. Parameters. otherqutip.QobjQuantum object for a state vector of type ‘ket’, ‘bra’ or density; matrix. Returns. overlapcomplexComplex valued overlap. Raises. TypeErrorCan only calculate overlap between a bra, ket and density matrix; quantum objects. Notes; Since QuTiP mainly deals with ket vectors, the most efficient inner; product call is the ket-ket version that computes the product; <self|other> with both vectors expressed as kets. permute(order)[source]¶; Permutes a composite",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:16841,Performance,perform,performed,16841,"perqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number; / : C number. This object is constructed by passing a list of Qobj instances,; each of which may have an associated scalar time dependence. The list is; summed to produce the final result. In other words, if an instance of this; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37002,Performance,perform,performance,37002,"ndarrayArray of coeffcients defining cubic spline. Non-Markovian Solvers¶. class HEOMSolver[source]¶; This is superclass for all solvers that use the HEOM method for; calculating the dynamics evolution. There are many references for this.; A good introduction, and perhaps closest to the notation used here is:; DOI:10.1103/PhysRevLett.104.250401; A more canonical reference, with full derivation is:; DOI: 10.1103/PhysRevA.41.6676; The method can compute open system dynamics without using any Markovian; or rotating wave approximation (RWA) for systems where the bath; correlations can be approximated to a sum of complex eponentials.; The method builds a matrix of linked differential equations, which are; then solved used the same ODE solvers as other qutip solvers (e.g. mesolve); This class should be treated as abstract. Currently the only subclass; implemented is that for the Drude-Lorentz spectral density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:37853,Performance,perform,performance,37853," density. This covers; the majority of the work that has been done using this model, and there; are some performance advantages to assuming this model where it is; appropriate.; There are opportunities to develop a more general spectral density code. Attributes. H_sysQobjSystem Hamiltonian. coup_opQobjOperator describing the coupling between system and bath. coup_strengthfloatCoupling strength. temperaturefloatBath temperature, in units corresponding to planck. N_cutintCutoff parameter for the bath. N_expintNumber of exponential terms used to approximate the bath correlation; functions. planckfloatreduced Planck constant. boltzmannfloatBoltzmann’s constant. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38898,Performance,perform,performance,38898,"overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; For practical computation purposes an approximation must be used based; on a small number of Matsubara terms (typically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormb",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:43953,Performance,perform,performed,43953,"gator(blist, tlist, tau, c1=None, c2=None, notrace=False)[source]¶; Compute propagator for computing output field expectation values; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_out^dagger; 3: b_loop; 4: b_loop^dagger. tlistarray_likelist of corresponding times t1,..,tn at which to evaluate the field; operators. taufloattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Tra",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44437,Performance,perform,performed,44437,"oattime-delay. c1qutip.Qobjsystem collapse operator that couples to the in-loop field in; question (only needs to be specified if self.L1 has more than one; element). c2qutip.Qobjsystem collapse operator that couples to the output field in; question (only needs to be specified if self.L2 has more than one; element). notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:49332,Performance,perform,performance,49332,"auto check. class Result[source]¶; Class for storing simulation results from any of the dynamics solvers. Attributes. solverstrWhich solver was used [e.g., ‘mesolve’, ‘mcsolve’, ‘brmesolve’, …]. timeslist/arrayTimes at which simulation data was collected. expectlist/arrayExpectation values (if requested) for simulation. statesarrayState of the simulation (density matrix or ket) evaluated at times. num_expectintNumber of expectation value operators in simulation. num_collapseintNumber of collapse operators in simualation. ntrajint/listNumber of trajectories (for stochastic solvers). A list indicates; that averaging of expectation values was done over a subset of total; number of trajectories. col_timeslistTimes at which state collpase occurred. Only for Monte Carlo solver. col_whichlistWhich collapse operator was responsible for each collapse in; col_times. Only for Monte Carlo solver. class SolverConfiguration[source]¶. class Stats(section_names=None)[source]¶; Statistical information on the solver performance; Statistics can be grouped into sections.; If no section names are given in the the contructor, then all statistics; will be added to one section ‘main’. Parameters. section_nameslistlist of keys that will be used as keys for the sections; These keys will also be used as names for the sections; The text in the output can be overidden by setting the header property; of the section; If no names are given then one section called ‘main’ is created. Attributes. sectionsOrderedDict of _StatsSectionThese are the sections that are created automatically on instantiation; or added using add_section. headerstringSome text that will be used as the heading in the report; By default there is None. total_timefloatTime in seconds for the solver to complete processing; Can be None, meaning that total timing percentages will be reported. add_count(key, value, section=None)[source]¶; Add value to count. If key does not already exist in section then; it is created with this value",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:97474,Performance,optimiz,optimized,97474,"`qutip.Qobj`, optionalOld API, same as init_state. solver: str“mesolve” or “mcsolve”. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)[source]¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)[source]¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. class OptPulseProcessor(N, drift=None, t1=None, t2=None, dims=None)[source]¶; A processor, which takes the Hamiltonian available; as dynamic generators, calls the; qutip.control.optimize_pulse_unitary function; to find an optimized pulse sequence for the desired quantum circuit.; The processor can simulate the evolution under the given; control pulses using qutip.mesolve.; (For attributes documentation, please; refer to the parent class Processor). Parameters. N: intThe number of component systems. drift: `:class:`qutip.Qobj`The drift Hamiltonian. The size must match the whole quantum system. t1: list or floatCharacterize the decoherence of amplitude damping for; each qubit. A list of size N or a float for all qubits. t2: list of floatCharacterize the decoherence of dephasing for; each qubit. A list of size N or a float for all qubits. dims: listThe dimension of each component system.; Default value is a; qubit system of dim=[2,2,2,...,2]. add_control(qobj, targets=None, cyclic_permutation=False, label=None)¶; Add a control Hamiltonian to the processor. It creates a new; Pulse; object for the device that is turned off; (tlist = None, coeff = None). To activate the pulse, one; can set its tlist and coeff. Param",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:181694,Performance,optimiz,optimized,181694,"lphase_compiler(gate, args)[source]¶; Compiler for the GLOBALPHASE gate. iswap_compiler(gate, args)[source]¶; Compiler for the ISWAP gate. rx_compiler(gate, args)[source]¶; Compiler for the RX gate. rz_compiler(gate, args)[source]¶; Compiler for the RZ gate. sqrtiswap_compiler(gate, args)[source]¶; Compiler for the SQRTISWAP gate. class Scheduler(method='ALAP', constraint_functions=None)[source]¶; A gate (pulse) scheduler for quantum circuits (instructions).; It schedules a given circuit or instructions; to reduce the total execution time by parallelization.; It uses heuristic methods mainly from; in https://doi.org/10.1117/12.666419.; The scheduler includes two methods,; “ASAP”, as soon as possible, and “ALAP”, as late as possible.; The later is commonly used in quantum computation; because of the finite lifetime of qubits.; The scheduler aims at pulse schedule and; therefore does not consider merging gates to reduce the gates number.; It assumes that the input circuit is optimized at the gate level; and matches the hardware topology. Parameters. method: str“ASAP” for as soon as possible.; “ALAP” for as late as possible. constraint_functions: list, optionalA list of hardware constraint functions.; Default includes a function qubit_contraint,; i.e. one qubit cannot be used by two gates at the same time. apply_constraint(ind1, ind2, instructions)[source]¶; Apply hardware constraint to check; if two instructions can be executed in parallel. Parameters. ind1, ind2: intindices of the two instructions. instructions: listThe instruction list. commutation_rules(ind1, ind2, instructions)[source]¶; Determine if two gates commute, given that their used qubits overlap.; Since usually the input gates are already in a universal gate sets,; it uses an oversimplified condition:; If the two gates do not have the same name,; they are considered as not commuting.; If they are the same gate and have the same controls or targets,; they are considered as commuting.; E.g. CNOT 0, 1 commu",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:186970,Performance,Optimiz,Optimizer,186970,"Notice that gate3 and gate4 commute with gate2,; therefore, the order is changed to reduce the number of cycles. class Instruction(gate, tlist=None, pulse_info=(), duration=1)[source]¶; The instruction that implements a quantum gate.; It contains the control pulse required to implement the gate; on a particular hardware model. Parameters. gate: :class:`.Gate`The quantum gate. duration: list, optionalThe execution time needed for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188299,Performance,optimiz,optimize,188299,"s; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:188360,Performance,optimiz,optimize,188360,") system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error. method_paramsDictionaryOptions for the optim_method.; Note that where there is an equivalent attribute of this instance; or the termination_conditions (for example maxiter); it will override an value in these options. approx_gradboolIf set True then the method will approximate the gradient itself; (if it has requirement and facility for this); This will mean that the fid_err_grad_wrapper will not get called; Note it should be left False when using the Dynamics; to calculate approximate gradients; Note it is set True automatically when the alg is CRAB. amp_lboundfloat or list of floatslower boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. amp_uboundfloat or list of floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:190174,Performance,perform,performance,190174,"floatsupper boundaries for the control amplitudes; Can be a scalar value applied to all controls; or a list of bounds for each control. boundsList of floatsBounds for the parameters.; If not set before the run_optimization call then the list; is built automatically based on the amp_lbound and amp_ubound; attributes.; Setting this attribute directly allows specific bounds to be set; for individual parameters.; Note: Only some methods use bounds. dynamicsDynamics (subclass instance)describes the dynamics of the (quantum) system to be control optimised; (see Dynamics classes for details). configOptimConfig instancevarious configuration options; (see OptimConfig for details). termination_conditionsTerminationCondition instanceattributes determine when the optimisation will end. pulse_generatorPulseGen (subclass instance)(can be) used to create initial pulses; not used by the class, but set by pulseoptim.create_pulse_optimizer. statsStatsattributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Dynamics instance. dumpdump.OptimDumpContainer for data dumped during the optimisation.; Can be set by specifying the dumping level or set directly.; Note this is mainly intended for user and a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=Non",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:191492,Performance,optimiz,optimize,191492," a development debugging; but could be used for status information during a long optimisation. dumpingstringThe level of data dumping that will occur during the optimisation. dump_to_fileboolIf set True then data will be dumped to file during the optimisation; dumping will be set to SUMMARY during init_optim; if dump_to_file is True and dumping not set.; Default is False. dump_dirstringBasically a link to dump.dump_dir. Exists so that it can be set through; optim_params.; If dump is None then will return None or will set dumping to SUMMARY; when setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the curre",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194049,Performance,optimiz,optimize,194049,"t the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); Although the optimisation algorithms have a check within them for; function convergence, i.e. local minima, the sum of the squares; of the normalised gradient is checked explicitly, and the; optimisation is terminated if this is below the min_gradient_norm; condition. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason fo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195079,Performance,Optimiz,OptimizerBFGS,195079,"spect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; th",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195593,Performance,optimiz,optimize,195593,"een tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Opti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:195910,Performance,Optimiz,OptimizerLBFGSB,195910," in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:196262,Performance,optimiz,optimize,196262,"mplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_bfgs; function; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerLBFGSB(config, dyn, params=None)[source]¶; Implements the run_optimization method using the L-BFGS-B algorithm. Attributes. max_metric_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and detail",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197049,Performance,optimiz,optimize,197049,"_corrintegerThe maximum number of variable metric corrections used to define; the limited memory matrix. That is the number of previous; gradient values that are used to approximate the Hessian; see the scipy.optimize.fmin_l_bfgs_b documentation for description; of m argument. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197576,Performance,Optimiz,OptimizerCrab,197576,"mplitudes to minimise the fidelity error; using the L-BFGS-B algorithm, which is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197695,Performance,optimiz,optimize,197695," is the constrained; (bounded amplitude values), limited memory, version of the; Broyden–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_opti",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:197784,Performance,Optimiz,Optimizer,197784,"n–Fletcher–Goldfarb–Shanno algorithm.; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to the:; scipy.optimize.fmin_l_bfgs_b function; This in turn is a warpper for well established implementation of; the L-BFGS-B algorithm written in Fortran, which is therefore; very fast. See SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198176,Performance,Optimiz,OptimizerCrabFmin,198176,"SciPy documentation for credit and details on; this function.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation wil",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198304,Performance,optimiz,optimize,198304,"rm_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function v",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198504,Performance,Optimiz,Optimizer,198504,"es; the final fidelity, time evolution, reason for termination etc. class OptimizerCrab(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1].; It uses the scipy.optimize.minimize function with the method specified; by the optim_method attribute. See Optimizer.run_optimization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returne",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:198797,Performance,optimiz,optimize,198797,"imization for details; It minimises the fidelity error function with respect to the CRAB; basis function coefficients.; AJGP ToDo: Add citation here. init_optim(term_conds)[source]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. class OptimizerCrabFmin(config, dyn, params=None)[source]¶; Optimises the pulse using the CRAB algorithm [1], [2].; It uses the scipy.optimize.fmin function which is effectively a wrapper; for the Nelder-Mead method. It minimises the fidelity error function with; respect to the CRAB basis function coefficients. This is the default; Optimizer for CRAB.; References. 1; P. Doria, T. Calarco & S. Montangero. Phys. Rev. Lett. 106, 190501; (2011). 2; T. Caneva, T. Calarco, & S. Montangero. Phys. Rev. A 84, 022326; (2011). run_optimization(term_conds=None)[source]¶; This function optimisation method is a wrapper to the; scipy.optimize.fmin function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals which; in the case of CRAB are the basis function coefficients; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Specifically to the fmin; method, the optimisation will stop when change parameter values; is less than xtol or the change in function value is below ftol.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimIterSummary[source]¶; A summary of the most recent iteration of the pulse optimisation. Attributes. iter_numintIteration number of the pulse optimisation. fid_func_call_numintFidel",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:201077,Performance,optimiz,optimize,201077,"efloatTime spent computing the pulse optimisation so far; (in seconds of elapsed time). class TerminationConditions[source]¶; Base class for all termination conditions; Used to determine when to stop the optimisation algorithm; Note different subclasses should be used to match the type of; optimisation being used. Attributes. fid_err_targfloatTarget fidelity error. fid_goalfloatgoal fidelity, e.g. 1 - self.fid_err_targ; It its typical to set this for unitary systems. max_wall_timefloat# maximum time for optimisation (seconds). min_gradient_normfloatMinimum normalised gradient after which optimisation will terminate. max_iterationsintegerMaximum iterations of the optimisation algorithm. max_fid_func_callsintegerMaximum number of calls to the fidelity function during; the optimisation algorithm. accuracy_factorfloatDetermines the accuracy of the result.; Typical values for accuracy_factor are: 1e12 for low accuracy;; 1e7 for moderate accuracy; 10.0 for extremely high accuracy; scipy.optimize.fmin_l_bfgs_b factr argument.; Only set for specific methods (fmin_l_bfgs_b) that uses this; Otherwise the same thing is passed as method_option ftol; (although the scale is different); Hence it is not defined here, but may be set by the user. class OptimResult[source]¶; Attributes give the result of the pulse optimisation attempt. Attributes. termination_reasonstringDescription of the reason for terminating the optimisation. fidelityfloatfinal (normalised) fidelity that was achieved. initial_fid_errfloatfidelity error before optimisation starting. fid_errfloatfinal fidelity error that was achieved. goal_achievedbooleanTrue is the fidely error achieved was below the target. grad_norm_finalfloatFinal value of the sum of the squares of the (normalised) fidelity; error gradients. grad_norm_min_reachedfloatTrue if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exc",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:202870,Performance,optimiz,optimizerOptimizerInstance,202870,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:202904,Performance,Optimiz,Optimizer,202904,"if the optimisation terminated due to the minimum value; of the gradient being reached. num_iterintegerNumber of iterations of the optimisation algorithm completed. max_iter_exceededbooleanTrue if the iteration limit was reached. max_fid_func_exceededbooleanTrue if the fidelity function call limit was reached. wall_timefloattime elapsed during the optimisation. wall_time_limit_exceededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENS",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203651,Performance,perform,performance,203651,"n. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propaga",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204369,Performance,perform,performance,204369,"at is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory s",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:204500,Performance,Optimiz,Optimizer,204500,"meslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData typ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:205607,Performance,perform,perform,205607,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:205657,Performance,perform,perform,205657,"mputerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_computerFidelityComputer (subclass instance)Used to computer the fidelity error and the fidelity error; gradient. memory_optimizationintLevel of memory optimisation. Setting to 0 (default) means that; execution speed is prioritized over memory.; Setting to 1 means that some memory prioritisation steps will be; taken, for instance using Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:206150,Performance,cache,cache,206150,"ng Qobj (and hence sparse arrays) as the; the internal operator data type, and not caching some operators; Potentially further memory saving maybe made with; memory_optimization > 1.; The options are processed in _set_memory_optimizations, see; this for more information. Individual memory saving options can be; switched by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:206403,Performance,cache,cached,206403,"d by settting them directly (see below). oper_dtypetypeData type for internal dynamics generators, propagators and time; evolution operators. This can be ndarray or Qobj.; Qobj may perform better for larger systems, and will also; perform better when (custom) fidelity measures use Qobj methods; such as partial trace.; See _choose_oper_dtype for how this is chosen when not specified. cache_phased_dyn_genboolIf True then the dynamics generators will be saved with and; without the propagation prefactor (if there is one); Defaults to True when memory_optimization=0, otherwise False. cache_prop_gradboolIf the True then the propagator gradients (for exact gradients) will; be computed when the propagator are computed and cache until; the are used by the fidelity computer. If False then the; fidelity computer will calculate them as needed.; Defaults to True when memory_optimization=0, otherwise False. cache_dyn_gen_eigenvectors_adj: boolIf True then DynamicsUnitary will cached the adjoint of; the Hamiltion eignvector matrix; Defaults to True when memory_optimization=0, otherwise False. sparse_eigen_decomp: boolIf True then DynamicsUnitary will use the sparse eigenvalue; decomposition.; Defaults to True when memory_optimization<=1, otherwise False. num_tslotsintegerNumber of timeslots (aka timeslices). num_ctrlsintegercalculate the of controls from the length of the control list. evo_timefloatTotal time for the evolution. tauarray[num_tslots] of floatDuration of each timeslot; Note that if this is set before initialize_controls is called; then num_tslots and evo_time are calculated from tau, otherwise; tau is generated from num_tslots and evo_time, that is; equal size time slices. timearray[num_tslots+1] of floatCumulative time for the evolution, that is the time at the start; of each time slice. drift_dyn_genQobj or list of QobjDrift or system dynamics generator (Hamiltonian); Matrix defining the underlying dynamics of the system; Can also be a list of Qobj (length num_tslo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223470,Performance,cache,cached,223470,"der). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:223913,Performance,cache,cached,223913,"litude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any config",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226422,Performance,cache,cached,226422,"ance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242153,Performance,Perform,Perform,242153, of time the timeslot evolution is recomputed; (It is only computed if any amplitudes changed since the last call). num_fidelity_computesintegerNumber of time the fidelity is computed; (It is only computed if any amplitudes changed since the last call). num_grad_computesintegerNumber of time the gradient is computed; (It is only computed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension fo,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:242501,Performance,Optimiz,Optimizer,242501,ed if any amplitudes changed since the last call). num_ctrl_amp_updatesintegerNumber of times the control amplitudes are updated. mean_num_ctrl_amp_updates_per_iterfloatMean number of control amplitude updates per iteration. num_timeslot_changesintegerNumber of times the amplitudes of a any control in a timeslot changes. mean_num_timeslot_changes_per_updatefloatMean average number of timeslot amplitudes that are changed per update. num_ctrl_amp_changesintegerNumber of times individual control amplitudes that are changed. mean_num_ctrl_amp_changes_per_updatefloatMean average number of control amplitudes that are changed per update. calculate()[source]¶; Perform the calculations (e.g. averages) that are required on the stats; Should be called before calling report. report()[source]¶; Print a report of the stats to the console. class Dump[source]¶; A container for dump items.; The lists for dump items is depends on the type; Note: abstract class. Attributes. parentsome control object (Dynamics or Optimizer)aka the host. Object that generates the data that is dumped and is; host to this dump object. dump_dirstrdirectory where files (if any) will be written out; the path and be relative or absolute; use ~/ to specify user home directory; Note: files are only written when write_to_file is True; of writeout is called explicitly; Defaults to ~/.qtrl_dump. levelstringThe level of data dumping that will occur. write_to_fileboolWhen set True data and summaries (as configured) will be written; interactively to file during the processing; Set during instantiation by the host based on its dump_to_file attrib. dump_file_extstrDefault file extension for any file names that are auto generated. fname_basestrFirst part of any auto generated file names.; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrde,MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:244261,Performance,optimiz,optimizer,244261,"; This is usually overridden in the subclass. dump_summaryboolIf True a summary is recorded each time a new item is added to the; the dump.; Default is True. summary_sepstrdelimiter for the summary file.; default is a space. data_sepstrdelimiter for the data files (arrays saved to file).; default is a space. summary_filestrFile path for summary file.; Automatically generated. Can be set specifically. create_dump_dir()[source]¶; Checks dump directory exists, creates it if not. property level¶; The level of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:244773,Performance,optimiz,optimizer,244773," of data dumping that will occur. SUMMARYA summary will be recorded. FULLAll possible dumping. CUSTOMSome customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify what specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.Evo",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10357,Safety,safe,safe,10357,"erator. Raises. TypeErrorQuantum operator is not square. extract_states(states_inds, normalize=False)[source]¶; Qobj with states in state_inds only. Parameters. states_indslist of integerThe states that should be kept. normalizeTrue / FalseWeather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwic",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:10736,Safety,safe,safebool,10736,"ably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns. qqutip.QobjA new instance of qutip.Qobj that contains only the states; corresponding to the indices in state_inds. Notes; Experimental. full(order='C', squeeze=False)[source]¶; Dense array from quantum object. Parameters. orderstr {‘C’, ‘F’}Return array in C (default) or Fortran ordering. squeezebool {False, True}Squeeze output array. Returns. dataarrayArray of complex data from quantum objects data attribute. groundstate(sparse=False, tol=0, maxiter=100000, safe=True)[source]¶; Ground state Eigenvalue and Eigenvector.; Defined for quantum operators or superoperators only. Parameters. sparseboolUse sparse Eigensolver. tolfloatTolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiterintMaximum number of iterations performed by sparse solver (if used). safebool (default=True)Check for degenerate ground state. Returns. eigvalfloatEigenvalue for the ground state of quantum operator. eigvecqutip.QobjEigenket for the ground state of quantum operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. inv(sparse=False)[source]¶; Matrix inverse of a quantum operator; Operator must be square. Returns. operqutip.QobjMatrix inverse of operator. Raises. TypeErrorQuantum object is not square. matrix_element(bra, ket)[source]¶; Calculates a matrix element.; Gives the matrix element for the quantum object sandwiched between a; bra and ket vector. Parameters. braqutip.QobjQuantum object of type ‘bra’ or ‘ket’. ketqutip.QobjQuantum object of type ‘ket’. Returns. elemcomplexComplex valued matrix element. Notes; It is slightly more computationally efficient to use a ket; vector for the ‘bra’ input. norm(norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Norm of a quantum object.; Default norm is L2-norm",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:22867,Safety,safe,safePickleboolFlag,22867,"lue of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obtain a list of all the coefficients at a particular; time. coeff_fileslistRuntime created files to delete with the instance. dummy_cteboolIs self.cte an empty Qobj. constboolIndicates if quantum object is constant. type{“cte”, “string”, “func”, “array”, “spline”, “mixed_callable”, “mixed_compilable”}Information about the type of coefficients used in the entire object. num_objintNumber of Qobj in the QobjEvo. use_cythonboolFlag to compile string to Cython or Python. safePickleboolFlag to not share pointers between thread. apply(function, *args, **kw_args)[source]¶; Apply the linear function function to every Qobj included in; this time-dependent object, and return a new QobjEvo with the; result.; Any additional arguments or keyword arguments will be appended to every; function call. apply_decorator(function, *args, str_mod=None, inplace_np=False, **kw_args)[source]¶; Apply the given function to every time-dependent coefficient in the; quantum object, and return a new object with the result.; Any additional arguments and keyword arguments will be appended to the; function calls. Parameters. functioncallable(time_dependence, *args, **kwargs) -> time_dependence. Called; on each time-dependent coefficient to produce a new coefficient.; The additional arguments and keyword arguments are the ones given; to this function. str_modlistA 2-element list of strings, that will additionally wrap any string; time-dependences. An existing time-dependence string x will; become str_mod[0] + x",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19821,Security,access,access,19821," The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers. Replace <n> with; an integer literal, e.g. ""expect_op_0"". This will be either real- or; complex-valued, depending on whether the state and operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first paramete",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:21421,Security,access,access,21421,"operator are both; Hermitian or not.; ""collapse"": (mcsolve only) a list of the collapses that have; occurred during the evolution. Each element of the list is a 2-tuple; (time: float, which: int), where time is the time this collapse; happened, and which is an integer indexing the c_ops argument to; mcsolve. Parameters. Q_objectlist, Qobj or QobjEvoThe time-dependent description of the quantum object. This is of the; same format as the first parameter to the general ODE solvers; in; general, it is a list of [Qobj, time_dependence] pairs that are; summed to make the whole object. The time_dependence can be any of; the formats discussed in the previous section. If a particular term; has no time-dependence, then you should just give the Qobj instead; of the 2-element list. argsdict, optionalMapping of {str: object}, discussed in greater detail above. The; strings can be any valid Python identifier, and the objects are of the; consumable types. See the previous section for details on the “magic”; names used to access solver internals. tlistarray_like, optionalList of the times any numpy-array coefficients describe. This is used; only in at least one of the time dependences in Q_object is given; in Numpy-array format. The times must be sorted, but need not be; equidistant. Values inbetween will be interpolated. Attributes. cteQobjConstant part of the QobjEvo. opslist of EvoElementInternal representation of the time-dependence structure of the; elements. argsdictThe current value of the args dictionary passed into the; constructor. dynamics_argslistNames of the dynamic arguments that the solvers will generate. These; are the magic names that were found in the args parameter. tlistarray_likeList of times at which the numpy-array coefficients are applied. compiledstrA string representing the properties of the low-level Cython class; backing this object (may be empty). compiled_qobjevoCQobjCte or CQobjEvoTdCython version of the QobjEvo. coeff_getcallableObject called to obta",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203246,Security,access,access,203246,"ededbooleanTrue if the wall time limit was reached. timearray[num_tslots+1] of floatTime are the start of each timeslot; with the final value being the total evolution time. initial_ampsarray[num_tslots, n_ctrls]The amplitudes at the start of the optimisation. final_ampsarray[num_tslots, n_ctrls]The amplitudes at the end of the optimisation. evo_full_finalQobjThe evolution operator from t=0 to t=T based on the final amps. evo_full_initialQobjThe evolution operator from t=0 to t=T based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exis",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:421,Testability,Log,Log,421,". Classes — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Classes. Classes¶. Qobj¶. class Qobj(inpt=None, dims=None, shape=None, type=None, isherm=None, copy=True, fast=False, superrep=None, isunitary=None)[source]¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operations. The Qobj constructor optionally takes a; dimension list and/or shape list as arguments. Parameters. inptarray_likeData for vector/matrix representation of the quantum object. dimslistDimensions of object used for tensor products. shapelistShape of underlying data structure (matrix shape). copyboolFlag specifying whether Qobj should get a copy of the; input data, or use the original. fastboolFlag for fast qobj creation when running ode solvers.; This parameter is used internally only. Attributes. dataarray_likeSparse matrix characterizing the quantum object. dimslistList of dimensions keeping track of the tensor structure. shapelistShape of the underlying data array. typestrType of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,; ‘operator-bra’, or ‘super’. superrepstrRepresentation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). ishermboolIndicates if quantum object represents Hermitian operator. isunitaryb",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:18417,Testability,log,log,18417,"is; class is \(Q(t)\), then it is constructed from a set of constant; Qobj \(\{Q_k\}\) and time-dependent scalars \(f_k(t)\) by. \[Q(t) = \sum_k f_k(t) Q_k\]; If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:19236,Testability,log,logspace,19236,"1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; supported by the code to be compiled in the string.; There are some “magic” names that can be specified, whose objects will be; overwritten when used within sesolve, mesolve and; mcsolve. This allows access to the solvers’ internal states, and; they are updated at every call. The initial values of these dictionary; elements is unimportant. The magic names available are:. ""state"": the current state as a Qobj; ""state_vec"": the current state as a column-stacked 1D np.ndarray; ""state_mat"": the current state as a 2D np.ndarray; ""expect_op_<n>"": the current expectation value of the element; e_ops[n], which is an argument to the solvers.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:187462,Testability,log,logger,187462," for the instruction. tlist: array_like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. pulse_info: list, optionalA list of tuples, each tuple corresponding to a pair of pulse label; and pulse coefficient, in the format (str, array_like).; This pulses will implement the desired gate. Attributes. targets: list, optionalThe target qubits. controls: list, optionalThe control qubits. used_qubits: setUnion of the control and target qubits. Optimal control¶. class Optimizer(config, dyn, params=None)[source]¶; Base class for all control pulse optimisers. This class should not be; instantiated, use its subclasses. This class implements the fidelity,; gradient and interation callback functions. All subclass objects must be; initialised with a. OptimConfig instance - various configuration options; Dynamics instance - describes the dynamics of the (quantum) system; to be control optimised. Attributes. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value. Note: attributes; are created if they do not exist already, and are overwritten if they; do. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the pulse optim algorithm alg. disp_conv_msgboolSet true to display a convergence message; (for scipy.optimize.minimize methods anyway). optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fi",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192066,Testability,log,logs,192066,"setting a path. iter_summaryOptimIterSummarySummary of the most recent iteration.; Note this is only set if dummping is on. apply_method_params(params=None)[source]¶; Loops through all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimise",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:192244,Testability,log,logs,192244,"all the method_params; (either passed here or the method_params attribute); If the name matches an attribute of this object or the; termination conditions object, then the value of this attribute; is set. Otherwise it is assumed to a method_option for the; scipy.optimize.minimize function. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. property dumping¶; The level of data dumping that will occur during the optimisation. NONE : No processing data dumped (Default); SUMMARY : A summary at each iteration will be recorded; FULL : All logs will be generated and dumped; CUSTOM : Some customised level of dumping. When first set to CUSTOM this is equivalent to SUMMARY. It is then up; to the user to specify which logs are dumped. fid_err_func_wrapper(*args)[source]¶; Get the fidelity error achieved using the ctrl amplitudes passed; in as the first argument.; This is called by generic optimisation algorithm as the; func to the minimised. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used to update the stored ctrl values (if they have changed); The error is checked against the target, and the optimisation is; terminated if the target has been achieved. fid_err_grad_wrapper(*args)[source]¶; Get the gradient of the fidelity error with respect to all of the; variables, i.e. the ctrl amplidutes in each timeslot; This is called by generic optimisation algorithm as the gradients of; func to the minimised wrt the variables. The argument is the current; variable values, i.e. control amplitudes, passed as; a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]; and then used",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:194601,Testability,test,tested,194601,"ource]¶; Check optimiser attribute status and passed parameters before; running the optimisation.; This is called by run_optimization, but could called independently; to check the configuration. iter_step_callback_func(*args)[source]¶; Check the elapsed wall time for the optimisation run so far.; Terminate if this has exceeded the maximum allowed time. run_optimization(term_conds=None)[source]¶; This default function optimisation method is a wrapper to the; scipy.optimize.minimize function.; It will attempt to minimise the fidelity error with respect to some; parameters, which are determined by _get_optim_var_vals (see below); The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, wall time, or; function call or iteration count exceeded. Note these; conditions include gradient minimum met (local minima) for; methods that use a gradient.; The function minimisation method is taken from the optim_method; attribute. Note that not all of these methods have been tested.; Note that some of these use a gradient and some do not.; See the scipy documentation for details. Options specific to the; method can be passed setting the method_params attribute.; If the parameter term_conds=None, then the termination_conditions; attribute must already be set. It will be overwritten if the; parameter is not None; The result is returned in an OptimResult object, which includes; the final fidelity, time evolution, reason for termination etc. class OptimizerBFGS(config, dyn, params=None)[source]¶; Implements the run_optimization method using the BFGS algorithm. run_optimization(term_conds=None)[source]¶; Optimise the control pulse amplitudes to minimise the fidelity error; using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm; The optimisation end when one of the passed termination conditions; has been met, e.g. target achieved, gradient minimum met; (local minima), wall time / iteration count exceeded.; Essentially this is wrapper to t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:203796,Testability,log,logger,203796," based on the initial amps. statsStatsObject contaning the stats for the run (if any collected). optimizerOptimizerInstance of the Optimizer used to generate the result. class Dynamics(optimconfig, params=None)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before most of the methods; can be used. init_timeslots can be called sometimes earlier in order; to access timeslot related attributes; This acts as a container for the operators that are used to calculate; time evolution of the system under study. That is the dynamics generators; (Hamiltonians, Lindbladians etc), the propagators from one timeslot to; the next, and the evolution operators. Due to the large number of matrix; additions and multiplications, for small systems at least, the optimisation; performance is much better using ndarrays to represent these operators.; However. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. params: DictionaryThe key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. statsStatsAttributes of which give performance stats for the optimisation; set to None to reduce overhead of calculating stats.; Note it is (usually) shared with the Optimizer object. tslot_computerTimeslotComputer (subclass instance)Used to manage when the timeslot dynamics; generators, propagators, gradients etc are updated. prop_computerPropagatorComputer (subclass instance)Used to compute the propagators and their gradients. fid_com",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:214567,Testability,log,logged,214567,"on assumes that the _apply_phase method has been; set to a custom function. Type; phase_application. property prop¶; List of propagators (Qobj) for each timeslot. property prop_grad¶; Array of propagator gradients (Qobj) for each timeslot, control. refresh_drift_attribs()[source]¶; Reset the dyn_shape, dyn_dims and time_depend_drift attribs. save_amps(file_name=None, times=None, amps=None, verbose=False)[source]¶; Save a file with the current control amplitudes in each timeslot; The first column in the file will be the start time of the slot. Parameters. file_namestringName of the file; If None given the def_amps_fname attribuite will be used. timesList type (or string)List / array of the start times for each slot; If None given this will be retrieved through get_amp_times(); If ‘exclude’ then times will not be saved in the file, just; the amplitudes. ampsArray[num_tslots, num_ctrls]Amplitudes to be saved; If None given the ctrl_amps attribute will be used. verboseBooleanIf True then an info message will be logged. unitarity_check()[source]¶; Checks whether all propagators are unitary. update_ctrl_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; The actual work is completed by the compare_amps method of the; timeslot computer. class DynamicsGenMat(optimconfig, params=None)[source]¶; This sub class can be used for any system where no additional; operator is applied to the dynamics generator before calculating; the propagator, e.g. classical dynamics, Lindbladian. class DynamicsUnitary(optimconfig, params=None)[source]¶; This is the subclass to use for systems with dynamics described by; unitary matrices. E.g. closed systems with Hermitian Hamiltonians; Note a matrix diagonalisation is used to compute the exponent; The eigen decomposition is also used to calculate the propagator gradient.; The method is taken from DYNAMO (see file header). Attributes. drift_hamQobjThis is the drift Hamiltonian ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:217586,Testability,log,logger,217586,"his is the subclass to use for systems where the dynamics is described; by symplectic matrices, e.g. coupled oscillators, quantum optics. Attributes. omegaarray[drift_dyn_gen.shape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:217633,Testability,log,logging,217633,"hape]matrix used in the calculation of propagators (time evolution); with symplectic systems. property dyn_gen_phase¶; The phasing operator for the symplectic group generators; usually refered to as Omega; By default this is applied as ‘postop’ dyn_gen*-Omega; If phase_application is ‘preop’ it is applied as Omega*dyn_gen. class PropagatorComputer(dynamics, params=None)[source]¶; Base for all Propagator Computer classes; that are used to calculate the propagators,; and also the propagator gradient when exact gradient methods are used; Note: they must be instantiated with a Dynamics object, that is the; container for the data that the functions operate on; This base class cannot be used directly. See subclass descriptions; and choose the appropriate one for the application. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:219761,Testability,log,logger,219761,"d; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. dimensional_normfloatNormalisation constant. fid_norm_funcfunctionUsed to normalise the fidelity; See SU and PSU options for the unitary dynamics. grad_norm_funcfunctionUsed to normalise the fidelity gradient; See SU and PSU options for the unitary dynamics. uses_onwd_evobooleanflag to specify whether the onwd_evo evolution operator; (see Dynamics) is used by the FidelityComputer. uses_onto_evoboolean; flag to specify whether the onto_evo evolution operator(see Dynamics) is used by the FidelityComputer. fid_errfloatLast computed value of the fidelity error. fidelityfloatLast computed value of the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227653,Testability,log,logger,227653,"namics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateA",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:230943,Testability,log,logger,230943,"e if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num_tslots] of floatDuration of each timeslot; (copied from Dynamics if given). lboundfloatLower boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is -Inf. uboundfloatUpper boundary for the pulse amplitudes; Note that the scaling and offset attributes can be used to fully; bound the pulse for all generators except some of the random ones; This bound (if set) may result in additional shifting / scaling; Default is Inf. periodicbooleanTrue if the pulse generator produces periodic pulses. randombooleanTrue if the pulse generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245024,Testability,log,log,245024,"hat specifically is dumped. class OptimDump(optim, level='SUMMARY')[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. d",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245086,Testability,log,log,245086,"[source]¶; A container for dumps of optimisation data generated during the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf T",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245163,Testability,log,log,245163,"g the pulse; optimisation. Attributes. dump_summaryboolWhen True summary items are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward e",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:245209,Testability,log,logs,245209," are appended to the iter_summary. iter_summarylist of optimizer.OptimIterSummarySummary at each iteration. dump_fid_errboolWhen True values are appended to the fid_err_log. fid_err_loglist of floatFidelity error at each call of the fid_err_func. dump_grad_normboolWhen True values are appended to the fid_err_log. grad_norm_loglist of floatGradient norm at each call of the grad_norm_log. dump_gradboolWhen True values are appended to the grad_log. grad_loglist of ndarrayGradients at each call of the fid_grad_func. add_iter_summary()[source]¶; add copy of current optimizer iteration summary. property dump_all¶; True if everything (ignoring the summary) is to be dumped. property dump_any¶; True if anything other than the summary is to be dumped. update_fid_err_log(fid_err)[source]¶; add an entry to the fid_err log. update_grad_log(grad)[source]¶; add an entry to the grad log. update_grad_norm_log(grad_norm)[source]¶; add an entry to the grad_norm log. writeout(f=None)[source]¶; write all the logs and the summary out to file(s). Parameters. ffilename or filehandleIf specified then all summary and object data will go in one file.; If None is specified then type specific files will be generated; in the dump_dir; If a filehandle is specified then it must be a byte mode file; as numpy.savetxt is used, and requires this. class DynamicsDump(dynamics, level='SUMMARY')[source]¶; A container for dumps of dynamics data. Mainly time evolution calculations. Attributes. dump_summaryboolIf True a summary is recorded. evo_summarylist of tslotcomp.EvoCompSummarySummary items are appended if dump_summary is True; at each recomputation of the evolution. dump_ampsboolIf True control amplitudes are dumped. dump_dyn_genboolIf True the dynamics generators (Hamiltonians) are dumped. dump_propboolIf True propagators are dumped. dump_prop_gradboolIf True propagator gradients are dumped. dump_fwd_evoboolIf True forward evolution operators are dumped. dump_onwd_evoboolIf True onward evolution oper",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:117,Usability,Guid,Guide,117,". Classes — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Classes. Classes¶. Qobj¶. class Qobj(inpt=None, dims=None, shape=None, type=None, isherm=None, copy=True, fast=False, superrep=None, isunitary=None)[source]¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operations. The Qobj constructor optionally takes a; dimension list and/or shape list as arguments. Parameters. inptarray_likeData for vector/matrix representation of the quantum object. dimslistDimensions of object used for tensor products. shapelistShape of underlying data structure (matrix shape). copyboolFlag specifying whether Qobj should get a copy of the; input data, or use the original. fastboolFlag for fast qobj creation when running ode solvers.; This parameter is used internally only. Attributes. dataarray_likeSparse matrix characterizing the quantum object. dimslistList of dimensions keeping track of the tensor structure. shapelistShape of the underlying data array. typestrType of quantum object: ‘bra’, ‘ket’, ‘oper’, ‘operator-ket’,; ‘operator-bra’, or ‘super’. superrepstrRepresentation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). ishermboolIndicates if quantum object represents Hermitian operator. isunitaryb",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:16213,Usability,simpl,simply,16213,"oved. tr()[source]¶; Trace of a quantum object. Returns. tracefloatReturns the trace of the quantum object. trans()[source]¶; Transposed operator. Returns. operqutip.QobjTranspose of input operator. transform(inpt, inverse=False, sparse=True)[source]¶; Basis transform defined by input array.; Input array can be a matrix defining the transformation,; or a list of kets that defines the new basis. Parameters. inptarray_likeA matrix or list of kets defining the transformation. inverseboolWhether to return inverse transformation. sparseboolUse sparse matrices when possible. Can be slower. Returns. operqutip.QobjOperator in new basis. Notes; This function is still in development. trunc_neg(method='clip')[source]¶; Truncates negative eigenvalues and renormalizes.; Returns a new Qobj by removing the negative eigenvalues; of this instance, then renormalizing to obtain a valid density; operator. Parameters. methodstrAlgorithm to use to remove negative eigenvalues. “clip”; simply discards negative eigenvalues, then renormalizes.; “sgs” uses the SGS algorithm (doi:10/bb76) to find the; positive operator that is nearest in the Shatten 2-norm. Returns. operqutip.QobjA valid density operator. unit(inplace=False, norm=None, sparse=False, tol=0, maxiter=100000)[source]¶; Operator or state normalized to unity.; Uses norm from Qobj.norm(). Parameters. inplaceboolDo an in-place normalization. normstrRequested norm for states / operators. sparseboolUse sparse eigensolver for trace norm. Does not affect other norms. tolfloatTolerance used by sparse eigensolver. maxiterintNumber of maximum iterations performed by sparse eigensolver. Returns. operqutip.QobjNormalized quantum object if not in-place,; else None. QobjEvo¶. class QobjEvo(Q_object=[], args={}, copy=True, tlist=None, state0=None, e_ops=[])[source]¶; A class for representing time-dependent quantum objects, such as quantum; operators and states.; Basic math operations are defined:. +, - : QobjEvo, Qobj, scalars.; *: Qobj, C number;",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:18584,Usability,simpl,simple,18584,"If a scalar \(f_k(t)\) is not passed with a given Qobj, then; that term is assumed to be constant. The next section contains more detail; on the allowed forms of the constants, and gives several examples for how; to build instances of this class.; Time-dependence formats; There are three major formats for specifying a time-dependent scalar:. Python function; string; array. For function format, the function signature must be; f(t: float, args: dict) -> complex, for example; def f1_t(t, args):; return np.exp(-1j * t * args[""w1""]). def f2_t(t, args):; return np.cos(t * args[""w2""]). H = QobjEvo([H0, [H1, f1_t], [H2, f2_t]], args={""w1"":1., ""w2"":2.}). For string-based coeffients, the string must be a compilable python code; resulting in a complex. The following symbols are defined:; pi exp log log10; erf zerf norm proj; real imag conj abs arg; sin sinh asin asinh; cos cosh acos acosh; tan tanh atan atanh; numpy as np; scipy.special as spe. A couple more simple examples:; H = QobjEvo([H0, [H1, 'exp(-1j*w1*t)'], [H2, 'cos(w2*t)']],; args={""w1"":1.,""w2"":2.}). For numpy array format, the array must be an 1d of dtype np.float64 or; np.complex128. A list of times (np.float64) at which the; coeffients must be given as tlist. The coeffients array must have the; same length as the tlist. The times of the tlist do not need to be; equidistant, but must be sorted. By default, a cubic spline interpolation; will be used for the coefficient at time t. If the coefficients are to be; treated as step functions, use the arguments; args = {""_step_func_coeff"": True}. Examples of array-format usage are:; tlist = np.logspace(-5,0,100); H = QobjEvo([H0, [H1, np.exp(-1j*tlist)], [H2, np.cos(2.*tlist)]],; tlist=tlist). Mixing time formats is allowed. It is not possible to create a single; QobjEvo that contains different tlist values, however.; Passing arguments; args is a dict of (name: object). The name must be a valid Python; identifier string, and in general the object can be any type that is; su",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:31751,Usability,clear,clear,31751,"it; state or a vector. Parameters. state_or_vectorQobj/array/list/tuplePosition for the annotaion.; Qobj of a qubit or a vector of 3 elements. textstrAnnotation text.; You can use LaTeX, but remember to use raw string; e.g. r”$langle x rangle$”; or escape backslashes; e.g. “$\langle x \rangle$”. kwargs :Options as for mplot3d.axes3d.text, including:; fontsize, color, horizontalalignment, verticalalignment. add_points(points, meth='s')[source]¶; Add a list of data points to bloch sphere. Parameters. pointsarray_likeCollection of data points. meth{‘s’, ‘m’, ‘l’}Type of points to plot, use ‘m’ for multicolored, ‘l’ for points; connected with a line. add_states(state, kind='vector')[source]¶; Add a state vector Qobj to Bloch sphere. Parameters. stateQobjInput state vector. kind{‘vector’, ‘point’}Type of object to plot. add_vectors(vectors)[source]¶; Add a list of vectors to Bloch sphere. Parameters. vectorsarray_likeArray with vectors of unit length or smaller. clear()[source]¶; Resets Bloch sphere data sets to empty. make_sphere()[source]¶; Plots Bloch sphere and data sets. render()[source]¶; Render the Bloch sphere and its data sets in on given figure and axes. save(name=None, format='png', dirc=None, dpin=None)[source]¶; Saves Bloch sphere to file of type format in directory dirc. Parameters. namestrName of saved image. Must include path and format as well.; i.e. ‘/Users/Paul/Desktop/bloch.png’; This overrides the ‘format’ and ‘dirc’ arguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikip",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:33236,Usability,simpl,simplest,33236,"rguments. formatstrFormat of output image. dircstrDirectory for output images. Defaults to current working directory. dpinintResolution in dots per inch. Returns. File containing plot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. Distributions¶. class QFunc(xvec, yvec, g: float = 1.4142135623730951, memory: float = 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:33443,Usability,simpl,simple,33443,"lot of Bloch sphere. set_label_convention(convention)[source]¶; Set x, y and z labels according to one of conventions. Parameters. conventionstringOne of the following:. “original”; “xyz”; “sx sy sz”; “01”; “polarization jones”; “polarization jones letters”; see also: http://en.wikipedia.org/wiki/Jones_calculus; “polarization stokes”; see also: http://en.wikipedia.org/wiki/Stokes_parameters. show()[source]¶; Display Bloch sphere and corresponding data sets.; Notes; When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; b = Bloch(..., fig=fig) and then call b.show() in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call .show(); in the cell you create the figure in. vector_mutation¶; Sets the width of the vectors arrowhead. vector_style¶; Style of Bloch vectors, default = ‘-|>’ (or ‘simple’). vector_width¶; Width of Bloch vectors, default = 5. Distributions¶. class QFunc(xvec, yvec, g: float = 1.4142135623730951, memory: float = 1024)[source]¶; Class-based method of calculating the Husimi-Q function of many different; quantum states at fixed phase-space points 0.5*g* (xvec + i*yvec).; This class has slightly higher first-usage costs than qfunc, but; subsequent operations will be several times faster. However, it can require; quite a lot of memory. Call the created object as a function to retrieve; the Husimi-Q function. Parameters. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of hbar in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). memoryreal, default 1024Size in MB that may be used internally as workspace. This class will; raise",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38732,Usability,progress bar,progress bar,38732," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:38779,Usability,progress bar,progress bar,38779," thereof, for; showing the progress of the simulation. statsqutip.solver.Statsoptional container for holding performance statitics; If None is set, then statistics are not collected; There may be an overhead in collecting statistics. exp_coefflist of complexCoefficients for the exponential series terms. exp_freqlist of complexFrequencies for the exponential series terms. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Configure the solver using the passed parameters; The parameters are described in the class attributes, unless there; is some specific behaviour. Parameters. optionsqutip.solver.OptionsGeneric solver options.; If set to None the default options will be used. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation.; If set to None, then the default progress bar will be used; Set to False for no progress bar. stats: :class:`qutip.solver.Stats`Optional instance of solver.Stats, or a subclass thereof, for; storing performance statistics for the solver; If set to True, then the default Stats for this class will be used; Set to False for no stats. create_new_stats()[source]¶; Creates a new stats object suitable for use with this solver; Note: this solver expects the stats object to have sections. config; integrate. reset()[source]¶; Reset any attributes to default values. class HSolverDL(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=1.0, boltzmann=1.0, renorm=True, bnd_cut_approx=True, options=None, progress_bar=None, stats=None)[source]¶; HEOM solver based on the Drude-Lorentz model for spectral density.; Drude-Lorentz bath the correlation functions can be exactly analytically; expressed as an infinite sum of exponentials which depend on the; temperature, these are called the Matsubara terms or Matsubara frequencies; ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:40968,Usability,feedback,feedback,40968,"pically < 4). Attributes. cut_freqfloatBath spectral density cutoff frequency. renormboolApply renormalisation to coupling terms; Can be useful if using SI units for planck and boltzmann. bnd_cut_approxboolUse boundary cut off approximation; Can be. configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., l",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41119,Usability,feedback,feedback,41119," configure(H_sys, coup_op, coup_strength, temperature, N_cut, N_exp, cut_freq, planck=None, boltzmann=None, renorm=None, bnd_cut_approx=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Co",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41254,Usability,feedback,feedback,41254,"x=None, options=None, progress_bar=None, stats=None)[source]¶; Calls configure from HEOMSolver and sets any attributes; that are specific to this subclass. reset()[source]¶; Reset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dag",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:41459,Usability,feedback,feedback,41459,"eset any attributes to default values. run(rho0, tlist)[source]¶; Function to solve for an open quantum system using the; HEOM model. Parameters. rho0QobjInitial state (density matrix) of the system. tlistlistTime over which system evolves. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. class MemoryCascade(H_S, L1, L2, S_matrix=None, c_ops_markov=None, integrator='propagator', parallel=False, options=None)[source]¶; Class for running memory cascade simulations of open quantum systems; with time-delayed coherent feedback. Attributes. H_Squtip.QobjSystem Hamiltonian (can also be a Liouvillian). L1qutip.Qobj / list of qutip.QobjSystem operators coupling into the feedback loop. Can be a single; operator or a list of operators. L2qutip.Qobj / list of qutip.QobjSystem operators coupling out of the feedback loop. Can be a single; operator or a list of operators. L2 must have the same length as L1. S_matrix: *array*S matrix describing which operators in L1 are coupled to which; operators in L2 by the feedback channel. Defaults to an n by n identity; matrix where n is the number of elements in L1/L2. c_ops_markovqutip.Qobj / list of qutip.QobjDecay operators describing conventional Markovian decay channels.; Can be a single operator or a list of operators. integratorstr {‘propagator’, ‘mesolve’}Integrator method to use. Defaults to ‘propagator’ which tends to be; faster for long times (i.e., large Hilbert space). parallelboolRun integrator in parallel if True. Only implemented for ‘propagator’; as the integrator method. optionsqutip.solver.OptionsGeneric solver options. outfieldcorr(rho0, blist, tlist, tau, c1=None, c2=None)[source]¶; Compute output field expectation value; <O_n(tn)…O_2(t2)O_1(t1)> for times t1,t2,… and; O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger. Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). blistarray_likeList of integers specifying the field operators:; 0: I (nothing); 1: b_out; 2: b_o",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:44872,Usability,learn,learningtimes,44872,"where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns. : qutip.Qobjtime-propagator for computing field correlation function. propagator(t, tau, notrace=False)[source]¶; Compute propagator for time t and time-delay tau. Parameters. tfloatcurrent time. taufloattime-delay. notracebool {False}If this optional is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:45273,Usability,learn,learning,45273," is set to True, a propagator is returned for a; cascade of k systems, where \((k-1) tau < t < k tau\).; If set to False (default), a generalized partial trace is performed; and a propagator for a single system is returned. Returns; ——-; : :class:`qutip.Qobj`time-propagator for reduced system dynamics. rhot(rho0, t, tau)[source]¶; Compute the reduced system density matrix \(\rho(t)\). Parameters. rho0qutip.Qobjinitial density matrix or state vector (ket). tfloatcurrent time. taufloattime-delay. Returns. : qutip.Qobjdensity matrix at time \(t\). class TTMSolverOptions(dynmaps=None, times=[], learningtimes=[], thres=0.0, options=None)[source]¶; Class of options for the Transfer Tensor Method solver. Attributes. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. timesarray_likeList of times \(t_n\) at which to calculate \(\rho(t_n)\). learningtimesarray_likeList of times \(t_k\) to use as learning times if argument; dynmaps is a callback function. thresfloatThreshold for halting. Halts if \(||T_{n}-T_{n-1}||\) is below; treshold. optionsqutip.solver.OptionsGeneric solver options. Solver Options and Results¶. class ExpectOps(e_ops=[], super_=False)[source]¶; Contain and compute expectation values. class Options(atol=1e-08, rtol=1e-06, method='adams', order=12, nsteps=1000, first_step=0, max_step=0, min_step=0, average_expect=True, average_states=False, tidy=True, num_cpus=0, norm_tol=0.001, norm_t_tol=1e-06, norm_steps=5, rhs_reuse=False, rhs_filename=None, ntraj=500, gui=False, rhs_with_state=False, store_final_state=False, store_states=False, steady_state_average=False, seeds=None, normalize_output=True, use_openmp=None, openmp_threads=None)[source]¶; Class of options for evolution solvers such as qutip.mesolve and; qutip.mcsolve. Options can be specified either as arguments to the; constructor:; opts = Options(order=10, ...). or by changing the class attributes after cr",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52166,Usability,clear,clear,52166,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:52184,Usability,Clear,Clear,52184,"h this string when concatenating. section: string or `class`_StatsSectionSection which to add the message to.; If None given, the default (first) section will be used. add_section(name)[source]¶; Add another section with the given name. Parameters. namestringwill be used as key for sections dict; will also be the header for the section. Returns. section_StatsSectionThe new section. add_timing(key, value, section=None)[source]¶; Add value to timing. If key does not already exist in section then; it is created with this value.; If key already exists it is increased by the give value; value is expected to be a float, and given in seconds. Parameters. keystringkey for the section.timings dictionary; reusing a key will result in numerical addition of value. valueintInitial value of the timing, or added to an existing timing. section: string or `class`_StatsSectionSection which to add the timing to.; If None given, the default (first) section will be used. clear()[source]¶; Clear counts, timings and messages from all sections. report(output=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='utf-8'>)[source]¶; Report the counts, timings and messages from the sections.; Sections are reported in the order that the names were supplied; in the constructor.; The counts, timings and messages are reported in the order that they; are added to the sections; The output can be written to anything that supports a write method,; e.g. a file or the console (default); The output is intended to in markdown format. Parameters. outputstreamfile or console stream - anything that support write - where; the output will be written. set_total_time(value, section=None)[source]¶; Sets the total time for the complete solve or for a specific section; value is expected to be a float, and given in seconds. Parameters. valuefloatTime in seconds to complete the solver section. sectionstring or classSection which to set the total_time for; If None given, the total_time for complete solve is set. class",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:57801,Usability,progress bar,progress bar,57801," instance returned by the solver. noiseint, or 1D array of int, or 4D array of float; int : seed of the noise; 1D array : length = ntraj, seeds for each trajectories.; 4D array : (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2]).; Vector for the noise, the len of the last dimensions is doubled for; solvers of order 1.5. This corresponds to results.noise. noiseDepthintNumber of terms kept of the truncated series used to create the; noise used by taylor2.0 solver. normalizebool(default True for (photo)ssesolve, False for (photo)smesolve); Whether or not to normalize the wave function during the evolution.; Normalizing density matrices introduce numerical errors. optionsqutip.solver.OptionsGeneric solver options. Only options.average_states and; options.store_states are used. map_func: functionA map function or managing the calls to single-trajactory solvers. map_kwargs: dictionaryOptional keyword arguments to the map_func function function. progress_barqutip.ui.BaseProgressBarOptional progress bar class instance. Permutational Invariance¶. class Dicke(N, hamiltonian=None, emission=0.0, dephasing=0.0, pumping=0.0, collective_emission=0.0, collective_dephasing=0.0, collective_pumping=0.0)[source]¶; The Dicke class which builds the Lindbladian and Liouvillian matrix. Parameters. N: intThe number of two-level systems. hamiltonianqutip.QobjA Hamiltonian in the Dicke basis.; The matrix dimensions are (nds, nds),; with nds being the number of Dicke states.; The Hamiltonian can be built with the operators; given by the jspin functions. emission: floatIncoherent emission coefficient (also nonradiative emission).; default: 0.0. dephasing: floatLocal dephasing coefficient.; default: 0.0. pumping: floatIncoherent pumping coefficient.; default: 0.0. collective_emission: floatCollective (superradiant) emmission coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:63208,Usability,simpl,simple,63208,"lective (superradiant) emmission coefficient.; default: 0.0. collective_dephasing: floatCollective dephasing coefficient.; default: 0.0. collective_pumping: floatCollective pumping coefficient.; default: 0.0. M: dictA nested dictionary of the structure {row: {col: val}} which holds; non zero elements of the matrix M. calculate_j_m(dicke_row, dicke_col)[source]¶; Get the value of j and m for the particular Dicke space element. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns. j, m: floatThe j and m values. calculate_k(dicke_row, dicke_col)[source]¶; Get k value from the current row and column element in the Dicke space. Parameters. dicke_row, dicke_col: intThe row and column from the Dicke space matrix. Returns; ——-; k: intThe row index for the matrix M for given Dicke space; element. coefficient_matrix()[source]¶; Generate the matrix M governing the dynamics for diagonal cases.; If the initial density matrix and the Hamiltonian is diagonal, the; evolution of the system is given by the simple ODE: dp/dt = Mp. isdicke(dicke_row, dicke_col)[source]¶; Check if an element in a matrix is a valid element in the Dicke space.; Dicke row: j value index. Dicke column: m value index.; The function returns True if the element exists in the Dicke space and; False otherwise. Parameters. dicke_row, dicke_colintIndex of the element in Dicke space which needs to be checked. solve(rho0, tlist, options=None)[source]¶; Solve the ODE for the evolution of diagonal states and Hamiltonians. tau1(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m, m). tau2(j, m)[source]¶; Calculate coefficient matrix element relative to (j, m+1, m+1). tau3(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m+1, m+1). tau4(j, m)[source]¶; Calculate coefficient matrix element relative to (j-1, m+1, m+1). tau5(j, m)[source]¶; Calculate coefficient matrix element relative to (j+1, m, m). tau6(j, m)[source]¶; Calculate coefficient ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:116964,Usability,simpl,simplicity,116964,"lass:`.QubitCircuit`, optionalA quantum circuit. If given, it first calls the load_circuit; and then calculate the evolution. states: :class:`qutip.Qobj`, optionalOld API, same as init_state. **kwargsKeyword arguments for the qutip solver. Returns. evo_result: qutip.ResultIf analytical is False, an instance of the class; qutip.Result will be returned.; If analytical is True, a list of matrices representation; is returned. save_coeff(file_name, inctime=True)¶; Save a file with the control amplitudes in each timeslot. Parameters. file_name: stringName of the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_params()[source]¶; Save the parameters in the attribute params and check the validity.; (Defined in subclasses); Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)[source]¶; Transfer a parameter to an array. class SpinChain(N, correct_global_phase, sx, sz, sxsy, t1, t2)[source]¶; The processor based on the physical implementation of; a spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically.; It is a base class and should not be used directly, please; refer the the subclasses qutip.qip.device.LinearSpinChain and; qutip.qip.device.CircularSpinChain.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:128336,Usability,simpl,simplicity,128336," the file. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class LinearSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a linear spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize the ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:138774,Usability,simpl,simplicity,138774,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class CircularSpinChain(N, correct_global_phase=True, sx=0.25, sz=1.0, sxsy=0.1, t1=None, t2=None)[source]¶; A processor based on the physical implementation of; a circular spin chain qubits system.; The available Hamiltonian of the system is predefined.; The processor can simulate the evolution under the given; control pulses either numerically or analytically. Parameters. N: intThe number of qubits in the system. correct_global_phase: floatSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. sx: int or listThe delta for each of the qubits in the system. sz: int or listThe epsilon for each of the qubits in the system. sxsy: int or listThe interaction strength for each of the qubit pair in the system. t1: list or float, optionalCharacterize the decoherence of amplitude damping for; each qubit. t2: list of float, optionalCharacterize ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:149216,Usability,simpl,simplicity,149216,"ile. inctime: bool, optionalTrue if the time list should be included in the first column. set_all_tlist(tlist)¶; Set the same tlist for all the pulses. Parameters. tlist: array-like, optionalA list of time at which the time-dependent coefficients are; applied. See Pulse for detailed information`. set_up_ops(N)[source]¶; Generate the Hamiltonians for the spinchain model and save them in the; attribute ctrls. Parameters. N: intThe number of qubits in the system. set_up_params(sx, sz, sxsy)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, and “sxsy”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “sxsy”, list element i is the interaction; between qubits i and i+1. Parameters. sx: float or listThe coefficient of sigmax in the model. sz: flaot or listThe coefficient of sigmaz in the model. Notes; The coefficient of sxsy is defined in the submethods.; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class DispersiveCavityQED(N, correct_global_phase=True, num_levels=10, deltamax=1.0, epsmax=9.5, w0=10.0, wq=None, eps=9.5, delta=0.0, g=0.01, t1=None, t2=None)[source]¶; The processor based on the physical implementation of; a dispersive cavity QED system.; The available Hamiltonian of the system is predefined.; For a given pulse amplitude matrix, the processor can; calculate the state evolution under the given control pulse,; either analytically or numerically.; (Only additional attributes are documented here, for others please; refer to the parent class ModelProcessor). Parameters. N: intThe number of qubits in the system. correct_global_phase: float, optionalSave the global phase, the analytical solution; will track the global phase.; It has no effect on the numerical solution. num_levels: int, optionalThe number of energy levels in the resonator. deltamax: int or list, optionalThe coefficients of",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:160823,Usability,simpl,simplicity,160823,"s. N: intThe number of qubits in the system. set_up_params(N, num_levels, deltamax, epsmax, w0, wq, eps, delta, g)[source]¶; Save the parameters in the attribute params and check the validity.; The keys of params including “sx”, “sz”, “w0”, “eps”, “delta”; and “g”, each; mapped to a list for parameters corresponding to each qubits.; For coupling strength “g”, list element i is the interaction; between qubits i and i+1. Parameters. N: intThe number of qubits in the system. num_levels: intThe number of energy levels in the resonator. deltamax: listThe coefficients of sigma-x for each of the qubits in the system. epsmax: listThe coefficients of sigma-z for each of the qubits in the system. wo: intThe base frequency of the resonator. wq: listThe frequency of the qubits. eps: listThe epsilon for each of the qubits in the system. delta: listThe delta for each of the qubits in the system. g: listThe interaction strength for each of the qubit with the resonator. Notes; All parameters will be multiplied by 2*pi for simplicity. to_array(params, N)¶; Transfer a parameter to an array. class Noise[source]¶; The base class representing noise in a processor.; The noise object can be added to Processor and; contributes to evolution. get_noisy_dynamics(dims, pulses, systematic_noise)[source]¶; Return a pulses list added with noise and; the pulse independent noise in a dummy Pulse object. Parameters. dims: list, optionalThe dimension of the components system, the default value is; [2,2…,2] for qubits system. pulses: list of :class:`.Pulse`The input pulses, on which the noise object is to be applied. systematic_noise: :class:`.Pulse`The dummy pulse with no ideal control element. Returns. noisy_pulses: list of PulseNoisy pulses. systematic_noise: PulseThe dummy pulse representing pulse independent noise. class DecoherenceNoise(c_ops, targets=None, coeff=None, tlist=None, all_qubits=False)[source]¶; The decoherence noise in a processor. It generates lindblad noise; according to the given",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:218658,Usability,simpl,simply,218658,"qutip_utils.logging,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. grad_exactbooleanindicates whether the computer class instance is capable; of computing propagator gradients. It is used to determine; whether to create the Dynamics prop_grad array. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. reset()[source]¶; reset any configuration data. class PropCompApproxGrad(dynamics, params=None)[source]¶; This subclass can be used when the propagator is calculated simply; by expm of the dynamics generator, i.e. when gradients will be calculated; using approximate methods. reset()[source]¶; reset any configuration data. class PropCompDiag(dynamics, params=None)[source]¶; Coumputes the propagator exponentiation using diagonalisation of; of the dynamics generator. reset()[source]¶; reset any configuration data. class PropCompFrechet(dynamics, params=None)[source]¶; Frechet method for calculating the propagator: exponentiating the combined; dynamics generator and the propagator gradient. It should work for all; systems, e.g. unitary, open, symplectic. There are other; PropagatorComputer subclasses that may be more efficient. reset()[source]¶; reset any configuration data. class FidelityComputer(dynamics, params=None)[source]¶; Base class for all Fidelity Computers.; This cannot be used directly. See subclass descriptions and choose; one appropriate for the application; Note: this must be instantiated with a Dynam",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221661,Usability,clear,clear,221661,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:221679,Usability,clear,clear,221679,"ty error. fidelityfloatLast computed value of the normalised fidelity. fidelity_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. fid_err_grad: array[num_tslot, num_ctrls] of floatLast computed values for the fidelity error gradients wrt the; control in the timeslot. grad_normfloatLast computed value for the norm of the fidelity error gradients; (sqrt of the sum of the squares). fid_err_grad_currentbooleanflag to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it i",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222198,Usability,clear,clear,222198," to specify whether the fidelity / fid_err are based on the; current amplitude values. Set False when amplitudes change. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. clear()[source]¶; clear any temporarily held status data. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; returns the absolute distance from the maximum achievable fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_c",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222916,Usability,clear,clear,222916,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:222934,Usability,clear,clear,222934,"rmalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude. init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompUnitary(dynamics, params=None)[source]¶; Computes fidelity error and gradient assuming unitary dynamics, e.g.; closed qubit systems; Note fidelity and gradient calculations were taken from DYNAMO; (see file header). Attributes. phase_optionstring; determines how global phase is treated in fidelity calculations:PSU - global phase ignored; SU - global phase included. fidelity_prenormcomplexLast computed value of the fidelity before it is normalised; It is stored to use in the gradient normalisation calculation. fidelity_prenorm_currentbooleanflag to specify whether fidelity_prenorm are based on the; current amplitude values. Set False when amplitudes change. clear()[source]¶; clear any temporarily held status data. compute_fid_grad()[source]¶; Calculates exact gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; These are returned as a (nTimeslots x n_ctrls) array. flag_system_changed()[source]¶; Flag fidelity and gradients as needing recalculation. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). get_fidelity()[source]¶; Gets the appropriately normalised fidelity value; The normalisation is determined by the fid_norm_func pointer; which should be set in the config. get_fidelity_prenorm()[source]¶; Gets the current fidelity value prior to normalisation; Note the gradient function uses this value; The value is cached, because it is used in t",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:224885,Usability,clear,clear,224885,"tion uses this value; The value is cached, because it is used in the gradient calculation. init_comp()[source]¶; Check configuration and initialise the normalisation. init_normalization()[source]¶; Calc norm of <Ufinal | Ufinal> to scale subsequent norms; When considering unitary time evolution operators, this basically; results in calculating the trace of the identity matrix; and is hence equal to the size of the target matrix; There may be situations where this is not the case, and hence it; is not assumed to be so.; The normalisation function called should be set to either the; PSU - global phase ignored; SU - global phase respected. normalize_PSU(A)[source]¶. normalize_SU(A)[source]¶. normalize_gradient_PSU(grad)[source]¶; Normalise the gradient matrix passed as grad; This PSU version is independent of global phase. normalize_gradient_SU(grad)[source]¶; Normalise the gradient matrix passed as grad; This SU version respects global phase. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. set_phase_option(phase_option=None)[source]¶; Deprecated - use phase_option; Phase options are; SU - global phase important; PSU - global phase is not important. class FidCompTraceDiff(dynamics, params=None)[source]¶; Computes fidelity error and gradient for general system dynamics; by calculating the the fidelity error as the trace of the overlap; of the difference between the target and evolution resulting from; the pulses with the transpose of the same.; This should provide a distance measure for dynamics described by matrices; Note the gradient calculation is taken from:; ‘Robust quantum gates for open systems via optimal control:; Markovian versus non-Markovian dynamics’; Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer. Attributes. scale_factorfloatThe fidelity error calculated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:226738,Usability,clear,clear,226738,"ated is of some arbitary scale. This; factor can be used to scale the fidelity error such that it may; represent some physical measure; If None is given then it is caculated as 1/2N, where N; is the dimension of the drift, when the Dynamics are initialised. compute_fid_err_grad()[source]¶; Calculate exact gradient of the fidelity error function; wrt to each timeslot control amplitudes.; Uses the trace difference norm fidelity; These are returned as a (nTimeslots x n_ctrls) array. get_fid_err()[source]¶; Gets the absolute error in the fidelity. get_fid_err_gradient()[source]¶; Returns the normalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:227334,Usability,clear,clear,227334,"ormalised gradient of the fidelity error; in a (nTimeslots x n_ctrls) array; The gradients are cached in case they are requested; mutliple times between control updates; (although this is not typically found to happen). init_comp()[source]¶; initialises the computer based on the configuration of the Dynamics; Calculates the scale_factor is not already set. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class FidCompTraceDiffApprox(dynamics, params=None)[source]¶; As FidCompTraceDiff, except uses the finite difference method to; compute approximate gradients. Attributes. epsilonfloatcontrol amplitude offset to use when approximating the gradient wrt; a timeslot control amplitude. compute_fid_err_grad()[source]¶; Calculates gradient of function wrt to each timeslot; control amplitudes. Note these gradients are not normalised; They are calulated; These are returned as a (nTimeslots x n_ctrls) array. reset()[source]¶; reset any configuration data and; clear any temporarily held status data. class TimeslotComputer(dynamics, params=None)[source]¶; Base class for all Timeslot Computers; Note: this must be instantiated with a Dynamics object, that is the; container for the data that the methods operate on. Attributes. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. evo_comp_summaryEvoCompSummaryA summary of the most recent evolution computation; Used in the stats and dump; Will be set to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a ",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:229143,Usability,simpl,simply,229143,"t to None if neither stats or dump are set. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value; Note: attributes are created if they do not exist already,; and are overwritten if they do. dump_current()[source]¶; Store a copy of the current time evolution. class TSlotCompUpdateAll(dynamics, params=None)[source]¶; Timeslot Computer - Update All; Updates all dynamics generators, propagators and evolutions when; ctrl amplitudes are updated. compare_amps(new_amps)[source]¶; Determine if any amplitudes have changed. If so, then mark the; timeslots as needing recalculation; Returns: True if amplitudes are the same, False if they have changed. get_timeslot_for_fidelity_calc()[source]¶; Returns the timeslot index that will be used calculate current fidelity; value.; This (default) method simply returns the last timeslot. recompute_evolution()[source]¶; Recalculates the evolution operators.; Dynamics generators (e.g. Hamiltonian) and; prop (propagators) are calculated as necessary. class PulseGen(dyn=None, params=None)[source]¶; Pulse generator; Base class for all Pulse generators; The object can optionally be instantiated with a Dynamics object,; in which case the timeslots and amplitude scaling and offset; are copied from that.; Otherwise the class can be used independently by setting:; tau (array of timeslot durations); or; num_tslots and pulse_time for equally spaced timeslots. Attributes. num_tslotsintegerNumber of timeslots, aka timeslices; (copied from Dynamics if given). pulse_timefloattotal duration of the pulse; (copied from Dynamics.evo_time if given). scalingfloatlinear scaling applied to the pulse; (copied from Dynamics.initial_ctrl_scaling if given). offsetfloatlinear offset applied to the pulse; (copied from Dynamics.initial_ctrl_offset if given). tauarray[num",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:231878,Usability,simpl,simply,231878,"e generator produces random pulses. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. apply_params(params=None)[source]¶; Set object attributes based on the dictionary (if any) passed in the; instantiation, or passed as a parameter; This is called during the instantiation automatically.; The key value pairs are the attribute name and value. gen_pulse()[source]¶; returns the pulse as an array of vales for each timeslot; Must be implemented by subclass. init_pulse()[source]¶; Initialise the pulse parameters. reset()[source]¶; reset attributes to default values. class PulseGenRandom(dyn=None, params=None)[source]¶; Generates random pulses as simply random values for each timeslot. gen_pulse()[source]¶; Generate a pulse of random values between 1 and -1; Values are scaled using the scaling property; and shifted using the offset property; Returns the pulse as an array of vales for each timeslot. reset()[source]¶; reset attributes to default values. class PulseGenZero(dyn=None, params=None)[source]¶; Generates a flat pulse. gen_pulse()[source]¶; Generate a pulse with the same value in every timeslot.; The value will be zero, unless the offset is not zero,; in which case it will be the offset. class PulseGenLinear(dyn=None, params=None)[source]¶; Generates linear pulses. Attributes. gradientfloatGradient of the line.; Note this is calculated from the start_val and end_val if these; are given. start_valfloatStart point of the line. That is the starting amplitude. end_valfloatEnd point of the line.; That is the amplitude at the start of the last timeslot. gen_pulse(gradient=None, start_val=None, end_val=None",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/classes.html:239707,Usability,simpl,simply,239707,"ons. randomize_freqsboolIf True (default) the some random offset is applied to the frequencies. gen_pulse(coeffs=None)[source]¶; Generate a pulse using the Fourier basis with the freqs and; coeffs attributes. Parameters. coeffsfloat array[num_coeffs, num_basis_funcs]The basis coefficient values; If given this overides the default and sets the attribute; of the same name. init_freqs()[source]¶; Generate the frequencies; These are the Fourier harmonics with a uniformly distributed; random offset. init_pulse(num_coeffs=None)[source]¶; Set the initial freq and coefficient values. reset()[source]¶; reset attributes to default values. class Stats[source]¶; Base class for all optimisation statistics; Used for configurations where all timeslots are updated each iteration; e.g. exact gradients; Note that all times are generated using timeit.default_timer() and are; in seconds. Attributes. dyn_gen_namestringText used in some report functions.; Makes sense to set it to ‘Hamiltonian’ when using unitary dynamics; Default is simply ‘dynamics generator’. num_iterintegerNumber of iterations of the optimisation algorithm. wall_time_optim_startfloatStart time for the optimisation. wall_time_optim_endfloatEnd time for the optimisation. wall_time_optimfloatTime elasped during the optimisation. wall_time_dyn_gen_computefloatTotal wall (elasped) time computing combined dynamics generator; (for example combining drift and control Hamiltonians). wall_time_prop_computefloatTotal wall (elasped) time computing propagators, that is the; time evolution from one timeslot to the next; Includes calculating the propagator gradient for exact gradients. wall_time_fwd_prop_computefloatTotal wall (elasped) time computing combined forward propagation,; that is the time evolution from the start to a specific timeslot.; Excludes calculating the propagators themselves. wall_time_onwd_prop_computefloatTotal wall (elasped) time computing combined onward propagation,; that is the time evolution from a specific",MatchSource.WIKI,docs/4.6/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/classes.html
https://qutip.org/docs/4.6/apidoc/functions.html:3840,Availability,down,down,3840,": dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.]; [0.]; [1.]; [0.]; [0.]; [0.]; [0.]; [0.]]. bell_state(state='00')[source]¶; Returns the selected Bell state:. \[\begin{split}\begin{aligned}; \lvert B_{00}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle+\lvert11\rangle)\\; \lvert B_{01}\rangle &=; \frac1{\sqrt2}(\lvert00\rangle-\lvert11\rangle)\\; \lvert B_{10}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle+\lvert10\rangle)\\; \lvert B_{11}\rangle &=; \frac1{\sqrt2}(\lvert01\rangle-\lvert10\rangle)\\; \end{aligned}\end{split}\]. Returns. Bell_stateqobjBell state. bra(seq, dim=2)[source]¶; Produces a multiparticle bra state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:. ‘g’/’e’ (ground and excited state); ‘u’/’d’ (spin up and down); ‘H’/’V’ (horizontal and vertical polarization). Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. braqobj. Examples; >>> bra(""10"") ; Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra; Qobj data =; [[ 0. 0. 1. 0.]]. >>> bra(""Hue"") ; Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra; Qobj data =; [[ 0. 1. 0. 0. 0. 0. 0. 0.]]. >>> bra(""12"", 3) ; Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 1. 0. 0. 0.]]. >>> bra(""31"", [5, 2]) ; Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra; Qobj data =; [[ 0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]]. coherent(N, alpha, offset=0, method='operator')[source]¶; Generates a coherent state with eigenvalue alpha.; Constructed using displacement operator on vacuum state. Parameters. NintNumber of Fock states in Hilbert",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:12532,Availability,down,down,12532,"gth. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns. dmqobjDensity matrix representation of Fock state. Examples; >>> fock_dm(3,1) ; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]]. ghz_state(N=3)[source]¶; Returns the N-qubit GHZ-state. Parameters. Nint (default=3)Number of qubits in state. Returns. GqobjN-qubit GHZ-state. ket(seq, dim=2)[source]¶; Produces a multiparticle ket state for a list or string,; where each element stands for state of the respective particle. Parameters. seqstr / list of ints or charactersEach element defines state of the respective particle.; (e.g. [1,1,0,1] or a string “1101”).; For qubits it is also possible to use the following conventions:; - ‘g’/’e’ (ground and excited state); - ‘u’/’d’ (spin up and down); - ‘H’/’V’ (horizontal and vertical polarization); Note: for dimension > 9 you need to use a list. dimint (default: 2) / list of intsSpace dimension for each particle:; int if there are the same, list if they are different. Returns. ketqobj. Examples; >>> ket(""10"") ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 1.]; [ 0.]]. >>> ket(""Hue"") ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""12"", 3) ; Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. >>> ket(""31"", [5, 2]) ; Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. ket2dm(Q)[source]¶; Takes input ket or bra vector and returns density matrix; formed by outer ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:33348,Availability,toler,tolerance,33348,"class, for representing quantum states and; operators, and related functions. dag(A)[source]¶; Adjont operator (dagger) of a quantum object. Parameters. Aqutip.QobjInput quantum object. Returns. operqutip.QobjAdjoint of input operator. Notes; This function is for legacy compatibility only. It is recommended to use; the dag() Qobj method. dims(inpt)[source]¶; Returns the dims attribute of a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. dimslistA list of the quantum objects dimensions. Notes; This function is for legacy compatibility only. Using the Qobj.dims; attribute is recommended. isbra(Q)[source]¶; Determines if given quantum object is a bra-vector. Parameters. Qqutip.QobjQuantum object. Returns. isbraboolTrue if Qobj is bra-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isbra; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> isket(psi); False. isequal(A, B, tol=None)[source]¶; Determines if two qobj objects are equal to within given tolerance. Parameters. Aqutip.QobjQobj one. Bqutip.QobjQobj two. tolfloatTolerence for equality to be valid. Returns. isequalboolTrue if qobjs are equal, False otherwise. Notes; This function is for legacy compatibility only. Instead, it is recommended; to use the equality operator of Qobj instances instead: A == B. isherm(Q)[source]¶; Determines if given operator is Hermitian. Parameters. Qqutip.QobjQuantum object. Returns. ishermboolTrue if operator is Hermitian, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isherm; attribute is recommended.; Examples; >>> a = destroy(4); >>> isherm(a); False. isket(Q)[source]¶; Determines if given quantum object is a ket-vector. Parameters. Qqutip.QobjQuantum object. Returns. isketboolTrue if qobj is ket-vector, False otherwise. Notes; This function is for legacy compatibility only. Using the Qobj.isket; attribute is recommended.; Examples; >>> psi = basis(5,2); >>> is",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:37121,Availability,error,error,37121," a quantum object. Parameters. inptqutip.QobjInput quantum object. Returns. shapelistA list of the quantum objects shape. Notes; This function is for legacy compatibility only. Using the Qobj.shape; attribute is recommended. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None, seed=None)[source]¶; Creates a random NxN density matrix. Parameters. Nint, ndarray, listIf int, then shape of output operator. If list/ndarray then eigenvalues; of generated density matrix. densityfloatDensity between [0,1] of output density matrix. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. seedintSeed for the random number generator. Returns. operqobjNxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_dm_ginibre(N=2, rank=None, dims=None, seed=None)[source]¶; Returns a Ginibre random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. If rank is None, a full-rank; (Hilbert-Schmidt ensemble) random density operator will be; returned. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. rankint or NoneRank of the sampled density operator. If None, a full-rank; density operator is generated. Returns. rhoQobjAn N × N density operator sampled from the Ginibre; or Hilbert-Schmidt distribution. rand_dm_hs(N=2, dims=None, seed=None)[source]¶; Returns a Hilbert-Schmidt random density operator of dimension; dim and rank rank by using the algorithm of; [BCSZ08]. Parameters. NintDimension of the density operator to be returned. dimslistDimensions of quantum object. Used for specifyin",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:50523,Availability,error,errors,50523,"senting a quantum map to a list of quantum objects,; each representing an operator in the Kraus decomposition of the given map. Parameters. q_operQobjSuperoperator to be converted to Kraus representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_kraus(A) == to_kraus(sprepost(A, A.dag())) == [A]. tolFloatOptional threshold parameter for eigenvalues/Kraus ops to be discarded.; The default is to=1e-9. Returns. kraus_opslist of QobjA list of quantum objects, each representing a Kraus operator in the; decomposition of q_oper. Raises. TypeError: if the given quantum object is not a map, or cannot bedecomposed into Kraus operators. to_stinespring(q_oper)[source]¶; Converts a Qobj representing a quantum map $Lambda$ to a pair of partial isometries; $A$ and $B$ such that $Lambda(X) = Tr_2(A X B^dagger)$ for all inputs $X$, where; the partial trace is taken over a a new index on the output dimensions of $A$ and $B$.; For completely positive inputs, $A$ will always equal $B$ up to precision errors. Parameters. q_operQobjSuperoperator to be converted to a Stinespring pair. Returns. A, BQobjQuantum objects representing each of the Stinespring matrices for the input Qobj. to_super(q_oper)[source]¶; Converts a Qobj representing a quantum map to the supermatrix (Liouville); representation. Parameters. q_operQobjSuperoperator to be converted to supermatrix representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_super(A) == sprepost(A, A.dag()). Returns. superopQobjA quantum object representing the same map as q_oper, such that; superop.superrep == ""super"". Raises. TypeErrorIf the given quantum object is not a map, or cannot be converted; to supermatrix representation. Operators and Superoperator Dimensions¶; Internal use module for manipulating dims specifications. collapse_dims_oper(dims)[source]¶; Given the dimensions specifications for a ket-, bra- or oper-type; Qobj, returns a dimensions specificatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:54809,Availability,down,down,54809,". Parameters. dimslistDimensions specification for a Qobj. Returns. permlistA list such that data[flatten(dims)[idx]] gives the; index of the tensor data corresponding to the idx``th; dimension of ``dims. dims_to_tensor_shape(dims)[source]¶; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters. dimslistDimensions specification for a Qobj. Returns. tensor_shapetupleNumPy shape of the corresponding tensor. enumerate_flat(l)[source]¶; Labels the indices at which scalars occur in a flattened list.; Given a list containing a mix of scalars and lists,; returns a list of the same structure, where each scalar; has been replaced by an index into the flattened list.; Examples; >>> print(enumerate_flat([[[10], [20, 30]], 40])) ; [[[0], [1, 2]], 3]. flatten(l)[source]¶; Flattens a list of lists to the first level.; Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list.; Examples; >>> flatten([[[0], 1], 2]) ; [0, 1, 2]. is_scalar(dims)[source]¶; Returns True if a dims specification is effectively; a scalar (has dimension 1). unflatten(l, idxs)[source]¶; Unflattens a list by a given structure.; Given a list of scalars and a deep list of indices; as produced by flatten, returns an “unflattened”; form of the list. This perfectly inverts flatten.; Examples; >>> l = [[[10, 20, 30], [40, 50, 60]], [[70, 80, 90], [100, 110, 120]]] ; >>> idxs = enumerate_flat(l) ; >>> unflatten(flatten(l), idxs) == l ; True. Functions acting on states and operators¶. Expectation Values¶. expect(oper, state)[source]¶; Calculates the expectation value for operator(s) and state(s). Parameters. operqobj/array-likeA single or a list or operators for expectation value. stateqobj/array-likeA single or a list of quantum states or density matrices. Returns. exptfloat/complex/array-likeExpectation value. real if oper is Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58139,Availability,mask,mask,58139,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58231,Availability,mask,mask,58231,"ct. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58367,Availability,mask,mask,58367," objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58464,Availability,mask,mask,58464,"shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected c",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58626,Availability,mask,masklist,58626,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58644,Availability,mask,mask,58644,"0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:71783,Availability,down,down,71783,"result of the; measurement is the corresponding eigenvalue. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opQobjThe measurement operator. targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. measured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, p",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72290,Availability,down,down,72290,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger * M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger =",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:90076,Availability,Toler,Tolerance,90076," the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108270,Availability,avail,available,108270,"Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108338,Availability,Avail,Available,108338,", see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:111302,Availability,Avail,Available,111302,", \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:113549,Availability,error,errors,113549,"qrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the elemen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:115011,Availability,error,errors,115011,"agger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:116724,Availability,error,errors,116724,"; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:118425,Availability,error,errors,118425,"arameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:120214,Availability,error,errors,120214,"he initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121901,Availability,error,errors,121901," parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of time",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:123691,Availability,error,errors,123691,"ho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:125410,Availability,error,errors,125410,"t is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-sta",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:127299,Availability,error,errors,127299,"or; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:128695,Availability,error,errors,128695,"ver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\]; along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; solver parameter. Parameters. HQobjsystem Hamiltonian. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate; \(\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>\) instead of; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by tlist. References; See, Gardiner, Quantum Noise, Section 5.2. spectrum(H, wlist, c_ops, a_op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s p",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135405,Availability,avail,availability,135405,"a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ system",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137408,Availability,Toler,Tolerance,137408,"alseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and u",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137498,Availability,Toler,Tolerance,137498,"of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137628,Availability,toler,tolerance,137628,"ominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142098,Availability,error,error,142098,"ystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is cons",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197937,Availability,error,error,197937,"al maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisat",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198105,Availability,error,error,198105,"kelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198402,Availability,error,error,198402,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198649,Availability,error,error,198649,"TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199322,Availability,error,error,199322,"hods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_ty",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:202341,Availability,error,error,202341,"can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be u",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:202408,Availability,error,error,202408,"alQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203382,Availability,error,error,203382,"n the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:204954,Availability,error,error,204954," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:204974,Availability,error,error,204974," Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method; Options are DEF, UNIT, TRACEDIFF, TD_APPROX; DEF will use the default for the specific dyn_type; (See FidelityComputer classes for details). fid_paramsdictParameters for the FidelityComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and; evolution in the timeslots.; Options: DEF, UPDATE_ALL, DYNAMIC; UPDATE_ALL is the only one that currently works; (See TimeslotComputer classes for details). tslot_paramsdictParameters for the TimeslotComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringtype / shape of pulse(s) used to initialise the; the control amplitudes.; Options (GRAPE) include:. RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207320,Availability,ERROR,ERROR,207320,"ey applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:208808,Availability,error,error,208808,"Instance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209287,Availability,error,error,209287,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209307,Availability,error,error,209307,"t_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:210773,Availability,error,error,210773,"can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:210840,Availability,error,error,210840,"lQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212485,Availability,error,error,212485,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityCo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:213292,Availability,error,error,213292,"assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator object.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:213312,Availability,error,error,213312,"assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC UPDATE_ALL is the; only one that currently works. (See TimeslotComputer classes; for details). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. guess_pulse_typestring, default NoneType / shape of pulse(s) used modulate the control amplitudes.; Options include: RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN. guess_pulse_paramsdictParameters for the guess pulse generator object.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:215519,Availability,ERROR,ERROR,215519,"rated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=Non",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:216259,Availability,error,error,216259,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217008,Availability,error,error,217008,"ill suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217746,Availability,error,error,217746,"slot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217766,Availability,error,error,217766,"lse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:219229,Availability,error,error,219229,"mput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:219296,Availability,error,error,219296,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequenci",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220942,Availability,error,error,220942," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:223491,Availability,ERROR,ERROR,223491,"how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:224231,Availability,error,error,224231,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225084,Availability,error,error,225084," for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time depen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225494,Availability,error,error,225494,"=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots w",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225514,Availability,error,error,225514,"im_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; duratio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:226980,Availability,error,error,226980," can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:227047,Availability,error,error,227047,"ialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note tha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228020,Availability,error,error,228020,"r target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictPara",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:229592,Availability,error,error,229592,"r the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details.). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(s)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:229612,Availability,error,error,229612,"r the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type (See FidelityComputer classes for; details). fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. phase_optionstringDeprecated. Pass in fid_params instead. fid_err_scale_factorfloatDeprecated. Use scale_factor key in fid_params instead. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details.). tslot_paramsdictParameters for the TimeslotComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. amp_update_modestringDeprecated. Use tslot_type instead. init_pulse_typestringType / shape of pulse(s)",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:231969,Availability,ERROR,ERROR,231969,"e assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:232709,Availability,error,error,232709,"airs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233483,Availability,error,error,233483,"atsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provid",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234148,Availability,error,error,234148,"thod_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234315,Availability,error,error,234315,"ffset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_ts",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:235670,Availability,error,error,235670,"nput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be us",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:235737,Availability,error,error,235737,"U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236710,Availability,error,error,236710,"en the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:240043,Availability,ERROR,ERROR,240043," applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and ge",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:240782,Availability,error,error,240782," pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:256321,Availability,Toler,Tolerance,256321,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:99,Deployability,Install,Installation,99,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:561,Deployability,Continuous,Continuous,561,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43267,Deployability,configurat,configuration,43267,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43356,Deployability,configurat,configurations,43356," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64886,Deployability,Continuous,Continuous,64886,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64969,Deployability,continuous,continuous,64969,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74821,Deployability,integrat,integrating,74821,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77089,Deployability,integrat,integrating,77089,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79423,Deployability,integrat,integration,79423,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80062,Deployability,integrat,integrator,80062," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Ha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80399,Deployability,integrat,integrator,80399,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:84840,Deployability,integrat,integration,84840,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qob",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142327,Deployability,configurat,configuration,142327,"enting the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142707,Deployability,integrat,integrated,142707," a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161593,Deployability,integrat,integrated,161593,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:162325,Deployability,integrat,integrated,162325,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197809,Deployability,configurat,configuration,197809,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:200807,Deployability,configurat,configuration,200807,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:256951,Deployability,update,updated,256951,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20363,Energy Efficiency,charge,charge,20363,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20427,Energy Efficiency,charge,charge,20427,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20448,Energy Efficiency,charge,charge,20448,"0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20509,Energy Efficiency,charge,charge,20509,"0. 0. 0.03125]]. triplet_states()[source]¶; Returns a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20567,Energy Efficiency,charge,charge,20567,"s a list of the two particle triplet-states:. \[\lvert T_1\rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Pa",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:20635,Energy Efficiency,charge,charge,20635,"rangle = \lvert11\rangle; \lvert T_2\rangle = \frac1{\sqrt2}(\lvert01\rangle + \lvert10\rangle); \lvert T_3\rangle = \lvert00\rangle\]. Returns. trip_stateslist2 particle triplet states. w_state(N=3)[source]¶; Returns the N-qubit W-state. Parameters. Nint (default=3)Number of qubits in state. Returns. WqobjN-qubit W-state. zero_ket(N, dims=None)[source]¶; Creates the zero ket vector with shape Nx1 and; dimensions dims. Parameters. NintHilbert space dimensionality. dimslistOptional dimensions if ket corresponds to; a composite Hilbert space. Returns. zero_ketqobjZero ket on given Hilbert space. Quantum Operators¶; This module contains functions for generating Qobj representation of a variety; of commonly occuring quantum operators. charge(Nmax, Nmin=None, frac=1)[source]¶; Generate the diagonal charge operator over charge states; from Nmin to Nmax. Parameters. NmaxintMaximum charge state to consider. Nminint (default = -Nmax)Lowest charge state to consider. fracfloat (default = 1)Specify fractional charge if needed. Returns. CQobjCharge operator over [Nmin,Nmax]. Notes. New in version 3.2. commutator(A, B, kind='normal')[source]¶; Return the commutator of kind kind (normal, anti) of the; two operators A and B. create(N, offset=0)[source]¶; Creation (raising) operator. Parameters. NintDimension of Hilbert space. Returns. operqobjQobj for raising operator. offsetint (default 0)The lowest number state that is included in the finite number state; representation of the operator. Examples; >>> create(4) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. destroy(N, offset=0)[source]¶; Destruction (lowering) operator. Parameters. NintDimension of Hilbert space. offsetint (defaul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91624,Energy Efficiency,power,power,91624,"uation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parame",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98538,Energy Efficiency,power,power,98538,"me for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times sp",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98984,Energy Efficiency,energy,energy,98984,"loquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:112083,Energy Efficiency,Efficient,Efficient,112083,"r2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:129926,Energy Efficiency,power,power,129926,"op, b_op, solver='es', use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using the solver indicated by the solver parameter. Note: this spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_like",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:130381,Energy Efficiency,power,power,130381,"tionary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslistlist of collapse operators. a_opQobjoperator A. b_opQobjoperator B. solverstrchoice of solver (es for exponential series and; pi for psuedo-inverse). use_pinvboolFor use with the pi solver: if True use numpy’s pinv method,; otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_correlation_fft(tlist, y, inverse=False)[source]¶; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters. tlistarray_likelist/array of times \(t\) which the correlation function is given. yarray_likelist/array of correlations corresponding to time delays \(t\). inverse: booleanboolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns. w, StupleReturns an array of angular frequencies ‘w’ and the corresponding; two-sided power spectrum ‘S(w)’. spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False)[source]¶; Calculate the spectrum of the correlation function; \(\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>\),; i.e., the Fourier transform of the correlation function:. \[S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega\tau} d\tau.\]; using a psuedo-inverse method. Note: this spectrum is only defined for; stationary statistics (uses steady state rho0). Parameters. Hqutip.qobjsystem Hamiltonian. wlistarray_likelist of frequencies for \(\omega\). c_opslist of qutip.qobjlist of collapse operators. a_opqutip.qobjoperator A. b_opqutip.qobjoperator B. use_pinvboolIf True use numpy’s pinv method, otherwise use a generic solver. Returns. spectrumarrayAn array with spectrum \(S(\omega)\) for the frequencies; specified in wlist. spectrum_ss(H, wlist, c_ops, a_op, b_op)[source]¶; Calculate the spectrum of the correlation function; \(\l",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:133471,Energy Efficiency,power,power,133471,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:133500,Energy Efficiency,power,power,133500,". AqobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. return_infobool, optional, default = FalseReturn a dictionary of solver-specific infomation about the; solution and how it was obtained. use_rcmbool, optional, default = FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the; LU factorization of the Liouvillian. use_wbmbool, optional, default = FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_M",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:134113,Energy Efficiency,reduce,reduced,134113,"ce condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. methodstr, default = ‘iterative’Tells the preconditioner what type of Liouvillian to build for; iLU factorization. For direct iterative methods use ‘iterative’.; For power iterative methods use ‘power’. permc_specstr, optional, default=’COLAMD’Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ and; ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. fill_factorfloat, optional, default = 100Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, optional, default = 1e-4Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optional, default = NoneSets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, optional, default = ‘smilu_2’Selects the incomplete LU decomposition method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135578,Energy Efficiency,power,power,135578,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135587,Energy Efficiency,power,power-gmres,135587,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135602,Energy Efficiency,power,power-lgmres,135602,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135618,Energy Efficiency,power,power-bicgstab,135618,"n method algoithm used in; creating the preconditoner. Should only be used by advanced users. Returns. luobjectReturns a SuperLU object representing iLU preconditioner. infodict, optionalDictionary containing solver-specific information. steadystate(A, c_op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135926,Energy Efficiency,power,power,135926,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135940,Energy Efficiency,power,power,135940,"op_list=[], method='direct', solver=None, **kwargs)[source]¶; Calculates the steady state for quantum evolution subject to the supplied; Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135962,Energy Efficiency,power,power,135962,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135978,Energy Efficiency,power,power-gmres,135978,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:135993,Energy Efficiency,power,power-lgmres,135993,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:136009,Energy Efficiency,power,power-bicgstab,136009,"onian) a list of; collapse operators.; If the user passes a Hamiltonian then it, along with the list of collapse; operators, will be converted into a Liouvillian operator in Lindblad form. Parameters. AQobjA Hamiltonian or Liouvillian operator. c_op_listlistA list of collapse operators. solver{‘scipy’, ‘mkl’}, optionalSelects the sparse solver to use. Default is to auto-select based on; the availability of the MKL library. methodstr, default ‘direct’The allowed methods are. ‘direct’; ‘eigen’; ‘iterative-gmres’; ‘iterative-lgmres’; ‘iterative-bicgstab’; ‘svd’; ‘power’; ‘power-gmres’; ‘power-lgmres’; ‘power-bicgstab’. Method for solving the underlying linear equation. Direct LU solver; ‘direct’ (default), sparse eigenvalue problem ‘eigen’, iterative GMRES; method ‘iterative-gmres’, iterative LGMRES method ‘iterative-lgmres’,; iterative BICGSTAB method ‘iterative-bicgstab’, SVD ‘svd’ (dense), or; inverse-power method ‘power’. The iterative power methods; ‘power-gmres’, ‘power-lgmres’, ‘power-bicgstab’ use the same solvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137477,Energy Efficiency,power,power,137477,"inimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated aut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:138842,Energy Efficiency,reduce,reduced,138842,"xplicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the rate of convergence for iterative methods.; If no preconditioner is given and use_precond = True, then one; is generated automatically. fill_factorfloat, default 100ITERATIVE ONLY. Specifies the fill ratio upper bound (>=1) of the iLU; preconditioner. Lower values save memory at the cost of longer; execution times and a possible singular factorization. drop_tolfloat, default 1e-4ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner; elements that should be dropped. Can be reduced for a courser; factorization at the cost of an increased number of iterations, and a; possible singular factorization. diag_pivot_threshfloat, optionalITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal; elements are considered acceptable pivot points when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:151745,Energy Efficiency,energy,energy,151745,"cks(rho)[source]¶; Create the list of blocks for block-diagonal density matrix in the Dicke basis. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. square_blocks: list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:151998,Energy Efficiency,energy,energy,151998,"list of np.arrayGive back the blocks list. dicke_blocks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:152034,Energy Efficiency,energy,energy,152034,"locks_full(rho)[source]¶; Give the full (2^N-dimensional) list of blocks for a Dicke-basis matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. full_blockslistThe list of blocks expanded in the 2^N space for N qubits. dicke_function_trace(f, rho)[source]¶; Calculate the trace of a function on a Dicke density matrix.; :param f: A Taylor-expandable function of rho.; :type f: function; :param rho: A density matrix in the Dicke basis.; :type rho: qutip.Qobj. Returns. resfloatTrace of a nonlinear function on rho. energy_degeneracy(N, m)[source]¶; Calculate the number of Dicke states with same energy.; The use of the Decimals class allows to explore N > 1000,; unlike the built-in function scipy.special.binom. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue.; This is proportional to the total energy. Returns. degeneracy: intThe energy degeneracy. entropy_vn_dicke(rho)[source]¶; Von Neumann Entropy of a Dicke-basis density matrix. Parameters. rhoqutip.QobjA 2D block-diagonal matrix of ones with dimension (nds,nds),; where nds is the number of Dicke states for N two-level; systems. Returns. entropy_dm: floatEntropy. Use degeneracy to multiply each block. excited(N, basis='dicke')[source]¶; Generate the density matrix for the excited state.; This state is given by (N/2, N/2) in the default Dicke basis. If the; argument basis is “uncoupled” then it generates the state in a; 2**N dim Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe excited state density matrix in the requested basis. ghz(N, basis='dicke')[source]¶; Generate the density matrix of the GHZ state.; If the argument basis is “uncoupled” then it generates the state; in a \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:154877,Energy Efficiency,energy,energy,154877,"of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate bloc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:155012,Energy Efficiency,energy,energy,155012,"rameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num_dicke_ladders(N)[source]¶; Calculate the total number of ladders in the Dicke space.; For a collection of N two-level systems it counts how many different; “j” exist or the number of blocks in the block-diagonal matrix. Parameters. N: intThe number of two-level systems. Returns. Nj: intThe number of Dicke ladders. num_dicke_states(N)[source]¶; Calculate the number of Dicke states. Parameters. N: intThe number of two-level systems. Returns. nds: intThe number of Dicke states. num_tls(nds)[source]¶; Calculate the number of two-level systems. Parameters. nds: intThe number of Dicke states. Returns. N: intThe number of two-level systems. purity_dicke(rho)[source]¶; Calculate purity of a density matrix in the Dicke basis.; It accounts for the degenerate blocks in the density matrix. Parameters. rhoqutip.QobjDensity matrix in the Dicke basis of qutip.piqs.jspin(N), for N spins. Returns. purityfloatThe pu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161116,Energy Efficiency,efficient,efficient,161116,"ix. This cannot have tensor-product; structure. xvec, yvecarray_likex- and y-coordinates at which to calculate the Husimi-Q function. gfloat, default sqrt(2)Scaling factor for a = 0.5 * g * (x + iy). The value of g is; related to the value of \(\hbar\) in the commutation relation; \([x,\,y] = i\hbar\) via \(\hbar=2/g^2\), so the default; corresponds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161473,Energy Efficiency,efficient,efficient,161473,"onds to \(\hbar=1\). precompute_memoryreal, default 1024Size in MB that may be used during calculations as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:164327,Energy Efficiency,efficient,efficient,164327,"urce]¶; Wigner function for a state vector or density matrix at points; xvec + i * yvec. Parameters. stateqobjA state vector or density matrix. xvecarray_likex-coordinates at which to calculate the Wigner function. yvecarray_likey-coordinates at which to calculate the Wigner function. Does not; apply to the ‘fft’ method. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168156,Energy Efficiency,energy,energy,168156,"ax=None, threshold=None)[source]¶; Draw a histogram for the amplitudes of matrix M, using the argument; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, ax",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168223,Energy Efficiency,energy,energy,168223,"t; of each element for coloring the bars, with the given x and y labels; and title. Parameters. MMatrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168270,Energy Efficiency,energy,energy,168270,"Matrix of QobjThe matrix to visualize. xlabelslist of stringslist of x labels. ylabelslist of stringslist of y labels. titlestringtitle of the plot (optional). limitslist/array with two float numbersThe z-axis limits [min, max] (optional). phase_limitslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. res",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168577,Energy Efficiency,energy,energy,168577,"itslist/array with two float numbersThe phase-axis (colorbar) limits [min, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWheth",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:168638,Energy Efficiency,energy,energy,168638,"n, max] (optional). axa matplotlib axes instanceThe axes context in which the plot will be drawn. threshold: float (None)Threshold for when bars of smaller height should be transparent. If; not set, all bars are colored according to the color map. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_energy_levels(H_list, N=0, labels=None, show_ylabels=False, figsize=(8, 12), fig=None, ax=None)[source]¶; Plot the energy level diagrams for a list of Hamiltonians. Include; up to N energy levels. For each element in H_list, the energy; levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,; where n is the index of an element in H_list. Parameters. H_listList of Qobj; A list of Hamiltonians. labelsList of stringA list of labels for each Hamiltonian. show_ylabelsBool (default False)Show y labels to the left of energy levels of the initial; Hamiltonian. NintThe number of energy levels to plot. figsizetuple (int,int)The size of the figure (width, height). figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Raises. ValueErrorInput argument is not valid. plot_expectation_values(results, ylabels=[], title=None, show_legend=False, fig=None, axes=None, figsize=(8, 4))[source]¶; Visualize the results (expectation values) for an evolution solver.; results is assumed to be an instance of Result, or a list of Result; instances. Parameters. results(list of) qutip.solver.ResultList of results objects returned by any of the QuTiP evolution solvers. ylabelslist of stringsThe y-axis labels. List should be of the same length as results. titlestringThe title of the figure. show_legendboolWhether or not to show the legend. figa matplotlib Figure instanceThe Figure c",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198963,Energy Efficiency,reduce,reduces,198963,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:246964,Energy Efficiency,energy,energy,246964,"ith maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:247032,Energy Efficiency,energy,energy,247032,"the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:247235,Energy Efficiency,energy,energy,247235,"ithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253094,Energy Efficiency,schedul,scheduling,253094,"ask_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253439,Energy Efficiency,schedul,scheduled,253439,"t and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evalua",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254696,Energy Efficiency,schedul,scheduling,254696,"rgs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255041,Energy Efficiency,schedul,scheduled,255041,", args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:937,Integrability,depend,dependent,937,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:1312,Integrability,Rout,Routines,1312,"peroperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)Integer corresponding to desired number state, defaults to 0 for all; dimensions if omitted. The shape must match dimensions, e.g. if; dimensions is a list, then n must either be omitted or a list; of equal length. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representat",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:24976,Integrability,depend,depending,24976,"ntity(dims, excitations)[source]¶; Generate the identity operator for the excitation-number restricted; state space defined by the dims and exciations arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters. dimslistA list of the dimensions of each subsystem of a composite quantum; system. excitationsintegerThe maximum number of excitations that are to be included in the; state space. statelist of integersThe state in the number basis representation. Returns. opQobjA Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by dims and; exciations. identity(dims)[source]¶; Identity operator. Alternative name to qeye. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. jmat(j, *args)[source]¶; Higher-order spin operators:. Parameters. jfloatSpin of operator. argsstrWhich operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no args given, then output is [‘x’,’y’,’z’]. Returns. jmatqobj / ndarrayqobj for requested spin operator(s). Notes; If no ‘args’ input, then returns array of [‘x’,’y’,’z’] operators.; Examples; >>> jmat(1) ; [ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0. 0.70710678 0. ]; [ 0.70710678 0. 0.70710678]; [ 0. 0.70710678 0. ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-0.70710678j 0.+0.j ]; [ 0.+0.70710678j 0.+0.j 0.-0.70710678j]; [ 0.+0.j 0.+0.70710678j 0.+0.j ]]; Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 0. 0.]; [ 0. 0. -1.]]]. momentum(N, offset=0)[source]¶; Momentum operator p=-1j/sq",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:28405,Integrability,depend,depending,28405,"_likeArray of elements to place along the selected diagonals. offsetssequence of ints; Sequence for diagonals to be set:; k=0 main diagonal; k>0 kth upper diagonal; k<0 kth lower diagonal. dimslist, optionalDimensions for operator. shapelist, tuple, optionalShape of operator. If omitted, a square operator large enough; to contain the diagonals is generated. See also. scipy.sparse.diagsfor usage information. Notes; This function requires SciPy 0.11+.; Examples; >>> qdiags(sqrt(range(1, 4)), 1) ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. qeye(dimensions)[source]¶; Identity operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:29255,Integrability,depend,depending,29255,", then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. operqobjIdentity operator Qobj. Examples; >>> qeye(3) ; Quantum object: dims = [[3], [3]], shape = (3, 3), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0.]; [ 0. 1. 0.]; [ 0. 0. 1.]]; >>> qeye([2,2]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[1. 0. 0. 0.]; [0. 1. 0. 0.]; [0. 0. 1. 0.]; [0. 0. 0. 1.]]. qutrit_ops()[source]¶; Operators for a three level system (qutrit). Returns. opers: arrayarray of qutrit operators. qzero(dimensions)[source]¶; Zero operator. Parameters. dimensions(int) or (list of int) or (list of list of int)Dimension of Hilbert space. If provided as a list of ints, then the; dimension is the product over this list, but the dims property of; the new Qobj are set to this list. This can produce either oper or; super depending on the passed dimensions. Returns. qzeroqobjZero operator Qobj. sigmam()[source]¶; Annihilation operator for Pauli spins.; Examples; >>> sigmam() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 0.]; [ 1. 0.]]. sigmap()[source]¶; Creation operator for Pauli spins.; Examples; >>> sigmap() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 0. 0.]]. sigmax()[source]¶; Pauli spin 1/2 sigma-x operator; Examples; >>> sigmax() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False; Qobj data =; [[ 0. 1.]; [ 1. 0.]]. sigmay()[source]¶; Pauli spin 1/2 sigma-y operator.; Examples; >>> sigmay() ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.-1.j]; [ 0.+1.j 0.+0.j]]. sigmaz()[source]¶; Pauli spin 1/2 sigma-z operator.; Examples; >>> sigmaz() ; Quantum object: dims = [[2], [2]], shape = [2, 2], t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43191,Integrability,Depend,Depending,43191,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:57741,Integrability,Contract,Contracts,57741,"rdinary operators; are assumed to be unitaries, and are promoted using to_super,; while kets and bras are promoted by taking their projectors and; using operator_to_vector(ket2dm(arg)). super_tensor(*args)[source]¶; Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58003,Integrability,contract,contracted,58003,"ce]¶; Calculates the tensor product of input superoperators, by tensoring; together the underlying Hilbert spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transp",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58078,Integrability,contract,contracted,58078,"t spaces on which each vectorized operator; acts. Parameters. argsarray_likelist or array of quantum objects with type=""super"". Returns. objqobjA composite quantum object. tensor(*args)[source]¶; Calculates the tensor product of input operators. Parameters. argsarray_likelist or array of quantum objects for tensor product. Returns. objqobjA composite quantum object. Examples; >>> tensor([sigmax(), sigmax()]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j 1.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [ 0.+0.j 1.+0.j 0.+0.j 0.+0.j]; [ 1.+0.j 0.+0.j 0.+0.j 0.+0.j]]. tensor_contract(qobj, *pairs)[source]¶; Contracts a qobj along one or more index pairs.; Note that this uses dense representations and thus; should not be used for very large Qobjs. Parameters. pairstupleOne or more tuples (i, j) indicating that the; i and j dimensions of the original qobj; should be contracted. Returns. cqobjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74821,Integrability,integrat,integrating,74821,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:75541,Integrability,depend,dependent,75541,"ion¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or n",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:76019,Integrability,depend,dependent,76019,"either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag() * op(t)).tr(). argsdict, optionalDictionary of scope parameters for time-dependent Hamiltonians. optionsOptions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77089,Integrability,integrat,integrating,77089,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77817,Integrability,depend,dependent,77817,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77847,Integrability,depend,dependent,77847,"operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:78177,Integrability,depend,dependent,78177,"apse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluatin",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:78653,Integrability,depend,dependence,78653,"eroperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an elemen",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79108,Integrability,depend,dependent,79108,"rmat) that evaluates to the time-dependent; coefficient for the corresponding operator, or a NumPy array (list; array format) which specifies the value of the coefficient to the; corresponding operator for each value of t in tlist.; Alternatively, H (but not c_ops) can be a callback function with the; signature f(t, args) -> Qobj (callback format), which can return the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:79423,Integrability,integrat,integration,79423,"the; Hamiltonian or Liouvillian superoperator at any point in time. If the; equation cannot be put in standard Lindblad form, then this time-dependence; format must be used.; Examples. H = [[H0, ‘sin(w*t)’], [H1, ‘sin(2*w*t)’]]; H = [[H0, f0_t], [H1, f1_t]]; where f0_t and f1_t are python functions with signature f_t(t, args).; H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]. In the list string format and list callback format, the string; expression and the callback function must evaluate to a real or complex; number (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80062,Integrability,integrat,integrator,80062," (coefficient for the corresponding operator).; In all cases of time-dependent operators, args is a dictionary of; parameters that is used when evaluating operators. It is passed to the; callback functions as their second argument.; Additional options; Additional options to mesolve can be set via the options argument, which; should be an instance of qutip.solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Ha",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80399,Integrability,integrat,integrator,80399,"solver.Options. Many ODE; integration options can be set this way, and the store_states and; store_final_state options can be used to store states even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectatio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:80540,Integrability,depend,dependent,80540," even though; expectation values are requested via the e_ops argument. Note; If an element in the list-specification of the Hamiltonian or; the list of collapse operators are in superoperator form it will be; added to the total Liouvillian of the problem without further; transformation. This allows for using mesolve for solving master; equations that are not in standard Lindblad form. Note; On using callback functions: mesolve transforms all qutip.Qobj; objects to sparse matrices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:81027,Integrability,depend,dependent,81027,"rices before handing the problem to the integrator; function. In order for your callback function to work correctly, pass; all qutip.Qobj objects that are used in constructing the; Hamiltonian via args. mesolve will check for qutip.Qobj in; args and handle the conversion to sparse matrices. All other; qutip.Qobj objects that are not passed via args will be; passed on to the integrator in scipy which will raise a NotImplemented; exception. Parameters. Hqutip.QobjSystem Hamiltonian, or a callback function for time-dependent; Hamiltonians, or alternatively a system Liouvillian. rho0qutip.Qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opsNone / list of qutip.Qobjsingle collapse operator, or list of collapse operators, or a list; of Liouvillian superoperators. e_opsNone / list of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. argsNone / dictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators. optionsNone / qutip.Optionswith options for the solver. progress_barNone / BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82151,Integrability,depend,dependent,82151,"r a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82257,Integrability,depend,dependent,82257,"r a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.ResultAn instance of the class qutip.Result, which contains; either an array result.expect of expectation values for the times; specified by tlist, or an array result.states of state vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; opera",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82380,Integrability,depend,dependent,82380,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82466,Integrability,depend,dependent,82466,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82556,Integrability,depend,dependent,82556,"ate vectors or; density matrices corresponding to the times in tlist [if e_ops is; an empty list], or nothing if a callback function was given in place of; operators for which to calculate the expectation values. Monte Carlo Evolution¶. mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:82684,Integrability,depend,dependent,82684," mcsolve(H, psi0, tlist, c_ops=[], e_ops=[], ntraj=0, args={}, options=None, progress_bar=True, map_func=<function parallel_map>, map_kwargs={}, _safe_mode=True)[source]¶; Monte Carlo evolution of a state vector \(|\psi \rangle\) for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class.; mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term.; As an example of a time-dependent problem, consider a Hamiltonian with two; terms H0 and H1, where H1 is time-dependent with coefficient; sin(w*t), and collapse operators C0 and C1, where C1 is; time-dependent with coeffcient exp(-a*t). Here, w and a are constant; arguments with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver op",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:83619,Integrability,depend,dependent,83619," with values W and A.; Using the Python function time-dependent format requires two Python; functions, one for each collapse coefficient. Therefore, this problem could; be expressed as:; def H1_coeff(t,args):; return sin(args['w']*t). def C1_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbit",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:84840,Integrability,integrat,integration,84840,"lation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qob",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:85397,Integrability,depend,dependent,85397,"st, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjIni",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:85780,Integrability,depend,dependence,85780,"n 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinger/Lindblad master equation. This will likely be faster than; essolve for you. Parameters. Hqobj/function_typeSystem Hamiltonian. rho0qutip.qobjInitial state density matrix. tlistlist/arraylist of times for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times spec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88322,Integrability,depend,dependent,88322,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88455,Integrability,depend,dependent,88455,"oat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88626,Integrability,depend,dependence,88626,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88778,Integrability,depend,dependence,88778,"_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opsli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88991,Integrability,depend,dependence,88991,"functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when e",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:89278,Integrability,depend,dependence,89278,"le.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProg",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91409,Integrability,depend,dependent,91409,"n instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a d",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91463,Integrability,depend,dependence,91463,"ns; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92767,Integrability,depend,dependent,92767,"axintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. T",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92885,Integrability,depend,dependence,92885," of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93046,Integrability,depend,dependent,93046,"elta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93675,Integrability,depend,dependent,93675," be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93793,Integrability,depend,dependence,93793,"rgsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\).",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94060,Integrability,depend,dependence,94060,"le period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the ti",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94310,Integrability,depend,dependence,94310,"odes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94930,Integrability,depend,dependent,94930,"e_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:94984,Integrability,depend,dependence,94984," the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet st",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96378,Integrability,depend,dependent,96378,"arameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96432,Integrability,depend,dependence,96432,"quet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet ene",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97616,Integrability,depend,dependent,97616,"_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97670,Integrability,depend,dependence,97670,"wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamil",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98647,Integrability,depend,dependence,98647,"The period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schroding",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:98817,Integrability,depend,dependent,98817,"ime \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:99741,Integrability,depend,dependent,99741," single period of the driving. argsdictionarydictionary of parameters for time-dependent Hamiltonians and; collapse operators.; This dictionary should also contain an entry ‘w_th’, which is; the temperature of the environment (if finite) in the; energy/frequency units of the Hamiltonian. For example, if; the Hamiltonian written in units of 2pi GHz, and the; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100096,Integrability,depend,dependence,100096,"; temperature is given in K, use the following conversion; >>> temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100766,Integrability,depend,depending,100766,"objInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:101924,Integrability,depend,dependent,101924,"ist of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:101966,Integrability,depend,depend,101966,"le classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable classFunction representing the stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.R",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102188,Integrability,depend,dependent,102188," stochastic evolution of the system. def d2(time (double), state (as a np.array vector)):return 2d np.array (N_sc_ops, len(state0)). len_d2intNumber of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102310,Integrability,depend,depend,102310," of output vector produced by d2. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102405,Integrability,depend,dependent,102405,"tor or list of operators for which to evaluate; expectation values.; Must be a superoperator if the state vector is a density matrix. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be unifo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:102636,Integrability,depend,depend,102636,"sultAn instance of the class qutip.solver.Result. photocurrent_mesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 function",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103206,Integrability,depend,dependent,103206,"erministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103248,Integrability,depend,depend,103248,"Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103453,Integrability,depend,dependent,103453,"tors. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:103684,Integrability,depend,depend,103684,"utip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. photocurrent_sesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation using the photocurrent method. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smepdpsolve(H, rho0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for density matrix; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opsl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105174,Integrability,depend,depending,105174,"; evolution. Parameters. Hqutip.QobjSystem Hamiltonian. rho0qutip.QobjInitial density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105262,Integrability,depend,dependent,105262,"density matrix. timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.Resul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105304,Integrability,depend,depend,105304,"iformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. sc_opslist of qutip.QobjList of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105526,Integrability,depend,dependent,105526,"ators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105648,Integrability,depend,depend,105648,"nd d2 functions; are defined. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105743,Integrability,depend,dependent,105743,"tion singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse oper",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:105974,Integrability,depend,depend,105974,"esult. smesolve(H, rho0, times, c_ops=[], sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic master equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. rho0qutip.QobjInitial density matrix or state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.Qobj, or time dependent Qobjs.Deterministic collapse operator which will contribute with a standard; Lindblad type of dissipation.; Can depend on time, see StochasticSolverOptions help for format. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; quti",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107282,Integrability,depend,depending,107282,"ip.solver.Result. ssepdpsolve(H, psi0, times, c_ops, e_ops, **kwargs)[source]¶; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic so",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107370,Integrability,depend,dependent,107370,"; A stochastic (piecewse deterministic process) PDP solver for wavefunction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107412,Integrability,depend,depend,107412,"unction; evolution. For most purposes, use qutip.mcsolve instead for quantum; trajectory simulations. Parameters. Hqutip.QobjSystem Hamiltonian. psi0qutip.QobjInitial state vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler metho",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107609,Integrability,depend,dependent,107609,"e vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. c_opslist of qutip.QobjDeterministic collapse operator which will contribute with a standard; Lindblad type of dissipation. e_opslist of qutip.Qobj / callback function singlesingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruya",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:107840,Integrability,depend,depend,107840,"esingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. ssesolve(H, psi0, times, sc_ops=[], e_ops=[], _safe_mode=True, args={}, **kwargs)[source]¶; Solve stochastic schrodinger equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. Hqutip.Qobj, or time dependent system.System Hamiltonian.; Can depend on time, see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:112787,Integrability,depend,dependent,112787,"r of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.so",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:113209,Integrability,depend,dependent,113209,"4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:114193,Integrability,depend,dependent,114193,"s, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:114615,Integrability,depend,dependent,114615,"Returns. g1, G1tupleThe normalized and unnormalized second-order coherence function. coherence_function_g2(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized second-order quantum coherence function:. \[ g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0Qobj",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:115559,Integrability,depend,dependent,115559,"nt 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. argsdictDictionary of arguments to be passed to solver. solverstrchoice of solver (me for master-equation and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. g2, G2tupleThe normalized and unnormalized second-order coherence function. correlation(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options cla",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:116238,Integrability,depend,dependent,116238,"se=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reverseboolIf True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculat",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:117484,Integrability,depend,dependent,117484,"nte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:117906,Integrability,depend,dependent,117906," index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along one time axis using the quantum regression theorem and the evolution; solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using th",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:119041,Integrability,depend,dependent,119041,"t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstr {‘me’, ‘mc’, ‘es’}choice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionsSolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecndarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver opt",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:119714,Integrability,depend,dependent,119714," reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:; \(\left<A(t+\tau)B(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. reversebool {False, True}If True, calculate \(\left<A(t)B(t+\tau)\right>\) instead of; \(\left<A(t+\tau)B(t)\right>\). solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121080,Integrability,depend,dependent,121080,"ement list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matndarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quan",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:121500,Integrability,depend,dependent,121500,"s; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:122619,Integrability,depend,dependent,122619," solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the three-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursive",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:123290,Integrability,depend,dependent,123290," correlation function:; \(\left<A(t)B(t+\tau)C(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\r",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:124569,Integrability,depend,dependent,124569,"ecause; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:124989,Integrability,depend,dependent,124989," instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along one time axis using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:126207,Integrability,depend,dependent,126207,"ries). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_vecarrayAn array of correlation values for the times specified by taulist. References; See, Gardiner, Quantum Noise, Section 5.2. Note; Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. correlation_4op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op, d_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the four-operator two-time correlation function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:126878,Integrability,depend,dependent,126878,"ion function:; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\); along two time axes using the quantum regression theorem and the; evolution solver indicated by the solver parameter.; Note: it is not possibly to calculate a physically meaningful correlation; of this form where \(\tau<0\). Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. rho0QobjInitial state density matrix \(\rho_0\) or state vector; \(\psi_0\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. tlistarray_likelist of times for \(t\). tlist must be positive and contain the; element 0. When taking steady-steady correlations only one tlist; value is necessary, i.e. when \(t \rightarrow \infty\); here; tlist is automatically set, ignoring user input. taulistarray_likelist of times for \(\tau\). taulist must be positive and contain; the element 0. c_opslistlist of collapse operators, may be time-dependent for solver choice of; me or mc. a_opQobjoperator A. b_opQobjoperator B. c_opQobjoperator C. d_opQobjoperator D. solverstrchoice of solver (me for master-equation, mc for Monte Carlo, and; es for exponential series). optionsOptionssolver options class. ntraj is taken as a two-element list because; the mc correlator calls mcsolve() recursively; by default,; ntraj=[20, 100]. mc_corr_eps prevents divide-by-zero errors in; the mc correlator; by default, mc_corr_eps=1e-10. Returns. corr_matarrayAn 2-dimensional array (matrix) of correlation values for the times; specified by tlist (first index) and taulist (second index). If; tlist is None, then a 1-dimensional array of correlation values; is returned instead. References; See, Gardiner, Quantum Noise, Section 5.2. correlation_ss(H, taulist, c_ops, a_op, b_op, solver='me', reverse=False, args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the two-operator two-time correlation function:. \[\lim_{t \to \infty} \lef",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140160,Integrability,depend,dependent,140160,"ints when using a; preconditioner. A value of zero forces the pivot to be the diagonal; element. ILU_MILUstr, default ‘smilu_2’ITERATIVE ONLY. Selects the incomplete LU decomposition method algoithm; used in creating the preconditoner. Should only be used by advanced; users. Returns. dmqobjSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive appl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140412,Integrability,depend,dependent,140412,"objSteady state density matrix. infodict, optionalDictionary containing solver-specific information about the solution. Notes; The SVD method works only for dense operators (i.e. small systems). Propagators¶. propagator(H, t, c_op_list=[], args={}, options=None, unitary_mode='batch', parallel=False, progress_bar=None, _safe_mode=True, **kwargs)[source]¶; Calculate the propagator U(t) for the density matrix or wave function such; that \(\psi(t) = U(t)\psi(0)\) or; \(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\); where \(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing,",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141278,Integrability,depend,dependent,141278,"e propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141351,Integrability,depend,dependent,141351,"rs. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141787,Integrability,depend,dependent,141787,"e of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accep",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142707,Integrability,integrat,integrated,142707," a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (into any combination of; waveguides). c_opslistList of collapse operators for each waveguide; these are assumed to; include spontaneous decay rates, e.g.; \(\sigma = \sqrt \gamma \cdot a\). tlistarray_likeList of times for \(\tau_i\). tlist should contain 0 and exceed; the pulse duration / temporal region of interest; tlist need not be; linearly spaced. system_zero_state:class: qutip.QobjState representing zero excitations in the syst",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:154052,Integrability,depend,depending,154052,"s to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe GHZ state density matrix in the requested basis. ground(N, basis='dicke')[source]¶; Generate the density matrix of the ground state.; This state is given by (N/2, -N/2) in the Dicke basis. If the argument; basis is “uncoupled” then it generates the state in a; \(2^N\)-dimensional Hilbert space. Parameters. N: intThe number of two-level systems. basis: strThe basis to use. Either “dicke” or “uncoupled”. Returns. state: :class: qutip.QobjThe ground state density matrix in the requested basis. identity_uncoupled(N)[source]¶; Generate the identity in a \(2^N\)-dimensional Hilbert space.; The identity matrix is formed from the tensor product of N TLSs. Parameters. N: intThe number of two-level systems. Returns. identity: :class: qutip.QobjThe identity matrix. isdiagonal(mat)[source]¶; Check if the input matrix is diagonal. Parameters. mat: ndarray/QobjA 2D numpy array. Returns. diag: boolTrue/False depending on whether the input matrix is diagonal. jspin(N, op=None, basis='dicke')[source]¶; Calculate the list of collective operators of the total algebra.; The Dicke basis \(\lvert j,m\rangle\langle j,m'\rvert\) is used by; default. Otherwise with “uncoupled” the operators are in a; \(2^N\) space. Parameters. N: intNumber of two-level systems. op: strThe operator to return ‘x’,’y’,’z’,’+’,’-‘.; If no operator given, then output is the list of operators; for [‘x’,’y’,’z’]. basis: strThe basis of the operators - “dicke” or “uncoupled”; default: “dicke”. Returns. j_alg: list or :class: qutip.QobjA list of qutip.Qobj representing all the operators in; the “dicke” or “uncoupled” basis or a single operator requested. m_degeneracy(N, m)[source]¶; Calculate the number of Dicke states \(\lvert j, m\rangle\) with; same energy. Parameters. N: intThe number of two-level systems. m: floatTotal spin z-axis projection eigenvalue (proportional to the total; energy). Returns. degeneracy: intThe m-degeneracy. num",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:161593,Integrability,integrat,integrated,161593,"ions as working space when; dealing with density-matrix inputs. This is ignored for state-vector; inputs. The bound is not quite exact due to other, order-of-magnitude; smaller, intermediaries being necessary, but is a good approximation.; If you want to use the same iterative algorithm for density matrices; that is used for single kets, set precompute_memory=None. Returns. ndarrayValues representing the Husimi-Q function calculated over the specified; range [xvec, yvec]. See also. QFunca class-based version, more efficient if you want to calculate the Husimi-Q function for several states over the same coordinates. spin_q_function(rho, theta, phi)[source]¶; The Husimi Q function for spins is defined as Q(theta, phi) =; SCS.dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:162325,Integrability,integrat,integrated,162325,".dag() * rho * SCS for the spin coherent state SCS = spin_coherent(; j, theta, phi) where j is the spin length.; The implementation here is more efficient as it doesn’t; generate all of the SCS at theta and phi (see references).; The spin Q function is normal when integrated over the surface of the; sphere. \[\frac{4 \pi}{2j + 1}\int_\phi \int_\theta; Q(\theta, \phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the Husimi-Q function. phiarray_likeAzimuthal angle at which to calculate the Husimi-Q function. Returns. Q, THETA, PHI2d-arrayValues representing the spin Husimi Q function at the values specified; by THETA and PHI. References; [1] Lee Loh, Y., & Kim, M. (2015). American J. of Phys., 83(1), 30–35.; https://doi.org/10.1119/1.4898595. spin_wigner(rho, theta, phi)[source]¶; Wigner function for a spin-j system.; The spin W function is normal when integrated over the surface of the; sphere. \[\sqrt{\frac{4 \pi}{2j + 1}}\int_\phi \int_\theta; W(\theta,\phi) \sin(\theta) d\theta d\phi = 1\]. Parameters. stateqobjA state vector or density matrix for a spin-j quantum system. thetaarray_likePolar (colatitude) angle at which to calculate the W function. phiarray_likeAzimuthal angle at which to calculate the W function. Returns. W, THETA, PHI2d-arrayValues representing the spin Wigner function at the values specified; by THETA and PHI. References; [1] Agarwal, G. S. (1981). Phys. Rev. A, 24(6), 2889–2896.; https://doi.org/10.1103/PhysRevA.24.2889; [2] Dowling, J. P., Agarwal, G. S., & Schleich, W. P. (1994).; Phys. Rev. A, 49(5), 4101–4109. https://doi.org/10.1103/PhysRevA.49.4101; [3] Conversion between Wigner 3-j symbol and Clebsch-Gordan coefficients; taken from Wikipedia (https://en.wikipedia.org/wiki/3-j_symbol). wigner(psi, xvec, yvec, method='clenshaw', g=1.4142135623730951, sparse=False, parfor=False)[source]¶; Wigner function for",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197734,Integrability,Wrap,Wrapper,197734,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:201140,Integrability,depend,dependent,201140,"', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:201360,Integrability,depend,dependent,201360,"_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203612,Integrability,depend,dependent,203612,"ng local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209572,Integrability,depend,dependent,209572," guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar val",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209791,Integrability,depend,dependent,209791,"urce]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are dervived from it.; None implies that timeslot durations will be equal and calculated; as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217120,Integrability,wrap,wrapper,217120,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:218042,Integrability,depend,dependent,218042,"to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:218253,Integrability,depend,dependent,218253," format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:225780,Integrability,depend,dependent,225780,"s=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar valu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:226000,Integrability,depend,dependent,226000,"file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error. The dynamics of; the system in any given timeslot are governed by the combined dynamics; generator, i.e. the sum of the drift + ctrl_amp[j]*ctrls[j].; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes; Starting from an initial (typically random) pulse, a multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228252,Integrability,depend,dependent,228252,"g local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each times",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233595,Integrability,wrap,wrapper,233595,"error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234483,Integrability,depend,dependent,234483,"ource]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; appli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:234694,Integrability,depend,dependent,234694,"and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array. tauarray[num_tslots] of floats or NoneDurations for the timeslots. If this is given then num_tslots and; evo_time are derived from it. None implies that timeslot; durations will be equal and calculated as evo_time/num_tslots. amp_lboundfloat or list of floatsLower boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. amp_uboundfloat or list of floatsUpper boundaries for the control amplitudes. Can be a scalar value; applied to all controls or a list of bounds for each control. fid_err_targfloatFidelity error target. Pul",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236946,Integrability,depend,dependent,236946," local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:242099,Integrability,Rout,Routines,242099,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:242160,Integrability,rout,routines,242160,"¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RNDWALK2 - Random change in amp gradient each timeslot. These are the other non-periodic options:. LIN - Linear, i.e. contant gradient over the time; ZERO - special case of the LIN pulse, where the gradient is 0. These are the periodic options. SINE - Sine wave; SQUARE - Square wave; SAW - Saw tooth wave; TRIANGLE - Triangular wave. If a Dynamics object is passed in then this is used in instantiate; the PulseGen, meaning that some timeslot and amplitude properties; are copied over. Utility Functions¶. Graph Theory Routines¶; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers. breadth_first_search(A, start)[source]¶; Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting; from a given node (row). Takes Qobjs and CSR or CSC matrices as inputs.; This function requires a matrix with symmetric structure. Use A+trans(A); if original matrix is not symmetric or not sure. Parameters. Acsc_matrix, csr_matrixInput graph in CSC or CSR matrix format. startintStaring node for BFS traversal. Returns. orderarrayOrder in which nodes are traversed from starting node. levelsarrayLevel of the nodes in the order that they are traversed. graph_degree(A)[source]¶; Returns the degree for the nodes (rows) of a symmetric graph in sparse CSR; or CSC format, or a qobj. Parameters. Aqobj, csr_matrix, csc_matrixInput quantum object or csr_matrix. Returns. degreearrayArray of integers giving the degree for each node (row). maximum_bipartite_matching(A, perm_type='row')[source]¶; Returns an ar",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244169,Integrability,rout,routine,244169,"mutations that removes nonzero; elements from the diagonal of a nonsingular square CSC sparse matrix. Such; a permutation is always possible provided that the matrix is nonsingular.; This function looks at the structure of the matrix only.; The input matrix will be converted to CSC matrix format if necessary. Parameters. Asparse matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function relies on a maximum cardinality bipartite matching algorithm; based on a breadth-first search (BFS) of the underlying graph[1]_.; References; I. S. Duff, K. Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the prod",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244780,Integrability,rout,routine,244780," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:244886,Integrability,rout,routines,244886," Kaya, and B. Ucar, “Design, Implementation, and; Analysis of Maximum Transversal Algorithms”, ACM Trans. Math. Softw.; 38, no. 2, (2011). reverse_cuthill_mckee(A, sym=False)[source]¶; Returns the permutation array that orders a sparse CSR or CSC matrix in; Reverse-Cuthill McKee ordering. Since the input matrix must be symmetric,; this routine works on the matrix A+Trans(A) if the sym flag is set to False; (Default).; It is assumed by default (sym=False) that the input matrix is not; symmetric. This is because it is faster to do A+Trans(A) than it is to; check for symmetry for a generic matrix. If you are guaranteed that the; matrix is symmetric in structure (values of matrix element do not matter); then set sym=True. Parameters. Acsc_matrix, csr_matrixInput sparse CSC or CSR sparse matrix format. symbool {False, True}Flag to set whether input matrix is symmetric. Returns. permarrayArray of permuted row and column indices. Notes; This routine is used primarily for internal reordering of Lindblad; superoperators for use in iterative solver routines.; References; E. Cuthill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255494,Integrability,depend,dependencies,255494," to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255812,Integrability,depend,dependencies,255812,"iew, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyri",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:572,Modifiability,Variab,Variables,572,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43267,Modifiability,config,configuration,43267,"xp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters. NintShape of output quantum operator. densityfloatDensity between [0,1] of output Unitary operator. dimslistDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:43356,Modifiability,config,configurations,43356," object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. operqobjNxN Unitary quantum operator. rand_unitary_haar(N=2, dims=None, seed=None)[source]¶; Returns a Haar random unitary matrix of dimension; dim, using the algorithm of [Mez07]. Parameters. NintDimension of the unitary to be returned. dimslist of lists of int, or NoneDimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns. UQobjUnitary of dims [[dim], [dim]] drawn from the Haar; measure. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References; The naming of qutip operators follows the convention in [1] . 1; Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:47187,Modifiability,extend,extend,47187,"tum operator for pre-multiplication. BQobj or QobjEvoQuantum operator for post-multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input quantum objects. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:47395,Modifiability,extend,extend,47395,"eate a matrix representation given a quantum operator in vector form.; The passed object should have a Qobj.type of ‘operator-ket’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in column-stacked-vector form. This must have a type; of ‘operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the sys",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64897,Modifiability,Variab,Variables,64897,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64980,Modifiability,variab,variable,64980,"ctor. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with operators is returned. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. rhoQobjDensity matrix for which to calculate the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74755,Modifiability,Evolve,Evolve,74755,"slist of ints, optionalSpecifies a list of targets “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:74915,Modifiability,evolve,evolve,74915,"p.gates.expand_operator to expand op; into full dimension. Returns. eigenvalues: list of floatThe list of eigenvalues of the measurement operator. eigenstates_or_projectors: list of QobjIf the state was a ket, return the eigenstates of the measurement; operator. Otherwise return the projectors onto the eigenstates. probabilities: list of floatThe probability of measuring the state as being in the corresponding; eigenstate (and the measurement result being the corresponding; eigenvalue). Dynamics and Time-Evolution¶. Schrödinger Equation¶; This module provides solvers for the unitary Schrodinger equation. sesolve(H, psi0, tlist, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Schrödinger equation evolution of a state vector or unitary matrix for a; given Hamiltonian.; Evolve the state vector (psi0) using a given Hamiltonian (H), by; integrating the set of ordinary differential equations that define the; system. Alternatively evolve a unitary matrix in solving the Schrodinger; operator equation.; The output is either the state vector or unitary matrix at arbitrary points; in time (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values. e_ops cannot be used in conjunction; with solving the Schrodinger operator equation. Parameters. HQobj, QobjEvo, list, or callableSystem Hamiltonian as a Qobj , list of :obj:`Qobj and; coefficient, QObjEvo, or a callback function for time-dependent; Hamiltonians. List format and options can be found in QobjEvo’s; description. psi0QobjInitial state vector (ket) or initial unitary operator psi0 = U. tlistarray_like of floatList of times for \(t\). e_opslist of Qobj or callback function, optionalSingle operator or list of operators for which to evaluate expectation; values. For operator evolution, the overlap is computed:; (e_ops[i].dag",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:76939,Modifiability,Evolve,Evolve,76939,"tions, optionalOptions for the ODE solver. progress_barBaseProgressBar, optionalOptional instance of BaseProgressBar, or a subclass thereof,; for showing the progress of the simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the sec",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:77221,Modifiability,evolve,evolved,77221," simulation. Returns. output: ResultAn instance of the class Result, which contains either; an array of expectation values for the times specified by tlist, or; an array or state vectors corresponding to the times in tlist (if; e_ops is an empty list), or nothing if a callback function was; given inplace of operators for which to calculate the expectation; values. Master Equation¶; This module provides solvers for the Lindblad master equation and von Neumann; equation. mesolve(H, rho0, tlist, c_ops=None, e_ops=None, args=None, options=None, progress_bar=None, _safe_mode=True)[source]¶; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian.; Evolve the state vector or density matrix (rho0) using a given; Hamiltonian or Liouvillian (H) and an optional set of collapse operators; (c_ops), by integrating the set of ordinary differential equations; that define the system. In the absence of collapse operators the system is; evolved according to the unitary evolution of the Hamiltonian.; The output is either the state vector at arbitrary points in time; (tlist), or the expectation values of the supplied operators; (e_ops). If e_ops is a callback function, it is invoked for each; time in tlist with time and the state as arguments, and the function; does not use any return values.; If either H or the Qobj elements in c_ops are superoperators, they; will be treated as direct contributions to the total system Liouvillian.; This allows the solution of master equations that are not in standard; Lindblad form.; Time-dependent operators; For time-dependent problems, H and c_ops can be a specified in a; nested-list format where each element in the list is a list of length 2,; containing an operator (qutip.qobj) at the first element and where; the second element is either a string (list string format), a callback; function (list callback format) that evaluates to the time-dependent; coefficient for the corresponding oper",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:86088,Modifiability,Evolve,Evolve,86088,"imes for \(t\). c_op_listlist of qutip.qobjlist of qutip.qobj collapse operators. e_opslist of qutip.qobjlist of qutip.qobj operators for which to evaluate; expectation values. Returns. expt_arrayarrayExpectation values of wavefunctions/density matrices for the; times specified in tlist. Note; This solver does not support time-dependent Hamiltonians.; .. ode2es(L, rho0)[source]¶; Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) rho0, given the Liouvillian; (or Hamiltonian) L. Deprecated since version 4.6.0: ode2es will be removed in QuTiP 5. Please use; Qobj.eigenstates to get the eigenstates and -values, and use; QobjEvo for general time-dependence. Parameters. LqobjLiouvillian of the system. rho0qobjInitial state vector or density matrix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that cou",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:86946,Modifiability,coupling,couplingto,86946,"rix. Returns. eseriesqutip.eserieseseries represention of the system dynamics. Bloch-Redfield Master Equation¶. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters. Rqutip.qobjBloch-Redfield tensor. eketsarray of qutip.qobjArray of kets that make up a basis tranformation for the eigenbasis. rho0qutip.qobjInitial density matrix. tlistlist / arrayList of times for \(t\). e_opslist of qutip.qobj / callback functionList of operators for which to evaluate expectation values. optionsqutip.QdeoptionsOptions for the ODE solver. Returns. output: qutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. bloch_redfield_tensor()¶. Calculates the time-independent Bloch-Redfield tensor for a system given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:87913,Modifiability,coupling,coupling,87913,"em given; a set of operators and corresponding spectral functions that describes the; system’s couplingto its environment. Parameters. Hqutip.qobj; System Hamiltonian. a_opslistNested list of system operators that couple to the environment,; and the corresponding bath spectra represented as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88109,Modifiability,coupling,coupling,88109,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88249,Modifiability,variab,variable,88249,"d as Python; functions. spectra_cblistDepreciated. c_opslistList of system collapse operators. use_secularbool {True, False}Flag that indicates if the secular approximation should; be used. sec_cutofffloat {0.1}Threshold for secular approximation. atolfloat {qutip.settings.atol}Threshold for removing small parameters. Returns. R, kets: qutip.Qobj, list of qutip.QobjR is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88510,Modifiability,variab,variable,88510,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88571,Modifiability,variab,variables,88571,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:88654,Modifiability,variab,variable,88654,"; Hamiltonian. brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={}, use_secular=True, sec_cutoff=0.1, tol=1e-12, spectra_cb=None, options=None, progress_bar=None, _safe_mode=True, verbose=False)[source]¶; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators.; For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the w variable.; Example. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be w, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable t:; Example. a_ops = [[a+a.dag(), ‘0.2*exp(-t)*(w>=0)’]]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:; Example. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:89974,Modifiability,coupling,coupling,89974,"line objects for the bath; spectrum and time-dependence, respectively.; Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is; Example. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],… ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators a and a.dag(), respectively. Parameters. HQobj / listSystem Hamiltonian given as a Qobj or; nested list in string-based format. psi0: QobjInitial density matrix or state vector (ket). tlistarray_likeList of times for evaluating evolution. a_opslistNested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_opslistList of operators for which to evaluate expectation values. c_opslistList of system collapse operators, or nested list in; string-based format. argsdictPlaceholder for future implementation, kept for API consistency. use_secularbool {True}Use secular approximation when evaluating bath-coupling terms. sec_cutofffloat {0.1}Cutoff for secular approximation. tolfloat {qutip.setttings.atol}Tolerance used for removing small values after; basis transformation. spectra_cblistDEPRECIATED. Do not use. optionsqutip.solver.OptionsOptions for the solver. progress_barBaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns. result: qutip.solver.ResultAn instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system u",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:91524,Modifiability,variab,variables,91524," in e_ops,; or a list of states for the times specified by tlist. Floquet States and Floquet-Markov Master Equation¶. floquet_basis_transform(f_modes, f_energies, rho0)[source]¶; Make a basis transform that takes rho0 from the floquet basis to the; computational basis. floquet_markov_mesolve(R, ekets, rho0, tlist, e_ops, f_modes_table=None, options=None, floquet_basis=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. floquet_master_equation_rates(f_modes_0, f_energies, c_op, H, T, args, J_cb, w_th, kmax=5, f_modes_table_t=None)[source]¶; Calculate the rates and matrix elements for the Floquet-Markov master; equation. Parameters. f_modes_0list of qutip.qobj (kets)A list of initial Floquet modes. f_energiesarrayThe Floquet energies. c_opqutip.qobjThe collapse operators describing the dissipation. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. J_cbcallback functionsA callback function that computes the noise power spectrum, as; a function of frequency, associated with the collapse operator c_op. w_thfloatThe temperature in units of frequency. k_maxintThe truncation of the number of sidebands (default 5). f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of cor",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:92822,Modifiability,variab,variables,92822," f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table (optional). Returns. outputlistA list (Delta, X, Gamma, A) containing the matrices Delta, X, Gamma; and A used in the construction of the Floquet-Markov master equation. floquet_master_equation_steadystate(H, A)[source]¶; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation. floquet_modes(H, T, args=None, sort=False, U=None)[source]¶; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T.; Returns a list of qutip.qobj instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter sort; decides if the output is to be sorted in increasing quasienergies or not. Parameters. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:93730,Modifiability,variab,variables,93730,"Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ spans a single period of the driving. Uqutip.qobjThe propagator for the time-dependent Hamiltonian with period T.; If U is None (default), it will be calculated from the Hamiltonian; H using qutip.propagator.propagator. Returns. outputlist of kets, list of quasi energiesTwo lists: the Floquet modes as kets and the quasi energies. floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tfloatThe time at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. argsdictionarydictionary with variables required to evaluate H. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputlist of ketsThe Floquet modes as kets at time \(t\). floquet_modes_t_lookup(f_modes_table_t, t, T)[source]¶; Lookup the floquet mode at time t in the pre-calculated table of floquet; modes in the first period of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Paramet",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:95045,Modifiability,variab,variables,95045,"d of the time-dependence. Parameters. f_modes_table_tnested list of qutip.qobj (kets)A lookup-table of Floquet modes at times precalculated by; qutip.floquet.floquet_modes_table. tfloatThe time for which to evaluate the Floquet modes. TfloatThe period of the time-dependence of the hamiltonian. Returns. outputnested listA list of Floquet modes as kets for the time that most closely matching; the time t in the supplied table of Floquet modes. floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args=None)[source]¶; Pre-calculate the Floquet modes for a range of times spanning the floquet; period. Can later be used as a table to look up the floquet modes for; any time. Parameters. f_modes_0list of qutip.qobj (kets)Floquet modes at \(t\). f_energieslistFloquet energies. tlistarrayThe list of times at which to evaluate the floquet modes. Hqutip.qobjsystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionarydictionary with variables required to evaluate H. Returns. outputnested listA nested list of Floquet modes as kets for each time in tlist. floquet_state_decomposition(f_states, f_energies, psi)[source]¶; Decompose the wavefunction psi (typically an initial state) in terms of; the Floquet states, \(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\). Parameters. f_stateslist of qutip.qobj (kets)A list of Floquet modes. f_energiesarrayThe Floquet energies. psiqutip.qobjThe wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:96493,Modifiability,variab,variables,96493,"The wavefunction to decompose in the Floquet state basis. Returns. outputarrayThe coefficients \(c_\alpha\) in the Floquet state decomposition. floquet_states(f_modes_t, f_energies, t)[source]¶; Evaluate the floquet states at time t given the Floquet modes at that time. Parameters. f_modes_tlist of qutip.qobj (kets)A list of Floquet modes for time \(t\). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Returns. outputlistA list of Floquet states for the time \(t\). floquet_states_t(f_modes_0, f_energies, t, H, T, args=None)[source]¶; Evaluate the floquet states at time t given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputlistA list of Floquet states for the time \(t\). floquet_wavefunction(f_modes_t, f_energies, f_coeff, t)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:97731,Modifiability,variab,variables,97731,"n, given the Floquet modes at time t. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Returns. outputqutip.qobjThe wavefunction for the time \(t\). floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args=None)[source]¶; Evaluate the wavefunction for a time t using the Floquet state; decompositon, given the initial Floquet modes. Parameters. f_modes_tlist of qutip.qobj (kets)A list of initial Floquet modes (for time \(t=0\)). f_energiesarrayThe Floquet energies. f_coeffarrayThe coefficients for Floquet decomposition of the initial wavefunction. tfloatThe time for which to evaluate the Floquet states. Hqutip.qobjSystem Hamiltonian, time-dependent with period T. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. Returns. outputqutip.qobjThe wavefunction for the time \(t\). fmmesolve(H, rho0, tlist, c_ops=[], e_ops=[], spectra_cb=[], T=None, args={}, options=<qutip.solver.Options object>, floquet_basis=True, kmax=5, _safe_mode=True)[source]¶; Solve the dynamics for the system using the Floquet-Markov master equation. Note; This solver currently does not support multiple collapse operators. Parameters. Hqutip.qobjsystem Hamiltonian. rho0 / psi0qutip.qobjinitial density matrix or state vector (ket). tlistlist / arraylist of times for \(t\). c_opslist of qutip.qobjlist of collapse operators. e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. spectra_cblist callback functionsList of callback functions that compute the noise power spectrum as; a function of frequency for the collapse operators in c_ops. TfloatThe period of the time-dependence of the hamiltonian. The default value; ‘None’ indicates that the ‘tlist’ s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:100157,Modifiability,variab,variables,100157," temperature = 25e-3 # unit K ; >>> h = 6.626e-34 ; >>> kB = 1.38e-23 ; >>> args['w_th'] = temperature * (kB / h) * 2 * pi * 1e-9 . optionsqutip.solveroptions for the ODE solver. k_maxintThe truncation of the number of sidebands (default 5). Returns. outputqutip.solverAn instance of the class qutip.solver, which contains either; an array of expectation values for the times specified by tlist. fsesolve(H, psi0, tlist, e_ops=[], T=None, args={}, Tsteps=100)[source]¶; Solve the Schrodinger equation using the Floquet formalism. Parameters. Hqutip.qobj.QobjSystem Hamiltonian, time-dependent with period T. psi0qutip.qobjInitial state vector (ket). tlistlist / arraylist of times for \(t\). e_opslist of qutip.qobj / callback functionlist of operators for which to evaluate expectation values. If this; list is empty, the state vectors for each time in tlist will be; returned instead of expectation values. TfloatThe period of the time-dependence of the hamiltonian. argsdictionaryDictionary with variables required to evaluate H. TstepsintegerThe number of time steps in one driving period for which to; precalculate the Floquet modes. Tsteps should be an even number. Returns. outputqutip.solver.ResultAn instance of the class qutip.solver.Result, which; contains either an array of expectation values or an array of; state vectors, for the times specified by tlist. Stochastic Schrödinger Equation and Master Equation¶. general_stochastic(state0, times, d1, d2, e_ops=[], m_ops=[], _safe_mode=True, len_d2=1, args={}, **kwargs)[source]¶; Solve stochastic general equation. Dispatch to specific solvers; depending on the value of the solver keyword argument. Parameters. state0qutip.QobjInitial state vector (ket) or density matrix as a vector. timeslist / arrayList of times for \(t\). Must be uniformly spaced. d1function, callable classFunction representing the deterministic evolution of the system. def d1(time (double), state (as a np.array vector)):return 1d np.array. d2function, callable",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141434,Modifiability,config,config,141434,"t Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:142327,Modifiability,config,configuration,142327,"enting the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the; mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent; Pulses from Quantum Optical Systems (2017, arXiv:1710.02875). scattering_probability(H, psi0, n_emissions, c_ops, tlist, system_zero_state=None, construct_effective_hamiltonian=True)[source]¶; Compute the integrated probability of scattering n photons in an arbitrary; system. This function accepts a nonlinearly spaced array of times. Parameters. H:class: qutip.Qobj or listSystem-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or; list-callback format. If construct_effective_hamiltonian is not; specified, an effective Hamiltonian is constructed from H and; c_ops. psi0:class: qutip.QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). n_emissionsintNumber of photons emitted by the system (i",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:179373,Modifiability,enhance,enhance,179373,"oatAngle with respect to z-axis. phifloatAngle in x-y plane. valuesarrayData set to be plotted. figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. savebool {False , True}Whether to save the figure or not. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. Parameters. thetalist/arrayPolar angles. philist/arrayAzimuthal angles. argslist/arraylist of ket vectors. Returns. array for angular wave function. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data value",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:179510,Modifiability,variab,variables,179510,"figa matplotlib Figure instanceThe Figure canvas in which the plot will be drawn. axa matplotlib axes instanceThe axes context in which the plot will be drawn. savebool {False , True}Whether to save the figure or not. Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. orbital(theta, phi, *args)[source]¶; Calculates an angular wave function on a sphere.; psi = orbital(theta,phi,ket1,ket2,...) calculates; the angular wave function on a sphere at the mesh of points; defined by theta and phi which is; \(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\) where \(C_{lm}\) are the; coefficients specified by the list of kets. Each ket has 2l+1 components; for some integer l. Parameters. thetalist/arrayPolar angles. philist/arrayAzimuthal angles. argslist/arraylist of ket vectors. Returns. array for angular wave function. This module contains utility functions that enhance Matplotlib; in one way or another. complex_phase_cmap()[source]¶; Create a cyclic colormap for representing the phase of complex variables. Returns. cmap :A matplotlib linear segmented colormap. wigner_cmap(W, levels=1024, shift=0, max_color='#09224F', mid_color='#FFFFFF', min_color='#530017', neg_color='#FF97D4', invert=False)[source]¶; A custom colormap that emphasizes negative values by creating a; nonlinear colormap. Parameters. WarrayWigner function array, or any array. levelsintNumber of color levels to create. shiftfloatShifts the value at which Wigner elements are emphasized.; This parameter should typically be negative and small (i.e -1e-5). max_colorstrString for color corresponding to maximum value of data. Accepts; any string format compatible with the Matplotlib.colors.ColorConverter. mid_colorstrColor corresponding to zero values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. min_colorstrColor corresponding to minimum data values. Accepts any string format; compatible with the Matplotlib.colors.ColorConverter. neg_colorstr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:197809,Modifiability,config,configuration,197809,"source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The C",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198427,Modifiability,variab,variables,198427,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198998,Modifiability,variab,variables,198998,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199085,Modifiability,variab,variables,199085,"tion in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199165,Modifiability,variab,variables,199165,"ntly two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, m",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:200807,Modifiability,config,configuration,200807,"rco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed configuration is; required before running the optmisation algorthim, or the algorithm will be; run many times, for instances when trying to finding global the optimum or; minimum time optimisation. Parameters. driftQobj or list of QobjThe underlying dynamics generator of the system can provide list (of; length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]A list of control dynamics generators. These are scaled by the; amplitudes to alter the overall dynamics. Array-like input can be; provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau array. evo_timefloat or NoneTotal time for the evolution. None implies that timeslots will be; given in the tau array",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207758,Modifiability,Config,Config,207758," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:209094,Modifiability,variab,variables,209094,"ization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function.; A multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution. Parameters. driftQobj or list of Qobjthe underlying dynamics generator of the system; can provide list (of length num_tslots) for time dependent drift. ctrlsList of Qobj or array like [num_tslots, evo_time]a list of control dynamics generators. These are scaled by; the amplitudes to alter the overall dynamics; Array like imput can be provided for time dependent control generators. initialQobjStarting point for the evolution. Typically the identity matrix. targetQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau ar",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211912,Modifiability,variab,variable,211912,"of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212427,Modifiability,variab,variable,212427,"e from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Options are DEF, UNIT, TRACEDIFF, TD_APPROX. DEF will use the default; for the specific dyn_type. (See FidelityCo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217553,Modifiability,variab,variables,217553,"ff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array like imput can be provided for time; dependent control generators. U_0QobjStarting point for the evolution. Typically the identity matrix. U_targQobjTarget transformation, e.g. gate or state, for the time evolution. num_tslotsinteger or NoneNumber of timeslots. None implies that timeslots will be given in; the tau arr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220369,Modifiability,variab,variable,220369,"f the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The k",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220884,Modifiability,variab,variable,220884," from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only one that currently works. (See TimeslotComputer; classes for details). tslot_paramsdictParameters for the Tim",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:246558,Modifiability,coupling,coupling,246558,"nerate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(value, orig='meV', to='GHz')[source]¶; Convert an energy from unit orig to unit to. Parameters. valuefloat / arrayThe energy in the old unit. origstringThe name of the original unit (“J”, “eV”, “meV”, “GHz”, “mK”). tostringThe name of the new unit (“J”, “eV”, “meV”, “GHz”, “mK”). Returns. value_new_unitfloat / arrayThe energy in the new unit. n_thermal(w, w_th)[source]¶; Return the number of photons in thermal equilibrium for an harmonic; oscillator mode with frequency ‘w’, at the temperature described by; ‘w_th’ where \(\omega_{\rm th} = k_BT/\hbar\). Parameters. wfloat or arrayFrequency of the oscillator. w_thflo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:249941,Modifiability,variab,variable,249941,"This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:250355,Modifiability,variab,variables,250355,"values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. tas",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:250415,Modifiability,variab,variables,250415," or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for w",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:58980,Performance,concurren,concurrence,58980,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:59021,Performance,concurren,concurrence,59021,"bjQobjThe original Qobj with all named index pairs contracted; away. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:70516,Performance,Perform,Perform,70516,"of quantum states¶; Module for measuring quantum objects. measure(state, ops, targets=None)[source]¶; A dispatch method that provides measurement results handling both; observable style measurements and projector style measurements (POVMs and; PVMs).; For return signatures, please check:. measure_observable for observable measurements.; measure_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger = M_i\)); kets (transformed to projectors). targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand ops; into full dimension. measure_observable(state, op, targets=None)[source]¶; Perform a measurement specified by an operator on the given state.; This function simulates the classic quantum measurement described in many; introductory texts on quantum mechanics. The measurement collapses the; state to one of the eigenstates of the given operator and the result of the; measurement is the corresponding eigenvalue. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opQobjThe measurement operator. targetslist of ints, optionalSpecifies a list of target “qubit” indices on which to apply the; measurement using qutip.qip.gates.expand_operator to expand op; into full dimension. Returns. measured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72144,Performance,perform,perform,72144,"sured_valuefloatThe result of the measurement (one of the eigenvalues of op). stateQobjThe new state (a ket if a ket was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:72196,Performance,perform,perform,72196,"was given, otherwise a density matrix). Examples; Measure the z-component of the spin of the spin-up basis state:; >>> measure_observable(basis(2, 0), sigmaz()); (1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-1.]; [ 0.]]). Since the spin-up basis is an eigenstate of sigmaz, this measurement always; returns 1 as the measurement result (the eigenvalue of the spin-up basis); and the original state (up to a global phase).; Measure the x-component of the spin of the spin-down basis state:; >>> measure_observable(basis(2, 1), sigmax()); (-1.0, Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[-0.70710678]; [ 0.70710678]]). This measurement returns 1 fifty percent of the time and -1 the other fifty; percent of the time. The new state returned is the corresponding eigenstate; of sigmax.; One may also perform a measurement on a density matrix. Below we perform; the same measurement as above, but on the density matrix representing the; pure spin-down state:; >>> measure_observable(ket2dm(basis(2, 1)), sigmax()); (-1.0, Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper; Qobj data =; [[ 0.5 -0.5]; [-0.5 0.5]]). The measurement result is the same, but the new state is returned as a; density matrix. measurement_statistics(state, ops, targets=None)[source]¶; A dispatch method that provides measurement statistics handling both; observable style measurements and projector style measurements(POVMs and; PVMs).; For return signatures, please check:. measurement_statistics_observable for observable measurements.; measurement_statistics_povm for POVM measurements. Parameters. stateQobjThe ket or density matrix specifying the state to measure. opsQobj or list of Qobj; measurement observable (:class:.Qobj); or; list of measurement operators \(M_i\) or kets (list of; Qobj) Either:. specifying a POVM s.t. \(E_i = M_i^\dagger * M_i\); projection operators if ops correspond to projectors (s.t.; \(E_i = M_i^\dagger =",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137053,Performance,perform,perform,137053,"olvers as; their direct counterparts. return_infobool, default FalseReturn a dictionary of solver-specific infomation about the solution; and how it was obtained. sparsebool, default TrueSolve for the steady state using sparse algorithms. If set to False,; the underlying Liouvillian operator will be converted into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:137360,Performance,perform,perform,137360,"ed into a dense; matrix. Use only for ‘smaller’ systems. use_rcmbool, default FalseUse reverse Cuthill-Mckee reordering to minimize fill-in in the LU; factorization of the Liouvillian. use_wbmbool, default FalseUse Weighted Bipartite Matching reordering to make the Liouvillian; diagonally dominant. This is useful for iterative preconditioners; only, and is set to True by default when finding a preconditioner. weightfloat, optionalSets the size of the elements used for adding the unity trace condition; to the linear solvers. This is set to the average abs value of the; Liouvillian elements if not specified by the user. max_iter_refineint, default 10MKL ONLY. Max. number of iterative refinements to perform. scaling_vectorsboolMKL ONLY. Scale matrix to unit norm columns and rows. weighted_matchingboolMKL ONLY. Use weighted matching to better condition diagonal. x0ndarray, optionalITERATIVE ONLY. Initial guess for solution vector. maxiterint, default 1000ITERATIVE ONLY. Maximum number of iterations to perform. tolfloat, default 1e-12ITERATIVE ONLY. Tolerance used for terminating solver. mtolfloat, optionalITERATIVE ‘power’ methods ONLY. Tolerance for lu solve method. If None; given then max(0.1*tol, 1e-15) is used. matolfloat, default 1e-15ITERATIVE ONLY. Absolute tolerance for lu solve method. permc_specstr, optionalITERATIVE ONLY. Column ordering used internally by superLU for the; ‘direct’ LU decomposition method. Options include ‘COLAMD’ (default); and ‘NATURAL’. If using RCM then this is set to ‘NATURAL’ automatically; unless explicitly specified. use_precondbool, default FalseITERATIVE ONLY. Use an incomplete sparse LU decomposition as a; preconditioner for the ‘iterative’ GMRES and BICG solvers. Speeds up; convergence time by orders of magnitude in many cases. M{sparse matrix, dense matrix, LinearOperator}, optionalITERATIVE ONLY. Preconditioner for A. The preconditioner should; approximate the inverse of A. Effective preconditioning can; dramatically improve the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:164824,Performance,perform,performance,164824,"hbar via hbar=2/g^2 giving the default; value hbar=1. methodstring {‘clenshaw’, ‘iterative’, ‘laguerre’, ‘fft’}Select method ‘clenshaw’ ‘iterative’, ‘laguerre’, or ‘fft’, where ‘clenshaw’; and ‘iterative’ use an iterative method to evaluate the Wigner functions for density; matrices \(|m><n|\), while ‘laguerre’ uses the Laguerre polynomials; in scipy for the same task. The ‘fft’ method evaluates the Fourier; transform of the density matrix. The ‘iterative’ method is default, and; in general recommended, but the ‘laguerre’ method is more efficient for; very sparse density matrices (e.g., superpositions of Fock states in a; large Hilbert space). The ‘clenshaw’ method is the preferred method for; dealing with density matrices that have a large number of excitations; (>~50). ‘clenshaw’ is a fast and numerically stable method. sparsebool {False, True}Tells the default solver whether or not to keep the input density; matrix in sparse format. As the dimensions of the density matrix; grow, setthing this flag can result in increased performance. parforbool {False, True}Flag for calculating the Laguerre polynomial based Wigner function; method=’laguerre’ in parallel using the parfor function. Returns. WarrayValues representing the Wigner function calculated over the specified; range [xvec,yvec]. yvexarrayFFT ONLY. Returns the y-coordinate values calculated via the Fourier; transform. Notes; The ‘fft’ method accepts only an xvec input for the x-coordinate.; The y-coordinates are calculated internally.; References; Ulf Leonhardt,; Measuring the Quantum State of Light, (Cambridge University Press, 1997). Graphs and Visualization¶; Functions for visualizing results of quantum dynamics simulations,; visualizations of quantum states and processes. hinton(rho, xlabels=None, ylabels=None, title=None, ax=None, cmap=None, label_top=True)[source]¶; Draws a Hinton diagram for visualizing a density matrix or superoperator. Parameters. rhoqobjInput density matrix or superoperator. xlabelsli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198359,Performance,optimiz,optimize,198359,"mes \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:199815,Performance,optimiz,optimization,199815," CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelder-Mead method for fidelity error minimisation.; References. N Khaneja et. al.; Optimal control of coupled spin dynamics: Design of NMR pulse sequences; by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).; Shai Machnes et.al; DYNAMO - Dynamic Framework for Quantum Optimal Control; arXiv.1011.4874; Doria, P., Calarco, T. & Montangero, S.; Optimal Control Technique for Many-Body Quantum Dynamics.; Phys. Rev. Lett. 106, 1–4 (2011).; Caneva, T., Calarco, T. & Montangero, S.; Chopped random-basis quantum optimization.; Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011). create_pulse_optimizer(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, gen_stats=False)[source]¶; Generate the objects of the appropriate subclasses required for the pulse; optmisation based on the parameters given Note this method may be; preferable to calling optimize_pulse if more detailed",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203295,Performance,optimiz,optimize,203295,"r each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (s",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203480,Performance,optimiz,optimize,203480,"rol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation.; Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203819,Performance,Optimiz,Optimizer,203819,"re:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key valu",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:203988,Performance,optimiz,optimize,203988," above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringa scipy.optimize.minimize method that will be used to optimise; the pulse for minimum fidelity error; Note that FMIN, FMIN_BFGS & FMIN_L_BFGS_B will all result; in calling these specific scipy.optimize methods; Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards; capatibility reasons.; Supplying DEF will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is Nelder-Mead. method_paramsdictParameters for the optim_method.; Note that where there is an attribute of the; Optimizer object or the termination_conditions matching the key; that attribute. Otherwise, and in some case also,; they are assumed to be method_options; for the scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe; the dynamics. Options are UNIT, GEN_MAT, SYMPL; (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. prop_typestringPropagator type i.e. the method used to calculate the; propagtors and propagtor gradient for each timeslot; options are DEF, APPROX, DIAG, FRECHET, AUG_MAT; DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. fid_typestringFidelity error (and fidelity error gradient) com",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207728,Performance,Optimiz,Optimizer,207728," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207983,Performance,optimiz,optimizer,207983,"ng pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:208056,Performance,optimiz,optimizer,208056,"are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]; The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211723,Performance,perform,performane,211723,"idelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribut",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212053,Performance,optimiz,optimize,212053,"are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see P",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212182,Performance,Optimiz,Optimizer,212182,"lues. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:212350,Performance,optimiz,optimize,212350,"rride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT DEF will use the default for the specific dyn_type; (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradient) computation method.; Option",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220179,Performance,perform,performance,220179,"delity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; as",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220510,Performance,optimiz,optimize,220510,"re specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the Fideli",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220639,Performance,Optimiz,Optimizer,220639,"ues. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typest",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220807,Performance,optimiz,optimize,220807,"ride these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC. UPDATE_ALL is; the only on",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:227933,Performance,optimiz,optimize,227933,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dyna",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228119,Performance,optimiz,optimize,228119," squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. pr",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228451,Performance,Optimiz,Optimizer,228451,"ions are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:228619,Performance,optimiz,optimize,228619,"thm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error. Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods. Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying DEF; will given alg dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics; classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_typestringPropagator type i.e. the method used to calculate the propagators and; propagator gradient for each timeslot options are DEF, APPROX, DIAG,; FRECHET, AUG_MAT. DEF will use the default for the specific; dyn_type (see PropagatorComputer classes for details). prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_typestringFidelity error (and fidelity error gradie",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236623,Performance,optimiz,optimize,236623,"or each control. fid_err_targfloatFidelity error target. Pulse optimisation will terminate when the; fidelity error falls below this value. mim_gradfloatMinimum gradient. When the sum of the squares of the gradients wrt to; the control amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:236808,Performance,optimiz,optimize,236808,"trol amplitudes falls below this value, the optimisation; terminates, assuming local minima. max_iterintegerMaximum number of iterations of the optimisation algorithm. max_wall_timefloatMaximum allowed elapsed time for the optimisation algorithm. algstringAlgorithm to use in pulse optimisation. Options are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParame",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:237145,Performance,Optimiz,Optimizer,237145," are:. ‘GRAPE’ (default) - GRadient Ascent Pulse Engineering; ‘CRAB’ - Chopped RAndom Basis. alg_paramsDictionaryoptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the obje",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:237314,Performance,optimiz,optimize,237314,"ee above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. optim_methodstringA scipy.optimize.minimize method that will be used to optimise the; pulse for minimum fidelity error Note that FMIN, FMIN_BFGS &; FMIN_L_BFGS_B will all result in calling these specific; scipy.optimize methods Note the LBFGSB is equivalent to; FMIN_L_BFGS_B for backwards compatibility reasons. Supplying; DEF will given algorithm-dependent result:. GRAPE - Default optim_method is FMIN_L_BFGS_B; CRAB - Default optim_method is FMIN. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the; termination_conditions matching the key that attribute. Otherwise,; and in some case also, they are assumed to be method_options for the; scipy.optimize.minimize method. optim_algstringDeprecated. Use optim_method. max_metric_corrintegerDeprecated. Use method_params instead. accuracy_factorfloatDeprecated. Use method_params instead. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. fid_paramsdictParameters for the FidelityComputer object. The key value; pairs are assumed to be attribute name value pairs. They applied after; the object is created. tslot_typestringMethod for computing the dynamics generators, propagators and evolution; in the timeslots. Options: DEF, UPDATE_ALL, DYNAMIC.;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:245868,Performance,perform,performing,245868,"hill and J. McKee, “Reducing the Bandwidth of Sparse Symmetric; Matrices”, ACM ‘69 Proceedings of the 1969 24th national conference,; (1969). weighted_bipartite_matching(A, perm_type='row')[source]¶; Returns an array of row permutations that attempts to maximize the product; of the ABS values of the diagonal elements in a nonsingular square CSC; sparse matrix. Such a permutation is always possible provided that the; matrix is nonsingular.; This function looks at both the structure and ABS values of the underlying; matrix. Parameters. Acsc_matrixInput matrix. perm_typestr {‘row’, ‘column’}Type of permutation to generate. Returns. permarrayArray of row or column permutations. Notes; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and are; traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method.; References; I. S. Duff and J. Koster, “The design and use of algorithms for permuting; large entries to the diagonal of sparse matrices”, SIAM J. Matrix Anal.; and Applics. 20, no. 4, 889 (1997). Utility Functions¶; This module contains utility functions that are commonly needed in other; qutip modules. clebsch(j1, j2, j3, m1, m2, m3)[source]¶; Calculates the Clebsch-Gordon coefficient; for coupling (j1,m1) and (j2,m2) to give (j3,m3). Parameters. j1floatTotal angular momentum 1. j2floatTotal angular momentum 2. j3floatTotal angular momentum 3. m1floatz-component of angular momentum 1. m2floatz-component of angular momentum 2. m3floatz-component of angular momentum 3. Returns. cg_coefffloatRequested Clebsch-Gordan coefficient. convert_unit(v",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:248511,Performance,Load,Loads,248511,"illator. w_thfloatThe temperature in units of frequency (or the same units as w). Returns. n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:248622,Performance,load,loaded,248622,". n_avgfloat or arrayReturn the number of average photons in thermal equilibrium for a; an oscillator with the given frequency and temperature. File I/O Functions¶. file_data_read(filename, sep=None)[source]¶; Retrieves an array of data from the requested file. Parameters. filenamestrName of file containing reqested data. sepstrSeperator used to store data. Returns. dataarray_likeData from selected file. file_data_store(filename, data, numtype='complex', numformat='decimal', sep=',')[source]¶; Stores a matrix of data to a file to be read by an external program. Parameters. filenamestrName of data file to be stored, including extension. data: array_likeData to be written to file. numtypestr {‘complex, ‘real’}Type of numerical data. numformatstr {‘decimal’,’exp’}Format for written data. sepstrSingle-character field seperator. Usually a tab, space, comma,; or semicolon. qload(name)[source]¶; Loads data file from file named ‘filename.qu’ in current directory. Parameters. namestrName of data file to be loaded. Returns. qobjectinstance / array_likeObject retrieved from requested file. qsave(data, name='qutip_data')[source]¶; Saves given data to file named ‘filename.qu’ in current directory. Parameters. datainstance/array_likeInput Python object to be stored. filenamestrName of output data file. Parallelization¶; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing. parallel_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Parallel execution of a mapping of values to the function task. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslis",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:250724,Performance,Perform,Performance,250724,". resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for; each value in values. parfor(func, *args, **kwargs)[source]¶; Executes a multi-variable function in parallel on the local machine.; Parallel execution of a for-loop over function func for multiple input; arguments and keyword arguments. Note; From QuTiP 3.1, we recommend to use qutip.parallel_map; instead of this function. Parameters. funcfunction_typeA function to run in parallel on the local machine. The function ‘func’; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:; num_cpusintNumber of CPU’s to use. Default uses maximum number of CPU’s.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns. resultlistA list with length equal to number of input parameters; containing the output from func. serial_map(task, values, task_args=(), task_kwargs={}, **kwargs)[source]¶; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:; result = [task(value, *task_args, **task_kwargs) for value in values]. This function work as a drop-in replacement of qutip.parallel_map. Parameters. taska Python functionThe function that is to be called for each value in task_vec. valuesarray / listThe list or array of values for which the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result l",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:252432,Performance,load,load-balanced,252432,"the task function is to be; evaluated. task_argslist / dictionaryThe optional additional argument to the task function. task_kwargslist / dictionaryThe optional additional keyword argument to the task function. progress_barProgressBarProgress bar class instance for showing progress. Returns. resultlistThe result list contains the value of; task(value, *task_args, **task_kwargs) for each; value in values. Semidefinite Programming¶; This module implements internal-use functions for semidefinite programming. IPython Notebook Tools¶; This module contains utility functions for using QuTiP with IPython notebooks. parallel_map(task, values, task_args=None, task_kwargs=None, client=None, view=None, progress_bar=None, show_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253153,Performance,load,load-balanced,253153,"w_scheduling=False, **kwargs)[source]¶; Call the function task for each value in values using a cluster; of IPython engines. The function task should have the signature; task(value, *args, **kwargs).; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instanc",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254081,Performance,load,load-balanced,254081,"ing the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:254755,Performance,load,load-balanced,254755,"view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string contai",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:44836,Safety,avoid,avoids,44836," a three level atom. Returns. statesarrayarray of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns. opsarrayarray of three level operators. Superoperators and Liouvillians¶. lindblad_dissipator(a, b=None, data_only=False, chi=None)[source]¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters. aQobj or QobjEvoLeft part of collapse operator. bQobj or QobjEvo (optional)Right part of collapse operator. If not specified, b defaults to a. Returns. Dqobj, QobjEvoLindblad dissipator superoperator. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters. HQobj or QobjEvoSystem Hamiltonian. c_opsarray_like of Qobj or QobjEvoA list or array of collapse operators. Returns. LQobj or QobjEvoLiouvillian superoperator. operator_to_vector(op)[source]¶; Create a vector representation given a quantum operator in matrix form.; The passed object should have a Qobj.type of ‘oper’ or ‘super’; this; function is not designed for general-purpose matrix reshaping. Parameters. opQobj or QobjEvoQuantum operator in matrix form. This must have a type of ‘oper’ or; ‘super’. Returns. Qobj or QobjEvoThe same object, but re-cast into a column-stacked-vector form of type; ‘operator-ket’. The output is the same type as the passed object. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters. AQobj or QobjEvoQuantum operator for post multiplication. Returns. superQobj or QobjEvoSuperoperator formed from input qauntum object. spre(A)[source]¶;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60980,Safety,detect,detect,60980,"alculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. E",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109029,Safety,predict,predictor-correctorGeneralization,109029,"ticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109317,Safety,predict,predictor-corrector,109317,"sesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:111648,Safety,predict,predictor,111648,"ochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolutio",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:256335,Safety,detect,detecting,256335,"n the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array of qobjs representing commuting Hermitian; operators. evalsbool [True]Whether to return the eigenvalues for each ops and eigenvectors or just; the eigenvectors. tolfloat [1e-14]Tolerance for detecting degenerate eigenstates. safe_modebool [True]Whether to check that all ops are Hermitian and commuting. If set to; False and operators are not commuting, the eigenvectors returned; will often be eigenvectors of only the first operator. Returns. eigstupleTuple of arrays representing eigvecs and eigvals of quantum objects; corresponding to simultaneous eigenvectors and eigenvalues for each; operator. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:47732,Security,Sanitiz,Sanitize,47732,"operator-ket’. Returns. Qobj or QobjEvoThe same object, but re-cast into “standard” operator form. The output; is the same type as the passed object. Superoperator Representations¶; This module implements transformations between superoperator representations,; including supermatrix, Kraus, Choi and Chi (process) matrix formalisms. chi_to_choi(q_oper)[source]¶; Converts a Chi matrix to a Choi matrix.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the system. Parameters. q_operQobjSuperoperator to be converted to Chi representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_chi(A) == to_chi(sprepost(A, A.dag())). Returns. chiQobjA quantum object representing the same map as q_oper, such that; chi.superrep == ""chi"".",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:48139,Security,Sanitiz,Sanitize,48139,"E: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_chi(q_oper)[source]¶; Converts a Choi matrix to a Chi matrix in the Pauli basis.; NOTE: this is only supported for qubits right now. Need to extend to; Heisenberg-Weyl for other subsystem dimensions. choi_to_kraus(q_oper, tol=1e-09)[source]¶; Takes a Choi matrix and returns a list of Kraus operators.; TODO: Create a new class structure for quantum channels, perhaps as a; strict sub-class of Qobj. choi_to_super(q_oper)[source]¶; Takes a Choi matrix to a superoperator; TODO: Sanitize input, Abstract-ify application of channels to states. kraus_to_choi(kraus_list)[source]¶; Takes a list of Kraus operators and returns the Choi matrix for the channel; represented by the Kraus operators in kraus_list. kraus_to_super(kraus_list)[source]¶; Converts a list of Kraus operators and returns a super operator. super_to_choi(q_oper)[source]¶; Takes a superoperator to a Choi matrix; TODO: Sanitize input, incorporate as method on Qobj if type==’super’. to_chi(q_oper)[source]¶; Converts a Qobj representing a quantum map to a representation as a chi; (process) matrix in the Pauli basis, such that the trace of the returned; operator is equal to the dimension of the system. Parameters. q_operQobjSuperoperator to be converted to Chi representation. If; q_oper is type=""oper"", then it is taken to act by conjugation,; such that to_chi(A) == to_chi(sprepost(A, A.dag())). Returns. chiQobjA quantum object representing the same map as q_oper, such that; chi.superrep == ""chi"". Raises. TypeError: if the given quantum object is not a map, or cannot be convertedto Chi representation. to_choi(q_oper)[source]¶; Converts a Qobj representing a quantum map to the Choi representation,; such that the trace of the returned operator is equal to the dimension; of the system. Parameters. q_operQobjSuperoperator to be converted to Choi representation. If; q_oper is type=""oper"", then it is t",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:172550,Security,access,access,172550,"be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iterationint (default 0) or ‘grid_iteration’ or ‘all’Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns. fig, axtupleA tuple of the matplotlib figure and axes instances used to produce; the figure. Notes; See also [1].; References. 1; J. Rodriguez-Laguna, P. Migdal, M. Ibanez Berganza, M. Lewenstein; and G. Sierra, Qubism: self-similar visualization of many-body; wavefunctions, New J. Phys. 14 053028, arXiv:1112.3560; (2012), open access. plot_schmidt(ket, splitting=None, labels_iteration=(3, 2), theme='light', fig=None, ax=None, figsize=(6, 6))[source]¶; Plotting scheme related to Schmidt decomposition.; Converts a state into a matrix (A_ij -> A_i^j),; where rows are first particles and columns - last.; See also: plot_qubism with how=’before_after’ for a similar plot. Parameters. ketQobjPure state for plotting. splittingintPlot for a number of first particles versus the rest.; If not given, it is (number of particles + 1) // 2. theme‘light’ (default) or ‘dark’Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. labels_iterationint or pair of ints (default (3,2))Number of particles to be shown as tick labels,; for first (vertical) and last (horizontal) particles, respectively. figa matplotlib figure instanceThe figure canvas on which the plot will be drawn. axa matplotlib axis instanceThe axis context in which the plot will be drawn. figsize(width, height)The size of the m",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:198277,Security,access,accessible,198277,"nsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and execute the algorithm required to optimise; a set of ctrl pulses for a given (quantum) system.; The fidelity error is some measure of distance of the system evolution; from the given target evolution in the time allowed for the evolution.; The functions minimise this fidelity error wrt the piecewise control; amplitudes in the timeslots; There are currently two quantum control pulse optmisations algorithms; implemented in this library. There are accessible through the methods; in this module. Both the algorithms use the scipy.optimize methods; to minimise the fidelity error with respect to to variables that define; the pulse. GRAPE¶; The default algorithm (as it was implemented here first) is GRAPE; GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such; as BFGS to minimise the fidelity error. This makes convergence very quick; when an exact gradient can be calculated, but this limits the factors that can; taken into account in the fidelity. CRAB¶; The CRAB [3][4] algorithm was developed at the University of Ulm.; In full it is the Chopped RAndom Basis algorithm.; The main difference is that it reduces the number of optimisation variables; by defining the control pulses by expansions of basis functions,; where the variables are the coefficients. Typically a Fourier series is chosen,; i.e. the variables are the Fourier coefficients.; Therefore it does not need to compute an explicit gradient.; By default it uses the Nelde",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207640,Security,access,accessible,207640,"is value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, gue",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207828,Security,access,accessed,207828," for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207931,Security,access,accessed,207931,"added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error.; The dynamics of the system in any given timeslot are governed; by the combined dynamics generator,; ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:216080,Security,access,accessible,216080,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system a",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:224052,Security,access,accessible,224052,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initial, target, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, dyn_type='GEN_MAT', dyn_params=None, prop_type='DEF', prop_params=None, fid_type='DEF', fid_params=None, phase_option=None, fid_err_scale_factor=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:232530,Security,access,accessible,232530,"only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:240603,Security,access,accessible,240603,"s only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses for the timeslots; Each class defines a gen_pulse function that produces a float array of; size num_tslots. Each class produces a differ type of pulse.; See the class and gen_pulse function descriptions for details. create_pulse_gen(pulse_type='RND', dyn=None, pulse_params=None)[source]¶; Create and return a pulse generator object matching the given type.; The pulse generators each produce a different type of pulse,; see the gen_pulse function description for details.; These are the random pulse options:. RND - Independent random value in each timeslot; RNDFOURIER - Fourier series with random coefficients; RNDWAVES - Summation of random waves; RNDWALK1 - Random change in amplitude each timeslot; RN",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:1450,Testability,Log,Log,1450,"ectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)Integer corresponding to desired number state, defaults to 0 for all; dimensions if omitted. The shape must match dimensions, e.g. if; dimensions is a list, then n must either be omitted or a list; of equal length. offsetint or list of ints, optional (default 0 for all dimensions)The lowest number state that is included in the finite number state; representation of the state in the relevant dimension. Returns. statequtip.QobjQobj representing the requested number state |",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:59563,Testability,log,logarithm,59563,"m; should be tranposed. Parameters. rhoqutip.qobjA density matrix. masklist / arrayA mask that selects which subsystems should be transposed. methodstrchoice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns. rho_pr: qutip.qobjA density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters. stateqobjKet, bra, or density matrix for a two-qubit state. Returns. concurfloatConcurrence. References. 1; http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(r",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60314,Testability,log,logarithm,60314,"45, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a selected density matrix component. Parameters. rhoqobjDensity matrix of composite object. selBint/listSelected components for density matrix B. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_condfloatValue of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters. rhoqobjsensity matrix or ket/bra vector. Returns. entropyfloatLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:60811,Testability,log,logarithm,60811,"tLinear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters. rhoqobjDensity matrix for composite quantum systems. selAint/listint or list of first selected density matrix components. selBint/listint or list of second selected density matrix components. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. ent_mutfloatMutual information between selected components. entropy_relative(rho, sigma, base=2.718281828459045, sparse=False, tol=1e-12)[source]¶; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters. rhoqutip.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-N",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:61618,Testability,log,log,61618,"p.QobjFirst density matrix (or ket which will be converted to a density; matrix). sigmaqutip.QobjSecond density matrix (or ket which will be converted to a density; matrix). base{e,2}Base of logarithm. Defaults to e. sparseboolFlag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:61893,Testability,log,logarithm,61893," the eigenvectors; of the density matrices. Defaults to False. tolfloatTolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns. rel_entfloatValue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. References; See Nielsen & Chuang, “Quantum Computation and Quantum Information”,; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; Examples; First we define two density matrices:; >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. log2); and base e (i.e. log).; >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy of density matrix. Parameters. rhoqobjDensity matrix. base{e,2}Base of logarithm. sparse{False,True}Use sparse eigensolver. Returns. entropyfloatVon-Neumann entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. Density Matrix Metrics¶; This module contains a collection of functions for calculating metrics; (distance measures) between states and operators. average_gate_fidelity(oper, target=None)[source]¶; Given a Qobj representing the supermatrix form of a map, returns the; average gate fidelity (pseudo-metric) of that map. Parameters. AQobjQuantum object representing a superoperator. targetQobjQuantum object representing the target unitary; the inverse; is applied before evaluating the fidelity. Returns. fidfloatFidelity pseudo-metric between A and the identity superoperator,; or between A and the target superunitary. bures_angle(A, B)[source]¶; Returns the Bures Angle between two density matrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:63765,Testability,test,testing,63765,"atrices A & B.; The Bures angle ranges from 0, for states with unit fidelity, to pi/2. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. anglefloatBures angle between density matrices. bures_dist(A, B)[source]¶; Returns the Bures distance between two density matrices A & B.; The Bures distance ranges from 0, for states with unit fidelity,; to sqrt(2). Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatBures distance between density matrices. fidelity(A, B)[source]¶; Calculates the fidelity (pseudo-metric) between two density matrices.; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. fidfloatFidelity pseudo-metric between A and B. Examples; >>> x = fock_dm(5,3); >>> y = coherent_dm(5,1); >>> np.testing.assert_almost_equal(fidelity(x,y), 0.24104350624628332). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples;",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:64821,Testability,test,testing,64821,"32). hilbert_dist(A, B)[source]¶; Returns the Hilbert-Schmidt distance between two density matrices A & B. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. Returns. distfloatHilbert-Schmidt distance between density matrices. Notes; See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998). process_fidelity(U1, U2, normalize=True)[source]¶; Calculate the process fidelity given two process operators. tracedist(A, B, sparse=False, tol=0)[source]¶; Calculates the trace distance between two density matrices..; See: Nielsen & Chuang, “Quantum Computation and Quantum Information”. Parameters. AqobjDensity matrix or state vector. BqobjDensity matrix or state vector with same dimensions as A. tolfloatTolerance used by sparse eigensolver, if used. (0=Machine precision). sparse{False, True}Use sparse eigensolver. Returns. tracedistfloatTrace distance between A and B. Examples; >>> x=fock_dm(5,3); >>> y=coherent_dm(5,1); >>> np.testing.assert_almost_equal(tracedist(x,y), 0.9705143161472971). Continuous Variables¶; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields. correlation_matrix(basis, rho=None)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the correlation; matrix:. \[C_{mn} = \langle a_m a_n \rangle\]. Parameters. basislistList of operators that defines the basis for the correlation matrix. rhoQobjDensity matrix for which to calculate the correlation matrix. If; rho is None, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns. corr_matndarrayA 2-dimensional array of correlation values or operators. correlation_matrix_field(a1, a2, rho=None)[source]¶; Calculates the correlation matrix for given field operators \(a_1\) and; \(a_2\). If a density matrix is given the expectation values are; calculated, otherwise a matrix with",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:67762,Testability,log,logarithmic,67762,"ue hbar=1. Returns. corr_matndarrayArray of complex numbers or Qobj’s; A 2-dimensional array of covariance values for the field quadratures,; or, if rho=0, a matrix of operators. covariance_matrix(basis, rho, symmetrized=True)[source]¶; Given a basis set of operators \(\{a\}_n\), calculate the covariance; matrix:. \[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle\]; or, if of the optional argument symmetrized=False,. \[V_{mn} = \langle a_m a_n\rangle -; \langle a_m \rangle \langle a_n\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two mode",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:68264,Testability,log,logarithmic,68264,"\rangle\]. Parameters. basislistList of operators that defines the basis for the covariance matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. symmetrizedbool {True, False}Flag indicating whether the symmetrized (default) or non-symmetrized; correlation matrix is to be calculated. Returns. corr_matndarrayA 2-dimensional array of covariance values. logarithmic_negativity(V, g=1.4142135623730951)[source]¶; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see qutip.continous_variables.covariance_matrix. Note that; the two-mode field state that is described by V must be Gaussian for this; function to applicable. Parameters. V2d arrayThe covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the value of hbar in the commutation; relation [x, y] = i * hbar via hbar=2/g ** 2 giving the default; value hbar=1. Returns. NfloatThe logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. wigner_covariance_matrix(a1=None, a2=None, R=None, rho=None, g=1.4142135623730951)[source]¶; Calculates the Wigner covariance matrix; \(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\), given; the quadrature correlation matrix; \(R_{ij} = \langle R_{i} R_{j}\rangle -; \langle R_{i}\rangle \langle R_{j}\rangle\), where; \(R = (q_1, p_1, q_2, p_2)^T\) is the vector with quadrature operators; for the two modes.; Alternatively, if R = None, and if annihilation operators a1 and a2; for the two modes are supplied instead, the quadrature correlation matrix; is constructed from the annihilation operators before then the covariance; matrix is calculated. Parameters. a1QobjField operator for mode 1. a2QobjField operator for mode 2. RndarrayThe quadrature correlation matrix. rhoQobjDensity matrix for which to calculate the covariance matrix. gfloatScaling factor for a = 0.5 * g * (x + iy), default g = sqrt(2).; The value of g is related to the ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108572,Testability,test,tested,108572,". sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:207173,Testability,log,logger,207173,"is the guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses; By default initial pulses are generated with amplitudes in the; range (-1.0, 1.0). These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added; to any initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse.; It’s intended use for a ramping modulation, which is often required in; experimental setups.; This is only currently implemented in CRAB.; GAUSSIAN_EDGE was added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object; The key value pairs are assumed to be attribute name value pairs; They applied after the object is created. log_levelintegerlevel of messaging output from the logger.; Options are attributes of qutip.logging_utils,; in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution,; assuming everything runs as expected.; The default NOTSET implies that the level will be taken from; the QuTiP settings file, which by default is WARN. gen_statsbooleanif set to True then statistics for the optimisation; run will be generated - accessible through attributes; of the stats object. Returns. optOptimizerInstance of an Optimizer, through which the; Config, Dynamics, PulseGen, and TerminationConditions objects; can be accessed as attributes.; The PropagatorComputer, FidelityComputer and TimeslotComputer objects; can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer; The optimisation can be run through the optimizer.run_optimization. opt_pulse_crab(drift, ctrls, initial, target, num_tslots=None, evo_",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:211951,Testability,test,tested,211951,"um allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by alg_params; (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performane of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.mininize could be used. method_paramsdictParameters for the optim_method. Note that where there is an attribute; of the Optimizer object or the termination_conditions matching; the key that attribute. Otherwise, and in some case also, they are; assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. dyn_typestringDynamics type, i.e. the type of matrix used to describe the dynamics.; Options are UNIT, GEN_MAT, SYMPL (see Dynamics classes for details). dyn_paramsdictParameters for the Dynamics object. The key value pairs are assumed to; be attribute name value pairs. They applied after the object is; created. prop_typestringPropagator type i.e. the method used to calculate the propagtors and; propagtor gradient for each timeslot options are DEF, A",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:215373,Testability,log,logger,215373,"tribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, default ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerlevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse. Amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:220408,Testability,test,tested,220408,"m allowed elapsed time for the optimisation algorithm. alg_paramsDictionaryOptions that are specific to the algorithm see above. optim_paramsDictionaryThe key value pairs are the attribute name and value used to set; attribute values. Note: attributes are created if they do not exist; already, and are overwritten if they do. Note: method_params are; applied afterwards and so may override these. coeff_scalingfloatLinear scale factor for the random basis coefficients. By default; these range from -1.0 to 1.0. Note this is overridden by; alg_params (if given there). num_coeffsintegerNumber of coefficients used for each basis function. Note this is; calculated automatically based on the dimension of the dynamics if not; given. It is crucial to the performance of the algorithm that it is set; as low as possible, while still giving high enough frequencies. Note; this is overridden by alg_params (if given there). optim_methodstringMulti-variable optimisation method. The only tested options are ‘fmin’; and ‘Nelder-mead’. In theory any non-gradient method implemented in; scipy.optimize.minimize could be used. method_paramsdictParameters for the optim_method. Note that where there is an; attribute of the Optimizer object or the termination_conditions; matching the key that attribute. Otherwise, and in some case also, they; are assumed to be method_options for the scipy.optimize.minimize; method. The commonly used parameter are:. xtol - limit on variable change for convergence; ftol - limit on fidelity error change for convergence. phase_optionstringDetermines how global phase is treated in fidelity calculations; (fid_type='UNIT' only). Options:. PSU - global phase ignored; SU - global phase included. dyn_paramsdictParameters for the Dynamics object. The key value pairs are; assumed to be attribute name value pairs. They applied after the; object is created. prop_paramsdictParameters for the PropagatorComputer object. The key value; pairs are assumed to be attribute name value ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:223345,Testability,log,logger,223345,"to be attribute name value pairs. They applied after the; object is created. guess_pulse_actionstring, ‘MODULATE’Determines how the guess pulse is applied to the pulse generated by the; basis expansion. Options are: MODULATE, ADD. pulse_scalingfloatLinear scale factor for generated guess pulses. By default initial; pulses are generated with amplitudes in the range (-1.0, 1.0). These; will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse(drift, ctrls, initi",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:231823,Testability,log,logger,231823,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object.; The key value pairs are assumed to be attribute name value pairs.; They applied after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils, in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL.; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output of; files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:239898,Testability,log,logger,239898,"he guess_pulse_type. init_pulse_paramsdictParameters for the initial / guess pulse generator object. The key; value pairs are assumed to be attribute name value pairs. They applied; after the object is created. pulse_scalingfloatLinear scale factor for generated initial / guess pulses. By default; initial pulses are generated with amplitudes in the range (-1.0, 1.0).; These will be scaled by this parameter. pulse_offsetfloatLinear offset for the pulse. That is this value will be added to any; initial / guess pulses generated. ramping_pulse_typestringType of pulse used to modulate the control pulse. It’s intended use; for a ramping modulation, which is often required in experimental; setups. This is only currently implemented in CRAB. GAUSSIAN_EDGE was; added for this purpose. ramping_pulse_paramsdictParameters for the ramping pulse generator object. The key value pairs; are assumed to be attribute name value pairs. They applied after the; object is created. log_levelintegerLevel of messaging output from the logger. Options are attributes of; qutip.logging_utils in decreasing levels of messaging, are:; DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL; Anything WARN or above is effectively ‘quiet’ execution, assuming; everything runs as expected. The default NOTSET implies that the level; will be taken from the QuTiP settings file, which by default is WARN. out_file_extstring or NoneFiles containing the initial and final control pulse amplitudes are; saved to the current directory. The default name will be postfixed; with this extension. Setting this to None will suppress the output; of files. gen_statsbooleanIf set to True then statistics for the optimisation run will be; generated - accessible through attributes of the stats object. Returns. optOptimResultReturns instance of OptimResult, which has attributes giving; the reason for termination, final fidelity error, final evolution final; amplitudes, statistics etc. Pulse generator - Generate pulses fo",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:119,Usability,Guid,Guide,119,". Functions — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Classes; Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Quantum Objects; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations; Operators and Superoperator Dimensions. Functions acting on states and operators; Expectation Values; Tensor; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continuous Variables. Measurement; Measurement of quantum states. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems; Scattering in Quantum Optical Systems; Permutational Invariance. Lattice; Lattice Properties; Topology. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms; Circuit. Non-Markovian Solvers; Optimal control; GRAPE; CRAB. Utility Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; Semidefinite Programming; IPython Notebook Tools; Miscellaneous. Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; API documentation »; Functions. Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(dimensions, n=None, offset=None)[source]¶; Generates the vector representation of a Fock state. Parameters. dimensionsint or list of intsNumber of Fock states in Hilbert space. If a list, then the resultant; object will be a tensor product over spaces with those dimensions. nint or list of ints, optional (default 0 for all dimensions)I",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:83879,Usability,progress bar,progress bar,83879,"_coeff(t,args):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters. Hqutip.Qobj, listSystem Hamiltonian. psi0qutip.QobjInitial state vector. tlistarray_likeTimes at which results are recorded. ntrajintNumber of trajectories to run. c_opsqutip.Qobj, listsingle collapse operator or a list of collapse operators. e_opsqutip.Qobj, listsingle operator as Qobj or list or equivalent of Qobj operators; for calculating expectation values. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: functionA map function for managing the calls to the single-trajactory solver. map_kwargs: dictionaryOptional keyword arguments to the map_func function. Returns. resultsqutip.solver.ResultObject storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)[source]¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or the; expectation values of the supplied operators (e_ops). Deprecated since version 4.6.0: essolev will be removed in QuTiP 5. Please use sesolve; or mesolve for general-purpose integration of the; Schroedinge",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:108399,Usability,simpl,simple,108399,", see StochasticSolverOptions help for format. psi0qutip.QobjState vector (ket). timeslist / arrayList of times for \(t\). Must be uniformly spaced. sc_opslist of qutip.Qobj, or time dependent Qobjs.List of stochastic collapse operators. Each stochastic collapse; operator will give a deterministic and stochastic contribution; to the eqaution of motion according to how the d1 and d2 functions; are defined.; Can depend on time, see StochasticSolverOptions help for format. e_opslist of qutip.Qobjsingle operator or list of operators for which to evaluate; expectation values. kwargsdictionaryOptional keyword arguments. See; qutip.stochastic.StochasticSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. stochastic_solvers()[source]¶; This function is purely a reference point for documenting the available; stochastic solver methods, and takes no actions.; Notes. Available solvers for ssesolve and smesolve; euler-maruyamaA simple generalization of the Euler method for ordinary; differential equations to stochastic differential equations. Only; solver which could take non-commuting sc_ops. not tested. Order 0.5; Code: 'euler-maruyama', 'euler' or 0.5. milsteinAn order 1.0 strong Taylor scheme. Better approximate numerical; solution to stochastic differential equations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:109748,Usability,usab,usable,109748,"uations. See eq. (2.9) of; chapter 12.2 of [1]. Order strong 1.0; Code: 'milstein' or 1.0. milstein-impAn order 1.0 implicit strong Taylor scheme. Implicit Milstein; scheme for the numerical simulation of stiff stochastic; differential equations. Order strong 1.0; Code: 'milstein-imp'. predictor-correctorGeneralization of the trapezoidal method to stochastic differential; equations. More stable than explicit methods. See eq. (5.4) of; chapter 15.5 of [1]. Order strong 0.5, weak 1.0; Codes to only correct the stochastic part (\(\alpha=0\),; \(\eta=1/2\)): 'pred-corr', 'predictor-corrector' or; 'pc-euler'; Codes to correct both the stochastic and deterministic parts; (\(\alpha=1/2\), \(\eta=1/2\)): 'pc-euler-imp',; 'pc-euler-2' or 'pred-corr-2'. platenExplicit scheme, creates the Milstein using finite differences; instead of analytic derivatives. Also contains some higher order; terms, thus converges better than Milstein while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. O",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:110671,Usability,usab,usable,110671,"in while staying strong; order 1.0. Does not require derivatives, therefore usable by; general_stochastic. See eq. (7.47) of chapter 7 of [2]. Order strong 1.0, weak 2.0; Code: 'platen', 'platen1' or 'explicit1'. rouchonScheme keeping the positivity of the density matrix; (smesolve only). See eq. (4) with \(\eta=1\) of [3]. Order strong 1.0?; Code: 'rouchon' or 'Rouchon'. taylor1.5Order 1.5 strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredic",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:111032,Usability,usab,usable,111032,"strong Taylor scheme. Solver with more terms of the; Ito-Taylor expansion. Default solver for smesolve and; ssesolve. See eq. (4.6) of chapter 10.4 of [1]. Order strong 1.5; Code: 'taylor1.5', 'taylor15', 1.5, or None. taylor1.5-impOrder 1.5 implicit strong Taylor scheme. Implicit Taylor 1.5; (\(\alpha = 1/2\), \(\beta\) doesn’t matter). See eq.; (2.18) of chapter 12.2 of [1]. Order strong 1.5; Code: 'taylor1.5-imp' or 'taylor15-imp'. explicit1.5Explicit order 1.5 strong schemes. Reproduce the order 1.5 strong; Taylor scheme using finite difference instead of derivatives.; Slower than taylor15 but usable by; general_stochastic. See eq. (2.13) of chapter 11.2 of; [1]. Order strong 1.5; Code: 'explicit1.5', 'explicit15' or 'platen15'. taylor2.0Order 2 strong Taylor scheme. Solver with more terms of the; Stratonovich expansion. See eq. (5.2) of chapter 10.5 of [1]. Order strong 2.0; Code: 'taylor2.0', 'taylor20' or 2.0. All solvers, except taylor2.0, are usable in both smesolve and ssesolve; and for both heterodyne and homodyne. taylor2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:112124,Usability,Feedback,Feedback,112124,"r2.0 only works for 1; stochastic operator independent of time with the homodyne method.; general_stochastic only accepts the derivative-free; solvers: 'euler', 'platen' and 'explicit1.5'. Available solvers for photocurrent_sesolve and photocurrent_mesolvePhotocurrent use ordinary differential equations between; stochastic “jump/collapse”. eulerEuler method for ordinary differential equations between jumps.; Only one jump per time interval. Default solver. See eqs. (4.19); and (4.4) of chapter 4 of [4]. Order 1.0; Code: 'euler'. predictor–correctorpredictor–corrector method (PECE) for ordinary differential; equations. Uses the Poisson distribution to obtain the number of; jumps at each timestep. Order 2.0; Code: 'pred-corr'. References. 1(1,2,3,4,5,6); Peter E. Kloeden and Exkhard Platen, Numerical Solution of; Stochastic Differential Equations. 2; H.-P. Breuer and F. Petruccione, The Theory of Open Quantum; Systems. 3; Pierre Rouchon and Jason F. Ralpha, Efficient Quantum Filtering for; Quantum Feedback Control, arXiv:1410.5345 [quant-ph], Phys. Rev. A 91, 012118,; (2015). 4; Howard M. Wiseman, Gerard J. Milburn, Quantum measurement and; control. Correlation Functions¶. coherence_function_g1(H, state0, taulist, c_ops, a_op, solver='me', args={}, options=<qutip.solver.Options object>)[source]¶; Calculate the normalized first-order quantum coherence function:. \[g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}\]; using the quantum regression theorem and the evolution solver indicated by; the solver parameter. Parameters. HQobjsystem Hamiltonian, may be time-dependent for solver choice of me or; mc. state0QobjInitial state density matrix \(\rho(t_0)\) or state vector; \(\psi(t_0)\). If ‘state0’ is ‘None’, then the steady state will; be used as the initial state. The ‘steady-state’ is only implemented; for the me and es solvers. taulistarray_likelist of times for \(\tau\). taulist",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:140902,Usability,progress bar,progress bar,140902,"\(\rho_{\mathrm vec}\) is the vector representation of the; density matrix. Parameters. Hqobj or listHamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in qutip.mesolve). tfloat or array-likeTime or list of times for which to evaluate the propagator. c_op_listlistList of qobj collapse operators. argslist/array/dictionaryParameters to callback functions for time-dependent Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWh",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:141408,Usability,clear,clears,141408,"t Hamiltonians and; collapse operators. optionsqutip.Optionswith options for the ODE solver. unitary_mode = str (‘batch’, ‘single’)Solve all basis vectors simulaneously (‘batch’) or individually; (‘single’). parallelbool {False, True}Run the propagator in parallel mode. This will override the; unitary_mode settings if set to True. progress_bar: BaseProgressBarOptional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns. aqobjInstance representing the propagator \(U(t)\). propagator_steadystate(U)[source]¶; Find the steady state for successive applications of the propagator; \(U\). Parameters. UqobjOperator representing the propagator. Returns. aqobjInstance representing the steady-state density matrix. Time-dependent problems¶. rhs_clear()[source]¶; Resets the string-format time-dependent Hamiltonian parameters. Returns. Nothing, just clears data from internal config module. rhs_generate(H, c_ops, args={}, options=<qutip.solver.Options object>, name=None, cleanup=True)[source]¶; Generates the Cython functions needed for solving the dynamics of a; given system using the mesolve function inside a parfor loop. Parameters. HqobjSystem Hamiltonian. c_opslistlist of collapse operators. argsdictArguments for time-dependent Hamiltonian and collapse operator terms. optionsOptionsInstance of ODE solver options. name: strName of generated RHS. cleanup: boolWhether the generated cython file should be automatically removed or; not. Notes; Using this function with any solver other than the mesolve function; will result in an error. Scattering in Quantum Optical Systems¶; Photon scattering in quantum optical systems; This module includes a collection of functions for numerically computing photon; scattering in driven arbitrary systems coupled to some configuration of output; waveguides. The implementation of these functions closely follows the",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:196774,Usability,learn,learningtimes,196774," for QASM file to be imported. In case of; string input, the parameter strmode must be True. modestrQASM mode to be read in. When mode is “qiskit”,; the “qelib1.inc” include is automatically included,; without checking externally. Otherwise, each include is; processed. versionstrQASM version of the QASM file. Only version 2.0 is currently supported. strmodeboolif specified as True, indicates that qasm_input is in string format; rather than from file. Returns. qcQubitCircuitReturns a QubitCircuit object specified in the QASM file. save_qasm(qc, file_loc)[source]¶; Save QASM output of circuit object to file. Parameters. qc: :class:`.QubitCircuit`circuit object to produce QASM output for. Non-Markovian Solvers¶; This module contains an implementation of the non-Markovian transfer tensor; method (TTM), introduced in [1].; [1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014). ttmsolve(dynmaps, rho0, times, e_ops=[], learningtimes=None, tensors=None, **kwargs)[source]¶; Solve time-evolution using the Transfer Tensor Method, based on a set of; precomputed dynamical maps. Parameters. dynmapslist of qutip.QobjList of precomputed dynamical maps (superoperators),; or a callback function that returns the; superoperator at a given time. rho0qutip.QobjInitial density matrix or state vector (ket). timesarray_likelist of times \(t_n\) at which to compute \(\rho(t_n)\).; Must be uniformily spaced. e_opslist of qutip.Qobj / callback functionsingle operator or list of operators for which to evaluate; expectation values. learningtimesarray_likelist of times \(t_k\) for which we have knowledge of the dynamical; maps \(E(t_k)\). tensorsarray_likeoptional list of precomputed tensors \(T_k\). kwargsdictionaryOptional keyword arguments. See; qutip.nonmarkov.ttm.TTMSolverOptions. Returns. output: qutip.solver.ResultAn instance of the class qutip.solver.Result. Optimal control¶; Wrapper functions that will manage the creation of the objects,; build the configuration, and exe",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:217111,Usability,simpl,simply,217111,"which has attributes giving the; reason for termination, final fidelity error, final evolution; final amplitudes, statistics etc. opt_pulse_crab_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-05, max_iter=500, max_wall_time=180, alg_params=None, num_coeffs=None, init_coeff_scaling=1.0, optim_params=None, optim_method='fmin', method_params=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, guess_pulse_type=None, guess_pulse_params=None, guess_pulse_scaling=1.0, guess_pulse_offset=0.0, guess_pulse_action='MODULATE', ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics. The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes.; The CRAB algorithm uses basis function coefficents as the variables to; optimise. It does NOT use any gradient function. A multivariable; optimisation algorithm attempts to determines the optimal values for the; control pulse to minimise the fidelity error. The fidelity error is some; measure of distance of the system evolution from the given target evolution; in the time allowed for the evolution. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter ",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:233586,Usability,simpl,simply,233586,"error, final evolution final; amplitudes, statistics etc. optimize_pulse_unitary(H_d, H_c, U_0, U_targ, num_tslots=None, evo_time=None, tau=None, amp_lbound=None, amp_ubound=None, fid_err_targ=1e-10, min_grad=1e-10, max_iter=500, max_wall_time=180, alg='GRAPE', alg_params=None, optim_params=None, optim_method='DEF', method_params=None, optim_alg=None, max_metric_corr=None, accuracy_factor=None, phase_option='PSU', dyn_params=None, prop_params=None, fid_params=None, tslot_type='DEF', tslot_params=None, amp_update_mode=None, init_pulse_type='DEF', init_pulse_params=None, pulse_scaling=1.0, pulse_offset=0.0, ramping_pulse_type=None, ramping_pulse_params=None, log_level=0, out_file_ext=None, gen_stats=False)[source]¶; Optimise a control pulse to minimise the fidelity error, assuming that the; dynamics of the system are generated by unitary operators. This function; is simply a wrapper for optimize_pulse, where the appropriate options for; unitary dynamics are chosen and the parameter names are in the format; familiar to unitary dynamics The dynamics of the system in any given; timeslot are governed by the combined Hamiltonian, i.e. the sum of the; H_d + ctrl_amp[j]*H_c[j] The control pulse is an [n_ts, n_ctrls]; array of piecewise amplitudes Starting from an initial (typically random); pulse, a multivariable optimisation algorithm attempts to determines the; optimal values for the control pulse to minimise the fidelity error The; maximum fidelity for a unitary system is 1, i.e. when the time evolution; resulting from the pulse is equivalent to the target. And therefore the; fidelity error is 1 - fidelity. Parameters. H_dQobj or list of QobjDrift (aka system) the underlying Hamiltonian of the system can provide; list (of length num_tslots) for time dependent drift. H_cList of Qobj or array like [num_tslots, evo_time]A list of control Hamiltonians. These are scaled by the amplitudes to; alter the overall dynamics. Array-like input can be provided for time; dependent contro",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:253553,Usability,progress bar,progress bar,253553,". Parameters. task: a Python functionThe function that is to be called for each value in task_vec. values: array / listThe list or array of values for which the task function is to be; evaluated. task_args: list / dictionaryThe optional additional argument to the task function. task_kwargs: list / dictionaryThe optional additional keyword argument to the task function. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar during the execution of the parfor; loop. Returns. resultlistThe result list contains the value of; task(value, task_args, task_kwargs) for each; value in values. parfor(task, task_vec, args=None, client=None, view=None, show_scheduling=False, show_progressbar=False)[source]¶; Call the function tast for each value in task_vec using a cluster; of IPython engines. The function task should have the signature; task(value, args) or task(value) if args=None.; The client and view are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.Cl",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/apidoc/functions.html:255155,Usability,progress bar,progress bar,255155," these; are None, new instances will be created. Parameters. task: a Python functionThe function that is to be called for each value in task_vec. task_vec: array / listThe list or array of values for which the task function is to be; evaluated. args: list / dictionaryThe optional additional argument to the task function. For example; a dictionary with parameter values. client: IPython.parallel.ClientThe IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client viewThe view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default FalseDisplay a graph showing how the tasks (the evaluation of task for; for the value in task_vec1) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default FalseDisplay a HTML-based progress bar duing the execution of the parfor; loop. Returns. resultlistThe result list contains the value of task(value, args) for each; value in task_vec, that is, it should be equivalent to; [task(v, args) for v in task_vec]. version_table(verbose=False)[source]¶; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns. version_table: stringReturn an HTML-formatted string containing version information for; QuTiP dependencies. Miscellaneous¶. about()[source]¶; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib. simdiag(ops, evals: bool = True, *, tol: float = 1e-14, safe_mode: bool = True)[source]¶; Simultaneous diagonalization of commuting Hermitian matrices. Parameters. opslist/arraylist or array o",MatchSource.WIKI,docs/4.6/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/apidoc/functions.html
https://qutip.org/docs/4.6/development/contributing.html:6136,Availability,reliab,reliably,6136,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6674,Availability,avail,available,6674,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8639,Availability,failure,failures,8639,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on oc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8692,Availability,error,error,8692,"cstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on oc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9602,Availability,down,down,9602,"for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10602,Availability,avail,available,10602,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10830,Availability,avail,available,10830,"that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been ch",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11941,Availability,failure,failure,11941,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12829,Availability,error,errors,12829," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:123,Deployability,Install,Installation,123,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:524,Deployability,Release,Release,524,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3016,Deployability,update,update,3016," result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are i",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3359,Deployability,install,installing,3359,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3507,Deployability,install,installation,3507," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3525,Deployability,release,release,3525," is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer,",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3719,Deployability,install,installation,3719," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3786,Deployability,install,installation,3786," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4251,Deployability,install,installed,4251,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4298,Deployability,install,install,4298,"ding the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4452,Deployability,install,installed,4452,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4473,Deployability,install,install,4473,"hon environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup com",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4527,Deployability,install,install,4527,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4968,Deployability,install,installation,4968,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4996,Deployability,install,installation,4996,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6071,Deployability,install,install,6071," python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6284,Deployability,update,updated,6284," is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are fun",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7471,Deployability,release,release,7471," is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7776,Deployability,update,update,7776,"e this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use som",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8524,Deployability,install,installed,8524,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the doc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10015,Deployability,install,install,10015,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10173,Deployability,configurat,configuration,10173,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10234,Deployability,install,install,10234,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10279,Deployability,configurat,configuration,10279,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10429,Deployability,install,install,10429,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10542,Deployability,update,update,10542,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10944,Deployability,release,release,10944,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10997,Deployability,install,install,10997,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11241,Deployability,install,installed,11241,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11612,Deployability,install,installation,11612,"te their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11797,Deployability,update,update,11797,"n.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests f",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11985,Deployability,install,installed,11985,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:13358,Deployability,update,updated,13358," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4543,Integrability,depend,dependencies,4543,"n of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sourc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5592,Integrability,rout,routines,5592,"ary development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8446,Integrability,depend,depending,8446,"r release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the doc",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9417,Integrability,depend,dependencies,9417," take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend y",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9785,Integrability,depend,dependencies,9785,"features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.;",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10035,Integrability,depend,dependencies,10035,"test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modif",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10437,Integrability,depend,dependencies,10437,"e the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11949,Integrability,message,messages,11949,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12015,Integrability,depend,dependencies,12015,"ning pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you hav",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7212,Modifiability,variab,variable,7212,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10173,Modifiability,config,configuration,10173,"p repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10279,Modifiability,config,configuration,10279,"pydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you shoul",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5133,Performance,load,load,5133,"version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temp",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5862,Safety,detect,detect,5862,"r you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6117,Safety,detect,detection,6117,"f you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try t",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11099,Security,access,accessible,11099,"requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will b",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:185,Testability,Log,Log,185,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:339,Testability,Test,Testing,339,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:414,Testability,Test,Testing,414,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:1049,Testability,test,testing,1049," Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2041,Testability,test,tests,2041,"vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of thi",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2658,Testability,test,tests,2658,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2753,Testability,test,tests,2753,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2788,Testability,test,tests,2788,"h to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation fr",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3833,Testability,test,tests,3833,"es are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to bu",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3953,Testability,test,testing,3953,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3985,Testability,test,tests,3985,"them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows inst",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:4122,Testability,test,test,4122,"ndards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. f",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:6695,Testability,test,test,6695,"until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this command will be faster on subsequent runs. Note; When undertaking Cython development, the reason we use python setup.py develop instead of pip install -e . is because Cython’s changed-file detection does not reliably work in the latter.; pip tends to build in temporary virtual environments, which often makes Cython think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make c",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8292,Testability,Test,Testing,8292,"o not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several add",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8323,Testability,test,test,8323,"o not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several add",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8363,Testability,test,test,8363,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rt",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8399,Testability,test,tests,8399,"s to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rt",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8558,Testability,test,tests,8558,"ry to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8833,Testability,test,tests,8833,"other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:8953,Testability,test,tests,8953,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; co",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9027,Testability,test,tests,9027,"nd classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; co",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9068,Testability,test,tests,9068,"me it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the API documentation section of the documentation. Testing¶; We use pytest as our test runner.; The base way to run every test is; pytest /path/to/repo/qutip/tests. This will take around 10 to 30 minutes, depending on your computer and how many of the optional requirements you have installed.; It is normal for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10723,Testability,test,test,10723,"o keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you w",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12726,Testability,Test,Testing,12726," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12773,Testability,test,tests,12773," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12951,Testability,test,test,12951," build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:143,Usability,Guid,Guide,143,". Contributing to QuTiP Development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Contributing to QuTiP Development. Contributing to QuTiP Development¶. Quick Start¶; QuTiP is developed through wide collaboration using the git version-control system, with the main repositories hosted in the qutip organisation on GitHub.; You will need to be familiar with git as a tool, and the GitHub Flow workflow for branching and making pull requests.; The exact details of environment set-up, build process and testing vary by repository and are discussed below, however in overview, the steps to contribute are:. Consider creating an issue on the GitHub page of the relevant repository, describing the change you think should be made and why, so we can discuss details with you and make sure it is appropriate.; (If this is your first contribution.) Make a fork of the relevant repository on GitHub and clone it to your local computer. Also add our copy as a remote (git remote add qutip https://github.com/qutip/<repo>); Begin on the master branch (git checkout master), and pull in changes from the main QuTiP repository to make sure you have an up-to-date copy (git pull qutip master).; Switch to a new git branch (git checkout -b <branch-name>).; Make the changes you want to make, then create some commits with short, descriptive names (git add <files> then git commit).; Follow the build process for this repository to build the final result so you can che",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:2873,Usability,feedback,feedback,2873,"add <files> then git commit).; Follow the build process for this repository to build the final result so you can check your changes work sensibly.; Run the tests for the repository (if it has them).; Push the changes to your fork (git push -u origin <branch-name>). You won’t be able to push to the main QuTiP repositories directly.; Go to the GitHub website for the repository you are contributing to, click on the “Pull Requests” tab, click the “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The b",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3352,Usability,simpl,simply,3352,"e “New Pull Request” button, and follow the instructions there. Once the pull request is created, some members of the QuTiP admin team will review the code to make sure it is suitable for inclusion in the library, to check the programming, and to ensure everything meets our standards.; For some repositories, several automated tests will run whenever you create or modify a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:3664,Usability,guid,guide,3664," a pull request; in general these will be the same tests you can run locally, and all tests are required to pass online before your changes are merged.; There may be some feedback and possibly some requested changes.; You can add more commits to address these, and push them to the relevant branch of your fork to update the pull request.; The rest of this document covers programming standards, and particular considerations for some of the more complicated repositories. Core Library: qutip/qutip¶; The core library is in the qutip/qutip repository on GitHub. Building¶; Building the core library from source is typically a bit more difficult than simply installing the package for regular use.; You will most likely want to do this in a clean Python environment so that you do not compromise a working installation of a release version, for example by starting from; conda create -n qutip-dev python. Complete instructions for the build are elsewhere in this guide, however beware that you will need to follow the installation from source using setuptools section, not the general installation.; You will need all the build and tests “optional” requirements for the package.; The build requirements can be found in the pyproject.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementati",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:5009,Usability,guid,guide,5009,"t.toml file, and the testing requirements are in the tests key of the options.extras_require section of setup.cfg.; You will also need the requirements for any optional features you want to test as well.; Refer to the main instructions for the most up-to-date version, however as of version 4.6 the requirements can be installed into a conda environment with; conda install setuptools wheel 'numpy>=1.16.6,<1.20' 'scipy>=1.0' 'cython>=0.29.20' packaging 'pytest>=5.2' pytest-rerunfailures. Note that qutip should not be installed with conda install. Note; If you prefer, you can also use pip to install all the dependencies.; We typically recommend conda when doing main-library development because it is easier to switch low-level packages around like BLAS implementations, but if this doesn’t mean anything to you, feel free to use pip. You will need to make sure you have a functioning C++ compiler to build QuTiP.; If you are on Linux or Mac, this is likely already done for you, however if you are on Windows, refer to the Windows installation section of the installation guide.; The command to build QuTiP in editable mode is; python setup.py develop. from the repository directory.; If you now load up a Python interpreter, you should be able to import qutip from anywhere as long as the correct Python environment is active.; Any changes you make to the Python files in the git repository should be immediately present if you restart your Python interpreter and re-import qutip.; On the first run, the setup command will compile many C++ extension modules built from Cython sources (files ending .pxd and .pyx).; Generally the low-level linear algebra routines that QuTiP uses are written in these files, not in pure Python.; Unlike Python files, changes you make to Cython files will not appear until you run python setup.py develop again; you will only need to re-run this if you are changing Cython files.; Cython will detect and compile only the files that have been changed, so this comm",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:7299,Usability,guid,guidelines,7299,"think its core library files have been updated, triggering a complete, slow rebuild of everything. Code Style¶; The biggest concern you should always have is to make it easy for your code to be read and understood by the person who comes next.; All new contributions must follow PEP 8 style; all pull requests will be passed through a linter that will complain if you violate it.; You should use the pycodestyle package locally (available on pip) to test you satisfy the requirements before you push your commits, since this is rather faster than pushing 10 different commits trying to fix minor niggles.; Keep in mind that there is quite a lot of freedom in this style, especially when it comes to line breaks.; If a line is too long, consider the best way to split it up with the aim of making the code readable, not just the first thing that doesn’t generate a warning.; Try to stay consistent with the style of the surrounding code.; This includes using the same variable names, especially if they are function arguments, even if these “break” PEP 8 guidelines.; Do not change existing parameter, attribute or method names to “match” PEP 8; these are breaking user-facing changes, and cannot be made except in a new major release of QuTiP.; Other than this, general “good-practice” Python standards apply: try not to duplicate code; try to keep functions short, descriptively-named and side-effect free; provide a docstring for every new function; and so on. Documenting¶; When you make changes in the core library, you should update the relevant documentation if needed.; If you are making a bug fix, or other relatively minor changes, you will probably only need to make sure that the docstrings of the modified functions and classes are up-to-date; changes here will propagate through to the documentation the next time it is built.; Be sure to follow the Numpy documentation standards (numpydoc) when writing docstrings.; All docstrings will be parsed as reStructuredText, and will form the AP",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:9539,Usability,simpl,simply,9539,"for some tests to be marked as “skip” or “xfail” in yellow; these are not problems.; True failures will appear in red and be called “fail” or “error”.; While prototyping and making changes, you might want to use some of the filtering features of pytest.; Instead of passing the whole tests directory to the pytest command, you can also pass a list of files.; You can also use the -k selector to only run tests whose names include a particular pattern, for example; pytest qutip/tests/test_qobj.py -k ""expm"". to run the tests of Qobj.expm. Documentation: qutip/qutip (doc directory)¶; The core library is in the qutip/qutip repository on GitHub, inside the doc directory. Building¶; The documentation is built using sphinx, matplotlib and numpydoc, with several additional extensions including sphinx-gallery and sphinx-rtd-theme.; The most up-to-date instructions and dependencies will be in the README.md file of the documentation directory.; You can see the rendered version of this file simply by going to the documentation GitHub page and scrolling down.; Building the documentation can be a little finnicky on occasion.; You likely will want to keep a separate Python environment to build the documentation in, because some of the dependencies can have tight requirements that may conflict with your favourite tools for Python development.; We recommend creating an empty conda environment containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:10923,Usability,guid,guide,10923,"nt containing only Python with; conda create -n qutip-doc python=3.8. and install all further dependencies with pip.; There is a requirements.txt file in the repository root that fixes all package versions exactly into a known-good configuration for a completely empty environment, using; pip install -r requirements.txt. This known-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get ",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:11304,Usability,simpl,simply,11304,"wn-good configuration was intended for Python 3.8, though in principle it is possible that other Python versions will work. Note; We recommend you use pip to install dependencies for the documentation rather than conda because several necessary packages can be slower to update their conda recipes, so suitable versions may not be available. The documentation build includes running many components of the main QuTiP library to generate figures and to test the output, and to generate all the API documentation.; You therefore need to have a version of QuTiP available in the same Python environment.; If you are only interested in updating the users’ guide, you can use a release version of QuTiP, for example by running pip install qutip.; If you are also modifying the main library, you need to make your development version accessible in this environment.; See the above section on building QuTiP for more details, though the requirements.txt file will have already installed all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12219,Usability,guid,guide,12219,"stalled all the build requirements, so you should be able to simply run; python setup.py develop. in the main library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/contributing.html:12324,Usability,guid,guide,12324,"in library repository.; The documentation is built by running the make command.; There are several targets to build, but the most useful will be html to build the webpage documentation, latexpdf to build the PDF documentation (you will also need a full pdflatex installation), and clean to remove all built files.; The most important command you will want to run is; make html. You should re-run this any time you make changes, and it should only update files that have been changed. Important; The documentation build includes running almost all the optional features of QuTiP.; If you get failure messages in red, make sure you have installed all of the optional dependencies for the main library. The HTML files will be placed in the _build/html directory.; You can open the file _build/html/index.html in your web browser to check the output. Code Style¶; All user guide pages and docstrings are parsed by Sphinx using reStructuredText.; There is a general Sphinx usage guide, which has a lot of information that can sometimes be a little tricky to follow.; It may be easier just to look at other .rst files already in the documentation to copy the different styles. Note; reStructuredText is a very different language to the Markdown that you might be familiar with.; It’s always worth checking your work in a web browser to make sure it’s appeared the way you intended. Testing¶; There are unfortunately no automated tests for the documentation.; You should ensure that no errors appeared in red when you ran make html.; Try not to introduce any new warnings during the build process.; The main test is to open the HTML pages you have built (open _build/html/index.html in your web browser), and click through to the relevant pages to make sure everything has rendered the way you expected it to. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.;",MatchSource.WIKI,docs/4.6/development/contributing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/contributing.html
https://qutip.org/docs/4.6/development/development.html:1573,Availability,Error,Error,1573,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2062,Availability,Down,Download,2062,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:115,Deployability,Install,Installation,115,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:357,Deployability,Release,Release,357,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:589,Deployability,release,releases,589,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1064,Deployability,integrat,integration,1064,". ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monito",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1247,Deployability,release,release,1247,"t; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D.",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1836,Deployability,Release,Release,1836,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1910,Deployability,release,release,1910,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1938,Deployability,release,release,1938,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1975,Deployability,release,release,1975,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2011,Deployability,release,release,2011,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2036,Deployability,deploy,deploy,2036,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2054,Deployability,deploy,deploy,2054,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2125,Deployability,release,release,2125,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2182,Deployability,update,updates,2182,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2409,Deployability,update,updated,2409,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:2084,Energy Efficiency,Monitor,Monitoring,2084,"he development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:1064,Integrability,integrat,integration,1064,". ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monito",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:177,Testability,Log,Log,177,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:743,Testability,Test,Testing,743,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:818,Testability,Test,Testing,818,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/development.html:135,Usability,Guid,Guide,135,". Development Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation. Development Documentation¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Building; Code Style; Documenting; Testing. Documentation: qutip/qutip (doc directory); Building; Code Style; Testing. QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. TensorFlow Data Backend; Why a TensorFlow backend?; Challenges. Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation bui",MatchSource.WIKI,docs/4.6/development/development.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/development.html
https://qutip.org/docs/4.6/development/docs.html:127,Deployability,Install,Installation,127,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:396,Deployability,Release,Release,396,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:5848,Deployability,update,updated,5848,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1066,Modifiability,config,configured,1066,"ion. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:189,Testability,Log,Log,189,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1457,Testability,test,tests,1457,"lbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, te",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2082,Testability,test,test,2082," in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the sa",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2120,Testability,test,testcode,2120,"can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2180,Testability,test,testcode,2180," the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2275,Testability,test,testoutput,2275,"ease refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To c",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2299,Testability,test,testoutput,2299,"individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2337,Testability,test,testcode,2337," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2452,Testability,test,tests,2452,"est way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doc",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2616,Testability,test,testcode,2616,"he documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directiv",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2778,Testability,test,testcode,2778,"y the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests a",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:3247,Testability,test,tested,3247,"). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:3790,Testability,test,tests,3790,"efault, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities between the expected and actual output are ignored.; For that, we can use the option +NORMALIZE_WHITESPACE. Plot¶; Since the doctest directive cannot render matplotlib figures, we use Matplotlib’s; Plot; directive when rendering to LaTeX or HTML.; The plot directive can also be used in the doctest format. In this case,; when running doctests (which is enabled by specifying all statements with the; >>> prompts), tests also include those specified under the plot directive.; Example:; First we specify some data:. .. plot::. >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code i",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:5485,Testability,test,testing,5485,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:147,Usability,Guid,Guide,147,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:588,Usability,guid,guide,588,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:646,Usability,guid,guide,646,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:806,Usability,learn,learn,806,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:882,Usability,guid,guide,882,"﻿. Working with the QuTiP Documentation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need t",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1195,Usability,guid,guide,1195,"ide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1352,Usability,guid,guidelines,1352,"Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1410,Usability,guid,guide,1410,"Directives; Doctest; Plot. Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Working with the QuTiP Documentation. Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:1498,Usability,simpl,simplest,1498,". Working with the QuTiP Documentation¶; The user guide provides an overview of QuTiP’s functionality.; The guide is composed of individual reStructuredText (.rst) files which each get rendered as a webpage.; Each page typically tackles one area of functionality.; To learn more about how to write .rst files, it is useful to follow the sphinx guide.; The documentation build also utilizes a number of; Sphinx Extensions; including but not limited to; doctest,; autodoc,; sphinx gallery and; plot.; Additional extensions can be configured in the conf.py file. Directives¶; There are two Sphinx directives that can be used to write code examples in the user guide:. Doctest; Plot. For a more comprehensive account of the usage of each directive, please refer to their individual pages. Here we outline some general guidelines on how to these directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; spec",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:2376,Usability,simpl,simpler,2376," directives while making a user guide. Doctest¶; The doctest directive enables tests on interactive code examples.; The simplest way to do this is by specifying a prompt along with its respective output:; .. doctest::. >>> a = 2; >>> a; 2. This is rendered in the documentation as follows:; >>> a = 2; >>> a; 2. While specifying code examples under the .. doctest:: directive, either all statements must be specified by the >>> prompt or without it.; For every prompt, any potential corresponding output must be specified immediately after it.; This directive is ideally used when there are a number of examples that need to be checked in quick succession.; A different way to specify code examples (and test them) is using the associated .. testcode:: directive which is effectively a code block:; .. testcode::. a = 2; print(a). followed by its results.; The result can be specified with the .. testoutput:: block:; .. testoutput::. 2. The advantage of the testcode directive is that it is a lot simpler to; specify and amenable to copying the code to clipboard. Usually, tests are; more easily specified with this directive as the input and output are; specified in different blocks. The rendering is neater too. Note; The doctest and testcode directives should not be assumed to; have the same namespace. Output:; a = 2; print(a). 2. A few notes on using the doctest extension:. By default, each testcode and doctest block is run in a fresh namespace.; To share a common namespace, we can specify a common group across the blocks; (within a single .rst file). For example,; .. doctest:: [group_name]. >>> a = 2. can be followed by some explanation followed by another code block; sharing the same namespace; .. doctest:: [group_name]. >>> print(a); 2. To only print the code blocks (or the output), use the option +SKIP to; specify the block without the code being tested when running make doctest.; To check the result of a Qobj output, it is useful to make sure that; spacing irregularities betw",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/docs.html:5560,Usability,learn,learn,5560,"2 * np.pi, 1000); >>> x[:10] # doctest: +NORMALIZE_WHITESPACE; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]). .. plot::; :context:. >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. Note the use of the NORMALIZE_WHITESPACE option to ensure that the; multiline output matches.; Render:; >>> import numpy as np; >>> x = np.linspace(0, 2 * np.pi, 1000); >>> x[:10] ; array([ 0. , 0.00628947, 0.01257895, 0.01886842, 0.0251579 ,; 0.03144737, 0.03773685, 0.04402632, 0.0503158 , 0.05660527]); >>> import matplotlib.pyplot as plt; >>> plt.plot(x, np.sin(x)); [...]. (png, hires.png, pdf). A few notes on using the plot directive:. A useful argument to specify in plot blocks is that of context which ensures; that the code is being run in the namespace of the previous plot block within the; same file.; By default, each rendered figure in one plot block (when using :context:); is carried over to the next block.; When the context argument is specified with the reset option; as :context: reset, the namespace is reset to a new one and all figures are; erased.; When the context argument is specified with the close-figs option; as :context: reset, the namespace is reset to a new one and all figures are; erased. The Plot directive cannot be used in conjunction with Doctest because they do not; share the same namespace when used in the same file.; Since Plot can also be used in doctest mode, in; the case where code examples require both testing and rendering figures, it is; easier to use the Plot directive. To learn more about each directive, it is useful; to refer to their individual pages. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/docs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/docs.html
https://qutip.org/docs/4.6/development/ideas.html:425,Availability,Error,Error,425,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:961,Availability,Error,Error,961,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:124,Deployability,Install,Installation,124,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:541,Deployability,Release,Release,541,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:820,Deployability,release,releases,820,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:1244,Deployability,update,updated,1244,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:186,Testability,Log,Log,186,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/ideas.html:144,Usability,Guid,Guide,144,". Ideas for future QuTiP development — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development. Ideas for future QuTiP development¶; This chapter covers the development of QuTiP and its subpackages, including; a roadmap for upcoming releases and ideas for future improvements. QuTiP Interactive; Pulse level description of quantum circuits; TensorFlow Data Backend; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/ideas.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/ideas.html
https://qutip.org/docs/4.6/development/release_distribution.html:583,Availability,Down,Download,583,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6269,Availability,down,download,6269,"d.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version numb",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6681,Availability,down,down,6681,"c directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7725,Availability,avail,available,7725," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7830,Availability,Down,Download,7830,"elease to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirm",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8145,Availability,down,download,8145,"evious deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8829,Availability,down,down,8829,"t files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, o",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9653,Availability,down,down,9653," might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10074,Availability,down,down,10074,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11240,Availability,down,downloads,11240,"e may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases sec",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11931,Availability,down,download,11931," Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-fee",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3,Deployability,Release,Release,3,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:115,Deployability,Install,Installation,115,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:357,Deployability,Release,Release,357,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:431,Deployability,release,release,431,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:459,Deployability,release,release,459,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:496,Deployability,release,release,496,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:532,Deployability,release,release,532,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:557,Deployability,deploy,deploy,557,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:575,Deployability,deploy,deploy,575,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:646,Deployability,release,release,646,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:703,Deployability,update,updates,703,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:805,Deployability,Release,Release,805,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:831,Deployability,Release,Release,831,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:915,Deployability,update,updates,915,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:944,Deployability,release,release,944,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:967,Deployability,release,releases,967,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1162,Deployability,release,release,1162,"cumentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1251,Deployability,release,release,1251," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1297,Deployability,release,release,1297," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1336,Deployability,release,release,1336," Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this bra",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1380,Deployability,release,release,1380,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1423,Deployability,release,release,1423,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1479,Deployability,patch,patch,1479,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1498,Deployability,release,release,1498,"ase; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstrea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1595,Deployability,deploy,deploy,1595,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1663,Deployability,deploy,deploy,1663,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1699,Deployability,release,release,1699,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1751,Deployability,update,update,1751,"Hub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, ch",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1817,Deployability,update,update,1817,"tribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pu",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1845,Deployability,deploy,deploying,1845,"tribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pu",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:1916,Deployability,release,release,1916,"; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the lat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2054,Deployability,release,release,2054,"; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the lat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2508,Deployability,patch,patch,2508," both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number i",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2606,Deployability,release,release,2606,"tion; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end i",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2981,Deployability,release,release,2981,"mmit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3057,Deployability,release,release,3057,"test release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3169,Deployability,release,release,3169,"similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new versio",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3359,Deployability,release,release,3359,"p-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3627,Deployability,release,release,3627,"arlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, startin",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3780,Deployability,release,release,3780,"8a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4256,Deployability,release,release,4256,"tifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly rele",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4307,Deployability,release,release,4307,"tifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly rele",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4408,Deployability,release,release,4408,".; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4457,Deployability,release,release,4457,"The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4514,Deployability,release,release-candidate,4514," with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4532,Deployability,release,releases,4532," with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4628,Deployability,release,release,4628,"r or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should al",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:4690,Deployability,release,release,4690,"y using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_ready qutip-4.1.X. First change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qut",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5155,Deployability,release,release,5155," change the VERSION file to contain the new version number, and remove any dev postfix if present.; A major release increments the first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This ste",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5288,Deployability,release,released,5288,"e first number, while a minor release increments the second.; All numbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5365,Deployability,release,release,5365,"umbers after the change digit are reset to 0, so the next minor release after 4.5.3 is 4.6.0, and the next major release after either of these is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP webs",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5517,Deployability,release,release,5517,"ese is 5.0.0.; Alpha, beta and release-candidate releases have a postfix .a<n>, .b<n> or .rc<n> repsectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Cli",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5564,Deployability,update,updates,5564,"psectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Ru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5591,Deployability,release,release,5591,"psectively, where <n> is a counter for the pre-release status, starting from 0.; For example, the third beta release of version 5.2.1 would have a version of 5.2.1.b2.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Ru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5810,Deployability,Update,Update,5810,"o extra characters (the automatic line-break at the end is fine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made ea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5869,Deployability,Update,Update,5869,"ine).; Next edit setup.cfg.; Change the “Development Status” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to P",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:5932,Deployability,Update,Update,5932,"” line in the classifiers section to; Development Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Conf",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6003,Deployability,release,release,6003,"elopment Status :: 5 - Production/Stable. Commit both changes, and then push them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6107,Deployability,release,release,6107," The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6132,Deployability,deploy,deploy,6132," The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6359,Deployability,deploy,deploy,6359," trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make a",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6519,Deployability,deploy,deploy,6519,"se.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6731,Deployability,release,release,6731,"c directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the n",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6869,Deployability,release,release,6869,"c/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, cl",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7019,Deployability,deploy,deployment,7019,"n, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the bel",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7171,Deployability,deploy,deployment,7171,"binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the sou",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7399,Deployability,upgrade,upgrades,7399,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7421,Deployability,release,releases,7421,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7457,Deployability,release,release,7457,"y.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7573,Deployability,deploy,deployment,7573,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7604,Deployability,deploy,deployment,7604,"ader notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, li",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7739,Deployability,install,install,7739," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7754,Deployability,install,install,7754," branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deploymen",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8695,Deployability,deploy,deployment,8695,"n will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the versio",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8958,Deployability,deploy,deployment,8958,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summa",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9030,Deployability,deploy,deployment,9030,"success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summa",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9181,Deployability,deploy,deployed,9181,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9319,Deployability,deploy,deploy,9319,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this descrip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9330,Deployability,release,release,9330,"*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this descrip",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9429,Deployability,release,release,9429,"you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.;",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9479,Deployability,Release,Releases,9479,"you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.;",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9561,Deployability,release,release,9561,"n workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you h",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9614,Deployability,release,release,9614,"subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip f",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10016,Deployability,release,release,10016,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10056,Deployability,release,release,10056,"tion” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10215,Deployability,release,release,10215,"eployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10629,Deployability,release,release,10629,"ip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into t",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10809,Deployability,update,updated,10809,"ion 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:10833,Deployability,release,release,10833,"ion 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11057,Deployability,release,release,11057,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11139,Deployability,release,releases,11139,"log you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Sourc",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11380,Deployability,release,release,11380,"nd qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11539,Deployability,release,release,11539,"those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and z",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11916,Deployability,update,updates,11916,"site repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11958,Deployability,release,release,11958,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/q",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11994,Deployability,update,updated,11994,"les into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/q",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12054,Deployability,release,release,12054," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12070,Deployability,update,updated,12070," and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generat",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12227,Deployability,Release,Releases,12227,"s) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12364,Deployability,release,release,12364,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12396,Deployability,release,release,12396,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12476,Deployability,release,releases,12476,"ation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to yo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12536,Deployability,release,release,12536,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12563,Deployability,update,updated,12563,"which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12621,Deployability,release,release,12621,"l into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12752,Deployability,update,updated,12752,"removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-fo",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12799,Deployability,release,release,12799,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prer",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:12854,Deployability,release,releases,12854,"hub.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need to have their micro release numbers updated in their filenames, labels and trackEvent javascript.; These links should point to the “Source code” links that appeared when you made in the GitHub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prer",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13221,Deployability,Update,Update,13221,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:14123,Deployability,update,updated,14123,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:605,Energy Efficiency,Monitor,Monitoring,605,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7950,Energy Efficiency,monitor,monitor,7950,"; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instru",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8413,Energy Efficiency,Monitor,Monitoring,8413," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” secti",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:8486,Energy Efficiency,monitor,monitor,8486," to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” secti",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6792,Integrability,depend,depending,6792,"nf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version ap",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:9144,Integrability,message,message,9144,"n.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below the “Run workflow” button.; You should see several subjobs, like the completed screen, except they might not yet be completed.; The “Verify PyPI deployment confirmation” should get ticked, no matter what.; If it fails, you have forgotten to choose the correct branch in the drop-down menu or you made a typo when confirming the correct branch, and you will need to restart this step.; You can check that the deployment instruction has been understood by clicking the “Verify PyPI deployment confirmation” job, and opening the “Compare confirmation to current reference” subjob.; You will see a message saying “Built wheels will be deployed” if you typed in the confirmation, or “Only building wheels” if you did not.; If you see “Only building wheels” but you meant to deploy the release to PyPI, you can cancel the workflow and re-run it after typing the confirmation. Making a release on GitHub¶; This is all done through the “Releases” section of the qutip/qutip repository on GitHub. Click the “Draft a new release” button.; Choose the correct branch for your release (e.g. qutip-4.5.X) in the drop-down.; For the tag name, use v<your-version>, where the version matches the contents of the VERSION file.; In other words, if you are releasing a micro version 4.5.3, use v4.5.3 as the tag, or if you are releasing major version 5.0.0, use v5.0.0.; The title is “QuTiP <your-version”, e.g. “QuTiP 4.6.0”.; For the description, write a short (~two-line for a micro release) summary of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13761,Modifiability,config,config,13761,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7551,Performance,perform,perform,7551,"left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just been uploaded to PyPI. Monitoring progress (optional)¶; While the build is in progress, you can monitor its progress by clicking on its entry in the list below ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2136,Security,hash,hash,2136,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2633,Security,hash,hash,2633," deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on th",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:11017,Security,access,access,11017,"of the reason for this release, and note down any particular user-facing changes that need special attention.; Underneath, put the changelog you wrote when you did the documentation release.; Note that there may be some syntax differences between the .rst file of the changelog and the Markdown of this description field.; Drag-and-drop all the qutip-*.whl, qutip-*.tar.gz and qutip-*.zip files you got after the build step into the assets box.; You may need to unzip the files wheels.zip and sdist.zip to find them if you haven’t already; don’t upload those two zip files. Click on the “Publish release” button to finalise. Website¶; This assumes that qutip.github.io has already been forked and familiarity with the website updating workflow.; The documentation need not be updated for every micro release. Copying new files¶; You only need to copy in new documentation to the website repository.; Do not copy the .whl, .tar.gz or .zip files into the git repository, because we can access the public links from the GitHub release stage, and this keeps the website .git folder a reasonable size.; For all releases move (no new docs) or copy (for new docs) the qutip-doc-<MAJOR>.<MINOR>.pdf into the folder downloads/<MAJOR>.<MINOR>.<MICRO>.; The legacy html documentation should be in a subfolder like; docs/<MAJOR>.<MINOR>. For a major or minor release the previous version documentation should be moved into this folder.; The latest version HTML documentation should be the folder; docs/latest. For any release which new documentation is included; - copy the contents qutip/doc/_build/html into this folder. Note that the underscores at start of the subfolder names will need to be removed, otherwise Jekyll will ignore the folders. There is a script in the docs folder for this.; https://github.com/qutip/qutip.github.io/blob/master/docs/remove_leading_underscores.py. HTML file updates¶. Edit download.html. The ‘Latest release’ version and date should be updated.; The tar.gz and zip links need ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:177,Testability,Log,Log,177,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:2097,Testability,log,log,2097,"ow to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then this bug(s) fix should now be applied to the latest release.; First checkout master, use $ git log to list the commits,; and copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tes",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:3131,Testability,test,tests,3131,"copy the hash(es) for the bug fix commit(s) to some temporary file or similar.; Now check out latest version branch, e.g.; If you have checked out this branch previously, then; $ git checkout qutip-4.0.X; $ git pull upstream qutip-4.0.X. Otherwise; $ git fetch upstream; $ git checkout -b qutip-4.0.X upstream/qutip-4.0.X; $ git push -u origin qutip-4.0.X. Create a branch for the patch; $ git checkout -b patch4.0-fix_bug123 qutip-4.0.X. Pick the commit(s) to be applied to the release.; Using the commit hash(es) copied earlier, cherry pick them into the current bug fix branch, e.g.; $ git cherry-pick 69d1641239b897eeca158a93b121553284a29ee1. for further info see https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html; push changes to your fork; $ git push --set-upstream origin patch4.0-fix_bug123. Make a Pull Request to the latest release branch on Github.; That is make a PR from the bug fix branch to the release branch (not the master), e.g. qutip-4.0.X; Merge this PR when the tests have passed. Create a new micro release¶; Commit a change to the VERSION file, setting it to the new version.; The only change should be in the third identifier, i.e. if the previous version was 4.5.2, then the next micro release must be 4.5.3.; It is ok to have two-digit identifiers; 4.6.10 is the next number after 4.6.9.; The file should contain only the version number in this format, with no extra characters (the automatic line-break at the end is fine). Create a new minor or major release¶; Create a new branch on the qutip/qutip repository using GitHub, e.g. ‘qutip-4.1.X’, beginning at the commit you want to use as the base of the release.; This will likely be something fairly recent on the master branch.; See the GitHub help pages for more information.; Checkout the branch and push to your fork; $ git fetch upstream; $ git checkout -b qutip-4.1.X upstream/qutip-4.1.X; $ git push -u origin qutip-4.1.X. Create a new branch from this, e.g.; $ git checkout -b 4.1-release_rea",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:7385,Testability,test,testing,7385,"ly by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package.; (Special circumstances) If for some reason you need to override the version number (for example if the previous deployment to PyPI only partially succeeded), you can type a valid Python version identifier into the “Override version number” field.; You probably do not need to do this.; The mechanism is designed to make alpha-testing major upgrades with nightly releases easier.; For even a bugfix release, you should commit the change to the VERSION file.; Click the lower “Run workflow” to perform the build and deployment. At this point, the deployment will take care of itself.; It should take between 30 minutes and an hour, after which the new version will be available for install by pip install qutip.; You should see the new version appear on QuTiP’s PyPI page. Download built files¶; When the build is complete, click into its summary screen.; This is the main screen used to both monitor the build and see its output, and should look like the below image on a success. The built binary wheels and the source distribution are the “build artifacts” at the bottom.; You need to download both the wheels and the source distribution.; Save them on your computer, and unzip both files; you should have many wheel qutip-*.whl files, and two sdist files: qutip-*.tar.gz and qutip-*.zip.; These are the same files that have just ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13521,Testability,test,tests,13521,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13572,Testability,test,tests,13572,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:13684,Testability,test,test,13684,"ub Releases section.; They should look something like https://github.com/qutip/qutip/archive/refs/tags/v4.6.0.tar.gz.; For a minor or major release links to the last micro release of the previous version will need to be moved (copied) to the ‘Previous releases’ section. Edit _includes/sidebar.html. The ‘Latest release’ version should be updated. The gztar and zip file links will need the micro release number updating in the traceEvent and file name.; The link to the documentation folder and PDF file (if created) should be updated. Edit documentation.html. The previous release tags should be moved (copied) to the ‘Previous releases’ section. Conda-forge¶; If not done previously then fork the qutip-feedstock:; https://github.com/conda-forge/qutip-feedstock; Checkout a new branch on your fork, e.g.; $ git checkout -b version-4.0.2. Generate a new sha256 code from the gztar for this version, e.g.; $ openssl sha256 qutip-4.0.2.tar.gz. Edit the recipe/meta.yaml file.; Change the version. Update the sha256 code.; Check that the recipe package version requirements at least match those in the setup.cfg.; Also ensure that the build number is reset; build:; number: 0. Push changes to your fork, e.g.; $ git push --set-upstream origin version-4.0.2. Make a Pull Request.; This will trigger tests of the package build process.; If (when) the tests pass, the PR can be merged, which will trigger the upload of the packages to the conda-forge channel.; To test the packages, add the conda-forge channel with lowest priority; $ conda config --append channels conda-forge. This should mean that the prerequistes come from the default channel, but the qutip packages are found in conda-forge. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:135,Usability,Guid,Guide,135,"﻿. Release and Distribution — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution; Preamble; Git workflow; Apply bug fix to latest release; Create a new micro release; Create a new minor or major release. Documentation build; Build release distribution and deploy; Build and deploy; Download built files; Monitoring progress (optional). Making a release on GitHub; Website; Copying new files; HTML file updates. Conda-forge. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Release and Distribution. Release and Distribution¶. Preamble¶; This document covers the process for managing updates to the current minor release and making new releases.; Within this document, the git remote upstream refers to the main QuTiP organsiation repository, and origin refers to your personal fork.; Instructions on how to backport bugfixes to a release branch are detailed in bugfix.; You need to do this to make changes to a current release that cannot wait until the next minor release, but need to go out in a micro release as soon as possible.; Follow either release if you are making a major or minor release, or microrelease instead if it is only a bugfix patch to a current release.; For both, then do the following steps in order:. docbuild, to build the documentation; deploy, to build the binary and source versions of the package, and deploy it to PyPI (pip); github, to release the files on the QuTiP GitHub page; web, to update qutip.org with the new links and documentation; cforge, to update the conda feedstock, deploying the package to conda. Git workflow¶. Apply bug fix to latest release¶; Assuming that the bug(s) has been fixed in some commit on the master,; then",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/release_distribution.html:6066,Usability,guid,guide,6066,"h them to your fork; $ git push --set-upstream origin 4.1-release_ready. Make a Pull Request to the release branch.; The “Development Status” of master should remain; Development Status :: 2 - Pre-Alpha. because it is never directly released.; The VERSION file on master should reflect the last major or minor release, with a trailing .dev to indicate that this is a development branch. Documentation build¶; Documentation should be rebuilt for a minor or major release.; If there have been any documentation updates as part of a micro release, then it should also be built for this.; The documentation repository is now inside qutip/qutip, in the doc directory..; Ensure that the following steps are complete:. The version should be changed in conf.py.; Update api_doc/classes.rst for any new / deleted classes.; Update api_doc/functions.rst for any new / deleted functions.; Update changelog.rst including all changes that are going into the new release. Then, fully rebuild the QuTiP documentation using the guide in the documentation README. Build release distribution and deploy¶; This step builds the source (sdist) and binary (wheel) distributions, and uploads them to PyPI (pip).; You will also be able to download the built files yourself in order to upload them to the QuTiP website. Build and deploy¶; This is handled entirely by a GitHub Action.; Go to the “Actions” tab at the top of the QuTiP code repository.; Click on the “Build wheels, optionally deploy to PyPI” action in the left-hand sidebar.; Click the “Run workflow” dropdown in the header notification; it should look like the image below. Use the drop-down menu to choose the branch or tag you want to release from.; This should be called qutip-4.5.X or similar, depending on what you made earlier.; This must never be master.; To make the release to PyPI, type the branch name (e.g. qutip-4.5.X) into the “Confirm chosen branch name […]” field.; You may leave this field blank to skip the deployment and only build the package",MatchSource.WIKI,docs/4.6/development/release_distribution.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/release_distribution.html
https://qutip.org/docs/4.6/development/roadmap.html:3434,Availability,mainten,maintence,3434,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12042,Availability,mask,masking,12042,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13703,Availability,error,errors,13703,"rally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is i",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15856,Availability,avail,available,15856,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:116,Deployability,Install,Installation,116,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:494,Deployability,integrat,integration,494,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:677,Deployability,release,release,677,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:779,Deployability,Release,Release,779,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:1213,Deployability,release,release,1213,"ment Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in the sense of a group; of people working collaboratively towards common objectives, and also a web; presence qutip.org. The QuTiP Community includes all the; people who have supported the project since in",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3572,Deployability,Install,Installation,3572,"y for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are m",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4002,Deployability,release,release,4002," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4185,Deployability,install,installed,4185,"pe of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a depen",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4796,Deployability,integrat,integrated,4796,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family pac",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4879,Deployability,install,installed,4879,"he freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components int",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5048,Deployability,install,installed,5048," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5929,Deployability,integrat,integrated,5929,"der structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6325,Deployability,integrat,integrated,6325,"p. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6540,Deployability,integrat,integrated,6540," fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6963,Deployability,integrat,integrated,6963," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10297,Deployability,integrat,integration,10297,"providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10528,Deployability,deploy,deploying,10528,"main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP contro",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11301,Deployability,integrat,integrated,11301,"dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11445,Deployability,integrat,integrated,11445," for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11949,Deployability,Continuous,Continuous,11949,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15149,Deployability,toggle,toggle,15149," file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15514,Deployability,release,release,15514,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15598,Deployability,release,release,15598,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15703,Deployability,integrat,integration,15703,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15789,Deployability,release,release,15789,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16023,Deployability,release,release,16023,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16068,Deployability,release,released,16068,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16283,Deployability,update,updated,16283,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:494,Integrability,integrat,integration,494,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3466,Integrability,depend,dependences,3466,"kages that are; somehow related to QuTiP, and specifically those that are maintained by the; QuTiP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavo",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3538,Integrability,depend,depend,3538,"iP Admim Team. Herin QuTiP will refer to the project / organisation and qutip; to the library for simulating quantum dyanmics.; Should we be starting again from scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; des",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:4796,Integrability,integrat,integrated,4796,"ompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family pac",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5115,Integrability,depend,dependency,5115," could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installed separately within the main qutip; folder structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:5929,Integrability,integrat,integrated,5929,"der structure to provide backwards compatibility, these are (will be); called qutip optional sub-packages. Others will be installed in their own; folders, but (most likely) have qutip as a dependency – these will just be; called ‘family’ packages. QuTiP affilliated packagesOther packages have been developed by others; outside of the QuTiP organisation that work with, and are complementary to,; qutip. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Fram",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6325,Integrability,integrat,integrated,6325,"p. The plan is to give some recognition to those that we deem worthy of; such [this needs clarification]. These packages will not be maintained by the; QuTiP Team. Todo; Do we really need optional subpackages? It seems that are a bit fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6540,Integrability,integrat,integrated,6540," fiddly and as; we are side-stepping bw compat with a major version, we could just make QIP a; separate package. Family packages¶. qutip main¶. current package status: family package qutip; planned package status: family package qutip. The in-scope components of the main qutip package all currently reside in the; base folder. The plan is to move some components into integrated subpackages as; follows:. core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:6963,Integrability,integrat,integrated,6963," core quantum objects and operations; solver quantum dynamics solvers. What will remain in the base folder will be miscellaneous modules. There may be; some opportunity for grouping some into a visualisation subpackage. There is; also some potential for renaming, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7222,Integrability,depend,depends,7222,"g, as some module names have underscores, which; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, devel",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7284,Integrability,depend,dependency,7284,"ch; is unconventional. Qtrl¶. current package status: integrated sub-package qutip.control; planned package status: family package qtrl. There are many OSS Python packages for quantum control optimisation. There are; also many different algorithms. The current control integrated subpackage; provides the GRAPE and CRAB algorithms. It is too ambitious for QuTiP to attempt; (or want) to provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7662,Integrability,wrap,wrapper,7662," provide for all options. Control optimisation has been deemed out; of scope and hence these components will be separated out into a family package; called Qtrl.; Potentially Qtrl may be replaced by separate packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10297,Integrability,integrat,integration,10297,"providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10557,Integrability,depend,dependent,10557,"main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP contro",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11301,Integrability,integrat,integrated,11301,"dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. s",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11445,Integrability,integrat,integrated,11445," for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12107,Integrability,depend,dependent,12107,"onents used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12380,Integrability,wrap,wrapper,12380,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12618,Integrability,interface,interface,12618,"new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python log",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14484,Integrability,interface,interface,14484,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15703,Integrability,integrat,integration,15703,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3862,Modifiability,enhance,enhancement,3862," as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTiP organisation will be called QuTiP ‘family’ packages. Sub-packages within; qutip main will be called ‘integrated’ sub-packages. Some packages will be; maintained in their own repos and installe",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:11973,Modifiability,variab,variables,11973,"uch] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status mes",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12117,Modifiability,variab,variable,12117,"onents used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12398,Modifiability,variab,variable,12398,"al codename of the; package before it was integrated into qutip. Also changes to exploit the new; data layer will be implemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, con",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12920,Modifiability,Extend,Extended,12920,"Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized component",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13450,Modifiability,layers,layers,13450," optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14716,Modifiability,flexible,flexible,14716," errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14759,Modifiability,flexible,flexible,14759,"ing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15212,Modifiability,config,configure,15212,"s. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Li",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:9208,Performance,perform,performance,9208,"develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data from code qutip components, allowing; for alternatives, such as sparse, dense etc. Difficult to summarize. Almost; every file in qutip affected in some way. A major milestone for qutip.; Significant performance improvements throughout qutip.; Some developments tasks remain, including providing full control over how the; data-layer dispatchers choose the most appropriate output type. qutip main reorganization¶. tag; qmain-reorg. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for docume",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:10454,Performance,perform,performance,10454,"g. status; development [pretty much] complete. admin lead; Eric. main dev; Jake Lishman. Reorganise qutip main components to the structure described above. qutip user docs migration¶. tag; qmain-docs. status; conceptualised. admin lead; TBA; Shahnawaz?. main dev; TBA. The qutip user documentation build files are to be moved to the qutip/qutip; repo. This is more typical for an OSS package.; As part of the move, the plan is to reconstruct the Sphinx structure from; scratch. Historically, there have been many issues with building the docs.; Sphinx has come a long way since qutip docs first developed. The main source; (rst) files will remain [pretty much] as they are, although there is a lot of; scope to improve them.; The qutip-doc repo will afterwards just be used for documents, such as this one,; pertaining to the QuTiP project. Solver data layer integration¶. tag; solve-dl. status; development ongoing. admin lead; Eric. main dev; Eric. The new data layer gives opportunity for significantly improving performance of; the qutip solvers. Eric has been revamping the solvers by deploying QobjEvo; (the time-dependent quantum object) that he developed. QobjEvo will exploit; the data layer, and the solvers in turn exploit QobjEvo. QIP migration¶. tag; qip-mig. status; development [pretty much] complete. admin lead; Boxi. main dev; Sidhant Saraogi. A separate package for qutip-qip was created during Sidhant’s GSoC project.; There is some fine tuning required, especially after qutip.control is migrated. HEOM revamp¶. tag; heom-revamp. status; development [pretty much] complete. admin lead; Neill. main dev; Tarun Raheja. An overhaul of the HEOM solver. C++ components used to speed up construction of; the hierarchy. Qtrl migration¶. tag; qtrl-mig. status; conceptualised. admin lead; Alex. main dev; TBA. The components currently packaged as an integrated subpackage of qutip main will; be moved to separate package called Qtrl. This is the original codename of the; package before ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12460,Performance,optimiz,optimize,12460,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13886,Safety,avoid,avoided,13886,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15017,Safety,avoid,avoid,15017,"tates, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full releas",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14552,Security,access,accessible,14552,"t it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major r",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:178,Testability,Log,Log,178,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:3683,Testability,test,testing,3683," scratch, then we would probably chose another; name for the main qutip library, such as qutip-quantdyn. However, qutip is; famous, and the name will stay. Library package structure¶; With a name as general as Quantum Toolkit in Python, the scope for new code; modules to be added to qutip is very wide. The library was becoming increasingly; difficult to maintain, and in c. 2020 the QuTiP Admim Team decided to limit the; scope of the ‘main’ (for want of a better name) qutip package. This scope is; restricted to components for the simulation (solving) of the dynamics of quantum; systems. The scope includes utilities to support this, including analysis and; visualisation of output.; At the same time, again with the intention of easing maintence, a decision to; limit dependences was agreed upon. Main qutip runtime code components should; depend only upon Numpy and Scipy. Installation (from source) requires Cython,; and some optional components also require Cython at runtime. Unit testing; requires Pytest. Visualisation (optional) components require Matplotlib.; Due to the all encompassing nature of the plan to abstract the linear algebra; data layer, this enhancement (developed as part of a GSoC project) was allowed; the freedom (potential for non-backward compatibility) of requiring a major; release. The timing of such allows for a restructuring of the qutip compoments,; such that some that could be deemed out of scope could be packaged in a; different way – that is, not installed as part of the main qutip package. Hence; the proposal for different types of package described next. With reference to; the discussion above on the name QuTiP/qutip, the planned; restructuring suffers from confusing naming, which seems unavoidable without; remaining either the organisation or the main package (neither of which are; desirable). QuTiP family packagesThe main qutip package already has sub-packages,; which are maintained in the main qutip repo. Any packages maitained by the; QuTi",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:7884,Testability,test,tests,7884,"te packages for GRAPE and CRAB, based; on the QuTiP Control Framework. QIP¶. current package status: integrated sub-package qutip.qip; planned package status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13228,Testability,log,logging,13228,"ining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, c",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13635,Testability,log,logging,13635," a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in educa",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14208,Testability,log,logging,14208,". main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have slider",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:15892,Testability,test,test,15892,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16008,Testability,test,testing,16008,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:16053,Testability,test,tested,16053,"l for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 release. data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; Qtrl migration; HEOM revamp. The planned timeline for the release is:. alpha version, April 2021. Core features packaged and available for; experienced users to test.; beta version, July 2021. All required features and documentation complete,; packaged and ready for community testing.; full release, September 2021. Full tested version released. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:136,Usability,Guid,Guide,136,"﻿. QuTiP Development Roadmap — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Preamble; What is QuTiP?. Library package structure; Family packages; Affilliated packages. Development Projects; data layer abstraction; qutip main reorganization; qutip user docs migration; Solver data layer integration; QIP migration; HEOM revamp; Qtrl migration; QuTiP control framework; QuTiP optimisation; Sympsi migration; Status messaging and recording; qutip Interactive. QuTiP major release roadmap; QuTiP v.5. Ideas for future QuTiP development; Working with the QuTiP Documentation; Release and Distribution. Bibliography. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; QuTiP Development Roadmap. QuTiP Development Roadmap¶. Preamble¶; This document outlines plan and ideas for the current and future development of; QuTiP. The document is maintained by the QuTiP Admim team. Contributuions from; the QuTiP Community are very welcome.; In particular this document outlines plans for the next major release of qutip,; which will be version 5. And also plans and dreams beyond the next major; version.; There is lots of development going on in QuTiP that is not recorded in here.; This a just an attempt at coordinated stragetgy and ideas for the future. What is QuTiP?¶; The name QuTiP refers to a few things. Most famously, qutip is a Python library; for simulating quantum dynamics. To support this, the library also contains; various software tools (functions and classes) that have more generic; applications, such as linear algebra components and visualisation utilities, and; also tools that are specifically quantum related, but have applications beyond; just solving dynamics (for instance partial trace computation).; QuTiP is also an organisation, in the Github sense, and in t",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:8023,Usability,simpl,simplifcation,8023,"e status: optional sub-package qutip.qip. Todo; Is it really necessary for this to be a sub-package? It could just be a; separate package. The QIP subpackage has been deemed out of scope (feature-wise). It also depends; on qutip.control and hence would be out of scope for dependency reasons. A; separate repository has already been made for qutip-qip. qutip-symbolic¶. current package status: independent package sympsi; planned package status: family package qutip-symbolic. Long ago Robert Johansson and Eunjong Kim developed Sympsi. It is a fairly; coomplete library for quantum computer algebra (symbolic computation). It is; primarily a quantum wrapper for Sympy.; It has fallen into unmaintained status. The latest version on the sympsi repo does not work with recent versions of; Sympy. Alex Pitchford has a fork that; does ‘work’ with recent Sympy versions – unit tests pass, and most examples; work. However, some (important) examples fail, due to lack of respect for; non-commuting operators in Sympy simplifcation functions (note this was true as; of Nov 2019, may be fixed now).; There is a [not discussed with RJ & EK] plan to move this into the QuTiP family; to allow the Admin Team to maintain, develop and promote it. The ‘Sympsi’ name; is cute, but a little abstract, and qutip-symbolic is proposed as an; alternative, as it is plainer and more distinct from Sympy. Affilliated packages¶. qucontrol-krotov¶. code repository: https://github.com/qucontrol/krotov. A package for quantum control optimisation using Krotov, developed mainly by; Michael Goerz.; Generally accepted by the Admin Team as well developed and maintained. A solid; candiate for affilliation. Development Projects¶. data layer abstraction¶. tag; dl-abs. status; majority of development completed. admin lead; Eric. main dev; Jake Lishman. Development completed as a GSoC project. Fully implemented in the dev.major; branch. Currently being used by some research groups.; Abstraction of the linear algebra data fr",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12556,Usability,learn,learning,12556,"mplemented. QuTiP control framework¶. tag; ctrl-fw. status; conceptualised. admin lead; Alex. main dev; TBA. Create new package qutip-ctrlfw “QuTiP Control Framework”. The aim is provide a; common framework that can be adopted by control optimisation packages, such that; different packages (algorithms) can be applied to the same problem.; Classes for defining a controlled system:. named control parameters. Scalar and n-dim. Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:12935,Usability,simpl,simplify,12935,"Continuous and discrete variables; mapping of control parameters to dynamics generator args; masking for control parameters to be optimised. Classes for time-dependent variable parameterisation. piecewise constant; piecewise linear; Fourier basis; more. Classes for defining an optimisation problem:. single and multiple objectives. QuTiP optimisation¶. tag; qutip-optim. status; conceptualised. admin lead; Alex. main dev; TBA. A wrapper for multi-variable optimisation functions. For instance those in; scipy.optimize (Nelder-Mead, BFGS), but also others, such as Bayesian; optimisation and other machine learning based approaches. Initially just; providing a common interface for quantum control optimisation, but applicable; more generally. Sympsi migration¶. tag; sympsi-mig. status; conceptualised. admin lead; Alex. main dev; TBA. Create a new family package qutip-symbolic from ajgpitch fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized component",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:13733,Usability,Clear,Clearly,13733,"h fork of Sympy. Must; gain permission from Robert Johansson and Eunjong Kim. Extended Sympy simplify; to respect non-commuting operators. Produce user documentation. Status messaging and recording¶. tag; status-msg. status; conceptualised. admin lead; Alex. main dev; TBA. QuTiP has various ways of recording and reporting status and progress. ProgressBar used by some solvers; Python logging used in qutip.control; Dump used in qutip.control; heom records solver.Stats. Some consolidation of these would be good.; Some processes (some solvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotl",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14354,Usability,simpl,simple,14354,"olvers, correlation, control optimisation) have many; stages and many layers. Dump was initially developed to help with debugging,; but it is also useful for recording data for analysis. qutip.logging_utils has; been criticised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuit",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/development/roadmap.html:14631,Usability,learn,learners,14631,"icised for the way it uses Python logging. The output goes to stderr; and hence the output looks like errors in Jupyter notebooks.; Clearly, storing process stage data is costly in terms of memory and cpu time,; so any implementation must be able to be optionally switched on/off, and avoided; completely in low-level processes (cythonized components).; Required features:. optional recording (storing) of process stage data (states, operators etc); optionally write subsets to stdout; maybe other graphical representations; option to save subsets to file; should ideally replace use of ProgressBar, Python logging, control.Dump, solver.Stats. qutip Interactive¶. status; conceptualised. tag; qutip-gui. admin lead; Alex. main dev; TBA. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; This would make an good GSoC project. It is independent and the scope is; flexible.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; Matplotlib has some interactive features (sliders, radio buttons, cmd buttons); that can be used to control parameters. They are a bit clunky to use, but they; are there. Could maybe avoid these and develop our own GUI. An interactive Bloch; sphere could have sliders for qubit state angles. Buttons to add states, toggle; state evolution path. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. QuTiP major release roadmap¶. QuTiP v.5¶; These Projects need to be completed for the qutip v.5 rele",MatchSource.WIKI,docs/4.6/development/roadmap.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/development/roadmap.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1257,Availability,avail,available,1257,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:9570,Availability,error,error,9570,"atrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eige",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:125,Deployability,Install,Installation,125,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1120,Deployability,install,installation,1120,"rontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structu",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:14555,Deployability,update,updated,14555,"97 0.035077 ]; [0.08826704 0.08822695 0.06263061 0.035077 0.0211765 ]]. >>> coherent_dm(5, 1).diag(); array([0.36791117, 0.36757705, 0.18523331, 0.05810197, 0.0211765 ]). >>> coherent_dm(5, 1).full(); array([[0.36791117+0.j, 0.36774407+0.j, 0.26105441+0.j, 0.14620658+0.j,; 0.08826704+0.j],; [0.36774407+0.j, 0.36757705+0.j, 0.26093584+0.j, 0.14614018+0.j,; 0.08822695+0.j],; [0.26105441+0.j, 0.26093584+0.j, 0.18523331+0.j, 0.10374209+0.j,; 0.06263061+0.j],; [0.14620658+0.j, 0.14614018+0.j, 0.10374209+0.j, 0.05810197+0.j,; 0.035077 +0.j],; [0.08826704+0.j, 0.08822695+0.j, 0.06263061+0.j, 0.035077 +0.j,; 0.0211765 +0.j]]). >>> coherent_dm(5, 1).norm(); 1.0000000175063126. >>> coherent_dm(5, 1).sqrtm(); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0.36791117+3.66778589e-09j 0.36774407-2.13388761e-09j; 0.26105441-1.51480558e-09j 0.14620658-8.48384618e-10j; 0.08826704-5.12182118e-10j]; [0.36774407-2.13388761e-09j 0.36757705+2.41479965e-09j; 0.26093584-1.11446422e-09j 0.14614018+8.98971115e-10j; 0.08822695+6.40705133e-10j]; [0.26105441-1.51480558e-09j 0.26093584-1.11446422e-09j; 0.18523331+4.02032413e-09j 0.10374209-3.39161017e-10j; 0.06263061-3.71421368e-10j]; [0.14620658-8.48384618e-10j 0.14614018+8.98971115e-10j; 0.10374209-3.39161017e-10j 0.05810197+3.36300708e-10j; 0.035077 +2.36883273e-10j]; [0.08826704-5.12182118e-10j 0.08822695+6.40705133e-10j; 0.06263061-3.71421368e-10j 0.035077 +2.36883273e-10j; 0.0211765 +1.71630348e-10j]]. >>> coherent_dm(5, 1).tr(); 1.0. >>> (basis(4, 2) + basis(4, 1)).unit(); Quantum object: dims = [[4], [1]], shape = (4, 1), type = ket; Qobj data =; [[0. ]; [0.70710678]; [0.70710678]; [0. ]]. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:4880,Energy Efficiency,Charge,Charge,4880,"ying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states.; Therefore, QuTiP includes predefined objects for a variety of states and operators:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:4897,Energy Efficiency,charge,charge,4897,"ying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used; types such as the; ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states.; Therefore, QuTiP includes predefined objects for a variety of states and operators:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha); same as coherent(N,alpha). Thermal density matrix; (for n particles); thermal_dm(N,n); n = particle number expectation value. Operators; Command (# means optional); Inputs. Charge operator; charge(N,M=-N); Diagonal operator with entries; from M..0..N. Commutator; commutator(A, B, kind); Kind = ‘normal’ or ‘anti’. Diagonals operator; qdiags(N); Quantum object created from arrays of; diagonals at given offsets. Displacement operator; (Single-mode); displace(N,alpha); N=number of levels in Hilbert space,; alpha = complex displacement amplitude. Higher spin operators; jmat(j,#s); j = integer or half-integer; representing spin, s = ‘x’, ‘y’, ‘z’,; ‘+’, or ‘-‘. Identity; qeye(N); N = number of levels in Hilbert space. Lowering (destruction); operator; destroy(N); same as above. Momentum operator; momentum(N); same as above. Number operator; num(N); same as above. Phase operator; (Single-mode); phase(N, phi0); Single-mode Pegg-Barnett phase; operator with ref phase phi0. Position operator; position(N); same as above. Raising (creation); operator; create(N); same as above. Squeezing operator; (Single-mode); squeeze(N, sp); N=number of levels in Hilbert space,; sp = squeezing parameter. Squeezing op",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:8478,Integrability,message,message,8478,"es (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1959,Modifiability,variab,variables,1959,"ment Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the names of Python classes, such as Qobj(), are capitalized whereas the names of functions are not. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; print(Qobj([[1],[2],[3],[4],[5]])). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), t",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1147,Performance,load,load,1147," on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra ",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1236,Performance,load,load,1236,"Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this us",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:1615,Performance,load,loaded,1615," of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems, we need a data structure that encapsulates the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; print(Qobj()). Output:; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, the",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:7366,Security,access,accessed,7366," =; [[0.]; [0.]; [0.]; [1.]; [0.]]. >>> coherent(5,0.5-0.5j); Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.7788017 +0.j ]; [ 0.38939142-0.38939142j]; [ 0. -0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. >>> destroy(4); Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. ]; [0. 0. 1.41421356 0. ]; [0. 0. 0. 1.73205081]; [0. 0. 0. 0. ]]. >>> sigmaz(); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. >>> jmat(5/2.0,'+'); Quantum object: dims = [[6], [6]], shape = (6, 6), type = oper, isherm = False; Qobj data =; [[0. 2.23606798 0. 0. 0. 0. ]; [0. 0. 2.82842712 0. 0. 0. ]; [0. 0. 0. 3. 0. 0. ]; [0. 0. 0. 0. 2.82842712 0. ]; [0. 0. 0. 0. 0. 2.23606798]; [0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; >>> q = destroy(4). >>> q.dims; [[4], [4]]. >>> q.shape; (4, 4). In general, the attributes (properties) of a Qobj object (or any Python object) can be retrieved using the Q.attribute notation.; In addition to the those shown with the print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex1",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:8602,Security,access,access,8602,"e print function, an instance of the Qobj class also has the following attributes:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties needed to characterize a quantum operator or state vector.¶. For the destruction operator above:; >>> q.type; 'oper'. >>> q.isherm; False. >>> q.data; <4x4 sparse matrix of type '<class 'numpy.complex128'>'; with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; >>> q = destroy(4). >>> x = sigmax(). >>> q + 5; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[5. 1. 0. 0. ]; [0. 5. 1.41421356 0. ]; [0. 0. 5. 1.73205081]; [0. 0. 0. 5. ]]. >>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); -----------------------------------",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:879,Testability,Log,Log,879,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:10012,Testability,log,logic,10012,">>> x * x; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 1.]]. >>> q ** 3; Quantum object: dims = [[4], [4]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[0. 0. 0. 2.44948974]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]; [0. 0. 0. 0. ]]. >>> x / np.sqrt(2); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[0. 0.70710678]; [0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> print(q * x); ------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-33-0b599f41213e> in <module>; ----> 1 print(q * x). ~/Documents/qutip_dev/qutip/qutip/qobj.py in __mul__(self, other); 553; 554 else:; --> 555 raise TypeError(""Incompatible Qobj shapes""); 556; 557 elif isinstance(other, np.ndarray):. TypeError: Incompatible Qobj shapes. In addition, the logic operators “is equal” == and “is not equal” != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Cosine; Q.cosm(); Cosine of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Diamond Norm; Q.dnorm(); Returns the diamond norm. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not spars",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:145,Usability,Guid,Guide,145,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:152,Usability,Guid,Guide,152,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-basics.html:980,Usability,Guid,Guide,980,". Basic Operations on Quantum Objects — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Basic Operations on Quantum Objects. Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, first call the import statement:; from qutip import *. This will load all of the user available functions. Often, we also need to import the NumPy and Matplotlib libraries with:; import numpy as np. import matplotlib.pyplot as plt. In the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt, Python script, or Jupyter notebook. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics is the use of operators instead of numbers as variables. Moreover, we need to specify st",MatchSource.WIKI,docs/4.6/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-basics.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:2167,Availability,avail,available,2167,"en studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replaci",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5982,Availability,down,down,5982,"(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leadi",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:119,Deployability,Install,Installation,119,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14483,Deployability,install,installing,14483,"pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Sha",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14649,Deployability,install,install,14649,"utip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:15549,Deployability,update,updated,15549," 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:527,Modifiability,Config,Configuring,527,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5477,Modifiability,Config,Configuring,5477,"he initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are i",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:7585,Modifiability,Config,Configuring,7585,"atplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leading to a higher quality figure.; Only the Bloch class can be embedded in a Matplotlib figure window. Thus if you want to combine a Bloch sphere with another figure generated in QuTiP, you can not use Bloch3d. Of course you can always post-process your figures using other software to get the desired result.; Due to limitations in the rendering engine, the Bloch3d class does not support LaTex for text. Again, you can get around this by post-processing.; The user customizable attributes for the Bloch and Bloch3d classes are not identical. Therefore, if you change the properties of one of the classes, these changes will cause an exception if the class is switched. Configuring the Bloch sphere¶. Bloch Class Options¶; At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming b=Bloch():. Attribute; Function; Default Setting. b.axes; Matplotlib axes instance for animations. Set by axes; keyword arg.; None. b.fig; User supplied Matplotlib Figure instance. Set by fig; keyword arg.; None. b.font_color; Color of fonts; ‘black’. b.font_size; Size of fonts; 20. b.frame_alpha; Transparency of wireframe; 0.1. b.frame_color; Color of wireframe; ‘gray’. b.frame_width; Width of wireframe; 1. b.point_color; List of colors for Bloch point markers to cycle through; ['b', 'r', 'g', '#CC6600']. b.point_marker; List of point marker shapes to cyc",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:13209,Modifiability,evolve,evolve,13209,"the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to te",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1781,Performance,load,load,1781,"tes & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for construc",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1866,Performance,load,loads,1866,"g; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:11064,Security,access,accessed,11064,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:941,Testability,Log,Log,941,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:139,Usability,Guid,Guide,139,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:146,Usability,Guid,Guide,146,"﻿. Plotting on the Bloch Sphere — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1042,Usability,Guid,Guide,1042,"n. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hire",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:1956,Usability,simpl,simply,1956,"pment Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). (png, hires.png, pdf). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). (png, hires.png, pdf). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec =",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3389,Usability,clear,clear,3389,"render(). (png, hires.png, pdf). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contr",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3493,Usability,clear,clear,3493,"the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial poin",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:3924,Usability,clear,clear,3924,"nts(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). (png, hires.png, pdf). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_point",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:4214,Usability,clear,clear,4214,"rates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:4227,Usability,clear,clear,4227,"plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). (png, hires.png, pdf). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). (png, hires.png, pdf). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). (png, hires.png, pdf). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). (png, hires.png, pdf). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set o",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5526,Usability,clear,clear,5526,"multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important d",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:5538,Usability,clear,clear,5538,"nts using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). (png, hires.png, pdf). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). (png, hires.png, pdf). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). (png, hires.png, pdf). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to co",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:11989,Usability,clear,clear,11989," [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0:",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14081,Usability,clear,clear,14081,"e > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax.",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14331,Usability,simpl,simple,14331,"turn output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be view",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-bloch.html:14940,Usability,clear,clear,14940," 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either mencoder or ffmpeg.; While either choice works on linux, it is best to choose ffmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-bloch.html
https://qutip.org/docs/4.6/guide/guide-control.html:5955,Availability,error,error,5955,"then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one parameter to minimise \(\varepsilon\), then the problem becomes a finite multi-variable optimisation problem, for which there are many established methods, often referred to as ‘hill-climbing’ methods. The simplest of these to understand is that of steepest ascent (or descent). The gradient of the fidelity with respect to all the variables is calculated (or approximated) and a step is made in the variable space in the direction of steepest ascent (or descent). This method is a first order gradient method. In two dimensions this describes a method of climbing a hill by heading in the direction where the ground rises fastest. This analogy also clearly illustrates one of the main challenges in multi-variable optimisation, which is that all methods have a tendency to get stuck in local maxima. It",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11627,Availability,down,down,11627,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11698,Availability,avail,available,11698,"a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integrat",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12755,Availability,error,errors,12755,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:113,Deployability,Install,Installation,113,". Quantum Optimal Control — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. what states or transformations can we achieve (if any)?; what is the shape of the control pulse required to achieve this?. Thes",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:11509,Deployability,integrat,integration,11509,"orithm [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually very low, it is sufficient to transform the optimal control problem to a few parameter search by introducing a physically motivated function basis that builds up the pulse. Compared to the number of time slices needed to accurately simulate quantum dynamics (often equals basis dimension for Gradient based algorithms), this number is lower by orders of magnitude, allowing CRAB to efficiently optimize smooth pulses with realistic experimental constraints. It is important to point out, that CRAB does not make any suggestion on the basis function to be used. The basis must be chosen carefully considered, taking into account a priori knowledge of the system (such as symmetries, magnitudes of scales,…) and solution (e.g. sign, smoothness, bang-bang behavior, singularities, maximum excursion or rate of change,….). By doing so, this algorithm allows for native integration of experimental constraints such as maximum frequencies allowed, maximum amplitude, smooth ramping up and down of the pulse and many more. Moreover initial guesses, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for dir",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12565,Deployability,integrat,integration,12565,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:12707,Deployability,integrat,integration,12707,"s, if they are available, can (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either not possible to derive the gradient for the cost functional with respect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:13182,Deployability,integrat,integrated,13182,"espect to each time slice or it is computationally expensive to do so. The same can apply for the necessary (reverse) propagation of the co-state. All this trouble does not occur within CRAB as those elements are not in use here. CRAB, instead, takes the time evolution as a black-box where the pulse goes as an input and the cost (e.g. infidelity) value will be returned as an output. This concept, on top, allows for direct integration in a closed loop experimental environment where both the preliminarily open loop optimization, as well as the final adoption, and integration to the lab (to account for modeling errors, experimental systematic noise, …) can be done all in one, using this algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The first is an implementation of first order GRAPE, and is not further described here, but there are the example notebooks. The second is referred to as Qtrl (when a distinction needs to be made) as this was its name before it was integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the multi-variable optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and method",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14279,Deployability,configurat,configuration,14279,"optimisation, typically the L-BFGS-B method for GRAPE and Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on the open-source package DYNAMO, which is a MATLAB implementation, and is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:14503,Deployability,configurat,configuration,14503,"is described in [DYNAMO]. It has since been restructured and extended for flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
https://qutip.org/docs/4.6/guide/guide-control.html:17213,Deployability,configurat,configuration,17213,"s shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/guide/guide-control.html
