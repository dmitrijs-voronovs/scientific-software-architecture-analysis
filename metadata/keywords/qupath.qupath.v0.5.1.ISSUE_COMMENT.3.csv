id,quality_attribute,keyword,matched_word,match_idx,sentence,source,author,repo,version,wiki,url
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:545,Deployability,Update,Update,545,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:178,Energy Efficiency,adapt,adapters,178,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:178,Integrability,adapter,adapters,178,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:178,Modifiability,adapt,adapters,178,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:227,Performance,Load,Loaded,227,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:299,Performance,Load,Loaded,299,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:348,Performance,Load,Loaded,348,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:401,Performance,Load,Loaded,401,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:462,Performance,Load,Loaded,462,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:830,Safety,avoid,avoid,830,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:148,Testability,log,log,148,"HI,. Thanks for you help!. File format: .tif . This is all the info of the image. I didn’t try with another version. Will do now. . Info under show log:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://gi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141124758:1435,Testability,log,log,1435,"og:. INFO: Initializing type adapters; INFO: Bio-Formats version 6.7.0; INFO: Loaded extension Bio-Formats options (Bio-Formats 6.7.0) (18 ms); INFO: Loaded extension ImageJ extension (69 ms); INFO: Loaded extension Processing extension (30 ms); INFO: Loaded extension Rich script editor extension (81 ms); INFO: Loaded extension SVG export extension (1 ms); INFO: OpenSlide version 3.4.1; INFO: Update check for https://github.com/qupath/qupath; INFO: Starting QuPath with parameters: []; INFO: Setting max Bio-Formats readers to 4; WARN: Temp memoization directory created at /var/folders/_v/1nq60v556l5cbwcdv47wq76w0000gn/T/qupath-memo-4532483650866269942; WARN: If you want to avoid this warning, either specify a memoization directory in the preferences or turn off memoization by setting the time to < 0; INFO: Image data set to ImageData: Not set, 16.tif - Series 0. Again, thank you very much for your incredible help!. Manuel. > El 30 may. 2022, a las 13:52, Pete ***@***.***> escribió:; > ; > ; > Hi, some questions:; > ; > What is the file format?; > Under the 'Image' tab, what is shown at the entry 'Server type'?; > Have you been able to view the whole slide image with any other version of QuPath (e.g. on Windows)?; > Is there any relevant information under View → Show log?; > If you have an mrxs image, this may be relevant: https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917 <https://forum.image.sc/t/potential-fix-for-problem-low-resolution-mrxs-3dhistech-scans/32917>; > If you have an mrxs or vsi image, you might be missing the folder the should exist alongside the main image file (the folder contains the high-resolution data).; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/973#issuecomment-1141062643>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/AM3QKIKUIXPG5ROSUQTBOELVMSTXDANCNFSM5XKDHIBQ>.; > You are receiving this because you authored the thread.; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141124758
https://github.com/qupath/qupath/issues/973#issuecomment-1141154596:31,Modifiability,variab,variable,31,"Thanks, TIFF files can be very variable - I'd probably need an example image to replicate the issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141154596
https://github.com/qupath/qupath/issues/973#issuecomment-1141214361:229,Deployability,release,release,229,"Hi @cossiomanuel . thanks for sharing an image. The underlying bug seems to be the same as these:; * https://github.com/qupath/qupath/issues/904; * https://github.com/qupath/qupath/issues/894. It will be fixed in the next QuPath release. In the meantime, the workaround is to [add images to a project](https://qupath.readthedocs.io/en/stable/docs/tutorials/projects.html) first. I'll close the issue because that resolved it for me on Monterey, but please do let me know if it works for you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/973#issuecomment-1141214361
https://github.com/qupath/qupath/issues/981#issuecomment-1144937621:613,Modifiability,extend,extend,613,"@saramcardle I'm afraid I didn't manage to include in the PR at https://github.com/qupath/qupath/pull/987; I think setting the gamma per channel could end up being pretty complex, and I'm apprehensive about trying any time soon for fear or breaking something else / further delaying more important stuff / making it too easy to have confusing displays. I'll think a bit more about it, but I'd rather see how the current gamma improvements work out first. Currently, gamma is applied only after the image is converted to RGB. So by that point the per-channel info has been lost, and so the approach doesn't easily extend to support that.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/981#issuecomment-1144937621
https://github.com/qupath/qupath/issues/982#issuecomment-1713247434:313,Integrability,interface,interface,313,"New discussion at https://forum.image.sc/t/openslide-4-0-is-coming-rsn-new-features-relevant-to-qupath/86015. Here's an initial proposal for the work involved in adding preliminary support:. - [ ] Static methods in `BufferedImageTools` to read ICC Profiles from TIFF images & byte arrays; - [ ] JSON-serializable interface for a color conversion (name, type, URIs, `convertTosRGB` method); - [ ] ICC Profile implementation that is basically a wrapper handle applying an ICC Profile to convert to sRGB, caching any required `ColorConvertOp`; - [ ] Retrofit `ImageServer` with a method to get a color conversion object (defaults to `null`), and return a flag to state whether the conversion has been applied when returning pixels (i.e. it's a property within the server itself - one can't ask for converted and unconverted pixels from the same server); - [ ] Support applying any conversion 'live' within the viewer (caching tiles as needed); - [ ] Support for applying any conversion *at the point the image is being read* via project import flags",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/982#issuecomment-1713247434
https://github.com/qupath/qupath/issues/982#issuecomment-1713247434:443,Integrability,wrap,wrapper,443,"New discussion at https://forum.image.sc/t/openslide-4-0-is-coming-rsn-new-features-relevant-to-qupath/86015. Here's an initial proposal for the work involved in adding preliminary support:. - [ ] Static methods in `BufferedImageTools` to read ICC Profiles from TIFF images & byte arrays; - [ ] JSON-serializable interface for a color conversion (name, type, URIs, `convertTosRGB` method); - [ ] ICC Profile implementation that is basically a wrapper handle applying an ICC Profile to convert to sRGB, caching any required `ColorConvertOp`; - [ ] Retrofit `ImageServer` with a method to get a color conversion object (defaults to `null`), and return a flag to state whether the conversion has been applied when returning pixels (i.e. it's a property within the server itself - one can't ask for converted and unconverted pixels from the same server); - [ ] Support applying any conversion 'live' within the viewer (caching tiles as needed); - [ ] Support for applying any conversion *at the point the image is being read* via project import flags",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/982#issuecomment-1713247434
https://github.com/qupath/qupath/issues/984#issuecomment-1183514515:288,Availability,ERROR,ERROR,288,"This update does allow the export to run as expected when saving as ""ome.tif"". It might be useful to have a check/warning prior to attempting to write a file that is too large to a basic .tif. If I attempt the same export to .tif, after a long pause I get:. `WARN: Unable to write image; ERROR: IOException at line 22: Unable to write F:\filepath\Sox2 region_0_annotationLabels.tif! No compatible writer found.`. Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing `gradlew ` when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183514515
https://github.com/qupath/qupath/issues/984#issuecomment-1183514515:5,Deployability,update,update,5,"This update does allow the export to run as expected when saving as ""ome.tif"". It might be useful to have a check/warning prior to attempting to write a file that is too large to a basic .tif. If I attempt the same export to .tif, after a long pause I get:. `WARN: Unable to write image; ERROR: IOException at line 22: Unable to write F:\filepath\Sox2 region_0_annotationLabels.tif! No compatible writer found.`. Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing `gradlew ` when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183514515
https://github.com/qupath/qupath/issues/984#issuecomment-1183514515:576,Testability,test,test,576,"This update does allow the export to run as expected when saving as ""ome.tif"". It might be useful to have a check/warning prior to attempting to write a file that is too large to a basic .tif. If I attempt the same export to .tif, after a long pause I get:. `WARN: Unable to write image; ERROR: IOException at line 22: Unable to write F:\filepath\Sox2 region_0_annotationLabels.tif! No compatible writer found.`. Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing `gradlew ` when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183514515
https://github.com/qupath/qupath/issues/984#issuecomment-1183514515:244,Usability,pause,pause,244,"This update does allow the export to run as expected when saving as ""ome.tif"". It might be useful to have a check/warning prior to attempting to write a file that is too large to a basic .tif. If I attempt the same export to .tif, after a long pause I get:. `WARN: Unable to write image; ERROR: IOException at line 22: Unable to write F:\filepath\Sox2 region_0_annotationLabels.tif! No compatible writer found.`. Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing `gradlew ` when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183514515
https://github.com/qupath/qupath/issues/984#issuecomment-1183544161:713,Availability,down,download,713,"Thanks!. > Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing gradlew when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later. Hmmm, that can happen if you've installed the latest JDK and it's now the system default, but you haven't built QuPath in a while. I tend to update gradlew as soon as I see there's a new stable release, although that tends to come a bit after the JDK. If that's the issue that got you, the 'solution' can be to set an older JDK to be the system default (e.g. Java 11) and run gradlew using that... or find some other way to run gradle with a different, older JDK. It's able to download separately the JDK it actually needs to build QuPath, separately from the JDK used to run gradle itself - if that makes any sense. More info about [toolchains here](https://docs.gradle.org/current/userguide/toolchains.html).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183544161
https://github.com/qupath/qupath/issues/984#issuecomment-1183544161:268,Deployability,install,installed,268,"Thanks!. > Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing gradlew when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later. Hmmm, that can happen if you've installed the latest JDK and it's now the system default, but you haven't built QuPath in a while. I tend to update gradlew as soon as I see there's a new stable release, although that tends to come a bit after the JDK. If that's the issue that got you, the 'solution' can be to set an older JDK to be the system default (e.g. Java 11) and run gradlew using that... or find some other way to run gradle with a different, older JDK. It's able to download separately the JDK it actually needs to build QuPath, separately from the JDK used to run gradle itself - if that makes any sense. More info about [toolchains here](https://docs.gradle.org/current/userguide/toolchains.html).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183544161
https://github.com/qupath/qupath/issues/984#issuecomment-1183544161:377,Deployability,update,update,377,"Thanks!. > Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing gradlew when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later. Hmmm, that can happen if you've installed the latest JDK and it's now the system default, but you haven't built QuPath in a while. I tend to update gradlew as soon as I see there's a new stable release, although that tends to come a bit after the JDK. If that's the issue that got you, the 'solution' can be to set an older JDK to be the system default (e.g. Java 11) and run gradlew using that... or find some other way to run gradle with a different, older JDK. It's able to download separately the JDK it actually needs to build QuPath, separately from the JDK used to run gradle itself - if that makes any sense. More info about [toolchains here](https://docs.gradle.org/current/userguide/toolchains.html).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183544161
https://github.com/qupath/qupath/issues/984#issuecomment-1183544161:430,Deployability,release,release,430,"Thanks!. > Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing gradlew when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later. Hmmm, that can happen if you've installed the latest JDK and it's now the system default, but you haven't built QuPath in a while. I tend to update gradlew as soon as I see there's a new stable release, although that tends to come a bit after the JDK. If that's the issue that got you, the 'solution' can be to set an older JDK to be the system default (e.g. Java 11) and run gradlew using that... or find some other way to run gradle with a different, older JDK. It's able to download separately the JDK it actually needs to build QuPath, separately from the JDK used to run gradle itself - if that makes any sense. More info about [toolchains here](https://docs.gradle.org/current/userguide/toolchains.html).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183544161
https://github.com/qupath/qupath/issues/984#issuecomment-1183544161:171,Testability,test,test,171,"Thanks!. > Oddly enough, I ran into trouble with the new Telerium openjdk not recognizing gradlew when trying to set that up on my new computer, but was able to build and test things out on my old one so... I will look into that later. Hmmm, that can happen if you've installed the latest JDK and it's now the system default, but you haven't built QuPath in a while. I tend to update gradlew as soon as I see there's a new stable release, although that tends to come a bit after the JDK. If that's the issue that got you, the 'solution' can be to set an older JDK to be the system default (e.g. Java 11) and run gradlew using that... or find some other way to run gradle with a different, older JDK. It's able to download separately the JDK it actually needs to build QuPath, separately from the JDK used to run gradle itself - if that makes any sense. More info about [toolchains here](https://docs.gradle.org/current/userguide/toolchains.html).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/984#issuecomment-1183544161
https://github.com/qupath/qupath/issues/986#issuecomment-1171673291:45,Availability,avail,available,45,"> However, now memory defaults to 50% of the available system memory. I would understand that this works for computers with not much RAM (e.g. 8 GB or 16 GB). But when you have 64 GB RAM or more, will using only 50% of available system memory mean having the other half of the massive RAM essentially unused?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/986#issuecomment-1171673291
https://github.com/qupath/qupath/issues/986#issuecomment-1171673291:219,Availability,avail,available,219,"> However, now memory defaults to 50% of the available system memory. I would understand that this works for computers with not much RAM (e.g. 8 GB or 16 GB). But when you have 64 GB RAM or more, will using only 50% of available system memory mean having the other half of the massive RAM essentially unused?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/986#issuecomment-1171673291
https://github.com/qupath/qupath/issues/986#issuecomment-1171921970:330,Deployability,install,installed,330,"It will still be possible to change the RAM, it just wouldn't be such a prominent option on startup. I'm not sure what the best default is, but I have the impression that more users will have too little RAM than too much - and the proportion needs to be defined when QuPath is built (I don't know any way to change it after it is installed).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/986#issuecomment-1171921970
https://github.com/qupath/qupath/issues/986#issuecomment-1308396263:184,Security,access,access,184,"Fixed by ; * https://github.com/qupath/qupath/pull/1124; * https://github.com/qupath/qupath/pull/1125. Extra comment on the memory: the limit affects Java, but JavaCPP can potentially access more memory. Therefore the most memory-hungry thing (pixel classification) isn't strictly subject to the same limit. It should still be possible to specify the memory in the preferences on Windows/Linux, but this needs checked.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/986#issuecomment-1308396263
https://github.com/qupath/qupath/issues/988#issuecomment-1145813614:149,Availability,down,down,149,"Hi @vatempeli . I can replicate the bug if I delete one of the values in the *Create thresholder* dialog, and then press one of the associated up or down arrows. The solution is to type a valid number instead. Then the arrows should work. If that's not the issue you're seeing, I'd need more details about *exactly* what steps you used. I'd also need the full log message (the top is cropped off in the screenshot, so it misses the most important information).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/988#issuecomment-1145813614
https://github.com/qupath/qupath/issues/988#issuecomment-1145813614:364,Integrability,message,message,364,"Hi @vatempeli . I can replicate the bug if I delete one of the values in the *Create thresholder* dialog, and then press one of the associated up or down arrows. The solution is to type a valid number instead. Then the arrows should work. If that's not the issue you're seeing, I'd need more details about *exactly* what steps you used. I'd also need the full log message (the top is cropped off in the screenshot, so it misses the most important information).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/988#issuecomment-1145813614
https://github.com/qupath/qupath/issues/988#issuecomment-1145813614:360,Testability,log,log,360,"Hi @vatempeli . I can replicate the bug if I delete one of the values in the *Create thresholder* dialog, and then press one of the associated up or down arrows. The solution is to type a valid number instead. Then the arrows should work. If that's not the issue you're seeing, I'd need more details about *exactly* what steps you used. I'd also need the full log message (the top is cropped off in the screenshot, so it misses the most important information).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/988#issuecomment-1145813614
https://github.com/qupath/qupath/issues/993#issuecomment-1159781538:659,Deployability,release,release,659,"Thanks for logging this after our chat about it, I agree QuPath should provide this option somewhere. I thought the LUT method was cleverer (and more effort to get working...), and it avoids some of the 'my image is all black' bug reports that otherwise ensue when exporting grayscale images that all have low pixel values and previewing them in the operating system's default viewer. But Iit is indeed a bit annoying that it requires setting the `mode` to `L` when using PIL - and also requires getting that option somehow passed through to PIL if using some library on top of it (like `imageio`). I'll try to get an optional alternative for the next QuPath release that can just output grayscale labelled images instead.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159781538
https://github.com/qupath/qupath/issues/993#issuecomment-1159781538:184,Safety,avoid,avoids,184,"Thanks for logging this after our chat about it, I agree QuPath should provide this option somewhere. I thought the LUT method was cleverer (and more effort to get working...), and it avoids some of the 'my image is all black' bug reports that otherwise ensue when exporting grayscale images that all have low pixel values and previewing them in the operating system's default viewer. But Iit is indeed a bit annoying that it requires setting the `mode` to `L` when using PIL - and also requires getting that option somehow passed through to PIL if using some library on top of it (like `imageio`). I'll try to get an optional alternative for the next QuPath release that can just output grayscale labelled images instead.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159781538
https://github.com/qupath/qupath/issues/993#issuecomment-1159781538:11,Testability,log,logging,11,"Thanks for logging this after our chat about it, I agree QuPath should provide this option somewhere. I thought the LUT method was cleverer (and more effort to get working...), and it avoids some of the 'my image is all black' bug reports that otherwise ensue when exporting grayscale images that all have low pixel values and previewing them in the operating system's default viewer. But Iit is indeed a bit annoying that it requires setting the `mode` to `L` when using PIL - and also requires getting that option somehow passed through to PIL if using some library on top of it (like `imageio`). I'll try to get an optional alternative for the next QuPath release that can just output grayscale labelled images instead.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159781538
https://github.com/qupath/qupath/issues/993#issuecomment-1159782587:511,Availability,down,downsample,511,"Actually... something that *might* help in the short term is to use the specify the color with [addLabel](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/LabeledImageServer.Builder.html#addLabel(qupath.lib.objects.classes.PathClass,int,java.lang.Integer))​, i.e.; ```groovy; // Create an ImageServer where the pixels are derived from annotations; def labelServer = new LabeledImageServer.Builder(imageData); .backgroundLabel(0, ColorTools.BLACK) // Specify background label (usually 0 or 255); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .addLabel('Tumor', 1, makeRGB(1, 1, 1)) // Choose output labels (the order matters!); .addLabel('Stroma', 2, makeRGB(2, 2, 2)); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(); ```. You might still end up with an RGB image in Python, but when I tried it briefly it gave me a 2D image without LUT - as long as my RGB colors were all grayscale.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159782587
https://github.com/qupath/qupath/issues/993#issuecomment-1159782587:522,Availability,down,downsample,522,"Actually... something that *might* help in the short term is to use the specify the color with [addLabel](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/LabeledImageServer.Builder.html#addLabel(qupath.lib.objects.classes.PathClass,int,java.lang.Integer))​, i.e.; ```groovy; // Create an ImageServer where the pixels are derived from annotations; def labelServer = new LabeledImageServer.Builder(imageData); .backgroundLabel(0, ColorTools.BLACK) // Specify background label (usually 0 or 255); .downsample(downsample) // Choose server resolution; this should match the resolution at which tiles are exported; .addLabel('Tumor', 1, makeRGB(1, 1, 1)) // Choose output labels (the order matters!); .addLabel('Stroma', 2, makeRGB(2, 2, 2)); .multichannelOutput(false) // If true, each label refers to the channel of a multichannel binary image (required for multiclass probability); .build(); ```. You might still end up with an RGB image in Python, but when I tried it briefly it gave me a 2D image without LUT - as long as my RGB colors were all grayscale.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159782587
https://github.com/qupath/qupath/issues/993#issuecomment-1159793793:188,Availability,mask,masks,188,"Nice, I can confirm that does appear to be working through fast.ai - ; ![image](https://user-images.githubusercontent.com/85200392/174496575-f5f147d1-855f-4ccb-81a5-d87fb78c5aa9.png); The masks are loading the correct number of channels in the right places now, at least!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159793793
https://github.com/qupath/qupath/issues/993#issuecomment-1159793793:198,Performance,load,loading,198,"Nice, I can confirm that does appear to be working through fast.ai - ; ![image](https://user-images.githubusercontent.com/85200392/174496575-f5f147d1-855f-4ccb-81a5-d87fb78c5aa9.png); The masks are loading the correct number of channels in the right places now, at least!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159793793
https://github.com/qupath/qupath/issues/993#issuecomment-1159796100:226,Availability,mask,mask,226,"I am glad I checked completely. Despite appearing to read in correctly, there is still some issue that saving using the LabeledImageServer does not resolve. I am not sure what the problem is, but my model, despite showing the mask correctly, trains as if the entire image is background. I am not happy to report ""something does not work somewhere"" since that will not help fix the problem, but that is where I am at. Running it through Fiji to convert to 8bit still works, however. ; Exporting the images both ways results in, as far as I can tell, identical images.; ![image](https://user-images.githubusercontent.com/85200392/174497099-16e24bec-c6db-442c-abe3-03e26d1d408a.png). However the one on the right was exported directly by the LabeledImageServer, and fails to work during training.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159796100
https://github.com/qupath/qupath/issues/993#issuecomment-1159797075:17,Testability,test,test,17,In case it helps test:; [LabeledImageServer.zip](https://github.com/qupath/qupath/files/8936245/LabeledImageServer.zip); [Resaved as 8bit Fiji.zip](https://github.com/qupath/qupath/files/8936249/Resaved.as.8bit.Fiji.zip),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/993#issuecomment-1159797075
https://github.com/qupath/qupath/issues/995#issuecomment-1167420838:1568,Energy Efficiency,efficient,efficiently,1568,"Hi @yau-lim as discussed, I agree this should be added - it would be an easy addition to `RoiTools`, and requiring `CombineOp` is awkward (not least because it's not obvious that it exists...). I suppose the difference with `union` and `intersection` is that they make sense with any number of ROIs (and so take a collection/list as input), but subtraction only really makes sense with two.... or at least that could have been what I was thinking originally. With that in mind, one option is to add; ```java; public static ROI subtract(ROI roi1, ROI roi2) {; return combineROIs(roi1, roi2, CombineOp.SUBTRACT);; }; ```; as a convenience method. But I wonder if it might be even more useful to add; ```java; public static ROI subtract(ROI baseROI, ROI... roisToSubtract) {; // Loop through one or more roisToSubtract, and remove then from baseROI; }; ```; What do you think? Would this output match your expectation for 'subtraction that supports multiple arguments'?. The 'optional array' syntax proposed above would support all the following:; ```groovy; def roiOutput1 = RoiTools.subtract(roi1) // Returns roi1 unchanged; def roiOutput2 = RoiTools.subtract(roi1, roi2) // Returns roi1 with pixels in roi2 removed; def roiOutput3 = RoiTools.subtract(roi1, roi2, roi3, roi4) // Returns roi1 with pixels in the union of roi2, roi3 and roi4 removed; ```. Alternatively, we could stick with just two arguments and then require; ```groovy; def roiOutput3 = RoiTools.subtract(roi1, RoiTools.union(roi2, roi3, roi4)); ```; to get the third output above (albeit perhaps less efficiently).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/995#issuecomment-1167420838
https://github.com/qupath/qupath/issues/995#issuecomment-1167534365:144,Testability,log,logically,144,"```; def roiOutput3 = RoiTools.subtract(roi1, RoiTools.union(roi2, roi3, roi4)); ```; makes sense to me by building/layering functions together logically but from your other suggestions, maybe. ```; public static ROI subtract(ROI baseROI, Collection<ROI> roisToSubtract) {; // Loop through one or more roisToSubtract, and remove them from baseROI; }; ```; will make it clear/less ambiguous to which ROIs are being subtracted from the baseROI, e.g.; ```; def roiOutput = RoiTools.subtract(baseROI, [roi1, roi2, roi3, ...]); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/995#issuecomment-1167534365
https://github.com/qupath/qupath/issues/995#issuecomment-1167534365:369,Usability,clear,clear,369,"```; def roiOutput3 = RoiTools.subtract(roi1, RoiTools.union(roi2, roi3, roi4)); ```; makes sense to me by building/layering functions together logically but from your other suggestions, maybe. ```; public static ROI subtract(ROI baseROI, Collection<ROI> roisToSubtract) {; // Loop through one or more roisToSubtract, and remove them from baseROI; }; ```; will make it clear/less ambiguous to which ROIs are being subtracted from the baseROI, e.g.; ```; def roiOutput = RoiTools.subtract(baseROI, [roi1, roi2, roi3, ...]); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/995#issuecomment-1167534365
https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120:631,Energy Efficiency,reduce,reduce,631,"Adding simple text fields to objects would certainly be nice for cluster/neighborhood/external to QuPath analyses where users may prefer to add non-class labels like ""immune dense cluster"" rather than ""1"" and look up what 1 was. Especially in cases involving many clusters. ; Possibly make it locked behind a default ""Off"" setting. I am guessing it might result in data file sizes getting somewhat out of hand in the cases of millions of cells?. I am less certain that detection objects should have descriptions, but maybe making a ""toAnnotation"" or ""toDetection"" function to make object type swapping simpler when scripting would reduce the need to place complex labels on detections.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120
https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120:469,Safety,detect,detection,469,"Adding simple text fields to objects would certainly be nice for cluster/neighborhood/external to QuPath analyses where users may prefer to add non-class labels like ""immune dense cluster"" rather than ""1"" and look up what 1 was. Especially in cases involving many clusters. ; Possibly make it locked behind a default ""Off"" setting. I am guessing it might result in data file sizes getting somewhat out of hand in the cases of millions of cells?. I am less certain that detection objects should have descriptions, but maybe making a ""toAnnotation"" or ""toDetection"" function to make object type swapping simpler when scripting would reduce the need to place complex labels on detections.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120
https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120:674,Safety,detect,detections,674,"Adding simple text fields to objects would certainly be nice for cluster/neighborhood/external to QuPath analyses where users may prefer to add non-class labels like ""immune dense cluster"" rather than ""1"" and look up what 1 was. Especially in cases involving many clusters. ; Possibly make it locked behind a default ""Off"" setting. I am guessing it might result in data file sizes getting somewhat out of hand in the cases of millions of cells?. I am less certain that detection objects should have descriptions, but maybe making a ""toAnnotation"" or ""toDetection"" function to make object type swapping simpler when scripting would reduce the need to place complex labels on detections.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120
https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120:7,Usability,simpl,simple,7,"Adding simple text fields to objects would certainly be nice for cluster/neighborhood/external to QuPath analyses where users may prefer to add non-class labels like ""immune dense cluster"" rather than ""1"" and look up what 1 was. Especially in cases involving many clusters. ; Possibly make it locked behind a default ""Off"" setting. I am guessing it might result in data file sizes getting somewhat out of hand in the cases of millions of cells?. I am less certain that detection objects should have descriptions, but maybe making a ""toAnnotation"" or ""toDetection"" function to make object type swapping simpler when scripting would reduce the need to place complex labels on detections.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120
https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120:602,Usability,simpl,simpler,602,"Adding simple text fields to objects would certainly be nice for cluster/neighborhood/external to QuPath analyses where users may prefer to add non-class labels like ""immune dense cluster"" rather than ""1"" and look up what 1 was. Especially in cases involving many clusters. ; Possibly make it locked behind a default ""Off"" setting. I am guessing it might result in data file sizes getting somewhat out of hand in the cases of millions of cells?. I am less certain that detection objects should have descriptions, but maybe making a ""toAnnotation"" or ""toDetection"" function to make object type swapping simpler when scripting would reduce the need to place complex labels on detections.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180616120
https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703:883,Modifiability,portab,portable,883,"Thanks @MichaelSNelson! The main idea here is to support adding text but without really specifying what that has to be... so someone could use it in the way you describe for clustering, but could use it for something else entirely. The use cases I'm thinking of here are really; * teaching, where an object annotation could be some useful explanatory text; * recording thoughts... where an object (or full image) annotation could be some comment on the image or analysis, e.g. *'excluded because of quality issues'*, or *'annotated by Pete on a rainy Tuesday'* etc. But it could also be a link to a website, a GitHub repository, or even even the text for a script used for the processing. For these, it needs to display nicely - hence the html support. > Extra intention: make it possible to export a summary markdown report, including image thumbnails. This could be used to give a portable, readable summary of an entire project in html. That could be handy, e.g. when asking a pathologist to QC a lot of annotations. For analysis-oriented things like the clustering application, it's already technically possible to use; ```groovy; getSelectedObject().storeMetadataValue('My key', 'My value'); fireHierarchyUpdate(); ```; currently, but only because of Groovy's laxity (the methods are `protected`) - and it won't show up in any results tables. It will also have all the detections-suddenly-use-a-whole-lot-more-memory issue, so *really* isn't to be encouraged at the moment. Nevertheless, exposing access to the arbitrary metadata map an official part of the API could be another new feature.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703
https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703:1374,Safety,detect,detections-suddenly-use-a-whole-lot-more-memory,1374,"Thanks @MichaelSNelson! The main idea here is to support adding text but without really specifying what that has to be... so someone could use it in the way you describe for clustering, but could use it for something else entirely. The use cases I'm thinking of here are really; * teaching, where an object annotation could be some useful explanatory text; * recording thoughts... where an object (or full image) annotation could be some comment on the image or analysis, e.g. *'excluded because of quality issues'*, or *'annotated by Pete on a rainy Tuesday'* etc. But it could also be a link to a website, a GitHub repository, or even even the text for a script used for the processing. For these, it needs to display nicely - hence the html support. > Extra intention: make it possible to export a summary markdown report, including image thumbnails. This could be used to give a portable, readable summary of an entire project in html. That could be handy, e.g. when asking a pathologist to QC a lot of annotations. For analysis-oriented things like the clustering application, it's already technically possible to use; ```groovy; getSelectedObject().storeMetadataValue('My key', 'My value'); fireHierarchyUpdate(); ```; currently, but only because of Groovy's laxity (the methods are `protected`) - and it won't show up in any results tables. It will also have all the detections-suddenly-use-a-whole-lot-more-memory issue, so *really* isn't to be encouraged at the moment. Nevertheless, exposing access to the arbitrary metadata map an official part of the API could be another new feature.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703
https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703:1502,Security,access,access,1502,"Thanks @MichaelSNelson! The main idea here is to support adding text but without really specifying what that has to be... so someone could use it in the way you describe for clustering, but could use it for something else entirely. The use cases I'm thinking of here are really; * teaching, where an object annotation could be some useful explanatory text; * recording thoughts... where an object (or full image) annotation could be some comment on the image or analysis, e.g. *'excluded because of quality issues'*, or *'annotated by Pete on a rainy Tuesday'* etc. But it could also be a link to a website, a GitHub repository, or even even the text for a script used for the processing. For these, it needs to display nicely - hence the html support. > Extra intention: make it possible to export a summary markdown report, including image thumbnails. This could be used to give a portable, readable summary of an entire project in html. That could be handy, e.g. when asking a pathologist to QC a lot of annotations. For analysis-oriented things like the clustering application, it's already technically possible to use; ```groovy; getSelectedObject().storeMetadataValue('My key', 'My value'); fireHierarchyUpdate(); ```; currently, but only because of Groovy's laxity (the methods are `protected`) - and it won't show up in any results tables. It will also have all the detections-suddenly-use-a-whole-lot-more-memory issue, so *really* isn't to be encouraged at the moment. Nevertheless, exposing access to the arbitrary metadata map an official part of the API could be another new feature.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180644703
https://github.com/qupath/qupath/issues/1005#issuecomment-1180666508:16,Energy Efficiency,efficient,efficient,16,"Actually... the efficient way to do the clustering would perhaps be to add the number to the measurement list, and then include the 'key' in the text field of the image (the root object of the hierarchy... if support for this is added). The memory requires to add an extra number to a measurement list is very small compared to the memory required to add a new metadata string. And the important thing for the key is that it's human-readable (although it could be stored in an script-readable way instead, if needed).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1005#issuecomment-1180666508
https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909:65,Availability,avail,available,65,"Upon further exploration, removing 'Original RGB' as the 'first' available channel could be more problematic/confusing whenever image types are changed. However, I think there's no justification for `Normalized OD colors` being available. Therefore proposed 'fix' is just to remove that as an option when using RGB fluorescence images. Channel toggling is still possible, it just involves adding one (i.e. 2 for red, 3 for green, 4 for blue). This doesn't feel optimal, but does feel less scary in the short term at least. ### Before; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 32 08"" src=""https://user-images.githubusercontent.com/4690904/178557437-e19f71c1-f733-4483-9fbb-3ef04943bfb4.png"">. ### After; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 31 48"" src=""https://user-images.githubusercontent.com/4690904/178557465-7937107a-bc8c-43c2-a658-cc5572536ddd.png"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909
https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909:228,Availability,avail,available,228,"Upon further exploration, removing 'Original RGB' as the 'first' available channel could be more problematic/confusing whenever image types are changed. However, I think there's no justification for `Normalized OD colors` being available. Therefore proposed 'fix' is just to remove that as an option when using RGB fluorescence images. Channel toggling is still possible, it just involves adding one (i.e. 2 for red, 3 for green, 4 for blue). This doesn't feel optimal, but does feel less scary in the short term at least. ### Before; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 32 08"" src=""https://user-images.githubusercontent.com/4690904/178557437-e19f71c1-f733-4483-9fbb-3ef04943bfb4.png"">. ### After; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 31 48"" src=""https://user-images.githubusercontent.com/4690904/178557465-7937107a-bc8c-43c2-a658-cc5572536ddd.png"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909
https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909:423,Energy Efficiency,green,green,423,"Upon further exploration, removing 'Original RGB' as the 'first' available channel could be more problematic/confusing whenever image types are changed. However, I think there's no justification for `Normalized OD colors` being available. Therefore proposed 'fix' is just to remove that as an option when using RGB fluorescence images. Channel toggling is still possible, it just involves adding one (i.e. 2 for red, 3 for green, 4 for blue). This doesn't feel optimal, but does feel less scary in the short term at least. ### Before; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 32 08"" src=""https://user-images.githubusercontent.com/4690904/178557437-e19f71c1-f733-4483-9fbb-3ef04943bfb4.png"">. ### After; <img width=""1732"" alt=""Screenshot 2022-07-12 at 18 31 48"" src=""https://user-images.githubusercontent.com/4690904/178557465-7937107a-bc8c-43c2-a658-cc5572536ddd.png"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1006#issuecomment-1182093909
https://github.com/qupath/qupath/issues/1020#issuecomment-1186083543:173,Deployability,release,release,173,"Thanks @MalgorzataSzolkowska , this comes from the same underlying bug as these:; * #894 ; * #904 ; * #973. I've already fixed it in the code, so it should work in the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1020#issuecomment-1186083543
https://github.com/qupath/qupath/issues/1020#issuecomment-1186103119:331,Deployability,release,release,331,"Thank you for your prompt response!. When I was searching for resolution of similar bug in previous issues I couldn’t find any. Perhaps because I thought the problem appears only for vsi (Olympus) format. I agree #894 refers to the similar problem as mine although they were launching Hamamatsu slides. Looking forward to the next release of my favourite platform QuPath! 😊. Have a nice weekend,; Malgorzata Szolkowska; ____________; Malgorzata Szolkowska, MD, PhD, DSc, Assoc. Prof.; The Institute of Tuberculosis and Lung Diseases; Department of Pathology; Plocka 26; PL-01138, Warsaw, Poland; Tel.: +48 22 43 12 257. > Wiadomość napisana przez Pete ***@***.***> w dniu 16.07.2022, o godz. 06:07:; > ; > ; > Thanks @MalgorzataSzolkowska <https://github.com/MalgorzataSzolkowska> , this comes from the same underlying bug as these:; > ; > #894 <https://github.com/qupath/qupath/issues/894>; > #904 <https://github.com/qupath/qupath/issues/904>; > #973 <https://github.com/qupath/qupath/issues/973>; > I've already fixed it in the code, so it should work in the next release.; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/1020#issuecomment-1186083543>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/A2CTSQHEGFTSDUI5NRQGJQLVUIYORANCNFSM53XGOATA>.; > You are receiving this because you were mentioned.; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1020#issuecomment-1186103119
https://github.com/qupath/qupath/issues/1020#issuecomment-1186103119:1067,Deployability,release,release,1067,"Thank you for your prompt response!. When I was searching for resolution of similar bug in previous issues I couldn’t find any. Perhaps because I thought the problem appears only for vsi (Olympus) format. I agree #894 refers to the similar problem as mine although they were launching Hamamatsu slides. Looking forward to the next release of my favourite platform QuPath! 😊. Have a nice weekend,; Malgorzata Szolkowska; ____________; Malgorzata Szolkowska, MD, PhD, DSc, Assoc. Prof.; The Institute of Tuberculosis and Lung Diseases; Department of Pathology; Plocka 26; PL-01138, Warsaw, Poland; Tel.: +48 22 43 12 257. > Wiadomość napisana przez Pete ***@***.***> w dniu 16.07.2022, o godz. 06:07:; > ; > ; > Thanks @MalgorzataSzolkowska <https://github.com/MalgorzataSzolkowska> , this comes from the same underlying bug as these:; > ; > #894 <https://github.com/qupath/qupath/issues/894>; > #904 <https://github.com/qupath/qupath/issues/904>; > #973 <https://github.com/qupath/qupath/issues/973>; > I've already fixed it in the code, so it should work in the next release.; > ; > —; > Reply to this email directly, view it on GitHub <https://github.com/qupath/qupath/issues/1020#issuecomment-1186083543>, or unsubscribe <https://github.com/notifications/unsubscribe-auth/A2CTSQHEGFTSDUI5NRQGJQLVUIYORANCNFSM53XGOATA>.; > You are receiving this because you were mentioned.; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1020#issuecomment-1186103119
https://github.com/qupath/qupath/issues/1020#issuecomment-1186393557:204,Availability,avail,available,204,"Thanks! And yes, I found the previous reports hard to find as well, even though I remembered writing them :) I've just reopened; * #894 . and changed the wording to make it easier to find until v0.4.0 is available.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1020#issuecomment-1186393557
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:181,Deployability,update,updated,181,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:1196,Deployability,update,updated,1196,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:362,Modifiability,inherit,inheriting,362,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:334,Safety,detect,detection,334,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:1105,Safety,detect,detections,1105,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712:439,Usability,clear,clear,439,"Hi @KidElectric I agree that's a bit odd and it took me a while to figure out what was going on. I think it's a consequence of QuPath evolving a bit and the old docs not being kept updated. And me hardly ever working with TMAs for years now. Basically, the TMA core is locked. The locking happens whenever the core is used for object detection. It's essentially inheriting the same behavior as for annotations. Unfortunately it's not very clear when an object is locked; QuPath v0.4.0 will make this more obvious through the UI thanks to; * #924. In the meantime, calling `getTMACoreList().each { it.setLocked(false) }` should resolve it. I suspect - but don't entirely remember - that `TMACoreObject.isEditible()` existed before object locking became a thing in QuPath, and when [the object hierarchy was more strict](https://petebankhead.github.io/qupath/2019/11/17/changing-the-hierarchy.html), as a way to make it harder to completely mess up TMA data by shifting a core ROI by a few pixels. It should possibly be removed, since locking gives a better way to control ROI editability than checking for detections. (I hope that helps - I'll keep this issue open at least until the javadocs are updated.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190617712
https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393:343,Deployability,update,update,343,Hi @petebankhead - thank you for your helpful reply! That does the trick. It totally makes sense to lock annotations once a detection is performed. I got distracted by isEditable and didn't realize to check what other relevant methods might be inherited. I agree with removing isEditable() and I look forward to the locked/unlocked annotation update! Thank you for the great tool!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393
https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393:244,Modifiability,inherit,inherited,244,Hi @petebankhead - thank you for your helpful reply! That does the trick. It totally makes sense to lock annotations once a detection is performed. I got distracted by isEditable and didn't realize to check what other relevant methods might be inherited. I agree with removing isEditable() and I look forward to the locked/unlocked annotation update! Thank you for the great tool!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393
https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393:137,Performance,perform,performed,137,Hi @petebankhead - thank you for your helpful reply! That does the trick. It totally makes sense to lock annotations once a detection is performed. I got distracted by isEditable and didn't realize to check what other relevant methods might be inherited. I agree with removing isEditable() and I look forward to the locked/unlocked annotation update! Thank you for the great tool!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393
https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393:124,Safety,detect,detection,124,Hi @petebankhead - thank you for your helpful reply! That does the trick. It totally makes sense to lock annotations once a detection is performed. I got distracted by isEditable and didn't realize to check what other relevant methods might be inherited. I agree with removing isEditable() and I look forward to the locked/unlocked annotation update! Thank you for the great tool!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1190645393
https://github.com/qupath/qupath/issues/1021#issuecomment-1287130611:43,Deployability,release,release,43,"This should be improved in the next QuPath release (v0.4.0) - and I've marked `isEditable()` as deprecated, with a note that it now just returns the opposite of `isLocked()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1021#issuecomment-1287130611
https://github.com/qupath/qupath/issues/1023#issuecomment-1192458814:58,Performance,load,loaded,58,"@petebankhead As you suspected, the images open fine when loaded from a project so could be #894. In this instance there are also multiple images in each file and I think it is opened with Bio-formats. Sorry for the extraneous bug report.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1023#issuecomment-1192458814
https://github.com/qupath/qupath/issues/1023#issuecomment-1192464518:98,Deployability,release,release,98,"No problem! The same bug has turned up in surprising ways, but all should be resolved in the next release. Thanks for confirming the workaround works for now!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1023#issuecomment-1192464518
https://github.com/qupath/qupath/issues/1027#issuecomment-1198350412:85,Deployability,release,releases,85,"> One easy way. Do you have any advice on how to streamline that, while using GitHub releases?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1198350412
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:241,Availability,down,download,241,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:39,Deployability,Release,Release,39,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:101,Deployability,Release,Release-Hashes,101,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:117,Deployability,Release,Release,117,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:47,Security,hash,hash,47,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309:109,Security,Hash,Hashes,109,I recently found resources like this:. Release hash:; https://github.com/MCJack123/ghaction-Generate-Release-Hashes. Release signing:; https://wiki.debian.org/Creating%20signed%20GitHub%20releases (which equally allows one to verify a given download),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1200433309
https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738:18,Availability,avail,available,18,Is an sha256 hash available for the current Qupath (0.3.2) release? (specifically the windows distribution?),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738
https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738:59,Deployability,release,release,59,Is an sha256 hash available for the current Qupath (0.3.2) release? (specifically the windows distribution?),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738
https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738:13,Security,hash,hash,13,Is an sha256 hash available for the current Qupath (0.3.2) release? (specifically the windows distribution?),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1207982738
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:51,Availability,avail,available,51,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:221,Availability,down,download,221,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:982,Availability,down,download,982,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:71,Deployability,release,release,71,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:308,Deployability,release,release,308,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:682,Deployability,install,installed,682,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:902,Deployability,Release,Release,902,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:960,Deployability,release,release,960,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1213,Deployability,release,release,1213,"nerated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this befo",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1548,Deployability,release,release,1548,"s needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1595,Deployability,release,release,1595,"s needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1643,Deployability,release,release,1643,"s needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1672,Deployability,update,update,1672,"s needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1710,Deployability,release,release,1710,"ple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea, I don't really like the associated admin (the cost doesn't help either)...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1825,Deployability,release,release,1825,"ple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea, I don't really like the associated admin (the cost doesn't help either)...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:2052,Deployability,release,releases,2052,"ple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea, I don't really like the associated admin (the cost doesn't help either)...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:2179,Deployability,release,release,2179,"ple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea, I don't really like the associated admin (the cost doesn't help either)...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:2268,Deployability,pipeline,pipeline,2268,"ple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting it right, and potentially make several 'accidental' releases along the way... confusing the version numbering. Therefore while I'd like to be able to explore this before the next release, but there's a very strong chance I won't have time to set up or debug the whole pipeline. If anyone else wants to work on improving the workflow, and contending with its messiness by checking the proposed solution really does work properly on all platforms, suggestions or PR's welcome!. > Sidenote: A related concern is that I've been asked several times for signed distributions. Much as I like the idea, I don't really like the associated admin (the cost doesn't help either)...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:801,Safety,avoid,avoid,801,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:972,Safety,avoid,avoid,972,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:9,Security,Hash,Hashes,9,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371:1031,Security,hash,hashes,1031,"@mezwick Hashes aren't currently generated or made available. Making a release remains a fairly laborious and manual process. Although the builds themselves are now generated automatically using GitHub Actions, I have to download and check these run on each platform and then upload again. And write all the release notes, tag the version etc. There can also be some extra renaming required, since `jpackage` (used for the build) has some awkwardness connected to artefact naming and 0.x.x versions that affects some platforms but not others (e.g. I think macOS forbids 0.x.x versions, so this needs worked around; also, it needs to be possible for people to have multiple versions installed for reproducibility). It's already a real pain to do, and I don't want to add any more manual steps if I can avoid it. It would be strongly preferable to automate the whole process a bit more, using [Upload to Release](https://github.com/marketplace/actions/upload-to-release) to avoid the download/upload requirement, and somehow include hashes (e.g. using the links from @KrisJanssen's last post) at that point. This seems to me at least a bit awkward to set up though, since the upload action is only triggered when a release is made. The [build workflow](https://github.com/qupath/qupath/blob/v0.3.2/.github/workflows/jpackage.yml) would have to be quite a bit more complex (e.g. to handle cross-platform filenames/content types for the builds, as well as different artefact compression methods). I'd also still need to retain the ability to check the release manually on each platform *before* the release itself is created, because creating the release is what triggers any update notifications... and after the release has been tagged is a bad time to identify some platform-specific breakage. These tend to happen with every release, e.g. because some dialog ends up misbehaving on Ubuntu but looks fine everywhere else. I strongly suspect I'd mess it up quite a few times before (hopefully) getting i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208071371
https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614:225,Deployability,install,installer,225,"@petebankhead : I can certainly understand you need to carefully balance workload. As our organization is somewhat rigorous regarding this topic I have looked into things further and it seems you mercifully use an accessible installer solution and as such I have been able to build it from source in full. This way, we can perform static code review and use an internally built binary, currently removing the need to obtain the hash from you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614
https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614:323,Performance,perform,perform,323,"@petebankhead : I can certainly understand you need to carefully balance workload. As our organization is somewhat rigorous regarding this topic I have looked into things further and it seems you mercifully use an accessible installer solution and as such I have been able to build it from source in full. This way, we can perform static code review and use an internally built binary, currently removing the need to obtain the hash from you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614
https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614:214,Security,access,accessible,214,"@petebankhead : I can certainly understand you need to carefully balance workload. As our organization is somewhat rigorous regarding this topic I have looked into things further and it seems you mercifully use an accessible installer solution and as such I have been able to build it from source in full. This way, we can perform static code review and use an internally built binary, currently removing the need to obtain the hash from you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614
https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614:428,Security,hash,hash,428,"@petebankhead : I can certainly understand you need to carefully balance workload. As our organization is somewhat rigorous regarding this topic I have looked into things further and it seems you mercifully use an accessible installer solution and as such I have been able to build it from source in full. This way, we can perform static code review and use an internally built binary, currently removing the need to obtain the hash from you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1027#issuecomment-1208463614
https://github.com/qupath/qupath/issues/1029#issuecomment-1199900807:597,Performance,queue,queue,597,"As you pointed out, the final image can be used just as in the [second post](https://forum.image.sc/t/qupath-audible-alert-windows-when-script-is-complete/46919?u=mike_nelson) about this. It has come up before for both [email ](https://gist.github.com/Svidro/5e4c29630e8d2ef36988184987d1028f#file-email-alert-py)and [telegram](https://forum.image.sc/t/qupath-script-telegram-messenger-alerts-how-to-set-up/56288), which is my preference. . I agree it would be nice to have something built in, but as long as you have a uniquely named file, that file can also be placed last in the Run for Project queue. Move the target file to the left, and then back to the right and it will always be at the bottom of the queue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1199900807
https://github.com/qupath/qupath/issues/1029#issuecomment-1199900807:708,Performance,queue,queue,708,"As you pointed out, the final image can be used just as in the [second post](https://forum.image.sc/t/qupath-audible-alert-windows-when-script-is-complete/46919?u=mike_nelson) about this. It has come up before for both [email ](https://gist.github.com/Svidro/5e4c29630e8d2ef36988184987d1028f#file-email-alert-py)and [telegram](https://forum.image.sc/t/qupath-script-telegram-messenger-alerts-how-to-set-up/56288), which is my preference. . I agree it would be nice to have something built in, but as long as you have a uniquely named file, that file can also be placed last in the Run for Project queue. Move the target file to the left, and then back to the right and it will always be at the bottom of the queue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1199900807
https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804:163,Energy Efficiency,power,power,163,"I've looked into this a little bit. I've never really needed or wanted this feature myself, but can see it would certainly help in some contexts. My worry is that power users running long scripts will tend to want different ways of being notified that the script is finished. Ideas that come to mind are:; * Something audible, e.g. the beep; * Email/telegram; * 'Requesting attention', e.g. forcing the app to the front; * A small, unobtrusive progress bar that can be 'always on top' (even if QuPath isn't). I'm not sure adding one option to the batch script dialog will be enough to solve the problem, and adding many becomes a lot more clutter and effort to maintain. To overcome that, my initial idea was to provide the option of adding a 'batch script listener' to the script editor. . So you could add a listener using something like this (in Groovy):; ```groovy; def scriptEditor = getQuPath().getScriptEditor(); scriptEditor.addBatchScriptListener(e -> {; if (e.isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; }); ```. The thing is that the listeners would be cumulative, so you'd likely want to just add one on startup and leave it (rather than add multiple listeners and then have them all firing when scripts are run). But then it becomes harder to turn it on/off the listener's behavior. Nevertheless, this approach would make it possible to add small extensions that offer different kinds of behavior, controlled via preferences or something else. So you could have a preference allowing the user to choose the audio file they want played on completion, for example.... but still, remembering to turn the option on and off could be a pain, since it wouldn't be easy to incorporate it as a checkbox in the batch processing dialog itself. While writing this, another option I've thought of is to make more info about the current script accessible within the script itself. So it might look like this:. ```groovy; if (getScriptInfo().i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804
https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804:2271,Safety,avoid,avoids,2271," * 'Requesting attention', e.g. forcing the app to the front; * A small, unobtrusive progress bar that can be 'always on top' (even if QuPath isn't). I'm not sure adding one option to the batch script dialog will be enough to solve the problem, and adding many becomes a lot more clutter and effort to maintain. To overcome that, my initial idea was to provide the option of adding a 'batch script listener' to the script editor. . So you could add a listener using something like this (in Groovy):; ```groovy; def scriptEditor = getQuPath().getScriptEditor(); scriptEditor.addBatchScriptListener(e -> {; if (e.isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; }); ```. The thing is that the listeners would be cumulative, so you'd likely want to just add one on startup and leave it (rather than add multiple listeners and then have them all firing when scripts are run). But then it becomes harder to turn it on/off the listener's behavior. Nevertheless, this approach would make it possible to add small extensions that offer different kinds of behavior, controlled via preferences or something else. So you could have a preference allowing the user to choose the audio file they want played on completion, for example.... but still, remembering to turn the option on and off could be a pain, since it wouldn't be easy to incorporate it as a checkbox in the batch processing dialog itself. While writing this, another option I've thought of is to make more info about the current script accessible within the script itself. So it might look like this:. ```groovy; if (getScriptInfo().isBatchProcessing() && getScriptInfo().isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; ```. So any notification would be something pasted at the end of the script itself. It's like @MichaelSNelson's approach except avoids worrying so much about the last file being uniquely named. What do you all think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804
https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804:1903,Security,access,accessible,1903," * 'Requesting attention', e.g. forcing the app to the front; * A small, unobtrusive progress bar that can be 'always on top' (even if QuPath isn't). I'm not sure adding one option to the batch script dialog will be enough to solve the problem, and adding many becomes a lot more clutter and effort to maintain. To overcome that, my initial idea was to provide the option of adding a 'batch script listener' to the script editor. . So you could add a listener using something like this (in Groovy):; ```groovy; def scriptEditor = getQuPath().getScriptEditor(); scriptEditor.addBatchScriptListener(e -> {; if (e.isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; }); ```. The thing is that the listeners would be cumulative, so you'd likely want to just add one on startup and leave it (rather than add multiple listeners and then have them all firing when scripts are run). But then it becomes harder to turn it on/off the listener's behavior. Nevertheless, this approach would make it possible to add small extensions that offer different kinds of behavior, controlled via preferences or something else. So you could have a preference allowing the user to choose the audio file they want played on completion, for example.... but still, remembering to turn the option on and off could be a pain, since it wouldn't be easy to incorporate it as a checkbox in the batch processing dialog itself. While writing this, another option I've thought of is to make more info about the current script accessible within the script itself. So it might look like this:. ```groovy; if (getScriptInfo().isBatchProcessing() && getScriptInfo().isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; ```. So any notification would be something pasted at the end of the script itself. It's like @MichaelSNelson's approach except avoids worrying so much about the last file being uniquely named. What do you all think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804
https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804:444,Usability,progress bar,progress bar,444,"I've looked into this a little bit. I've never really needed or wanted this feature myself, but can see it would certainly help in some contexts. My worry is that power users running long scripts will tend to want different ways of being notified that the script is finished. Ideas that come to mind are:; * Something audible, e.g. the beep; * Email/telegram; * 'Requesting attention', e.g. forcing the app to the front; * A small, unobtrusive progress bar that can be 'always on top' (even if QuPath isn't). I'm not sure adding one option to the batch script dialog will be enough to solve the problem, and adding many becomes a lot more clutter and effort to maintain. To overcome that, my initial idea was to provide the option of adding a 'batch script listener' to the script editor. . So you could add a listener using something like this (in Groovy):; ```groovy; def scriptEditor = getQuPath().getScriptEditor(); scriptEditor.addBatchScriptListener(e -> {; if (e.isLastScript()) {; // Do something... beep, email, whatever; java.awt.Toolkit.defaultToolkit.beep(); }; }); ```. The thing is that the listeners would be cumulative, so you'd likely want to just add one on startup and leave it (rather than add multiple listeners and then have them all firing when scripts are run). But then it becomes harder to turn it on/off the listener's behavior. Nevertheless, this approach would make it possible to add small extensions that offer different kinds of behavior, controlled via preferences or something else. So you could have a preference allowing the user to choose the audio file they want played on completion, for example.... but still, remembering to turn the option on and off could be a pain, since it wouldn't be easy to incorporate it as a checkbox in the batch processing dialog itself. While writing this, another option I've thought of is to make more info about the current script accessible within the script itself. So it might look like this:. ```groovy; if (getScriptInfo().i",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1029#issuecomment-1200084804
https://github.com/qupath/qupath/issues/1032#issuecomment-1203137853:176,Performance,optimiz,optimization,176,"Thanks @Svidro - and also for linking to the code. That reminds me why I didn't do it before... the code is *very* involved. I vaguely remember it going through some rounds of optimization and having to deal with corner cases (like mixtures of lines, areas and points). I agree it's necessary but may be tricky, not sure where I'll get time to delve into it again.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1032#issuecomment-1203137853
https://github.com/qupath/qupath/issues/1034#issuecomment-1205338080:94,Testability,log,logic,94,"Hi @GeorgeEVHB QuPath is using Bio-Formats to read .vsi files. There is a small bit of custom logic in QuPath to overcome some .vsi weirdness (with image dimensions not being as expected), which *could* be relevant... but may well not be. I'd suggest posting a question on the forum at https://forum.image.sc/tag/qupath and tagging it both with `qupath` and `bio-formats` as the easiest way to contact developers of both simultaneously. If you can share an example image there that would be very helpful. There are also lots of vsi-related discussions already on the forum, but I'm not sure if any of them match: https://forum.image.sc/search?q=vsi%20qupath. For example, this one might be relevant, but there isn't enough info for me to act on: https://forum.image.sc/t/difficulties-opening-vsi-files-in-qupath-0-3-2/64938/3",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1034#issuecomment-1205338080
https://github.com/qupath/qupath/issues/1035#issuecomment-1213304415:152,Integrability,message,message,152,"@XinyeDu1204 as @MichaelSNelson says, questions about QuPath should be posted on the forum at https://forum.image.sc/tag/qupath. You should have seen a message saying this when you tried to create this GitHub issue, and it's also stated on this page (under the 'labels' column). It's important to keep questions and answers in the same place so that others can find them. There are well over 2,000 discussions about QuPath on the forum, with lots involving XML: https://forum.image.sc/search?q=qupath%20xml. For example, see https://forum.image.sc/t/export-pixel-selection-as-image-scope-xml-format/26549/2. I will close this issue now, feel free to start a discussion on the forum if you have further questions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1035#issuecomment-1213304415
https://github.com/qupath/qupath/pull/1037#issuecomment-1219437840:256,Safety,avoid,avoid,256,"Thanks @zindy I'll try to have a look later. First thought is that I'd rather *not* have the second commit, unless you have a clear need for a public `getPreviouslySelectedTool()` method?. In general, I'd rather shrink the API and make it more stable, and avoid adding public methods just-in-case. But it could be added if it is really needed somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219437840
https://github.com/qupath/qupath/pull/1037#issuecomment-1219437840:126,Usability,clear,clear,126,"Thanks @zindy I'll try to have a look later. First thought is that I'd rather *not* have the second commit, unless you have a clear need for a public `getPreviouslySelectedTool()` method?. In general, I'd rather shrink the API and make it more stable, and avoid adding public methods just-in-case. But it could be added if it is really needed somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219437840
https://github.com/qupath/qupath/pull/1037#issuecomment-1219444033:73,Testability,test,testing,73,"I totally understand, this does look like a ""just-in-case"" method. I was testing gestures with the jpen extension and thought that with previousTool being private, there wasn't a mechanism to swap tools (I mean from move to previously selected) from anywhere else than within the QuPathGUI class. I'll revert the change.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219444033
https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529:586,Deployability,toggle,toggle,586,"I tested some old mice (that got hidden away for a reason), and their wheel button triggered multiple events at times. This behaviour was corrected with a 10ms debounce. Am I OK to add a (if you're happy with the variable name) :. ```; 	private long lastMousePressedWheel = 0L;; ```. and then, the `e.isMiddleButtonDown()` event would be handled as such:; ```; 			else if (e.isMiddleButtonDown()) {; 				//For 10ms after the first click, ignore all additional events; 				long time = System.currentTimeMillis();; 				if (time - lastMousePressedWheel < 10); 					return;. 				// Here we toggle between the MOVE tool and any previously selected tool; 				if (getSelectedTool() == PathTools.MOVE); 					setSelectedTool(previousTool);; 				else; 					setSelectedTool(PathTools.MOVE);; 				lastMousePressedWheel = time;; 			}; ```. I'm hoping to reuse the same variable to debounce the horizontal scroll buttons as well, hence the name.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529
https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529:213,Modifiability,variab,variable,213,"I tested some old mice (that got hidden away for a reason), and their wheel button triggered multiple events at times. This behaviour was corrected with a 10ms debounce. Am I OK to add a (if you're happy with the variable name) :. ```; 	private long lastMousePressedWheel = 0L;; ```. and then, the `e.isMiddleButtonDown()` event would be handled as such:; ```; 			else if (e.isMiddleButtonDown()) {; 				//For 10ms after the first click, ignore all additional events; 				long time = System.currentTimeMillis();; 				if (time - lastMousePressedWheel < 10); 					return;. 				// Here we toggle between the MOVE tool and any previously selected tool; 				if (getSelectedTool() == PathTools.MOVE); 					setSelectedTool(previousTool);; 				else; 					setSelectedTool(PathTools.MOVE);; 				lastMousePressedWheel = time;; 			}; ```. I'm hoping to reuse the same variable to debounce the horizontal scroll buttons as well, hence the name.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529
https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529:856,Modifiability,variab,variable,856,"I tested some old mice (that got hidden away for a reason), and their wheel button triggered multiple events at times. This behaviour was corrected with a 10ms debounce. Am I OK to add a (if you're happy with the variable name) :. ```; 	private long lastMousePressedWheel = 0L;; ```. and then, the `e.isMiddleButtonDown()` event would be handled as such:; ```; 			else if (e.isMiddleButtonDown()) {; 				//For 10ms after the first click, ignore all additional events; 				long time = System.currentTimeMillis();; 				if (time - lastMousePressedWheel < 10); 					return;. 				// Here we toggle between the MOVE tool and any previously selected tool; 				if (getSelectedTool() == PathTools.MOVE); 					setSelectedTool(previousTool);; 				else; 					setSelectedTool(PathTools.MOVE);; 				lastMousePressedWheel = time;; 			}; ```. I'm hoping to reuse the same variable to debounce the horizontal scroll buttons as well, hence the name.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529
https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529:2,Testability,test,tested,2,"I tested some old mice (that got hidden away for a reason), and their wheel button triggered multiple events at times. This behaviour was corrected with a 10ms debounce. Am I OK to add a (if you're happy with the variable name) :. ```; 	private long lastMousePressedWheel = 0L;; ```. and then, the `e.isMiddleButtonDown()` event would be handled as such:; ```; 			else if (e.isMiddleButtonDown()) {; 				//For 10ms after the first click, ignore all additional events; 				long time = System.currentTimeMillis();; 				if (time - lastMousePressedWheel < 10); 					return;. 				// Here we toggle between the MOVE tool and any previously selected tool; 				if (getSelectedTool() == PathTools.MOVE); 					setSelectedTool(previousTool);; 				else; 					setSelectedTool(PathTools.MOVE);; 				lastMousePressedWheel = time;; 			}; ```. I'm hoping to reuse the same variable to debounce the horizontal scroll buttons as well, hence the name.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219652529
https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857:332,Availability,down,down,332,"Before doing that, could you check if there's anything is in https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html that could help?. I *think* the issue may be because there's no test for the event type in your current code - and so it could be fired on a mouse move event as well (with the middle button down). So I think you need to check for a pressed, released or click event (I forget which... this is a place were cross-platform stuff can be annoying). I've never used [`isStillSincePressed()`](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html#isStillSincePress()) because I don't discovered it recently, but perhaps it can also help.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857
https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857:383,Deployability,release,released,383,"Before doing that, could you check if there's anything is in https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html that could help?. I *think* the issue may be because there's no test for the event type in your current code - and so it could be fired on a mouse move event as well (with the middle button down). So I think you need to check for a pressed, released or click event (I forget which... this is a place were cross-platform stuff can be annoying). I've never used [`isStillSincePressed()`](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html#isStillSincePress()) because I don't discovered it recently, but perhaps it can also help.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857
https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857:206,Testability,test,test,206,"Before doing that, could you check if there's anything is in https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html that could help?. I *think* the issue may be because there's no test for the event type in your current code - and so it could be fired on a mouse move event as well (with the middle button down). So I think you need to check for a pressed, released or click event (I forget which... this is a place were cross-platform stuff can be annoying). I've never used [`isStillSincePressed()`](https://openjfx.io/javadoc/11/javafx.graphics/javafx/scene/input/MouseEvent.html#isStillSincePress()) because I don't discovered it recently, but perhaps it can also help.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1219670857
https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670:362,Safety,detect,detected,362,"Hi Pete,. in retrospect, I shouldn't have added the middle button code to one of your existing events. Instead, I gave the code its own `viewer.getView().addEventHandler(MouseEvent.MOUSE_PRESSED, e -> {})` event, which hopefully makes it easier to follow. This has also solved my debouncing issues, it seems. I actually had code that logged whether a bounce was detected within 10ms (as detailed above) but never saw such an event. Interestingly, and this is code I left commented out in my commit, checking for `isStillSincePressed()` as you suggested led to missed clicks. That, or maybe my logic is flawed:; ```java; 			if (e.isMiddleButtonDown()) {; 				/* ; 				if (!e.isStillSincePress() ) {; 					logger.warn(""The mouse moved! {}"", System.currentTimeMillis());; 					return;; 				}; 				*/; 				...; 			}; ```; However, moving the mouse while pressing the middle button doesn't have any adverse effect. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670
https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670:334,Testability,log,logged,334,"Hi Pete,. in retrospect, I shouldn't have added the middle button code to one of your existing events. Instead, I gave the code its own `viewer.getView().addEventHandler(MouseEvent.MOUSE_PRESSED, e -> {})` event, which hopefully makes it easier to follow. This has also solved my debouncing issues, it seems. I actually had code that logged whether a bounce was detected within 10ms (as detailed above) but never saw such an event. Interestingly, and this is code I left commented out in my commit, checking for `isStillSincePressed()` as you suggested led to missed clicks. That, or maybe my logic is flawed:; ```java; 			if (e.isMiddleButtonDown()) {; 				/* ; 				if (!e.isStillSincePress() ) {; 					logger.warn(""The mouse moved! {}"", System.currentTimeMillis());; 					return;; 				}; 				*/; 				...; 			}; ```; However, moving the mouse while pressing the middle button doesn't have any adverse effect. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670
https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670:593,Testability,log,logic,593,"Hi Pete,. in retrospect, I shouldn't have added the middle button code to one of your existing events. Instead, I gave the code its own `viewer.getView().addEventHandler(MouseEvent.MOUSE_PRESSED, e -> {})` event, which hopefully makes it easier to follow. This has also solved my debouncing issues, it seems. I actually had code that logged whether a bounce was detected within 10ms (as detailed above) but never saw such an event. Interestingly, and this is code I left commented out in my commit, checking for `isStillSincePressed()` as you suggested led to missed clicks. That, or maybe my logic is flawed:; ```java; 			if (e.isMiddleButtonDown()) {; 				/* ; 				if (!e.isStillSincePress() ) {; 					logger.warn(""The mouse moved! {}"", System.currentTimeMillis());; 					return;; 				}; 				*/; 				...; 			}; ```; However, moving the mouse while pressing the middle button doesn't have any adverse effect. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670
https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670:704,Testability,log,logger,704,"Hi Pete,. in retrospect, I shouldn't have added the middle button code to one of your existing events. Instead, I gave the code its own `viewer.getView().addEventHandler(MouseEvent.MOUSE_PRESSED, e -> {})` event, which hopefully makes it easier to follow. This has also solved my debouncing issues, it seems. I actually had code that logged whether a bounce was detected within 10ms (as detailed above) but never saw such an event. Interestingly, and this is code I left commented out in my commit, checking for `isStillSincePressed()` as you suggested led to missed clicks. That, or maybe my logic is flawed:; ```java; 			if (e.isMiddleButtonDown()) {; 				/* ; 				if (!e.isStillSincePress() ) {; 					logger.warn(""The mouse moved! {}"", System.currentTimeMillis());; 					return;; 				}; 				*/; 				...; 			}; ```; However, moving the mouse while pressing the middle button doesn't have any adverse effect. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237132670
https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586:1698,Integrability,depend,depend,1698,"Thanks, I'll need to find time to explore this in more detail - it probably reveals an ugliness in how QuPath handles viewer interactions. I worry a bit about adding new event handlers, because it can become confusing which is called and when. Note that the move tool (as with other tools) defines a [`mousePressed(MouseEvent)`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/tools/MoveTool.java#L73) method. Conceivably, this or some other tool might do something with a middle button press. If so, then it might be hard to predict which method will actually be called. It's quite possible that both would be called. One way to ensure that one method is called before another `EventHandler` is to use an [`EventFilter`](https://docs.oracle.com/javafx/2/events/filters.htm)... although adding multiple event filters would presumably lead to the same kind of confusion regarding *their* order. For global application behavior that doesn't need to be customized, then I think it's best to include the logic in a single `EventHandler` or `EventFilter` rather than adding multiple ones. Having both an `EventFilter` and an `EventHandler` is fine because then we know the filter will be called first, but having more than one of either of them attached to a UI component is where the confusion starts. For that reason, my guess (without looking in detail!) is that the tool toggling should be implemented using an `EventFilter` attached to the scene (not viewer, because it's global to the application), somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). Where exactly would depend upon whether the middle click should switch the tool when the UI is blocked or not. Either way, you should probably make sure to consume the event after it has performed the switch. However I'm not sure... since I reached this conclusion by thinking about it rather than testing anything.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586
https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586:1865,Performance,perform,performed,1865,"Thanks, I'll need to find time to explore this in more detail - it probably reveals an ugliness in how QuPath handles viewer interactions. I worry a bit about adding new event handlers, because it can become confusing which is called and when. Note that the move tool (as with other tools) defines a [`mousePressed(MouseEvent)`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/tools/MoveTool.java#L73) method. Conceivably, this or some other tool might do something with a middle button press. If so, then it might be hard to predict which method will actually be called. It's quite possible that both would be called. One way to ensure that one method is called before another `EventHandler` is to use an [`EventFilter`](https://docs.oracle.com/javafx/2/events/filters.htm)... although adding multiple event filters would presumably lead to the same kind of confusion regarding *their* order. For global application behavior that doesn't need to be customized, then I think it's best to include the logic in a single `EventHandler` or `EventFilter` rather than adding multiple ones. Having both an `EventFilter` and an `EventHandler` is fine because then we know the filter will be called first, but having more than one of either of them attached to a UI component is where the confusion starts. For that reason, my guess (without looking in detail!) is that the tool toggling should be implemented using an `EventFilter` attached to the scene (not viewer, because it's global to the application), somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). Where exactly would depend upon whether the middle click should switch the tool when the UI is blocked or not. Either way, you should probably make sure to consume the event after it has performed the switch. However I'm not sure... since I reached this conclusion by thinking about it rather than testing anything.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586
https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586:571,Safety,predict,predict,571,"Thanks, I'll need to find time to explore this in more detail - it probably reveals an ugliness in how QuPath handles viewer interactions. I worry a bit about adding new event handlers, because it can become confusing which is called and when. Note that the move tool (as with other tools) defines a [`mousePressed(MouseEvent)`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/tools/MoveTool.java#L73) method. Conceivably, this or some other tool might do something with a middle button press. If so, then it might be hard to predict which method will actually be called. It's quite possible that both would be called. One way to ensure that one method is called before another `EventHandler` is to use an [`EventFilter`](https://docs.oracle.com/javafx/2/events/filters.htm)... although adding multiple event filters would presumably lead to the same kind of confusion regarding *their* order. For global application behavior that doesn't need to be customized, then I think it's best to include the logic in a single `EventHandler` or `EventFilter` rather than adding multiple ones. Having both an `EventFilter` and an `EventHandler` is fine because then we know the filter will be called first, but having more than one of either of them attached to a UI component is where the confusion starts. For that reason, my guess (without looking in detail!) is that the tool toggling should be implemented using an `EventFilter` attached to the scene (not viewer, because it's global to the application), somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). Where exactly would depend upon whether the middle click should switch the tool when the UI is blocked or not. Either way, you should probably make sure to consume the event after it has performed the switch. However I'm not sure... since I reached this conclusion by thinking about it rather than testing anything.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586
https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586:1045,Testability,log,logic,1045,"Thanks, I'll need to find time to explore this in more detail - it probably reveals an ugliness in how QuPath handles viewer interactions. I worry a bit about adding new event handlers, because it can become confusing which is called and when. Note that the move tool (as with other tools) defines a [`mousePressed(MouseEvent)`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/tools/MoveTool.java#L73) method. Conceivably, this or some other tool might do something with a middle button press. If so, then it might be hard to predict which method will actually be called. It's quite possible that both would be called. One way to ensure that one method is called before another `EventHandler` is to use an [`EventFilter`](https://docs.oracle.com/javafx/2/events/filters.htm)... although adding multiple event filters would presumably lead to the same kind of confusion regarding *their* order. For global application behavior that doesn't need to be customized, then I think it's best to include the logic in a single `EventHandler` or `EventFilter` rather than adding multiple ones. Having both an `EventFilter` and an `EventHandler` is fine because then we know the filter will be called first, but having more than one of either of them attached to a UI component is where the confusion starts. For that reason, my guess (without looking in detail!) is that the tool toggling should be implemented using an `EventFilter` attached to the scene (not viewer, because it's global to the application), somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). Where exactly would depend upon whether the middle click should switch the tool when the UI is blocked or not. Either way, you should probably make sure to consume the event after it has performed the switch. However I'm not sure... since I reached this conclusion by thinking about it rather than testing anything.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586
https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586:1976,Testability,test,testing,1976,"Thanks, I'll need to find time to explore this in more detail - it probably reveals an ugliness in how QuPath handles viewer interactions. I worry a bit about adding new event handlers, because it can become confusing which is called and when. Note that the move tool (as with other tools) defines a [`mousePressed(MouseEvent)`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/tools/MoveTool.java#L73) method. Conceivably, this or some other tool might do something with a middle button press. If so, then it might be hard to predict which method will actually be called. It's quite possible that both would be called. One way to ensure that one method is called before another `EventHandler` is to use an [`EventFilter`](https://docs.oracle.com/javafx/2/events/filters.htm)... although adding multiple event filters would presumably lead to the same kind of confusion regarding *their* order. For global application behavior that doesn't need to be customized, then I think it's best to include the logic in a single `EventHandler` or `EventFilter` rather than adding multiple ones. Having both an `EventFilter` and an `EventHandler` is fine because then we know the filter will be called first, but having more than one of either of them attached to a UI component is where the confusion starts. For that reason, my guess (without looking in detail!) is that the tool toggling should be implemented using an `EventFilter` attached to the scene (not viewer, because it's global to the application), somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). Where exactly would depend upon whether the middle click should switch the tool when the UI is blocked or not. Either way, you should probably make sure to consume the event after it has performed the switch. However I'm not sure... since I reached this conclusion by thinking about it rather than testing anything.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1237195586
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:1108,Deployability,release,release,1108,"e](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). In this iteration, if you have time to test it, I've also added the side-to-side wheel clicks (or shift + normal mousewheel scrolling). I've spent some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:1991,Energy Efficiency,power,powerbook,1991,"nt some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon desktop environment so far, but with a mouse, my code behaves in Mint/Ubuntu the way it does on Windows. For now, my code is quite verbose, both in terms of comments and in debug messages. I will clean this up if/when you're happy with this pull request.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:2313,Integrability,message,messages,2313,"nt some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon desktop environment so far, but with a mouse, my code behaves in Mint/Ubuntu the way it does on Windows. For now, my code is quite verbose, both in terms of comments and in debug messages. I will clean this up if/when you're happy with this pull request.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:283,Testability,test,test,283,"Last code reshuffle! I'm back to where I started and exactly where you wrote the middle button code should go, somewhere [around here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1046). In this iteration, if you have time to test it, I've also added the side-to-side wheel clicks (or shift + normal mousewheel scrolling). I've spent some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:1243,Testability,test,tested,1243,"ation, if you have time to test it, I've also added the side-to-side wheel clicks (or shift + normal mousewheel scrolling). I've spent some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon desktop environment so far, but with a mouse, my code behaves in Mint/Ubuntu the way it does on Windows. For now, my code ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:1962,Testability,test,test,1962,"nt some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon desktop environment so far, but with a mouse, my code behaves in Mint/Ubuntu the way it does on Windows. For now, my code is quite verbose, both in terms of comments and in debug messages. I will clean this up if/when you're happy with this pull request.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123:1240,Usability,UX,UX,1240,"ation, if you have time to test it, I've also added the side-to-side wheel clicks (or shift + normal mousewheel scrolling). I've spent some time trying to understand how [Mouse Events](https://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/MouseEvent.html) are handled in JavaFX and I *think* I managed to sort out the issues I was initially having: Behaviour when dragging with middle button pressed, fast clicks, when to consume events or not, debouncing... Incidentally, the debouncing code is not strictly necessary, but it was an interesting exercise in working with a broken mouse. Also, I *think* `MouseEvent.MOUSE_RELEASED` should be added to the [list of ignored events here](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1039) as without, I had to deal with the (middle) button release event multiple times as part of the events generated by JavaFX in the course of pressing a mouse button. Finally, I've also UX tested the behaviours we discussed in the [forum.sc post](https://forum.image.sc/t/tool-selection-via-mousewheel-side-scrolling-button-press/70796/4?u=ep.zindy) and reproduced in the first comment. For now,; * Windows,; * with my ""fancy"" mouse; * with the shift+scrollwheel substitute for side-to-side scrolling; * my Lenovo T460 touchpad; * with scroll touch gestures enabled or disabled; * with inverted mouse enabled or disabled; * with ctrl to modify opacity; ; I couldn't use ""Zoom"" or ""Rotate"" touch gestures, because I don't think my very basic touchpad understands them, so I couldn't see any effects on QuPath. Panning does work as expected (with my very last commit). ~~**todo** I will edit my comment when I test a Linux build on my old powerbook with Mint, which (maybe) will let me use more touch gestures.~~ I haven't been able to use touch gestures with QuPath in my Cinnamon desktop environment so far, but with a mouse, my code behaves in Mint/Ubuntu the way it does on Windows. For now, my code ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1243226123
https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231:440,Availability,down,down,440,"Hi Pete,. there's no much else I can do on this for now. It's ready to be tested by someone else in case I missed anything, and I don't have a mac to test on so I just can't guarantee this will work on all platforms. Also, the code is probably over-annotated and over-verbose on the console side, but that's just so that you can check what's going on in case there are issues I didn't notice myself. Once okayed, the code can be both toned down and cleaned up :-). If this is too much to test before the new release, we can reconsider this change for later. In fact, for this to be complete, I would also need to document my change (wouldn't be fair to let *you* do it if I wrote the feature) and add a middle button to your ""input viewer"". Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231
https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231:508,Deployability,release,release,508,"Hi Pete,. there's no much else I can do on this for now. It's ready to be tested by someone else in case I missed anything, and I don't have a mac to test on so I just can't guarantee this will work on all platforms. Also, the code is probably over-annotated and over-verbose on the console side, but that's just so that you can check what's going on in case there are issues I didn't notice myself. Once okayed, the code can be both toned down and cleaned up :-). If this is too much to test before the new release, we can reconsider this change for later. In fact, for this to be complete, I would also need to document my change (wouldn't be fair to let *you* do it if I wrote the feature) and add a middle button to your ""input viewer"". Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231
https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231:74,Testability,test,tested,74,"Hi Pete,. there's no much else I can do on this for now. It's ready to be tested by someone else in case I missed anything, and I don't have a mac to test on so I just can't guarantee this will work on all platforms. Also, the code is probably over-annotated and over-verbose on the console side, but that's just so that you can check what's going on in case there are issues I didn't notice myself. Once okayed, the code can be both toned down and cleaned up :-). If this is too much to test before the new release, we can reconsider this change for later. In fact, for this to be complete, I would also need to document my change (wouldn't be fair to let *you* do it if I wrote the feature) and add a middle button to your ""input viewer"". Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231
https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231:150,Testability,test,test,150,"Hi Pete,. there's no much else I can do on this for now. It's ready to be tested by someone else in case I missed anything, and I don't have a mac to test on so I just can't guarantee this will work on all platforms. Also, the code is probably over-annotated and over-verbose on the console side, but that's just so that you can check what's going on in case there are issues I didn't notice myself. Once okayed, the code can be both toned down and cleaned up :-). If this is too much to test before the new release, we can reconsider this change for later. In fact, for this to be complete, I would also need to document my change (wouldn't be fair to let *you* do it if I wrote the feature) and add a middle button to your ""input viewer"". Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231
https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231:488,Testability,test,test,488,"Hi Pete,. there's no much else I can do on this for now. It's ready to be tested by someone else in case I missed anything, and I don't have a mac to test on so I just can't guarantee this will work on all platforms. Also, the code is probably over-annotated and over-verbose on the console side, but that's just so that you can check what's going on in case there are issues I didn't notice myself. Once okayed, the code can be both toned down and cleaned up :-). If this is too much to test before the new release, we can reconsider this change for later. In fact, for this to be complete, I would also need to document my change (wouldn't be fair to let *you* do it if I wrote the feature) and add a middle button to your ""input viewer"". Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312782231
https://github.com/qupath/qupath/pull/1037#issuecomment-1312788298:108,Deployability,release,release,108,"Hi Egor, I was meaning to get to this - but ended up swamped by so many huge things to sort before the next release, and this one requires switching to an old computer with a small screen and no battery life... which I never quite found time to do. I've just merged in the >200 commits since this. If it builds ok I'll try to have a look in the next day or two.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312788298
https://github.com/qupath/qupath/pull/1037#issuecomment-1312788298:195,Energy Efficiency,battery,battery,195,"Hi Egor, I was meaning to get to this - but ended up swamped by so many huge things to sort before the next release, and this one requires switching to an old computer with a small screen and no battery life... which I never quite found time to do. I've just merged in the >200 commits since this. If it builds ok I'll try to have a look in the next day or two.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312788298
https://github.com/qupath/qupath/pull/1037#issuecomment-1312793422:1030,Deployability,integrat,integrating,1030,"Ok, had a quick check on my Mac since you mentioned it - and I'm afraid the scroll isn't working very nicely :( The 'magic mouse' makes horizontal scrolling really easy - which is handy for panning around the image if you turn *View &rarr; Multi-touch gestures &rarr; Scroll gestures*. However here it means that tools switch *really* easily... and continually happen by accident during normal use. How useful is this aspect of the PR? Would you miss it badly if that part was removed...?. I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. Can you say a bit more about how useful you've found this, and when?. The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312793422
https://github.com/qupath/qupath/pull/1037#issuecomment-1312793422:1030,Integrability,integrat,integrating,1030,"Ok, had a quick check on my Mac since you mentioned it - and I'm afraid the scroll isn't working very nicely :( The 'magic mouse' makes horizontal scrolling really easy - which is handy for panning around the image if you turn *View &rarr; Multi-touch gestures &rarr; Scroll gestures*. However here it means that tools switch *really* easily... and continually happen by accident during normal use. How useful is this aspect of the PR? Would you miss it badly if that part was removed...?. I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. Can you say a bit more about how useful you've found this, and when?. The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312793422
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:2664,Deployability,integrat,integrating,2664,"* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for move, ""r"" is for rectangle and ""p"" is for polygon. From my testing, I just find using the middle button more practical.; * Side-to-side selection: That came as an afterthought after implementing the middle button. I then use it because it's there, but honestly, the keyboard shortcuts *do* make sense.; * Debounce: Like I said, it helps with worn out buttons, but this isn't normally something anyone will have issues with. I'll keep it at the back of my mind and let you know if there is a real test case for including it in QuPath. > The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later. I'm all for this. What I can do now is scale back the PR to ""middle button functionality"" (no side-to-side or debounce), and also remove any logging that isn't strictly necessary. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:2664,Integrability,integrat,integrating,2664,"* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for move, ""r"" is for rectangle and ""p"" is for polygon. From my testing, I just find using the middle button more practical.; * Side-to-side selection: That came as an afterthought after implementing the middle button. I then use it because it's there, but honestly, the keyboard shortcuts *do* make sense.; * Debounce: Like I said, it helps with worn out buttons, but this isn't normally something anyone will have issues with. I'll keep it at the back of my mind and let you know if there is a real test case for including it in QuPath. > The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later. I'm all for this. What I can do now is scale back the PR to ""middle button functionality"" (no side-to-side or debounce), and also remove any logging that isn't strictly necessary. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:755,Testability,test,test,755,"Hi Pete, . > Ok, had a quick check on my Mac since you mentioned it - and I'm afraid the scroll isn't working very nicely :( The 'magic mouse' makes horizontal scrolling really easy - which is handy for panning around the image if you turn View → Multi-touch gestures → Scroll gestures. However here it means that tools switch really easily... and continually happen by accident during normal use. So, maybe this is because I use QuPath in Windows, usually with a mouse rather than a touchpad. Since I don't (know how to) use many Multi-touch gestures, I thought it would be enough to only enable my tool selector when ""use scroll gestures"" is disabled. I just checked that this is still the case and you don't even need to close the preference window to test that. > How useful is this aspect of the PR? Would you miss it badly if that part was removed...?. Not super important, I put it there for *my* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:2060,Testability,test,testing,2060,"* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for move, ""r"" is for rectangle and ""p"" is for polygon. From my testing, I just find using the middle button more practical.; * Side-to-side selection: That came as an afterthought after implementing the middle button. I then use it because it's there, but honestly, the keyboard shortcuts *do* make sense.; * Debounce: Like I said, it helps with worn out buttons, but this isn't normally something anyone will have issues with. I'll keep it at the back of my mind and let you know if there is a real test case for including it in QuPath. > The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later. I'm all for this. What I can do now is scale back the PR to ""middle button functionality"" (no side-to-side or debounce), and also remove any logging that isn't strictly necessary. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:2497,Testability,test,test,2497,"* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for move, ""r"" is for rectangle and ""p"" is for polygon. From my testing, I just find using the middle button more practical.; * Side-to-side selection: That came as an afterthought after implementing the middle button. I then use it because it's there, but honestly, the keyboard shortcuts *do* make sense.; * Debounce: Like I said, it helps with worn out buttons, but this isn't normally something anyone will have issues with. I'll keep it at the back of my mind and let you know if there is a real test case for including it in QuPath. > The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later. I'm all for this. What I can do now is scale back the PR to ""middle button functionality"" (no side-to-side or debounce), and also remove any logging that isn't strictly necessary. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565:2850,Testability,log,logging,2850,"* convenience as I don't scroll the image side to side (I use the move tool) and prefer using the mouse wheel for zooming. > I think (but haven't thoroughly checked) that the middle button should be less troublesome, partly because Mac mice don't have middle buttons. Of the two proposed changes (side to side tool selection, middle button to come back to the previously selected tool), the middle button is the one I would say is the more useful one. > But I remain a bit apprehensive about needing a debounce delay, and worry about adding even more complexity to the various event filters and handlers that are active when interacting with the viewer. I agree that debounce should really be part of the OS. QuPath shouldn't be blamed for not working quite right with a broken mouse. > Can you say a bit more about how useful you've found this, and when?. * First the one I found most useful: For me, this feature really shines when I need to draw lots of small regions for a pixel classifier. I draw either rectangles or use the polygon tool and yes, I could just try and remember that ""m"" is for move, ""r"" is for rectangle and ""p"" is for polygon. From my testing, I just find using the middle button more practical.; * Side-to-side selection: That came as an afterthought after implementing the middle button. I then use it because it's there, but honestly, the keyboard shortcuts *do* make sense.; * Debounce: Like I said, it helps with worn out buttons, but this isn't normally something anyone will have issues with. I'll keep it at the back of my mind and let you know if there is a real test case for including it in QuPath. > The option remains to add the functionality through an extension or startup script, to give it a bit more time before possibly integrating it into the core software later. I'm all for this. What I can do now is scale back the PR to ""middle button functionality"" (no side-to-side or debounce), and also remove any logging that isn't strictly necessary. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1312815565
https://github.com/qupath/qupath/pull/1037#issuecomment-1313413034:369,Safety,detect,detected,369,"OK, the code left is just the middle button, without side-to-side tool selection and without the debounce code. One [comment I left in](https://github.com/qupath/qupath/pull/1037/files#diff-fd4ad143f25db1ea49822496a62940abb1e550675d0a394acb80298892dbf7e8R1079-R1081) is this:. > // As part of MouseEvent.ANY, both MOUSE_RELEASED and MOUSE_PRESSED can be generated (and detected) separately, so maybe worth adding MOUSE_RELEASED to ignoreTypes?. For me, pressing the middle button quickly is what generated extra MOUSE_RELEASED events, which would then need to be filtered somewhere within ; ```; 		stage.getScene().addEventFilter(MouseEvent.ANY, e -> {; 		}; ```; Instead, I added `MouseEvent.MOUSE_RELEASED` to your `ignoreTypes` but left [the original line](https://github.com/qupath/qupath/pull/1037/files#diff-fd4ad143f25db1ea49822496a62940abb1e550675d0a394acb80298892dbf7e8R1080) commented out. If this is OK, I'll remove the line and amend my comment to mention `MouseEvent.MOUSE_RELEASED` is to do with pressing the middle button multiple times.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313413034
https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231:330,Deployability,release,released,330,"It's a long time since I wrote that bit (and I probably should have used `Set.of(...)` instead of the `HashSet`...), but I'm not sure that adding `MOUSE_RELEASED` would be correct. The purpose of the `EventFilter` in general is to block UI events under some circumstances, e.g. when a script is running. We'd want mouse pressed & released events to be blocked (and not ignored... since ignoring them would let them through. I realise that's not entirely intuitive naming...). To make minimal changes I think you'd just need to check for the event you want and leave the rest as it was, e.g.; ```java; ...; } else if (e.getEventType() == MouseEvent.MOUSE_CLICKED && e.getButton() == MouseButton.MIDDLE) {; ...; }; ```. (Not certain I've understood, since that comment is only from reading - not running)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231
https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231:103,Security,Hash,HashSet,103,"It's a long time since I wrote that bit (and I probably should have used `Set.of(...)` instead of the `HashSet`...), but I'm not sure that adding `MOUSE_RELEASED` would be correct. The purpose of the `EventFilter` in general is to block UI events under some circumstances, e.g. when a script is running. We'd want mouse pressed & released events to be blocked (and not ignored... since ignoring them would let them through. I realise that's not entirely intuitive naming...). To make minimal changes I think you'd just need to check for the event you want and leave the rest as it was, e.g.; ```java; ...; } else if (e.getEventType() == MouseEvent.MOUSE_CLICKED && e.getButton() == MouseButton.MIDDLE) {; ...; }; ```. (Not certain I've understood, since that comment is only from reading - not running)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231
https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231:454,Usability,intuit,intuitive,454,"It's a long time since I wrote that bit (and I probably should have used `Set.of(...)` instead of the `HashSet`...), but I'm not sure that adding `MOUSE_RELEASED` would be correct. The purpose of the `EventFilter` in general is to block UI events under some circumstances, e.g. when a script is running. We'd want mouse pressed & released events to be blocked (and not ignored... since ignoring them would let them through. I realise that's not entirely intuitive naming...). To make minimal changes I think you'd just need to check for the event you want and leave the rest as it was, e.g.; ```java; ...; } else if (e.getEventType() == MouseEvent.MOUSE_CLICKED && e.getButton() == MouseButton.MIDDLE) {; ...; }; ```. (Not certain I've understood, since that comment is only from reading - not running)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313439231
https://github.com/qupath/qupath/pull/1037#issuecomment-1313554395:143,Availability,robust,robust,143,"OK, it turns out that adding `MOUSE_RELEASED` to `ignoreTypes` is not needed (any more). At some point, I made the logic of the middle button [robust to fast clicks](https://github.com/qupath/qupath/blob/ca41a4d033eb65c5f9ee1c12a64bf1e96f60276d/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1108-L1112). I suspect that consuming the extra events generated by subsequent middle click events (`e.getClickCount() > 1`) is enough. Then all I do is check is `e.isMiddleButtonDown()` and I don't see anything weird happening whether I do rapid middle button clicks or if I press the left button or use the mouse wheel while the middle button is pressed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313554395
https://github.com/qupath/qupath/pull/1037#issuecomment-1313554395:115,Testability,log,logic,115,"OK, it turns out that adding `MOUSE_RELEASED` to `ignoreTypes` is not needed (any more). At some point, I made the logic of the middle button [robust to fast clicks](https://github.com/qupath/qupath/blob/ca41a4d033eb65c5f9ee1c12a64bf1e96f60276d/qupath-gui-fx/src/main/java/qupath/lib/gui/QuPathGUI.java#L1108-L1112). I suspect that consuming the extra events generated by subsequent middle click events (`e.getClickCount() > 1`) is enough. Then all I do is check is `e.isMiddleButtonDown()` and I don't see anything weird happening whether I do rapid middle button clicks or if I press the left button or use the mouse wheel while the middle button is pressed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1313554395
https://github.com/qupath/qupath/pull/1037#issuecomment-1318813525:15,Testability,test,tested,15,"As far as I've tested this, it's all working as expected, with the added benefit of letting the user manually click the move tool and still retain which other tool was previously selected (as you suggested). Fast clicks not an issue any more, even with the shorter code you suggested. All reflected in the last (cleaned-up) commit.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1037#issuecomment-1318813525
https://github.com/qupath/qupath/pull/1039#issuecomment-1219552207:291,Availability,error,error,291,"Thanks, can you describe a bit more how to replicate the original bug and check it is fixed?. We need something we can link to in https://github.com/qupath/qupath/blob/main/CHANGELOG.md to describe the fix (either an issue or a PR). Also, I think that `settings.gradle` was included here in error.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219552207
https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297:83,Modifiability,plugin,plugin,83,"Hi Pete,. I stumbled on it when trying to tile very large annotations for a simple plugin I am making. ; ; I basically set the bounds to be the entire image and then had a very large annotation (converted to ROI) that I computed the tiled ROIs for. I don't have a clean example to share, but maybe I can write some code that is commented out and then you can step through it with a debugger and check the behavior out for yourself?. Thank you again for your continued work on QuPath, I've learned so much through your source code. Also, yes. The settings.gradle file was not supposed to be committed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297
https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297:76,Usability,simpl,simple,76,"Hi Pete,. I stumbled on it when trying to tile very large annotations for a simple plugin I am making. ; ; I basically set the bounds to be the entire image and then had a very large annotation (converted to ROI) that I computed the tiled ROIs for. I don't have a clean example to share, but maybe I can write some code that is commented out and then you can step through it with a debugger and check the behavior out for yourself?. Thank you again for your continued work on QuPath, I've learned so much through your source code. Also, yes. The settings.gradle file was not supposed to be committed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297
https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297:489,Usability,learn,learned,489,"Hi Pete,. I stumbled on it when trying to tile very large annotations for a simple plugin I am making. ; ; I basically set the bounds to be the entire image and then had a very large annotation (converted to ROI) that I computed the tiled ROIs for. I don't have a clean example to share, but maybe I can write some code that is commented out and then you can step through it with a debugger and check the behavior out for yourself?. Thank you again for your continued work on QuPath, I've learned so much through your source code. Also, yes. The settings.gradle file was not supposed to be committed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219570297
https://github.com/qupath/qupath/pull/1039#issuecomment-1219581620:30,Deployability,update,update,30,"Thanks @crobbins327 could you update the PR (or create a new one) to remove the settings file please?. > I basically set the bounds to be the entire image. Ah, I think that's the key bit - I see the problematic behavior for a full image annotation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219581620
https://github.com/qupath/qupath/pull/1039#issuecomment-1219620729:35,Modifiability,refactor,refactor,35,"Thanks for the tip. Haha I need to refactor how I setup the qupath source code.... now I've squashed the commits but I had to ignore the folders for my extensions... sorry for all the complications, maybe you can cherry pick just the ""fixed ROITools.computeTiledROIs"" commit? I'm still learning git.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219620729
https://github.com/qupath/qupath/pull/1039#issuecomment-1219620729:286,Usability,learn,learning,286,"Thanks for the tip. Haha I need to refactor how I setup the qupath source code.... now I've squashed the commits but I had to ignore the folders for my extensions... sorry for all the complications, maybe you can cherry pick just the ""fixed ROITools.computeTiledROIs"" commit? I'm still learning git.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219620729
https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526:464,Usability,clear,clearAllObjects,464,"Probably best make a new PR, there shouldn't be changes to `.gitignore` included either :). Meanwhile, it seems this doesn't fix the bug I thought it was going to fix, i.e. extra tiles are generated along x but not along y:. <img width=""1300"" alt=""Screenshot 2022-08-18 at 16 15 08"" src=""https://user-images.githubusercontent.com/4690904/185431356-8140d40f-b121-485d-ad00-77d0934ba235.png"">. The objects shown in the screenshot can be reproduced using. ```groovy; clearAllObjects(); createSelectAllObject(true); runPlugin('qupath.lib.algorithms.TilerPlugin', '{""tileSizeMicrons"":200.0,""trimToROI"":false,""makeAnnotations"":true,""removeParentAnnotation"":false}'); ```. Creating objects outside the image is probably not a good idea anyway, so it's not clear to me whether the x or y behavior is less bad. The inconsistency doesn't seem good... but I wouldn't want to add a 'fix' unless it's totally clear that it's an improvement, since any change will impact the reproducibility of scripts across QuPath versions. Anyhow, I'm not seeing a change of behavior when using the code from the PR. Could you please fill in the info from the bug report template? It's still not clear to me what the bug is or whether the fix fixes it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526
https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526:749,Usability,clear,clear,749,"Probably best make a new PR, there shouldn't be changes to `.gitignore` included either :). Meanwhile, it seems this doesn't fix the bug I thought it was going to fix, i.e. extra tiles are generated along x but not along y:. <img width=""1300"" alt=""Screenshot 2022-08-18 at 16 15 08"" src=""https://user-images.githubusercontent.com/4690904/185431356-8140d40f-b121-485d-ad00-77d0934ba235.png"">. The objects shown in the screenshot can be reproduced using. ```groovy; clearAllObjects(); createSelectAllObject(true); runPlugin('qupath.lib.algorithms.TilerPlugin', '{""tileSizeMicrons"":200.0,""trimToROI"":false,""makeAnnotations"":true,""removeParentAnnotation"":false}'); ```. Creating objects outside the image is probably not a good idea anyway, so it's not clear to me whether the x or y behavior is less bad. The inconsistency doesn't seem good... but I wouldn't want to add a 'fix' unless it's totally clear that it's an improvement, since any change will impact the reproducibility of scripts across QuPath versions. Anyhow, I'm not seeing a change of behavior when using the code from the PR. Could you please fill in the info from the bug report template? It's still not clear to me what the bug is or whether the fix fixes it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526
https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526:896,Usability,clear,clear,896,"Probably best make a new PR, there shouldn't be changes to `.gitignore` included either :). Meanwhile, it seems this doesn't fix the bug I thought it was going to fix, i.e. extra tiles are generated along x but not along y:. <img width=""1300"" alt=""Screenshot 2022-08-18 at 16 15 08"" src=""https://user-images.githubusercontent.com/4690904/185431356-8140d40f-b121-485d-ad00-77d0934ba235.png"">. The objects shown in the screenshot can be reproduced using. ```groovy; clearAllObjects(); createSelectAllObject(true); runPlugin('qupath.lib.algorithms.TilerPlugin', '{""tileSizeMicrons"":200.0,""trimToROI"":false,""makeAnnotations"":true,""removeParentAnnotation"":false}'); ```. Creating objects outside the image is probably not a good idea anyway, so it's not clear to me whether the x or y behavior is less bad. The inconsistency doesn't seem good... but I wouldn't want to add a 'fix' unless it's totally clear that it's an improvement, since any change will impact the reproducibility of scripts across QuPath versions. Anyhow, I'm not seeing a change of behavior when using the code from the PR. Could you please fill in the info from the bug report template? It's still not clear to me what the bug is or whether the fix fixes it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526
https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526:1168,Usability,clear,clear,1168,"Probably best make a new PR, there shouldn't be changes to `.gitignore` included either :). Meanwhile, it seems this doesn't fix the bug I thought it was going to fix, i.e. extra tiles are generated along x but not along y:. <img width=""1300"" alt=""Screenshot 2022-08-18 at 16 15 08"" src=""https://user-images.githubusercontent.com/4690904/185431356-8140d40f-b121-485d-ad00-77d0934ba235.png"">. The objects shown in the screenshot can be reproduced using. ```groovy; clearAllObjects(); createSelectAllObject(true); runPlugin('qupath.lib.algorithms.TilerPlugin', '{""tileSizeMicrons"":200.0,""trimToROI"":false,""makeAnnotations"":true,""removeParentAnnotation"":false}'); ```. Creating objects outside the image is probably not a good idea anyway, so it's not clear to me whether the x or y behavior is less bad. The inconsistency doesn't seem good... but I wouldn't want to add a 'fix' unless it's totally clear that it's an improvement, since any change will impact the reproducibility of scripts across QuPath versions. Anyhow, I'm not seeing a change of behavior when using the code from the PR. Could you please fill in the info from the bug report template? It's still not clear to me what the bug is or whether the fix fixes it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219630526
https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929:1503,Integrability,depend,depends,1503,"Yea, that's from recentering the tiles. If you comment out the portion of the code that centers the tiles then I get the behavior that I wanted for my extension.; ```; // Center the tiles; // xMin = (int)(bounds.getCenterX() - (nx * w * .5));; // yMin = (int)(bounds.getCenterY() - (ny * h * .5));; ```; For a byRow image:; ![row no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441453-7fbba950-4a83-4dd9-96c9-d6b83237a966.png). For a byColumn image:; ![column no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441429-ec886abf-4068-4b9f-ab74-939bd5fd4513.png). Also, prepared geometries code (line 695 of RoiTools) will not be executed unless the geometry has > 1000 points, so you will not be able to easily test this for a parentROI that is a rectangle. From the images above, you can see that I have made some very large complex annotations using the SimpleThresholder and I was encountering this problem when tiling those annotations. The original fix is mainly to adjust the behavior of the code so that it actually is using the prepared geometries that are calculated. If you step through the code with a debugger, you can see that the rowParents or columnParents are not indexed by y or x but by yi and xi, so the geometries are never retrieved from these maps. And the columnParents geometries are sometimes not correct because the envelope for intersection did not go across the entire column. The final result depends on if you want the tiled objects to be centered or not within the parent annotation. Perhaps you could fix it by adding an additional ""center tiles"" argument for the places that need tiling, but I'm sure this would break a lot of things. I do not have the time to fill out a bug report now, but just wanted to let you know about this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929
https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929:792,Testability,test,test,792,"Yea, that's from recentering the tiles. If you comment out the portion of the code that centers the tiles then I get the behavior that I wanted for my extension.; ```; // Center the tiles; // xMin = (int)(bounds.getCenterX() - (nx * w * .5));; // yMin = (int)(bounds.getCenterY() - (ny * h * .5));; ```; For a byRow image:; ![row no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441453-7fbba950-4a83-4dd9-96c9-d6b83237a966.png). For a byColumn image:; ![column no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441429-ec886abf-4068-4b9f-ab74-939bd5fd4513.png). Also, prepared geometries code (line 695 of RoiTools) will not be executed unless the geometry has > 1000 points, so you will not be able to easily test this for a parentROI that is a rectangle. From the images above, you can see that I have made some very large complex annotations using the SimpleThresholder and I was encountering this problem when tiling those annotations. The original fix is mainly to adjust the behavior of the code so that it actually is using the prepared geometries that are calculated. If you step through the code with a debugger, you can see that the rowParents or columnParents are not indexed by y or x but by yi and xi, so the geometries are never retrieved from these maps. And the columnParents geometries are sometimes not correct because the envelope for intersection did not go across the entire column. The final result depends on if you want the tiled objects to be centered or not within the parent annotation. Perhaps you could fix it by adding an additional ""center tiles"" argument for the places that need tiling, but I'm sure this would break a lot of things. I do not have the time to fill out a bug report now, but just wanted to let you know about this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929
https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929:937,Usability,Simpl,SimpleThresholder,937,"Yea, that's from recentering the tiles. If you comment out the portion of the code that centers the tiles then I get the behavior that I wanted for my extension.; ```; // Center the tiles; // xMin = (int)(bounds.getCenterX() - (nx * w * .5));; // yMin = (int)(bounds.getCenterY() - (ny * h * .5));; ```; For a byRow image:; ![row no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441453-7fbba950-4a83-4dd9-96c9-d6b83237a966.png). For a byColumn image:; ![column no center roitools computeTiledROIs](https://user-images.githubusercontent.com/28576964/185441429-ec886abf-4068-4b9f-ab74-939bd5fd4513.png). Also, prepared geometries code (line 695 of RoiTools) will not be executed unless the geometry has > 1000 points, so you will not be able to easily test this for a parentROI that is a rectangle. From the images above, you can see that I have made some very large complex annotations using the SimpleThresholder and I was encountering this problem when tiling those annotations. The original fix is mainly to adjust the behavior of the code so that it actually is using the prepared geometries that are calculated. If you step through the code with a debugger, you can see that the rowParents or columnParents are not indexed by y or x but by yi and xi, so the geometries are never retrieved from these maps. And the columnParents geometries are sometimes not correct because the envelope for intersection did not go across the entire column. The final result depends on if you want the tiled objects to be centered or not within the parent annotation. Perhaps you could fix it by adding an additional ""center tiles"" argument for the places that need tiling, but I'm sure this would break a lot of things. I do not have the time to fill out a bug report now, but just wanted to let you know about this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219671929
https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264:548,Testability,test,test,548,"Thanks, although I remain quite confused. If you find time to write up a bug report that clearly shows the broken and fixed behavior then that would be really helpful. Otherwise, I'll be on the lookout for problems with the tiling, but I'm not sure I'll have time to look in much detail any time soon without a demonstration that the current behavior is critically broken. As far as I can tell, any current bugginess may lead to inefficiency but I'd like an example where it gives a wrong result to understand what to fix. Ideally there would be a test added to [`TestRoiTools`](https://github.com/qupath/qupath/blob/dddad1fe5c567015e07bed8c05940c4403b8d07f/qupath-core/src/test/java/qupath/lib/roi/TestRoiTools.java) that fails before and passes afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264
https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264:564,Testability,Test,TestRoiTools,564,"Thanks, although I remain quite confused. If you find time to write up a bug report that clearly shows the broken and fixed behavior then that would be really helpful. Otherwise, I'll be on the lookout for problems with the tiling, but I'm not sure I'll have time to look in much detail any time soon without a demonstration that the current behavior is critically broken. As far as I can tell, any current bugginess may lead to inefficiency but I'd like an example where it gives a wrong result to understand what to fix. Ideally there would be a test added to [`TestRoiTools`](https://github.com/qupath/qupath/blob/dddad1fe5c567015e07bed8c05940c4403b8d07f/qupath-core/src/test/java/qupath/lib/roi/TestRoiTools.java) that fails before and passes afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264
https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264:674,Testability,test,test,674,"Thanks, although I remain quite confused. If you find time to write up a bug report that clearly shows the broken and fixed behavior then that would be really helpful. Otherwise, I'll be on the lookout for problems with the tiling, but I'm not sure I'll have time to look in much detail any time soon without a demonstration that the current behavior is critically broken. As far as I can tell, any current bugginess may lead to inefficiency but I'd like an example where it gives a wrong result to understand what to fix. Ideally there would be a test added to [`TestRoiTools`](https://github.com/qupath/qupath/blob/dddad1fe5c567015e07bed8c05940c4403b8d07f/qupath-core/src/test/java/qupath/lib/roi/TestRoiTools.java) that fails before and passes afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264
https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264:699,Testability,Test,TestRoiTools,699,"Thanks, although I remain quite confused. If you find time to write up a bug report that clearly shows the broken and fixed behavior then that would be really helpful. Otherwise, I'll be on the lookout for problems with the tiling, but I'm not sure I'll have time to look in much detail any time soon without a demonstration that the current behavior is critically broken. As far as I can tell, any current bugginess may lead to inefficiency but I'd like an example where it gives a wrong result to understand what to fix. Ideally there would be a test added to [`TestRoiTools`](https://github.com/qupath/qupath/blob/dddad1fe5c567015e07bed8c05940c4403b8d07f/qupath-core/src/test/java/qupath/lib/roi/TestRoiTools.java) that fails before and passes afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264
https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264:89,Usability,clear,clearly,89,"Thanks, although I remain quite confused. If you find time to write up a bug report that clearly shows the broken and fixed behavior then that would be really helpful. Otherwise, I'll be on the lookout for problems with the tiling, but I'm not sure I'll have time to look in much detail any time soon without a demonstration that the current behavior is critically broken. As far as I can tell, any current bugginess may lead to inefficiency but I'd like an example where it gives a wrong result to understand what to fix. Ideally there would be a test added to [`TestRoiTools`](https://github.com/qupath/qupath/blob/dddad1fe5c567015e07bed8c05940c4403b8d07f/qupath-core/src/test/java/qupath/lib/roi/TestRoiTools.java) that fails before and passes afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1039#issuecomment-1219701264
https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778:101,Performance,cache,cache,101,"> noticed that the memory would take a while to be dereferenced. Is this a problem though?. The tile cache should fill up, but that can give a massive performance boost *if* the tiles are requested again - which I'd expect could happen with at least some workflows. If it's undesirable, you can clear the cache if needed. From the description, it's not clear to me that this is a bug.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778
https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778:151,Performance,perform,performance,151,"> noticed that the memory would take a while to be dereferenced. Is this a problem though?. The tile cache should fill up, but that can give a massive performance boost *if* the tiles are requested again - which I'd expect could happen with at least some workflows. If it's undesirable, you can clear the cache if needed. From the description, it's not clear to me that this is a bug.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778
https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778:305,Performance,cache,cache,305,"> noticed that the memory would take a while to be dereferenced. Is this a problem though?. The tile cache should fill up, but that can give a massive performance boost *if* the tiles are requested again - which I'd expect could happen with at least some workflows. If it's undesirable, you can clear the cache if needed. From the description, it's not clear to me that this is a bug.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778
https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778:295,Usability,clear,clear,295,"> noticed that the memory would take a while to be dereferenced. Is this a problem though?. The tile cache should fill up, but that can give a massive performance boost *if* the tiles are requested again - which I'd expect could happen with at least some workflows. If it's undesirable, you can clear the cache if needed. From the description, it's not clear to me that this is a bug.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778
https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778:353,Usability,clear,clear,353,"> noticed that the memory would take a while to be dereferenced. Is this a problem though?. The tile cache should fill up, but that can give a massive performance boost *if* the tiles are requested again - which I'd expect could happen with at least some workflows. If it's undesirable, you can clear the cache if needed. From the description, it's not clear to me that this is a bug.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219606778
https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389:55,Performance,cache,cache,55,That's a good point. I personally didn't like that the cache took up most of my memory after processing (because most days I'm using a laptop that only has ~12GB RAM). But I can see how in some workflows you would want to store the cache and empty it later. Good to know that it probably is the tile cache.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389
https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389:232,Performance,cache,cache,232,That's a good point. I personally didn't like that the cache took up most of my memory after processing (because most days I'm using a laptop that only has ~12GB RAM). But I can see how in some workflows you would want to store the cache and empty it later. Good to know that it probably is the tile cache.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389
https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389:300,Performance,cache,cache,300,That's a good point. I personally didn't like that the cache took up most of my memory after processing (because most days I'm using a laptop that only has ~12GB RAM). But I can see how in some workflows you would want to store the cache and empty it later. Good to know that it probably is the tile cache.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1040#issuecomment-1219611389
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:1986,Availability,error,errors,1986,"ith consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calling 'Simplify shape' on any complex annotations first."");; 		}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:721,Integrability,synchroniz,synchronizedList,721,"Yep, this works for me Pete. Clever example. I also messed around with consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calli",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:407,Modifiability,variab,variables,407,"Yep, this works for me Pete. Clever example. I also messed around with consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calli",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:1973,Safety,avoid,avoid,1973,"ith consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calling 'Simplify shape' on any complex annotations first."");; 		}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:1864,Testability,log,logger,1864,"ith consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calling 'Simplify shape' on any complex annotations first."");; 		}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:1941,Testability,log,logger,1941,"ith consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calling 'Simplify shape' on any complex annotations first."");; 		}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298:2005,Usability,Simpl,Simplify,2005,"ith consolidating the last portion of the code into a parallel stream, but it is not much faster than the original code for one parentROI. In my case, I want to calculate the intersections for multiple ROIs with the tile, so it was easier for me to write the code similar to the snippet below:. ```; //		have to make all these ""final"" temp variables.... probably a better way; 		double finalYMin = yMin;; 		double finalXMin = xMin;; 		boolean finalByColumn = byColumn;; 		Map<Integer, Geometry> finalColumnParents = columnParents;; 		boolean finalByRow = byRow;; 		Map<Integer, Geometry> finalRowParents = rowParents;; 		List<ROI> tileROIs = Collections.synchronizedList(new ArrayList<>());; 		var plane = parentROI.getImagePlane();; 		AtomicInteger nullInterExcepetions = new AtomicInteger(0);; 		IntStream.range(0, nx).parallel().forEach(xi -> {; 			double x = finalXMin + xi * w - overlap;; //			A very hacky way to consolidate the code into 1 loop.; //			Atomic Reference doesn't behave when getting hit by multiple streams setting potentially different values for each stream...; 			Geometry outerGeometryLocal = finalByColumn ? finalColumnParents.getOrDefault(xi, geometry) : geometry;; 			IntStream.range(0, ny).parallel().forEach(yi -> {; 				double y = finalYMin + yi * h - overlap;; 				Geometry geometryLocal = finalByRow ? finalRowParents.getOrDefault(yi, geometry) : outerGeometryLocal;. 				// Create the tile; 				var rect = GeometryTools.createRectangle(x, y, w + overlap * 2, h + overlap * 2);; 				Geometry inter = intersect(rect, geometryLocal);; 				if(inter==null) {; 					nullInterExcepetions.incrementAndGet();; 					return;; 				}; 				ROI roi = GeometryTools.geometryToROI(inter, plane);; 				tileROIs.add(roi);; 			});; 		});. 		if (nullInterExcepetions.get() > 0) {; 			logger.warn(""Tiles lost during tiling: {}"", nullInterExcepetions.get());; 			logger.warn(""You may be able to avoid tiling errors by calling 'Simplify shape' on any complex annotations first."");; 		}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219923298
https://github.com/qupath/qupath/pull/1043#issuecomment-1219943848:420,Safety,detect,detections,420,"This is kinda related but probably deserves it's own question. But I was wondering if there was a way to show the child objects inside the viewer for Tiles?. Here is a picture of my object hierarchy and current viewer:; ![children objects of tiles are not shown in viewer](https://user-images.githubusercontent.com/28576964/185491229-dc4943de-b770-4f1f-8117-7141399bee4f.png). I want all the children objects (which are detections/tiles) to be shown inside each tile:; ![selected children objects of tiles are not shown in viewer](https://user-images.githubusercontent.com/28576964/185491329-3c2123ad-214e-41ba-b8f3-787496c100ea.png). I tried changing child objects from tiles to detections, but they won't show in the viewer unless I click on each of the children individually. Is there a setting I am missing to show all child objects inside of tiles?. Thank you again for your help. EDIT: Actually this works fine after reloading the data. Sorry, you can ignore this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219943848
https://github.com/qupath/qupath/pull/1043#issuecomment-1219943848:680,Safety,detect,detections,680,"This is kinda related but probably deserves it's own question. But I was wondering if there was a way to show the child objects inside the viewer for Tiles?. Here is a picture of my object hierarchy and current viewer:; ![children objects of tiles are not shown in viewer](https://user-images.githubusercontent.com/28576964/185491229-dc4943de-b770-4f1f-8117-7141399bee4f.png). I want all the children objects (which are detections/tiles) to be shown inside each tile:; ![selected children objects of tiles are not shown in viewer](https://user-images.githubusercontent.com/28576964/185491329-3c2123ad-214e-41ba-b8f3-787496c100ea.png). I tried changing child objects from tiles to detections, but they won't show in the viewer unless I click on each of the children individually. Is there a setting I am missing to show all child objects inside of tiles?. Thank you again for your help. EDIT: Actually this works fine after reloading the data. Sorry, you can ignore this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1043#issuecomment-1219943848
https://github.com/qupath/qupath/issues/1045#issuecomment-1230162351:1912,Energy Efficiency,reduce,reduced,1912,"Using OS-2.ndpi with ~150k cells, the following script requires **12-15 seconds** on a Mac Studio:; ```groovy; import qupath.lib.gui.tools.MeasurementExporter; import qupath.lib.objects.PathCellObject. def project = getProject(); def imagesToExport = [getProjectEntry()]; def separator = ""\t"". def columnsToInclude = new String[]{""Name"", ""Class"", ""Nucleus: Area""}; def exportType = PathCellObject.class; def outputPath = buildFilePath(PROJECT_BASE_DIR, getProjectEntry().getImageName() + "".tsv""); def outputFile = new File(outputPath). def exporter = new MeasurementExporter(); .imageList(imagesToExport) // Images from which measurements will be exported; .separator(separator) // Character that separates values; .includeOnlyColumns(columnsToInclude) // Columns are case-sensitive; .exportType(exportType) // Type of objects to export; .exportMeasurements(outputFile) // Start the export process. print ""Done!""; ```. By contrast, the following exports something similar but takes **0.6-0.7 seconds**:. ```groovy; // Some kind of file path for the current image; def name = getProjectEntry().getImageName(); name = GeneralTools.getNameWithoutExtension(name); def path = buildFilePath(PROJECT_BASE_DIR, name + '.tsv'). def cells = getCellObjects(); def measurements = ['Nucleus: Area']. try (def writer = new PrintWriter(path)) {. // Write header; def sb = new StringBuilder(); sb.append('Class'); for (def measurementName in measurements) {; sb.append('\t'); sb.append(measurementName); }; writer.println(sb.toString()); ; // Write measurements; for (def cell in cells) {; sb.setLength(0); sb.append(cell.getPathClass()); for (def measurementName in measurements) {; sb.append('\t'); sb.append(cell.getMeasurementList().getMeasurementValue(measurementName)); }; writer.println(sb.toString()); }; ; }; println ""Written to $path""; ```. Some overhead is expected when using `MeasurementExporter`, but it should be reduced.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1045#issuecomment-1230162351
https://github.com/qupath/qupath/issues/1045#issuecomment-1230386652:72,Availability,down,down,72,"So the lack of a buffered stream is probably unimportant, since digging down deeper I see that a `PrintWriter` is used... which involves some buffering (as far as I can tell). Which may explain why I didn't really spot any clear improvement when using a `BufferedOutputStream`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1045#issuecomment-1230386652
https://github.com/qupath/qupath/issues/1045#issuecomment-1230386652:223,Usability,clear,clear,223,"So the lack of a buffered stream is probably unimportant, since digging down deeper I see that a `PrintWriter` is used... which involves some buffering (as far as I can tell). Which may explain why I didn't really spot any clear improvement when using a `BufferedOutputStream`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1045#issuecomment-1230386652
https://github.com/qupath/qupath/issues/1045#issuecomment-1231729271:429,Modifiability,maintainab,maintainability,429,"Upon further investigation, it's probably worth revising this command. The following methods do much the same thing:; * Export through the UI; * https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/MeasurementExportCommand.java#L413; * Export via scripting; * https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/MeasurementExporter.java#L212. For maintainability, we should try to figure out a way to reuse the same code.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1045#issuecomment-1231729271
https://github.com/qupath/qupath/pull/1049#issuecomment-1240602285:318,Testability,test,test,318,"Thanks @ap--!. From a quick search of the QuPath code, we do use `new File(uri)` in quite a lot of places, so I'd like to understand better what the problem is to see if we need to eliminate it entirely. I had a look at the other discussion, but I'm still fuzzy on the real-world implications and how I could properly test any fix. I saw the combination of URIs that do and don't work and I also saw; ```; print(java.io.File(java.net.URI(""file://localhost/c$/Windows"")).exists()) # fails URI has an authority component (bug as this is completely valid path); ```; but I guess I don't understand when and why that matters, or if the URI could simply be given in some other way?. Unfortunately, I use Windows very rarely, network shares on Windows even less, and don't know much about more exotic URIs...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1049#issuecomment-1240602285
https://github.com/qupath/qupath/pull/1049#issuecomment-1240602285:642,Usability,simpl,simply,642,"Thanks @ap--!. From a quick search of the QuPath code, we do use `new File(uri)` in quite a lot of places, so I'd like to understand better what the problem is to see if we need to eliminate it entirely. I had a look at the other discussion, but I'm still fuzzy on the real-world implications and how I could properly test any fix. I saw the combination of URIs that do and don't work and I also saw; ```; print(java.io.File(java.net.URI(""file://localhost/c$/Windows"")).exists()) # fails URI has an authority component (bug as this is completely valid path); ```; but I guess I don't understand when and why that matters, or if the URI could simply be given in some other way?. Unfortunately, I use Windows very rarely, network shares on Windows even less, and don't know much about more exotic URIs...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1049#issuecomment-1240602285
https://github.com/qupath/qupath/pull/1049#issuecomment-1240712824:816,Testability,test,tested,816,"> but I guess I don't understand when and why that matters, or if the URI could simply be given in some other way?; > ; > Unfortunately, I use Windows very rarely, network shares on Windows even less, and don't know much about more exotic URIs... tbh it's the same for me. So far as I understand, it's currently impossible to use valid file URIs on windows that are not mapped to a network drive. i.e. . ```; file://networkshare/c$/file.svs; ```. I am not 100% sure if it's possible to use files on network shares, when they are mapped to a network drive, i.e.; ```; file:///M:/file.svs; ```. And I should actually try this on a windows laptop first to verify. Initially, I was hoping that this might be some issue you're already aware of, and that the source of the bug might be obvious. I'll report back once I've tested this manually with QuPath on windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1049#issuecomment-1240712824
https://github.com/qupath/qupath/pull/1049#issuecomment-1240712824:80,Usability,simpl,simply,80,"> but I guess I don't understand when and why that matters, or if the URI could simply be given in some other way?; > ; > Unfortunately, I use Windows very rarely, network shares on Windows even less, and don't know much about more exotic URIs... tbh it's the same for me. So far as I understand, it's currently impossible to use valid file URIs on windows that are not mapped to a network drive. i.e. . ```; file://networkshare/c$/file.svs; ```. I am not 100% sure if it's possible to use files on network shares, when they are mapped to a network drive, i.e.; ```; file:///M:/file.svs; ```. And I should actually try this on a windows laptop first to verify. Initially, I was hoping that this might be some issue you're already aware of, and that the source of the bug might be obvious. I'll report back once I've tested this manually with QuPath on windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1049#issuecomment-1240712824
https://github.com/qupath/qupath/pull/1049#issuecomment-1312554697:273,Testability,test,tests,273,"I think this PR can be closed.; Providing networkshare uris in the form of `""file:////localhost/x$/some/path/file.ext""` seems to work. Thanks again for your help!. https://github.com/bayer-science-for-a-better-life/paquo/blob/832817f6b0a877a57afd8e7e008a287af0564f5e/paquo/tests/test_projects.py#L183-L190",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1049#issuecomment-1312554697
https://github.com/qupath/qupath/issues/1062#issuecomment-1261141581:254,Testability,Test,Test,254,"Just adding for reference that this self-contained script shows the problem as well:. ```groovy; def chartData =; [(getPathClass('Negative')): 5,; (getPathClass('1+')): 2,; (getPathClass('2+')): 3,; (getPathClass('3+')): 4]; ; Charts.pieChart(); .title('Test Chart'); .data(chartData); .show(); ```; [Also learned that non-string keys in Groovy need to be in (brackets)...]",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1062#issuecomment-1261141581
https://github.com/qupath/qupath/issues/1062#issuecomment-1261141581:306,Usability,learn,learned,306,"Just adding for reference that this self-contained script shows the problem as well:. ```groovy; def chartData =; [(getPathClass('Negative')): 5,; (getPathClass('1+')): 2,; (getPathClass('2+')): 3,; (getPathClass('3+')): 4]; ; Charts.pieChart(); .title('Test Chart'); .data(chartData); .show(); ```; [Also learned that non-string keys in Groovy need to be in (brackets)...]",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1062#issuecomment-1261141581
https://github.com/qupath/qupath/issues/1065#issuecomment-1261176857:36,Availability,down,down,36,"Yep, I was hoping that might narrow down the cause for Pete.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1065#issuecomment-1261176857
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:452,Availability,down,downsample,452,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:611,Availability,down,downsample,611,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:1199,Availability,down,downsample,1199,"esult in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes addres",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:1167,Energy Efficiency,monitor,monitor,1167,"esult in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes addres",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:378,Performance,perform,performance,378,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:491,Performance,cache,caches,491,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:539,Performance,perform,performance,539,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:814,Performance,cache,cached,814,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:1238,Performance,perform,performance,1238,"esult in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes addres",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:1595,Performance,cache,cache,1595,"t shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes address any related bugs that I know of.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:2164,Performance,perform,performance,2164,"t shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes address any related bugs that I know of.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:480,Safety,detect,detections,480,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:654,Safety,detect,detections,654,"I've added a PR that is intended to address this... although its main focus is on another related bug: https://github.com/qupath/qupath/pull/1070. > Visualizing objects overlaid onto images shouldn't result in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189:1181,Safety,detect,detections,1181,"esult in substantial lag. Ideally it shouldn't, but if it does I wouldn't say it's necessarily a bug... since QuPath is already needing to do a *lot* of stuff to get acceptable performance across a wide range of scenarios. Specifically here:; * For a downsample >= 1, repainting detections caches tiles and multiple resolution levels for performance - this is why QuPath can handle millions of objects.; * For downsample < 1, repainting happens for all detections in the field of view (like for annotations) for improved appearance without nasty bitmap-upsampling artefacts. This is inevitably laggier than using cached tiles, but caching itself has considerable overhead in terms of memory and worse appearance. I think this tradeoff makes sense, since details really matter when viewing the image at high magnification but the number of objects visible should be limited (possibly thousands, but not millions). However it does mean that if you have a large enough monitor, many detections, and a downsample value slightly less than 1, performance there certainly can be a noticeable lag... and object connections make this worse by meaning that thousands more lines need to be rendered. However, investigating this revealed that QuPath was painting all the connections twice, which certainly wasn't helping things :). So the PR fixes the double-painting bug. Along the way, it adds a spatial cache that enables QuPath to be a bit smarter about which connections it paints. The main reason for this change is to overcome an issue with long connections sometimes being broken at some resolutions:. ### Old behavior:; ![connection_bug-1](https://user-images.githubusercontent.com/4690904/194024037-795fceaa-e542-4c67-8fa2-84e6a8aca691.png). ### New behavior:; ![connection_fix-1](https://user-images.githubusercontent.com/4690904/194024122-00080b78-b59b-4b8f-bf0d-aa990683268c.png). Together, I'm not certain whether or not you'll see a substantial improvement in performance - but these changes addres",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1268167189
https://github.com/qupath/qupath/issues/1069#issuecomment-1279726367:78,Performance,perform,performance,78,I'll close this because I think the main bug is addressed - and hopefully the performance is also at least a bit improved for the original use case.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1069#issuecomment-1279726367
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:785,Availability,ping,pinging,785,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:356,Deployability,update,update,356,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:956,Deployability,update,update,956,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:1524,Deployability,update,updated,1524,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:1617,Integrability,message,message,1617,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547:1625,Testability,log,logged,1625,"Hi Pete, and thanks for putting us in the loop!; It is true that the` RegionRequest` bits are a bit verbose, and any ease on that part would be welcome. . The proposed changes will have little effect on our scripts, as most calls are for `IJTools.createPathImage()` in any case... Concerning Warpy, and other extensions, we are happy to modify them and to update them no problem, and make sure to freeze the previous versions. On a personal note, breaking changes let us keep an eye on scripts that are still being used (often for projects that have little to do with the original requirements), so we kind of see it as a good thing when people come to us because something ""no longer works"". Helps us make sure that not too many weird things are being done with our scripts :) . I am pinging @rdornier, for completion, as he was working on the OMERO-RAW part we have here and might need to make some changes there, if we keep that extension after the 0.4 update. . One argument for making more intensive changes, without too much backwards compatibility is that it really forces us to keep up with the new developments, rather than let it linger on until it's too late. So I'm more in favor of ""breaking"" than keeping full backwards compatibility. Though admittedly, our user base is not as large as yours, so we won't see as much of a tidalwave... > include this in QuPath v0.4.0 (hopefully later this month). Awesome. > remove the default implementation of readRegion in v0.5.0, forcing any subclass of ImageServer to be updated to work... but still allowing scripts to use readBufferedImage, with the deprecation message logged. OK for us, though if the scripts end up breaking, this would not be a problem, kind of a nice extra way of announcing that things have changed. > remove readBufferedImage later, e.g. in v0.6.0. Not in v0.5.0 already? . Thanks again for the discussion! Looking forward to notes and comments from others!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273134547
https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885:179,Deployability,release,release,179,"Hi Pete,. I just ran the `paquo` test suite against the `qupath` snapshot version from this PR and all tests pass. So there are no concerns from our side. Also, since the current release of `paquo` supports any QuPath from `0.2.0-m9` to (now tested) `0.4.0+snapshot` (https://github.com/qupath/qupath/pull/1072/commits/a91c5bfc865710308dc22f11fd6a3f4709eaf799) having a small breaking change would also be fine. We're maintaining a bunch of checks to support the different QuPath versions anyways. So what I am saying is: please don't keep any cruft around just because it might break `paquo`. Cheers,; Andreas",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885
https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885:33,Testability,test,test,33,"Hi Pete,. I just ran the `paquo` test suite against the `qupath` snapshot version from this PR and all tests pass. So there are no concerns from our side. Also, since the current release of `paquo` supports any QuPath from `0.2.0-m9` to (now tested) `0.4.0+snapshot` (https://github.com/qupath/qupath/pull/1072/commits/a91c5bfc865710308dc22f11fd6a3f4709eaf799) having a small breaking change would also be fine. We're maintaining a bunch of checks to support the different QuPath versions anyways. So what I am saying is: please don't keep any cruft around just because it might break `paquo`. Cheers,; Andreas",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885
https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885:103,Testability,test,tests,103,"Hi Pete,. I just ran the `paquo` test suite against the `qupath` snapshot version from this PR and all tests pass. So there are no concerns from our side. Also, since the current release of `paquo` supports any QuPath from `0.2.0-m9` to (now tested) `0.4.0+snapshot` (https://github.com/qupath/qupath/pull/1072/commits/a91c5bfc865710308dc22f11fd6a3f4709eaf799) having a small breaking change would also be fine. We're maintaining a bunch of checks to support the different QuPath versions anyways. So what I am saying is: please don't keep any cruft around just because it might break `paquo`. Cheers,; Andreas",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885
https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885:242,Testability,test,tested,242,"Hi Pete,. I just ran the `paquo` test suite against the `qupath` snapshot version from this PR and all tests pass. So there are no concerns from our side. Also, since the current release of `paquo` supports any QuPath from `0.2.0-m9` to (now tested) `0.4.0+snapshot` (https://github.com/qupath/qupath/pull/1072/commits/a91c5bfc865710308dc22f11fd6a3f4709eaf799) having a small breaking change would also be fine. We're maintaining a bunch of checks to support the different QuPath versions anyways. So what I am saying is: please don't keep any cruft around just because it might break `paquo`. Cheers,; Andreas",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1273266885
https://github.com/qupath/qupath/pull/1072#issuecomment-1274832991:101,Modifiability,extend,extends,101,"Hi Pete, . Thanks for thinking of Slide Score with breaking changes. Our ```SlideScoreImageServer``` extends ```AbstractTileableImageServer``` and only overrides ```readTile```. So, these changes don't cause any problems if I understand it correctly. I don't see any deprecation warnings at compile- or run-time. The new JDK version, modular JavaFX and mandatory JLS caused more issues ;-). Jan",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1274832991
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:440,Availability,down,downsample,440,"Thanks @ap-- and @j-hudecek :). The acceptance of this API change has me now thinking about going a step further... I am missing a method like; ```java; public T readLevel(int level, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T r",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:516,Availability,down,downsample,516,"Thanks @ap-- and @j-hudecek :). The acceptance of this API change has me now thinking about going a step further... I am missing a method like; ```java; public T readLevel(int level, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T r",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:623,Availability,down,downsample,623,"Thanks @ap-- and @j-hudecek :). The acceptance of this API change has me now thinking about going a step further... I am missing a method like; ```java; public T readLevel(int level, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T r",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:811,Availability,down,down,811,"Thanks @ap-- and @j-hudecek :). The acceptance of this API change has me now thinking about going a step further... I am missing a method like; ```java; public T readLevel(int level, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T r",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:921,Availability,error,errors,921,"Thanks @ap-- and @j-hudecek :). The acceptance of this API change has me now thinking about going a step further... I am missing a method like; ```java; public T readLevel(int level, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T r",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:1159,Availability,down,down,1159,"l, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:1630,Availability,down,downsample,1630,"something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupat",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:2024,Availability,down,downsample,2024," that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142) and [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142)). But I strongly suspect the [`TileExporter`](https://github.com/qupath/qupath/blob/9eaf034e2cd0325d38967bde5ac43900ddc15e3f/qupath-core/src/main/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:2191,Availability,down,downsample,2191," that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142) and [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142)). But I strongly suspect the [`TileExporter`](https://github.com/qupath/qupath/blob/9eaf034e2cd0325d38967bde5ac43900ddc15e3f/qupath-core/src/main/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:2359,Integrability,interface,interface,2359,", but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142) and [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142)). But I strongly suspect the [`TileExporter`](https://github.com/qupath/qupath/blob/9eaf034e2cd0325d38967bde5ac43900ddc15e3f/qupath-core/src/main/java/qupath/lib/images/writers/TileExporter.java) isn't always doing the right thing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:1430,Safety,predict,predictable,1430,"ing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to ad",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:1260,Testability,test,test,1260,"l, ImageRegion region);; ```; where the `level` is a specific level of the pyramid (0 for full-resolution). Currently, if I want to get a rectangle of pixels from level 2, I need to figure out the coordinates in the full-resolution image (i.e. multiply by the downsample value). Then QuPath should find them again after dividing by the downsample. However, the coordinates need to be integers - which makes me uneasy about what happens if the downsample is something like 4.23452345.; Should I be rounding or flooring when I scale up the coordinates?; And can I be sure that QuPath will do the right thing when it scales them back down, so that I get the original coordinates I wanted again...?. If not, then it seems I might get off-by-one errors and slightly unexpected results. If I want a 256 x 256 pixel region, I might end up with a 255 x 256 pixel region... which would be annoying. It seems that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:1920,Usability,simpl,simpler,1920," that I can round or floor when scaling up, and then round or floor when scaling down, but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142) and [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142)). But I strongly suspect the [`TileExporter`](https://github.com/qupath/qupath/blob/9eaf034e2cd0325d38967bde5ac43900ddc15e3f/qupath-core/src/main/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089:2311,Usability,simpl,simply,2311,", but I wasn't completely sure which I should be doing so I created a quick Python simulation to test what happens: https://gist.github.com/petebankhead/2d4a21cb69f3b68c8f8fa14475723647. Based on this, it seems I need to round in both directions... which was maybe a predictable conclusion for the more mathematically confident, but I wasn't sure of it's what QuPath does internally* and we can't count on users necessarily knowing that. (*However*, note that if the downsample is < 1 then all the methods fail...). I think it would be nice to resolve the ambiguity somehow, although adding an extra method; ```java; public T readLevel(int level, int x, int y, int width, int height, int z, int t);; ```; looks like a horrible explosion of ints. A possibly-simpler alternative might be to support something like this:; ```java; public T readScaledRegion(double downsample, int outputX, int outputY, int outputWidth, int outputHeight, int z, int t);; ```; where the coordinates are defined according to the output image, but the downsample isn't fixed to *have* to be a pyramidal level. Thinking about it, that could potentially be implemented more simply with another default method added to the interface that ultimately just called `readRegion`. The main trouble is that I don't know what to call the method. I'll keep thinking and try to add something to this PR.... *- I think that QuPath is doing the right thing in most places (based on [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142) and [this](https://github.com/qupath/qupath/blob/053efeff6d941e7a73beab5445cf0d6238ed97b7/qupath-core/src/main/java/qupath/lib/images/servers/TileRequest.java#L142)). But I strongly suspect the [`TileExporter`](https://github.com/qupath/qupath/blob/9eaf034e2cd0325d38967bde5ac43900ddc15e3f/qupath-core/src/main/java/qupath/lib/images/writers/TileExporter.java) isn't always doing the right thing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089
https://github.com/qupath/qupath/pull/1072#issuecomment-1279321821:401,Availability,down,downsample,401,"Just as another suggestion:. In our pathology dataset library we implemented functionality that allows you to retrieve a tile at a location with a certain size and at a **specific MPP** (see [here](https://github.com/Bayer-Group/pado/blob/738ed0f814297f22ba005d5b30d254244e23ef82/pado/images/image.py#L506-L508)). Because after talking to a few researchers, they usually don't want to think about the downsample values of levels in the file. They want tiles at a specific magnification / mpp / resolution.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1279321821
https://github.com/qupath/qupath/pull/1072#issuecomment-1279724824:137,Availability,avail,available,137,"Thanks @ap-- it's tempting since QuPath generally µm/px values where it can, but the trouble is that we can't count on them always being available. When I know it's there, I end up doing a lot of; ```groovy; double downsample = requestedPixelSizeMicrons / server.getPixelCalibration().getAveragedPixelSizeMicrons();; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1279724824
https://github.com/qupath/qupath/pull/1072#issuecomment-1279724824:215,Availability,down,downsample,215,"Thanks @ap-- it's tempting since QuPath generally µm/px values where it can, but the trouble is that we can't count on them always being available. When I know it's there, I end up doing a lot of; ```groovy; double downsample = requestedPixelSizeMicrons / server.getPixelCalibration().getAveragedPixelSizeMicrons();; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1279724824
https://github.com/qupath/qupath/pull/1072#issuecomment-1279727287:62,Safety,avoid,avoid,62,"Thanks everyone for the feedback - I'll merge this for now to avoid making too much of a mess while merging other PRs, but might return to it later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1279727287
https://github.com/qupath/qupath/pull/1072#issuecomment-1279727287:24,Usability,feedback,feedback,24,"Thanks everyone for the feedback - I'll merge this for now to avoid making too much of a mess while merging other PRs, but might return to it later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1072#issuecomment-1279727287
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:531,Availability,checkpoint,checkpoints,531,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:815,Availability,checkpoint,checkpoints,815,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:971,Availability,checkpoint,checkpoints,971,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:1610,Availability,checkpoint,checkpoints,1610,"3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet() as List; println ""Total time: \t${entries[-1].value - entries[0].value} ms""; for (int i = 0; i < entries.size()-1; i++) {; println "" ${entries[i].key} \t${entries[i+1].value - entries[i].value}""; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:1806,Availability,checkpoint,checkpoints,1806,"3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet() as List; println ""Total time: \t${entries[-1].value - entries[0].value} ms""; for (int i = 0; i < entries.size()-1; i++) {; println "" ${entries[i].key} \t${entries[i+1].value - entries[i].value}""; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:1962,Availability,checkpoint,checkpoints,1962,"3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet() as List; println ""Total time: \t${entries[-1].value - entries[0].value} ms""; for (int i = 0; i < entries.size()-1; i++) {; println "" ${entries[i].key} \t${entries[i+1].value - entries[i].value}""; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:2064,Availability,checkpoint,checkpoints,2064,"3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet() as List; println ""Total time: \t${entries[-1].value - entries[0].value} ms""; for (int i = 0; i < entries.size()-1; i++) {; println "" ${entries[i].key} \t${entries[i+1].value - entries[i].value}""; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:9,Performance,perform,performance,9,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:457,Safety,detect,detection,457,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:505,Safety,detect,detected,505,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:839,Safety,detect,detection,839,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:925,Safety,detect,detection,925,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:993,Safety,detect,detection,993,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:1080,Safety,detect,detect,1080,"lassifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:1121,Safety,detect,detectionImageBrightfield,1121," and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentTimeMillis()]; resetSelection(); println 'Done!'. def entries = checkpoints.entrySet() as List; println ""Total time: \t${entries[-1].value - entri",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:2,Testability,test,tested,2,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:75,Usability,simpl,simple,75,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584:796,Usability,clear,clearAllObjects,796,"I tested performance using CMU-1.svs.; I used a very basic thresholder and simple classifier trained for 3 classes, saved for both classification and probability output - then ran the script at the bottom. Using a Mac Studio (2022) with M1 Max and 32 GB RAM the processing time was:. | v0.3.0 | v0.4.0-SNAPSHOT |; | ------------- | ------------- |; | 593.9 s | 60.1 s |. Results identical as far as I can tell. So... quite a substantial difference :). Cell detection took close to 30s, with 326 498 cells detected,. ```groovy; def checkpoints = [:]. setImageType('BRIGHTFIELD_H_E'); setColorDeconvolutionStains('{""Name"" : ""H&E default"", ""Stain 1"" : ""Hematoxylin"", ""Values 1"" : ""0.65111 0.70119 0.29049"", ""Stain 2"" : ""Eosin"", ""Values 2"" : ""0.2159 0.8012 0.5581"", ""Background"" : "" 255 255 255""}'). clearAllObjects(). checkpoints << ['Tissue detection': System.currentTimeMillis()]. createAnnotationsFromPixelClassifier(""Tissue detection"", 10000.0, 0.0, ""INCLUDE_IGNORED""). checkpoints << ['Cell detection': System.currentTimeMillis()]. selectAnnotations(); runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImageBrightfield"": ""Hematoxylin OD"", ""requestedPixelSizeMicrons"": 1.0, ""backgroundRadiusMicrons"": 8.0, ""medianRadiusMicrons"": 0.0, ""sigmaMicrons"": 1.5, ""minAreaMicrons"": 10.0, ""maxAreaMicrons"": 400.0, ""threshold"": 0.1, ""maxBackground"": 2.0, ""watershedPostProcess"": true, ""cellExpansionMicrons"": 5.0, ""includeNuclei"": true, ""smoothBoundaries"": true, ""makeMeasurements"": true}'). for (classifier in ['Some probability', 'Some classification']) {. // Create annotation measurements; checkpoints << [""Annotation measurements for $classifier"": System.currentTimeMillis()]; selectAnnotations(); addPixelClassifierMeasurements(classifier, classifier); ; // Create cell measurements; checkpoints << [""Cell measurements for $classifier"": System.currentTimeMillis()]; selectCells(); addPixelClassifierMeasurements(classifier, classifier); }; checkpoints << [""Done"": System.currentT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279692584
https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970:854,Availability,down,down,854,"Latest commit adds more options to restrict where live pixel classifier prediction is calculated. Previously, it could be restricted to annotations - but using their full bounding box. This could sometimes still result in very large regions being processed. ![annotations_bounds](https://user-images.githubusercontent.com/4690904/195979231-ee656727-83dd-4569-80d7-318beb8c4c6f.png). Now it's also possible to restrict using the annotation ROI directly (i.e. the ROI shape intersects the tiled region that may be processed). This can reduce the amount of processing required substantially in some cases. ![annotations_only](https://user-images.githubusercontent.com/4690904/195979232-ef0c6862-d715-47b9-a022-0f4267f1c47c.png). Both options still exist, since the more complex calculations to restrict the predicted regions could *potentially* slow things down in some cases.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970
https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970:533,Energy Efficiency,reduce,reduce,533,"Latest commit adds more options to restrict where live pixel classifier prediction is calculated. Previously, it could be restricted to annotations - but using their full bounding box. This could sometimes still result in very large regions being processed. ![annotations_bounds](https://user-images.githubusercontent.com/4690904/195979231-ee656727-83dd-4569-80d7-318beb8c4c6f.png). Now it's also possible to restrict using the annotation ROI directly (i.e. the ROI shape intersects the tiled region that may be processed). This can reduce the amount of processing required substantially in some cases. ![annotations_only](https://user-images.githubusercontent.com/4690904/195979232-ef0c6862-d715-47b9-a022-0f4267f1c47c.png). Both options still exist, since the more complex calculations to restrict the predicted regions could *potentially* slow things down in some cases.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970
https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970:72,Safety,predict,prediction,72,"Latest commit adds more options to restrict where live pixel classifier prediction is calculated. Previously, it could be restricted to annotations - but using their full bounding box. This could sometimes still result in very large regions being processed. ![annotations_bounds](https://user-images.githubusercontent.com/4690904/195979231-ee656727-83dd-4569-80d7-318beb8c4c6f.png). Now it's also possible to restrict using the annotation ROI directly (i.e. the ROI shape intersects the tiled region that may be processed). This can reduce the amount of processing required substantially in some cases. ![annotations_only](https://user-images.githubusercontent.com/4690904/195979232-ef0c6862-d715-47b9-a022-0f4267f1c47c.png). Both options still exist, since the more complex calculations to restrict the predicted regions could *potentially* slow things down in some cases.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970
https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970:804,Safety,predict,predicted,804,"Latest commit adds more options to restrict where live pixel classifier prediction is calculated. Previously, it could be restricted to annotations - but using their full bounding box. This could sometimes still result in very large regions being processed. ![annotations_bounds](https://user-images.githubusercontent.com/4690904/195979231-ee656727-83dd-4569-80d7-318beb8c4c6f.png). Now it's also possible to restrict using the annotation ROI directly (i.e. the ROI shape intersects the tiled region that may be processed). This can reduce the amount of processing required substantially in some cases. ![annotations_only](https://user-images.githubusercontent.com/4690904/195979232-ef0c6862-d715-47b9-a022-0f4267f1c47c.png). Both options still exist, since the more complex calculations to restrict the predicted regions could *potentially* slow things down in some cases.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1076#issuecomment-1279704970
https://github.com/qupath/qupath/issues/1083#issuecomment-1287672102:936,Performance,perform,performance,936,"Thanks @ajay1685 the PR above should address most of this, and a couple of other bugs I spotted (like measurements not updating if cores were moved on the image). Please let me know if you notice any significant problems with this. Because the TMA data viewer is unmaintained, I think there is an above-average risk of unreported/unnoticed bugs so I've added a warning now as well. You can double-click on it to make it go away. <img width=""1006"" alt=""TMA data viewer"" src=""https://user-images.githubusercontent.com/4690904/197327977-4298edd4-13f3-41d3-b99c-6f95be821ff9.png"">. In the longer term, I think it should be removed or rewritten. Rewritten would be preferable, but it's really a matter of capacity... as the software gets bigger, there are so many different parts to maintain and I haven't worked with TMAs myself in years.; (In that regard, new QuPath jobs to be advertised next week - please share them widely!). Regarding performance, I couldn't replicate any sluggishness - it was very smooth for me, but then I was only using 'toy' datasets based on generating a grid on a regular whole slide image. If you can provide more info to replicate the sluggishness then I could have a quick look into that, but for now I hope the main issues are fixed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1287672102
https://github.com/qupath/qupath/issues/1083#issuecomment-1287672102:311,Safety,risk,risk,311,"Thanks @ajay1685 the PR above should address most of this, and a couple of other bugs I spotted (like measurements not updating if cores were moved on the image). Please let me know if you notice any significant problems with this. Because the TMA data viewer is unmaintained, I think there is an above-average risk of unreported/unnoticed bugs so I've added a warning now as well. You can double-click on it to make it go away. <img width=""1006"" alt=""TMA data viewer"" src=""https://user-images.githubusercontent.com/4690904/197327977-4298edd4-13f3-41d3-b99c-6f95be821ff9.png"">. In the longer term, I think it should be removed or rewritten. Rewritten would be preferable, but it's really a matter of capacity... as the software gets bigger, there are so many different parts to maintain and I haven't worked with TMAs myself in years.; (In that regard, new QuPath jobs to be advertised next week - please share them widely!). Regarding performance, I couldn't replicate any sluggishness - it was very smooth for me, but then I was only using 'toy' datasets based on generating a grid on a regular whole slide image. If you can provide more info to replicate the sluggishness then I could have a quick look into that, but for now I hope the main issues are fixed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1287672102
https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832:736,Availability,alive,alive,736,"@petebankhead I will definitely share the new QuPath jobs. Thank you for these fixes to the TMA Data viewer. The table now has correct colors and all the columns that were missing values now have correct values. . I am just realizing that the data table is only sluggish when the TMAs have cell detections present. If I were to calculate my measurements of interest for each TMA and remove detections before testing the TMA Data viewer then it works very smooth. Is it possible that the vertical scroll issue sluggishness is a side effect of being able to view huge combined dataset ""live""!. I hope TMA Viewer is here to stay as a legacy feature for a while, it seems to have served well and continues to work. Thank you for keeping it alive.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832
https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832:295,Safety,detect,detections,295,"@petebankhead I will definitely share the new QuPath jobs. Thank you for these fixes to the TMA Data viewer. The table now has correct colors and all the columns that were missing values now have correct values. . I am just realizing that the data table is only sluggish when the TMAs have cell detections present. If I were to calculate my measurements of interest for each TMA and remove detections before testing the TMA Data viewer then it works very smooth. Is it possible that the vertical scroll issue sluggishness is a side effect of being able to view huge combined dataset ""live""!. I hope TMA Viewer is here to stay as a legacy feature for a while, it seems to have served well and continues to work. Thank you for keeping it alive.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832
https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832:390,Safety,detect,detections,390,"@petebankhead I will definitely share the new QuPath jobs. Thank you for these fixes to the TMA Data viewer. The table now has correct colors and all the columns that were missing values now have correct values. . I am just realizing that the data table is only sluggish when the TMAs have cell detections present. If I were to calculate my measurements of interest for each TMA and remove detections before testing the TMA Data viewer then it works very smooth. Is it possible that the vertical scroll issue sluggishness is a side effect of being able to view huge combined dataset ""live""!. I hope TMA Viewer is here to stay as a legacy feature for a while, it seems to have served well and continues to work. Thank you for keeping it alive.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832
https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832:408,Testability,test,testing,408,"@petebankhead I will definitely share the new QuPath jobs. Thank you for these fixes to the TMA Data viewer. The table now has correct colors and all the columns that were missing values now have correct values. . I am just realizing that the data table is only sluggish when the TMAs have cell detections present. If I were to calculate my measurements of interest for each TMA and remove detections before testing the TMA Data viewer then it works very smooth. Is it possible that the vertical scroll issue sluggishness is a side effect of being able to view huge combined dataset ""live""!. I hope TMA Viewer is here to stay as a legacy feature for a while, it seems to have served well and continues to work. Thank you for keeping it alive.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289156832
https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954:360,Performance,load,load,360,"Project contains total of 6 TMA slides. Each contains approximately ~80 cores. A few cores are marked as missing per slide due to not enough tissue or missing information. I have a total of approximately ~400 valid cores in the project, each slide may contain multiple cores per subject id. I tested the Measure -> show TMA measurements. This means I can only load the data for the active image. The table does work with a tiny bit of scrolling lag - very little. If I open the same image without detections the table is smooth. . I have about ~ 13 classes. I am working with 7 channel multiplex image hence each detection has 116 measurements (shape and intensity)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954
https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954:497,Safety,detect,detections,497,"Project contains total of 6 TMA slides. Each contains approximately ~80 cores. A few cores are marked as missing per slide due to not enough tissue or missing information. I have a total of approximately ~400 valid cores in the project, each slide may contain multiple cores per subject id. I tested the Measure -> show TMA measurements. This means I can only load the data for the active image. The table does work with a tiny bit of scrolling lag - very little. If I open the same image without detections the table is smooth. . I have about ~ 13 classes. I am working with 7 channel multiplex image hence each detection has 116 measurements (shape and intensity)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954
https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954:613,Safety,detect,detection,613,"Project contains total of 6 TMA slides. Each contains approximately ~80 cores. A few cores are marked as missing per slide due to not enough tissue or missing information. I have a total of approximately ~400 valid cores in the project, each slide may contain multiple cores per subject id. I tested the Measure -> show TMA measurements. This means I can only load the data for the active image. The table does work with a tiny bit of scrolling lag - very little. If I open the same image without detections the table is smooth. . I have about ~ 13 classes. I am working with 7 channel multiplex image hence each detection has 116 measurements (shape and intensity)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954
https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954:293,Testability,test,tested,293,"Project contains total of 6 TMA slides. Each contains approximately ~80 cores. A few cores are marked as missing per slide due to not enough tissue or missing information. I have a total of approximately ~400 valid cores in the project, each slide may contain multiple cores per subject id. I tested the Measure -> show TMA measurements. This means I can only load the data for the active image. The table does work with a tiny bit of scrolling lag - very little. If I open the same image without detections the table is smooth. . I have about ~ 13 classes. I am working with 7 channel multiplex image hence each detection has 116 measurements (shape and intensity)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289206954
https://github.com/qupath/qupath/issues/1083#issuecomment-1289210565:314,Energy Efficiency,efficient,efficiently,314,"Ah ok, if you're loading from multiple images then I'd expect a lot more lag. I think that was always the case. As far as I can remember, the solution is to use *File &rarr; TMA data... &rarr; Export TMA data* first. That should save the measurements and thumbnail images so they can be read and browsed much more efficiently. Please let me know if that helps.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289210565
https://github.com/qupath/qupath/issues/1083#issuecomment-1289210565:17,Performance,load,loading,17,"Ah ok, if you're loading from multiple images then I'd expect a lot more lag. I think that was always the case. As far as I can remember, the solution is to use *File &rarr; TMA data... &rarr; Export TMA data* first. That should save the measurements and thumbnail images so they can be read and browsed much more efficiently. Please let me know if that helps.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289210565
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:839,Availability,error,error,839,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:914,Availability,error,error,914,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:978,Availability,ERROR,ERROR,978,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:942,Deployability,toggle,toggle,942,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:1482,Deployability,Update,Update,1482,"after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:1668,Deployability,Update,Update,1668,"er the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entr",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:133,Performance,load,loaded,133,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:211,Performance,load,load,211,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:859,Performance,load,loading,859,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2740,Performance,load,loaded,2740,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2874,Performance,load,load,2874,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:456,Safety,detect,detection,456,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:6,Testability,test,tested,6,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:852,Testability,log,log,852,"Ok, I tested the ""Offline TMA Data Viewer"" (not sure what to call this method!). I exported TMA data (qptma) for all 6 TMA slides. I loaded one file in the TMA Data Viewer in a new QuPath instance which seem to load data for all the qptma files present in the folder ! is that expected behavior ?. With this method the table is very smooth. It makes sense to work offline if I want to look at the combined data from multiple TMAs after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:1355,Testability,log,log,1355,"after completing the cell detection and classification. I opened one of the qptma file using notepad. I did not see any measurements or survival data in the file content - however the TMA Data Viewer was able to populate all the columns including measurements. Where is the data being pulled from ? what kind of magic is this. I may also have discovered additional bug(s):. 1. I am seeing columnImage is null error in the log at loading - everything seem to work regardless. The same error is thrown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2378,Testability,log,log-rank,2378,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2387,Testability,test,test,2387,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2509,Testability,log,log-rank,2509,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2518,Testability,test,test,2518,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2641,Testability,log,log-rank,2641,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901:2650,Testability,test,test,2650,"rown everytime I toggle ""Group by ID"" as well.; ```; ERROR: QuPath exception: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; java.lang.NullPointerException: Cannot invoke ""javafx.scene.control.TreeTableColumn.setPrefWidth(double)"" because ""columnImage"" is null; at qupath.lib.gui.tma.TMASummaryViewer.lambda$refreshTableData$66(TMASummaryViewer.java:1463); ```; 2. In the log I also noticed ```WARN: Unable to find censored column - survival data will be uncensored``` - not sure why ? ; ```; INFO: Update check for https://github.com/qupath/qupath; WARN: You need to enable the startup script in the Preferences if you want to run it; INFO: Starting QuPath with parameters: []; INFO: Update check for https://github.com/qupath/qupath-extension-stardist; INFO: Predicate set to: null; INFO: Parsed 84 from HS-1_Scan1.ome.tif.qptma (84 total); INFO: Parsed 84 from HS-2_Scan1.ome.tif.qptma (168 total); INFO: Parsed 84 from HS-3_Scan1.ome.tif.qptma (252 total); INFO: Parsed 84 from HS-4_Scan1.ome.tif.qptma (336 total); INFO: Parsed 84 from HS-5_Scan1.ome.tif.qptma (420 total); INFO: Parsed 84 from HS-6_Scan1.ome.tif.qptma (504 total); WARN: Unable to find censored column - survival data will be uncensored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: Survival column: Overall survival, Censored column: OS censored; INFO: No p-values < 0.05; INFO: Smoothing log-rank test p-values by 1; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; INFO: Longest stretch of p-values < 0.05: 12294.9 - 13980.4 (18 entries, 5 observed); INFO: Smoothing log-rank test p-values by 11; ```; I can see in the next couple of line the survival data is being loaded , and they are displayed in the table as well. 3. I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289564901
https://github.com/qupath/qupath/issues/1083#issuecomment-1289597590:226,Performance,load,load,226,"> is that expected behavior ?. Yes!. > Where is the data being pulled from ? what kind of magic is this. I think text files are exported as well?. > I also noticed the ""Missing"" column is missing in the TMA Data viewer when I load the qptma file in the Offline TMA Data Viewer. Are the missing columns included, or were they already excluded at export?. I'm afraid I don't know the answers to anything else, and lacking time and real data I'm not sure when I'll be able to investigate. The null pointer exception looks likely harmless, just annoying; the survival warning is odd - but because both printed statements come on both sides of an `if/else` statement [here](https://github.com/qupath/qupath/blob/17785d7364c39b79e5e09263849031f355c1c0b7/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L757) it looks like the method must be being called multiple times in succession.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1289597590
https://github.com/qupath/qupath/issues/1083#issuecomment-1292103430:56,Availability,fault,fault,56,"Here is another issue I ran into. Not entirely QuPath's fault because MS Excel on windows for some reason decided to capitalize the column with values ```True``` & ```False```. When I opened the text file containing TMA data and saved it with MS Excel missing TMAs were no longer flagged as missing!! . Changing both of this:; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1627; and,; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1713. to use ```Str1.equalsIgnoreCase(Str2)``` addresses the issue. i.e.; ```java; boolean missing = missingColumn != null && ""True"".equalsIgnoreCase(missingColumn.get(i));; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1083#issuecomment-1292103430
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:1718,Deployability,update,update,1718," server & cells; def server = getCurrentServer(); def cells = getCellObjects(). // Reset our classifications; cells.each { cell -> cell.resetPathClass() }. // Loop through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measurements` rather than `cell.getMeasurements()` or - previously in QuPath - `cell.getMeasurementList()`; * Getting from a map using `map[key]` syntax (rather than `map.get(key)`; * Calling a method on a list to get it applied to all elements... so `cells.measurements[measurementName].average()` first extracts all the measurements, then averages them; * Sneakily applying a `setClassifications()` again by accessing it like a property - and using collection concatenation with `=+` to join the old classifications to the new ones; * this works in the opposite direction, with `-=` to remove one or more classifications. The changes have been made without introducing any changes to QuPath's data files, since `PathClass` and `Measur",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:464,Safety,detect,detection,464,"Continued to work on this, and now the PR addresses both. * https://github.com/qupath/qupath/issues/1085; * https://github.com/qupath/qupath/issues/1087. **Please see the links for more detail. It's a fairly substantial change, so feedback would be very welcome!**. To see it in action, here is a script for multiplex classification - written for the famous [LuCa image](https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html) after running cell detection. The choice of threshold is dodgy, but the point is to show how this PR changes the way the scripter can interact with measurements and classifications, using a (I think) far simpler and more intuitive syntax, and fewer lines of code. ```groovy; // Get the server & cells; def server = getCurrentServer(); def cells = getCellObjects(). // Reset our classifications; cells.each { cell -> cell.resetPathClass() }. // Loop through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measur",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:1902,Safety,Avoid,Avoid,1902,"through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measurements` rather than `cell.getMeasurements()` or - previously in QuPath - `cell.getMeasurementList()`; * Getting from a map using `map[key]` syntax (rather than `map.get(key)`; * Calling a method on a list to get it applied to all elements... so `cells.measurements[measurementName].average()` first extracts all the measurements, then averages them; * Sneakily applying a `setClassifications()` again by accessing it like a property - and using collection concatenation with `=+` to join the old classifications to the new ones; * this works in the opposite direction, with `-=` to remove one or more classifications. The changes have been made without introducing any changes to QuPath's data files, since `PathClass` and `MeasurementList` are still doing the main work, it's just that there are now alternative ways to interact with them. They are designed to map well with Groovy tricks, whi",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:2405,Security,access,accessing,2405,"uble threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measurements` rather than `cell.getMeasurements()` or - previously in QuPath - `cell.getMeasurementList()`; * Getting from a map using `map[key]` syntax (rather than `map.get(key)`; * Calling a method on a list to get it applied to all elements... so `cells.measurements[measurementName].average()` first extracts all the measurements, then averages them; * Sneakily applying a `setClassifications()` again by accessing it like a property - and using collection concatenation with `=+` to join the old classifications to the new ones; * this works in the opposite direction, with `-=` to remove one or more classifications. The changes have been made without introducing any changes to QuPath's data files, since `PathClass` and `MeasurementList` are still doing the main work, it's just that there are now alternative ways to interact with them. They are designed to map well with Groovy tricks, while still behaving sensibly from Java. There are a few outstanding questions to be resolved, including:; * how much should classification names be validated?; * should duplicate classification names be permitted?. Duplicate names are currently allowed, but can also easily be restricted, e.g. see; ```groovy; // Add the same class multiple times; def p = getSelectedObject(); for (int i = 0; i < 10; i++) {; p.classifications += ['Class 1']; }; println p.classifications. // Calling this enforces uniqueness; p.classifications = p.classifications as Set; pr",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:3041,Security,validat,validated,3041,"reHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measurements` rather than `cell.getMeasurements()` or - previously in QuPath - `cell.getMeasurementList()`; * Getting from a map using `map[key]` syntax (rather than `map.get(key)`; * Calling a method on a list to get it applied to all elements... so `cells.measurements[measurementName].average()` first extracts all the measurements, then averages them; * Sneakily applying a `setClassifications()` again by accessing it like a property - and using collection concatenation with `=+` to join the old classifications to the new ones; * this works in the opposite direction, with `-=` to remove one or more classifications. The changes have been made without introducing any changes to QuPath's data files, since `PathClass` and `MeasurementList` are still doing the main work, it's just that there are now alternative ways to interact with them. They are designed to map well with Groovy tricks, while still behaving sensibly from Java. There are a few outstanding questions to be resolved, including:; * how much should classification names be validated?; * should duplicate classification names be permitted?. Duplicate names are currently allowed, but can also easily be restricted, e.g. see; ```groovy; // Add the same class multiple times; def p = getSelectedObject(); for (int i = 0; i < 10; i++) {; p.classifications += ['Class 1']; }; println p.classifications. // Calling this enforces uniqueness; p.classifications = p.classifications as Set; println p.classifications. fireHierarchyUpdate(); ```; which prints; ```; INFO: [Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1]; INFO: [Class 1]; ```. **If anyone wants to try the PR, I'd appreciate feedback - or any bugs or things I've failed to think about**",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:231,Usability,feedback,feedback,231,"Continued to work on this, and now the PR addresses both. * https://github.com/qupath/qupath/issues/1085; * https://github.com/qupath/qupath/issues/1087. **Please see the links for more detail. It's a fairly substantial change, so feedback would be very welcome!**. To see it in action, here is a script for multiplex classification - written for the famous [LuCa image](https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html) after running cell detection. The choice of threshold is dodgy, but the point is to show how this PR changes the way the scripter can interact with measurements and classifications, using a (I think) far simpler and more intuitive syntax, and fewer lines of code. ```groovy; // Get the server & cells; def server = getCurrentServer(); def cells = getCellObjects(). // Reset our classifications; cells.each { cell -> cell.resetPathClass() }. // Loop through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measur",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:649,Usability,simpl,simpler,649,"Continued to work on this, and now the PR addresses both. * https://github.com/qupath/qupath/issues/1085; * https://github.com/qupath/qupath/issues/1087. **Please see the links for more detail. It's a fairly substantial change, so feedback would be very welcome!**. To see it in action, here is a script for multiplex classification - written for the famous [LuCa image](https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html) after running cell detection. The choice of threshold is dodgy, but the point is to show how this PR changes the way the scripter can interact with measurements and classifications, using a (I think) far simpler and more intuitive syntax, and fewer lines of code. ```groovy; // Get the server & cells; def server = getCurrentServer(); def cells = getCellObjects(). // Reset our classifications; cells.each { cell -> cell.resetPathClass() }. // Loop through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measur",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:666,Usability,intuit,intuitive,666,"Continued to work on this, and now the PR addresses both. * https://github.com/qupath/qupath/issues/1085; * https://github.com/qupath/qupath/issues/1087. **Please see the links for more detail. It's a fairly substantial change, so feedback would be very welcome!**. To see it in action, here is a script for multiplex classification - written for the famous [LuCa image](https://qupath.readthedocs.io/en/stable/docs/intro/acknowledgements.html) after running cell detection. The choice of threshold is dodgy, but the point is to show how this PR changes the way the scripter can interact with measurements and classifications, using a (I think) far simpler and more intuitive syntax, and fewer lines of code. ```groovy; // Get the server & cells; def server = getCurrentServer(); def cells = getCellObjects(). // Reset our classifications; cells.each { cell -> cell.resetPathClass() }. // Loop through channels; for (def channel in server.getMetadata().getChannels()) {; // Extract the channel name; def channelName = channel.name; ; // Skip some channels; if ('DAPI' in channelName || 'Autofluorescence' in channelName); continue; ; // Create a classification name from the channel; // Here, I take the first bit up until any whitespace; def classificationName = channelName.split()[0]. // Define the measurement we want; def measurementName = ""Cell: $channelName mean""; ; // Calculate some threshold from the measurement; // Here, just the mean; double threshold = cells.measurements[measurementName].average(); ; // Append a classification to all the cells above the threshold; cells.each { cell ->; if (cell.measurements[measurementName] > threshold); cell.classifications += [classificationName]; }; }. // Figure update (could do this automatically...); fireHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measur",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235:3700,Usability,feedback,feedback,3700,"reHierarchyUpdate(); ```. Closer inspection reveals a few Groovy tricks at work:. * `List.each { }` as a shorter alternative to for loops; * Avoid explicitly calling getters (e.g. `channel.name` rather than `channel.getName()`, `cell.measurements` rather than `cell.getMeasurements()` or - previously in QuPath - `cell.getMeasurementList()`; * Getting from a map using `map[key]` syntax (rather than `map.get(key)`; * Calling a method on a list to get it applied to all elements... so `cells.measurements[measurementName].average()` first extracts all the measurements, then averages them; * Sneakily applying a `setClassifications()` again by accessing it like a property - and using collection concatenation with `=+` to join the old classifications to the new ones; * this works in the opposite direction, with `-=` to remove one or more classifications. The changes have been made without introducing any changes to QuPath's data files, since `PathClass` and `MeasurementList` are still doing the main work, it's just that there are now alternative ways to interact with them. They are designed to map well with Groovy tricks, while still behaving sensibly from Java. There are a few outstanding questions to be resolved, including:; * how much should classification names be validated?; * should duplicate classification names be permitted?. Duplicate names are currently allowed, but can also easily be restricted, e.g. see; ```groovy; // Add the same class multiple times; def p = getSelectedObject(); for (int i = 0; i < 10; i++) {; p.classifications += ['Class 1']; }; println p.classifications. // Calling this enforces uniqueness; p.classifications = p.classifications as Set; println p.classifications. fireHierarchyUpdate(); ```; which prints; ```; INFO: [Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1, Class 1]; INFO: [Class 1]; ```. **If anyone wants to try the PR, I'd appreciate feedback - or any bugs or things I've failed to think about**",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1094#issuecomment-1289456235
https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508:70,Availability,error,error,70,"Humnn, I have tested your suggestion and it doesn't seem to throw any error. I have yet to wrap my head around the whole TMA Data Viewer logic. Thank you for the quick review. Now does that mean, this also needs fixing ?; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1444-L1446. Because I looked at the above code when correcting the following:; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1463-L1465",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508
https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508:91,Integrability,wrap,wrap,91,"Humnn, I have tested your suggestion and it doesn't seem to throw any error. I have yet to wrap my head around the whole TMA Data Viewer logic. Thank you for the quick review. Now does that mean, this also needs fixing ?; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1444-L1446. Because I looked at the above code when correcting the following:; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1463-L1465",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508
https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508:14,Testability,test,tested,14,"Humnn, I have tested your suggestion and it doesn't seem to throw any error. I have yet to wrap my head around the whole TMA Data Viewer logic. Thank you for the quick review. Now does that mean, this also needs fixing ?; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1444-L1446. Because I looked at the above code when correcting the following:; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1463-L1465",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508
https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508:137,Testability,log,logic,137,"Humnn, I have tested your suggestion and it doesn't seem to throw any error. I have yet to wrap my head around the whole TMA Data Viewer logic. Thank you for the quick review. Now does that mean, this also needs fixing ?; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1444-L1446. Because I looked at the above code when correcting the following:; https://github.com/qupath/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1463-L1465",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1290993508
https://github.com/qupath/qupath/pull/1096#issuecomment-1292080941:2,Testability,test,tested,2,I tested your suggestion and included the fix. Now both column ```columnImage``` & ```columnOverlay``` sizes are in sync. Adjusting one also adjusts the other proportionally. I believe this is the correct behavior.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292080941
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:175,Availability,avail,available,175,"The commit [f37dcfc](https://github.com/qupath/qupath/pull/1096/commits/f37dcfc63cc65a43b8a0eba76e7b7db86c3d75bc) assumes both the ```columnImage``` & ```columnOverlay``` are available and works well when it is true. Table does not seem to refresh when only one of them is available. ; Hence the table may need to be refreshed outside the ```if``` statement. Does this mean that the table may refresh twice when both column are available ? ; This one is trickier that I had initially thought.; ; ```java; 		// Add columns to show images, if we have them; 		if (hasImages || hasOverlay) {; 			TreeTableColumn<TMAEntry, TMAEntry> columnImage = hasImages ? new TreeTableColumn<>(""Thumbnail"") : null;; 			TreeTableColumn<TMAEntry, TMAEntry> columnOverlay = hasOverlay ? new TreeTableColumn<>(""Overlay"") : null;. 			if (hasImages) {; 				columnImage.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnImage.setCellFactory(c -> new ImageTableCell(imageCache, false));; 				columnImage.maxWidthProperty().bind(maxSmallWidth);; 				columnImage.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addL",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:273,Availability,avail,available,273,"The commit [f37dcfc](https://github.com/qupath/qupath/pull/1096/commits/f37dcfc63cc65a43b8a0eba76e7b7db86c3d75bc) assumes both the ```columnImage``` & ```columnOverlay``` are available and works well when it is true. Table does not seem to refresh when only one of them is available. ; Hence the table may need to be refreshed outside the ```if``` statement. Does this mean that the table may refresh twice when both column are available ? ; This one is trickier that I had initially thought.; ; ```java; 		// Add columns to show images, if we have them; 		if (hasImages || hasOverlay) {; 			TreeTableColumn<TMAEntry, TMAEntry> columnImage = hasImages ? new TreeTableColumn<>(""Thumbnail"") : null;; 			TreeTableColumn<TMAEntry, TMAEntry> columnOverlay = hasOverlay ? new TreeTableColumn<>(""Overlay"") : null;. 			if (hasImages) {; 				columnImage.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnImage.setCellFactory(c -> new ImageTableCell(imageCache, false));; 				columnImage.maxWidthProperty().bind(maxSmallWidth);; 				columnImage.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addL",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:428,Availability,avail,available,428,"The commit [f37dcfc](https://github.com/qupath/qupath/pull/1096/commits/f37dcfc63cc65a43b8a0eba76e7b7db86c3d75bc) assumes both the ```columnImage``` & ```columnOverlay``` are available and works well when it is true. Table does not seem to refresh when only one of them is available. ; Hence the table may need to be refreshed outside the ```if``` statement. Does this mean that the table may refresh twice when both column are available ? ; This one is trickier that I had initially thought.; ; ```java; 		// Add columns to show images, if we have them; 		if (hasImages || hasOverlay) {; 			TreeTableColumn<TMAEntry, TMAEntry> columnImage = hasImages ? new TreeTableColumn<>(""Thumbnail"") : null;; 			TreeTableColumn<TMAEntry, TMAEntry> columnOverlay = hasOverlay ? new TreeTableColumn<>(""Overlay"") : null;. 			if (hasImages) {; 				columnImage.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnImage.setCellFactory(c -> new ImageTableCell(imageCache, false));; 				columnImage.maxWidthProperty().bind(maxSmallWidth);; 				columnImage.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addL",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:2369,Availability,avail,available,2369," o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnOverlay.getPrefWidth()); 						return;; 					if (hasImages); 						columnImage.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnOverlay);; 			}; 		}; ```. This might be better for now! Since it works in both cases:; 1. If both ```columnImage``` and ```columnOverlay``` are available.; 2. When one of the ```columnImage``` or ```columnOverlay``` is not available. I discovered this because when TMA Data is exported for the multichannel image (non-RGB) it is exported as TIF. The TMA viewer only seems to load the image if it is saved as .jpg for the ```columnImage``` column. For the overlay it load either .jpg or .png. Here is TMA Data exporter code that exports the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMADataIO.java#L107; ```java; 	String coreExt = imageData.getServer().isRGB() ? "".jpg"" : "".tif"";; ```. and Here is TMA Data Viewer code that loads the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1714; ```java; 	File fileImage = new File(dirData, name + "".jpg"");; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:2448,Availability,avail,available,2448," o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnOverlay.getPrefWidth()); 						return;; 					if (hasImages); 						columnImage.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnOverlay);; 			}; 		}; ```. This might be better for now! Since it works in both cases:; 1. If both ```columnImage``` and ```columnOverlay``` are available.; 2. When one of the ```columnImage``` or ```columnOverlay``` is not available. I discovered this because when TMA Data is exported for the multichannel image (non-RGB) it is exported as TIF. The TMA viewer only seems to load the image if it is saved as .jpg for the ```columnImage``` column. For the overlay it load either .jpg or .png. Here is TMA Data exporter code that exports the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMADataIO.java#L107; ```java; 	String coreExt = imageData.getServer().isRGB() ? "".jpg"" : "".tif"";; ```. and Here is TMA Data Viewer code that loads the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1714; ```java; 	File fileImage = new File(dirData, name + "".jpg"");; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:2600,Performance,load,load,2600," o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnOverlay.getPrefWidth()); 						return;; 					if (hasImages); 						columnImage.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnOverlay);; 			}; 		}; ```. This might be better for now! Since it works in both cases:; 1. If both ```columnImage``` and ```columnOverlay``` are available.; 2. When one of the ```columnImage``` or ```columnOverlay``` is not available. I discovered this because when TMA Data is exported for the multichannel image (non-RGB) it is exported as TIF. The TMA viewer only seems to load the image if it is saved as .jpg for the ```columnImage``` column. For the overlay it load either .jpg or .png. Here is TMA Data exporter code that exports the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMADataIO.java#L107; ```java; 	String coreExt = imageData.getServer().isRGB() ? "".jpg"" : "".tif"";; ```. and Here is TMA Data Viewer code that loads the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1714; ```java; 	File fileImage = new File(dirData, name + "".jpg"");; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:2691,Performance,load,load,2691," o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnOverlay.getPrefWidth()); 						return;; 					if (hasImages); 						columnImage.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnOverlay);; 			}; 		}; ```. This might be better for now! Since it works in both cases:; 1. If both ```columnImage``` and ```columnOverlay``` are available.; 2. When one of the ```columnImage``` or ```columnOverlay``` is not available. I discovered this because when TMA Data is exported for the multichannel image (non-RGB) it is exported as TIF. The TMA viewer only seems to load the image if it is saved as .jpg for the ```columnImage``` column. For the overlay it load either .jpg or .png. Here is TMA Data exporter code that exports the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMADataIO.java#L107; ```java; 	String coreExt = imageData.getServer().isRGB() ? "".jpg"" : "".tif"";; ```. and Here is TMA Data Viewer code that loads the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1714; ```java; 	File fileImage = new File(dirData, name + "".jpg"");; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472:3047,Performance,load,loads,3047," o, n) -> {; 					if (n.doubleValue() == columnImage.getPrefWidth()); 						return;; 					if (hasOverlay); 						columnOverlay.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnImage);; 			}. 			if (hasOverlay) {; 				columnOverlay.setCellValueFactory(new Callback<CellDataFeatures<TMAEntry, TMAEntry>, ObservableValue<TMAEntry>>() {; 					@Override; 					public ObservableValue<TMAEntry> call(CellDataFeatures<TMAEntry, TMAEntry> p) {; 						return p.getValue().valueProperty();; 					}; 				});; 				columnOverlay.setCellFactory(c -> new ImageTableCell(imageCache, true));; 				columnOverlay.maxWidthProperty().bind(maxSmallWidth);; 				columnOverlay.widthProperty().addListener((v, o, n) -> {; 					if (n.doubleValue() == columnOverlay.getPrefWidth()); 						return;; 					if (hasImages); 						columnImage.setPrefWidth(n.doubleValue());; 					table.refresh();; 				});; 				columns.add(columnOverlay);; 			}; 		}; ```. This might be better for now! Since it works in both cases:; 1. If both ```columnImage``` and ```columnOverlay``` are available.; 2. When one of the ```columnImage``` or ```columnOverlay``` is not available. I discovered this because when TMA Data is exported for the multichannel image (non-RGB) it is exported as TIF. The TMA viewer only seems to load the image if it is saved as .jpg for the ```columnImage``` column. For the overlay it load either .jpg or .png. Here is TMA Data exporter code that exports the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMADataIO.java#L107; ```java; 	String coreExt = imageData.getServer().isRGB() ? "".jpg"" : "".tif"";; ```. and Here is TMA Data Viewer code that loads the images:; https://github.com/petebankhead/qupath/blob/fca7fa5fd9efd815f4c317705fbe2a0f9c39270f/qupath-gui-fx/src/main/java/qupath/lib/gui/tma/TMASummaryViewer.java#L1714; ```java; 	File fileImage = new File(dirData, name + "".jpg"");; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292310472
https://github.com/qupath/qupath/pull/1096#issuecomment-1292322424:108,Availability,down,down,108,"Refreshing slightly more than necessary is probably ok, it's only a problem if you notice it slowing things down. Certainly better than missing a necessary `refresh()` call :). There's no .tif support because then that brings in channel colors/brightness & contrast and so on, so I guess that would require a more core change to export with those settings. But that gets even more awkward if the visualization settings might not be available if calling the export by batch processing...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292322424
https://github.com/qupath/qupath/pull/1096#issuecomment-1292322424:432,Availability,avail,available,432,"Refreshing slightly more than necessary is probably ok, it's only a problem if you notice it slowing things down. Certainly better than missing a necessary `refresh()` call :). There's no .tif support because then that brings in channel colors/brightness & contrast and so on, so I guess that would require a more core change to export with those settings. But that gets even more awkward if the visualization settings might not be available if calling the export by batch processing...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292322424
https://github.com/qupath/qupath/pull/1096#issuecomment-1292335714:161,Integrability,depend,depend,161,"Incidentally, if you're enjoying it and want to tackle the sluggishness you could try setting the cell height to be fixed - although it's tricky because it will depend upon the image size. So you'll need to bring to some other property, and make sure it never gets too small (or fails horribly if images are missing). I introduced that recently in the regular measurement tables and it improved performance quite a bit. The code I used is at https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/SummaryMeasurementTableCommand.java#L210. See here for more info: https://openjfx.io/javadoc/12/javafx.controls/javafx/scene/control/TableView.html#fixedCellSizeProperty(). (Not necessary though - just if you're curious!)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292335714
https://github.com/qupath/qupath/pull/1096#issuecomment-1292335714:395,Performance,perform,performance,395,"Incidentally, if you're enjoying it and want to tackle the sluggishness you could try setting the cell height to be fixed - although it's tricky because it will depend upon the image size. So you'll need to bring to some other property, and make sure it never gets too small (or fails horribly if images are missing). I introduced that recently in the regular measurement tables and it improved performance quite a bit. The code I used is at https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/commands/SummaryMeasurementTableCommand.java#L210. See here for more info: https://openjfx.io/javadoc/12/javafx.controls/javafx/scene/control/TableView.html#fixedCellSizeProperty(). (Not necessary though - just if you're curious!)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292335714
https://github.com/qupath/qupath/pull/1096#issuecomment-1292337367:145,Performance,perform,performace,145,[5a85905](https://github.com/qupath/qupath/pull/1096/commits/5a8590551d3030ff84ab0a3c0a713c452d68daf7) I think this will do. I didn't notice any performace issue with table refresh. Let's not make this pull request any messier than it already is. Any new issues will need to be a separate issue with it's own PR :),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1096#issuecomment-1292337367
https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800:260,Deployability,install,installed,260,"Thanks @jesusdpa1 although I either don't understand the issue or couldn't replicate it. I'd also be confused if the .msi and .exe behave differently in this regard, since they are built at exactly the same time from the same code. I created a new account and installed QuPath from the .msi, and it did not have an user/extensions directory set by default - as it shouldn't. The directory is only set whenever the user needs it for some reason (usually they install an extension), and at that point they have the option to set its path to whatever they choose. This is then stored in the user preferences, using Java's default preferences mechanism... which should keep the path restricted to wherever the user requests. Since you mention viewing the extensions directory immediately after installation - but not installing any extensions - I feel like something must be missing somewhere. Note I only have a Windows 10 system to test this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800
https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800:458,Deployability,install,install,458,"Thanks @jesusdpa1 although I either don't understand the issue or couldn't replicate it. I'd also be confused if the .msi and .exe behave differently in this regard, since they are built at exactly the same time from the same code. I created a new account and installed QuPath from the .msi, and it did not have an user/extensions directory set by default - as it shouldn't. The directory is only set whenever the user needs it for some reason (usually they install an extension), and at that point they have the option to set its path to whatever they choose. This is then stored in the user preferences, using Java's default preferences mechanism... which should keep the path restricted to wherever the user requests. Since you mention viewing the extensions directory immediately after installation - but not installing any extensions - I feel like something must be missing somewhere. Note I only have a Windows 10 system to test this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800
https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800:790,Deployability,install,installation,790,"Thanks @jesusdpa1 although I either don't understand the issue or couldn't replicate it. I'd also be confused if the .msi and .exe behave differently in this regard, since they are built at exactly the same time from the same code. I created a new account and installed QuPath from the .msi, and it did not have an user/extensions directory set by default - as it shouldn't. The directory is only set whenever the user needs it for some reason (usually they install an extension), and at that point they have the option to set its path to whatever they choose. This is then stored in the user preferences, using Java's default preferences mechanism... which should keep the path restricted to wherever the user requests. Since you mention viewing the extensions directory immediately after installation - but not installing any extensions - I feel like something must be missing somewhere. Note I only have a Windows 10 system to test this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800
https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800:813,Deployability,install,installing,813,"Thanks @jesusdpa1 although I either don't understand the issue or couldn't replicate it. I'd also be confused if the .msi and .exe behave differently in this regard, since they are built at exactly the same time from the same code. I created a new account and installed QuPath from the .msi, and it did not have an user/extensions directory set by default - as it shouldn't. The directory is only set whenever the user needs it for some reason (usually they install an extension), and at that point they have the option to set its path to whatever they choose. This is then stored in the user preferences, using Java's default preferences mechanism... which should keep the path restricted to wherever the user requests. Since you mention viewing the extensions directory immediately after installation - but not installing any extensions - I feel like something must be missing somewhere. Note I only have a Windows 10 system to test this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800
https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800:930,Testability,test,test,930,"Thanks @jesusdpa1 although I either don't understand the issue or couldn't replicate it. I'd also be confused if the .msi and .exe behave differently in this regard, since they are built at exactly the same time from the same code. I created a new account and installed QuPath from the .msi, and it did not have an user/extensions directory set by default - as it shouldn't. The directory is only set whenever the user needs it for some reason (usually they install an extension), and at that point they have the option to set its path to whatever they choose. This is then stored in the user preferences, using Java's default preferences mechanism... which should keep the path restricted to wherever the user requests. Since you mention viewing the extensions directory immediately after installation - but not installing any extensions - I feel like something must be missing somewhere. Note I only have a Windows 10 system to test this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302244800
https://github.com/qupath/qupath/issues/1108#issuecomment-1302305950:250,Deployability,install,install,250,"Hi Pete, here is a set of screenshots replicating my steps. Now that you mention this, I am not sure if the issue generates due to user privilege's. One of the user here is an admin, the second one isn't, the same first user credentials were used to install both QuPath's. From this test I was able to navigate to all the folders of the first user. ; ; [qupath_security.pdf](https://github.com/qupath/qupath/files/9930678/qupath_security.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302305950
https://github.com/qupath/qupath/issues/1108#issuecomment-1302305950:283,Testability,test,test,283,"Hi Pete, here is a set of screenshots replicating my steps. Now that you mention this, I am not sure if the issue generates due to user privilege's. One of the user here is an admin, the second one isn't, the same first user credentials were used to install both QuPath's. From this test I was able to navigate to all the folders of the first user. ; ; [qupath_security.pdf](https://github.com/qupath/qupath/files/9930678/qupath_security.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302305950
https://github.com/qupath/qupath/issues/1108#issuecomment-1302320391:270,Deployability,install,installing,270,"Thanks, I remain confused because I can see you're using https://github.com/BIOP/qupath-extension-cellpose - which is developed separately by another group. That's where all the CellPose/Miniconda things arise, since they aren't part of QuPath. Your steps don't mention installing the extension, miniconda or Cellpose though, so I can't tell when or why any problem occurs. Also, if the files are accessible via Windows Explorer / the file chooser then I also don't know see where this would be a QuPath problem... so I remain unclear that there is any bug here, at least in QuPath. @lacan may be able to help from the CellPose extension side, or the community forum may be a better place for the discussion that spreads across different software: https://forum.image.sc/tag/qupath",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302320391
https://github.com/qupath/qupath/issues/1108#issuecomment-1302320391:397,Security,access,accessible,397,"Thanks, I remain confused because I can see you're using https://github.com/BIOP/qupath-extension-cellpose - which is developed separately by another group. That's where all the CellPose/Miniconda things arise, since they aren't part of QuPath. Your steps don't mention installing the extension, miniconda or Cellpose though, so I can't tell when or why any problem occurs. Also, if the files are accessible via Windows Explorer / the file chooser then I also don't know see where this would be a QuPath problem... so I remain unclear that there is any bug here, at least in QuPath. @lacan may be able to help from the CellPose extension side, or the community forum may be a better place for the discussion that spreads across different software: https://forum.image.sc/tag/qupath",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302320391
https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711:47,Deployability,install,install,47,"> the same first user credentials were used to install both QuPath's. I guess maybe that's the issue. . QuPath is using Java's `Preferences` class: https://docs.oracle.com/en/java/javase/11/docs/api/java.prefs/java/util/prefs/Preferences.html. Specifically, it's going through `Preferences.userRoot()`, which according to Java's docs should be *'the root preference node for the calling user'*: https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/prefs/PathPrefs.java#L475. I think the Cellpose extension is doing the same. I've no idea what miniconda does, or if it's relevant here. I'm not sure what happens when the credentials used for installation are different from those used to run the software - but providing an .exe in addition to an .msi is intended to help in scenarios when one isn't suitable (usually a lack of admin access for installation). Based on all that, do you still think QuPath should be doing something differently?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711
https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711:674,Deployability,install,installation,674,"> the same first user credentials were used to install both QuPath's. I guess maybe that's the issue. . QuPath is using Java's `Preferences` class: https://docs.oracle.com/en/java/javase/11/docs/api/java.prefs/java/util/prefs/Preferences.html. Specifically, it's going through `Preferences.userRoot()`, which according to Java's docs should be *'the root preference node for the calling user'*: https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/prefs/PathPrefs.java#L475. I think the Cellpose extension is doing the same. I've no idea what miniconda does, or if it's relevant here. I'm not sure what happens when the credentials used for installation are different from those used to run the software - but providing an .exe in addition to an .msi is intended to help in scenarios when one isn't suitable (usually a lack of admin access for installation). Based on all that, do you still think QuPath should be doing something differently?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711
https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711:877,Deployability,install,installation,877,"> the same first user credentials were used to install both QuPath's. I guess maybe that's the issue. . QuPath is using Java's `Preferences` class: https://docs.oracle.com/en/java/javase/11/docs/api/java.prefs/java/util/prefs/Preferences.html. Specifically, it's going through `Preferences.userRoot()`, which according to Java's docs should be *'the root preference node for the calling user'*: https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/prefs/PathPrefs.java#L475. I think the Cellpose extension is doing the same. I've no idea what miniconda does, or if it's relevant here. I'm not sure what happens when the credentials used for installation are different from those used to run the software - but providing an .exe in addition to an .msi is intended to help in scenarios when one isn't suitable (usually a lack of admin access for installation). Based on all that, do you still think QuPath should be doing something differently?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711
https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711:866,Security,access,access,866,"> the same first user credentials were used to install both QuPath's. I guess maybe that's the issue. . QuPath is using Java's `Preferences` class: https://docs.oracle.com/en/java/javase/11/docs/api/java.prefs/java/util/prefs/Preferences.html. Specifically, it's going through `Preferences.userRoot()`, which according to Java's docs should be *'the root preference node for the calling user'*: https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/prefs/PathPrefs.java#L475. I think the Cellpose extension is doing the same. I've no idea what miniconda does, or if it's relevant here. I'm not sure what happens when the credentials used for installation are different from those used to run the software - but providing an .exe in addition to an .msi is intended to help in scenarios when one isn't suitable (usually a lack of admin access for installation). Based on all that, do you still think QuPath should be doing something differently?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302330711
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:43,Availability,error,error,43,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:145,Availability,error,error,145,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:211,Deployability,install,install,211,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:346,Deployability,install,installation,346,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:436,Deployability,install,installation,436,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:558,Deployability,install,installation,558,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:596,Deployability,install,installed,596,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:765,Deployability,install,installing,765,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:905,Deployability,install,installation,905,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161:1021,Deployability,install,install,1021,"Thanks Pete 😄! I will try to replicate the error without the extension to see if that might be the issue. . Miniconda should not be bringing any error since that is only use to create the virtual environment to install Cellpose. What is shown in the extensions window is just the path to the location of that python environment that contains the installation of Cellpose. I just used those settings to show how paths set from the first installation were being drag to the second one. . I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. . From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. The solution from my end was to proceed and install the zip version and uninstall the .msi version. Sorry for not being able to explain this more straight forward",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302519161
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:74,Deployability,install,installation,74,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:112,Deployability,install,installed,112,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:337,Deployability,install,installation,337,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:714,Deployability,install,installing,714,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:805,Deployability,install,installation,805,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:897,Deployability,install,installation,897,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:1317,Deployability,install,installing,1317,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432:1457,Deployability,install,installation,1457,"> I think the behavior should be like the one observed when using the zip installation where every time that is installed it resets the preferences. Hmmm, but I don't think it does? At least there's nothing in QuPath to intentionally do that. The only thing I can think of is that the 'user' is somehow remembered with the .msi from the installation... but I don't know if that makes sense. The Windows packages are created using `jpackage`, which in turn uses Wix toolset - so any surprising behavior may originate there. I remain confused and unconvinced that QuPath is doing anything odd, since it seems to me there *must* be other steps involved that aren't included in your PDF (because it doesn't talk about installing CellPose) *and/or* the path is coming from some the preferences from some prior installation. There won't be an extensions folder set if you have a completely clean QuPath installation with no lingering preferences*. And if you've set anything in the preferences, then that should affect the .msi and .zip in exactly the same way. *-I guess optionally removing the preferences when uninstalling QuPath might be handy, but I don't think `jpackage` offers that. > From all of these, I still think it might have been a user privilege difference. What I mean with this is that, if the first user installing QuPath is admin it sets the preferences globally. Then the second user, which doesn't have admin rights, seems to preserve first installation preferences and is able to navigate the first users files. Sounds possible. In case it helps investigate, the preferences should be found in the Windows registry under; ```; HKEY_CURRENT_USER/SOFTWARE/JavaSoft/Prefs/io.github.qupath/0.3/; ```. Again, this should be the same regardless of whether the .msi or .zip is used.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1302544432
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:60,Deployability,install,installation,60,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:192,Deployability,install,installed,192,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:367,Deployability,install,installation-and-left-behind-after,367,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:429,Deployability,install,installation,429,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:507,Deployability,install,installation,507,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:76,Modifiability,plugin,plugins,76,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858:101,Security,access,access,101,"Hi Sorry for the delay, I replicated the steps with a clean installation no plugins and saw the same access to the files. I went to the registry and it shows the paths for the first user that installed QuPath, . did a quick search and it seems that it can be a problem with the msix packages, ; https://techcommunity.microsoft.com/t5/msix/registry-keys-created-after-installation-and-left-behind-after/m-p/1802357. [QuPath Clean installation.pdf](https://github.com/qupath/qupath/files/9973964/QuPath.Clean.installation.pdf)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309180858
https://github.com/qupath/qupath/issues/1108#issuecomment-1309223445:71,Deployability,install,installing,71,"I understand, it is hard to capture the idea. Overall I see that after installing QuPath using the "".msi"" in two different users in the same computer when opening QuPath in the second one I notice that I have access to the first user files. . I'll proceed to close this ticket, Thanks",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309223445
https://github.com/qupath/qupath/issues/1108#issuecomment-1309223445:209,Security,access,access,209,"I understand, it is hard to capture the idea. Overall I see that after installing QuPath using the "".msi"" in two different users in the same computer when opening QuPath in the second one I notice that I have access to the first user files. . I'll proceed to close this ticket, Thanks",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309223445
https://github.com/qupath/qupath/issues/1108#issuecomment-1309256243:9,Security,access,access,9,> I have access to the first user files. I don't understand which files. I couldn't see which screenshot in the PDF demonstrated there was a problem.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309256243
https://github.com/qupath/qupath/issues/1108#issuecomment-1309474176:162,Deployability,install,installed,162,"I attempted to replicate this on a standard system (Win10 Pro, no active directory, no abnormal group policy) and was not able to. The normal user with the admin installed QuPath was not able to access any of the admin folders, nor could they see projects that had been opened/created by the admin user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309474176
https://github.com/qupath/qupath/issues/1108#issuecomment-1309474176:195,Security,access,access,195,"I attempted to replicate this on a standard system (Win10 Pro, no active directory, no abnormal group policy) and was not able to. The normal user with the admin installed QuPath was not able to access any of the admin folders, nor could they see projects that had been opened/created by the admin user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1108#issuecomment-1309474176
https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568:1173,Availability,avail,available,1173,"@petebankhead thank you for tagging me on these changes. . > Since all `PathObject` instances now have an ID property, which should be unique, the use of 'Unique ID' as a property for a TMA core becomes even more confusing. I agree. > My proposal is to change **Unique ID** to become **Case ID**. You have my upvote for this. Not necessarily better but the alternative I could think of is **Subject ID** but it has a similar vibe to **Patient ID**. > Making the change involves an extra decision. The easy bit is to create methods for `TMACoreObject.setCaseID(id)` and `TMACoreObject.getCaseID()` - the old methods can remain temporarily, but emit a warning if they are called*. The trickier choice is whether to update the name used internally to store the value; I'd like to change it, but it means that IDs saved in QuPath v0.4.0 won't be recognized in older versions. If these changes mean less confusing and clear APIs in the future, then, the sooner we address them, the fewer projects will be affected. . I personally do not have a reason to go back to 0.3.X once I create a project in 0.4.0X - because I believe all the commands that were present in 0.3.0X will be available in 0.4.0X. Please correct me if I am wrong - Are there any methods/workflows that will be dropped in 0.4.0? It would be easy to make a decision if we could identify potential reasons for someone to want to go back to 0.3.X - besides the fact that not everyone is running the most up-to-date version of QuPath.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568
https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568:713,Deployability,update,update,713,"@petebankhead thank you for tagging me on these changes. . > Since all `PathObject` instances now have an ID property, which should be unique, the use of 'Unique ID' as a property for a TMA core becomes even more confusing. I agree. > My proposal is to change **Unique ID** to become **Case ID**. You have my upvote for this. Not necessarily better but the alternative I could think of is **Subject ID** but it has a similar vibe to **Patient ID**. > Making the change involves an extra decision. The easy bit is to create methods for `TMACoreObject.setCaseID(id)` and `TMACoreObject.getCaseID()` - the old methods can remain temporarily, but emit a warning if they are called*. The trickier choice is whether to update the name used internally to store the value; I'd like to change it, but it means that IDs saved in QuPath v0.4.0 won't be recognized in older versions. If these changes mean less confusing and clear APIs in the future, then, the sooner we address them, the fewer projects will be affected. . I personally do not have a reason to go back to 0.3.X once I create a project in 0.4.0X - because I believe all the commands that were present in 0.3.0X will be available in 0.4.0X. Please correct me if I am wrong - Are there any methods/workflows that will be dropped in 0.4.0? It would be easy to make a decision if we could identify potential reasons for someone to want to go back to 0.3.X - besides the fact that not everyone is running the most up-to-date version of QuPath.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568
https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568:913,Usability,clear,clear,913,"@petebankhead thank you for tagging me on these changes. . > Since all `PathObject` instances now have an ID property, which should be unique, the use of 'Unique ID' as a property for a TMA core becomes even more confusing. I agree. > My proposal is to change **Unique ID** to become **Case ID**. You have my upvote for this. Not necessarily better but the alternative I could think of is **Subject ID** but it has a similar vibe to **Patient ID**. > Making the change involves an extra decision. The easy bit is to create methods for `TMACoreObject.setCaseID(id)` and `TMACoreObject.getCaseID()` - the old methods can remain temporarily, but emit a warning if they are called*. The trickier choice is whether to update the name used internally to store the value; I'd like to change it, but it means that IDs saved in QuPath v0.4.0 won't be recognized in older versions. If these changes mean less confusing and clear APIs in the future, then, the sooner we address them, the fewer projects will be affected. . I personally do not have a reason to go back to 0.3.X once I create a project in 0.4.0X - because I believe all the commands that were present in 0.3.0X will be available in 0.4.0X. Please correct me if I am wrong - Are there any methods/workflows that will be dropped in 0.4.0? It would be easy to make a decision if we could identify potential reasons for someone to want to go back to 0.3.X - besides the fact that not everyone is running the most up-to-date version of QuPath.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114#issuecomment-1303784568
https://github.com/qupath/qupath/issues/1114#issuecomment-1304333085:187,Availability,avail,available,187,"I actually didn't know that TMAs had a UniqueID property. I recently used TMAs with multiple cores from the same patient and I had to write my own work around for this. It seems it's not available in right click menu GUI, where it would be most natural (for me) to input them?. That being said, I think the changes you made are useful. I would prioritize clean code into the future over the ability for older versions to read new projects. If I have a project with TMAs in 0.3.2, will this change leave me unable to open in in 0.4?. Also, I vote that ID is capitalized in set and get functions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114#issuecomment-1304333085
https://github.com/qupath/qupath/issues/1114#issuecomment-1304432307:321,Deployability,update,update,321,"Thanks @saramcardle! My lack of using TMAs for years means that the documentation for the ID is only for v0.1.2 at https://github.com/qupath/qupath/wiki/TMA-CD3-analysis. > If I have a project with TMAs in 0.3.2, will this change leave me unable to open in in 0.4?. That shouldn't be a problem. It could potentially also update the IDs to use the v0.4.0 key. It's just that if you go back to v0.3.2, the IDs will seem to have been lost and needed added again. > Also, I vote that ID is capitalized in set and get functions. Thanks! Me too I think. Do you feel the same about URI...?. I tried to check what Java itself does and it seems a bit inconsistent with both of those.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1114#issuecomment-1304432307
https://github.com/qupath/qupath/issues/1138#issuecomment-1317241037:407,Performance,cache,cached,407,"Thanks @lacan the behavior was *extremely* confusing, but I think I figured it out in the end.; * https://github.com/qupath/qupath/pull/1139. Your project helped a lot - I couldn't replicate the issue with my own image, but the details turned out to really matter (ImageJ server, non-RGB... not sure what else exactly). Ultimately it traced back to the pixels being transformed in-place, which impacted the cached ImageJ `ImagePlus` in a way that shouldn't be permitted.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1138#issuecomment-1317241037
https://github.com/qupath/qupath/issues/1138#issuecomment-1317589117:218,Availability,down,down,218,"Awesome @petebankhead, yeah it's the first time someone uses an ImageJ server with rotation so we were quite at a loss too. Noticing that it worked with the BioFormats server saved the user's project and helped narrow down the issue a bit.; Thanks so much for looking into it!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1138#issuecomment-1317589117
https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873:151,Deployability,update,updated,151,"That's @SoerenXD QuPath makes such minimal use of commons-text (and doesn't use `StringLookup`) that it's tempting to just remove it, but for now I've updated the dependency for the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873
https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873:187,Deployability,release,release,187,"That's @SoerenXD QuPath makes such minimal use of commons-text (and doesn't use `StringLookup`) that it's tempting to just remove it, but for now I've updated the dependency for the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873
https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873:163,Integrability,depend,dependency,163,"That's @SoerenXD QuPath makes such minimal use of commons-text (and doesn't use `StringLookup`) that it's tempting to just remove it, but for now I've updated the dependency for the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1141#issuecomment-1318327873
https://github.com/qupath/qupath/pull/1145#issuecomment-1319606359:468,Availability,down,downside,468,"Hi @zindy I'm afraid this can't be included, as it breaks the menus on the Mac. In fact I've had to stay away from `CustomMenuItem` almost entirely for that reason (it's ok in popup menus). The problem is that QuPath uses the system menubar where possible. You can change this in the preferences, but it's on by default and that means that the app feels a lot more like a native one; on the Mac it means the menubar at the top, rather than anchored in the window. The downside on the Mac is that icons don't appear, and `CustomMenuItem` isn't supported. When I try this PR it causes the text of the recent menu items to disappear entirely. It reappears if I turn off the system menubar option... but then blocks me from ever turning it on again. I can't check it on Linux right now, but I suspect there might also be issues. Re. the separator, I can see an argument for changing it - but I'd tend towards leaving it as it is. My thinking is that it really represents the end part of the URI, so the slashes should be forward. Additionally, I'd encourage the use of forward slashes in paths for QuPath scripts - even when written in Windows - since they work consistently, while users need to know to escape backslashes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1145#issuecomment-1319606359
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:194,Performance,load,load,194,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:239,Performance,cache,cached,239,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:314,Performance,load,load,314,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:515,Performance,load,load,515,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:663,Performance,perform,performance,663,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989:693,Performance,load,load,693,"Reopened as I still have the same issue with a newly built 0.4.0 (built on 2022-11-21). I can only seem to reproduce this once per day on average, as restarting the system will still yield fast load times. There's probably something being cached that gets wiped after a day, which substantially helps with project load times. My best guess is that it's the thumbnails, and since there isn't a way to disable them entirely, I can't confirm if that is the root cause. Since only a single thread of the CPU is at 100% load when reproducing this bug, this will likely pose more of an issue in older computers and newer servers, since both will have low single-thread performance (takes ~4 mins to load the project on my system, and likely much longer on low single-thread systems).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325562989
https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611:231,Availability,error,errors,231,"If you use VisualVM then you should be able to find exactly what takes time. Thumbnail generation can't safely be done in parallel because there's no guarantee the images will be pyramidal, so there is a high risk of out of memory errors. That being said, I'm not certain thumbnail generation is the problem. If it's once per day, there could be some issue associated with update checking... but I can't see why that would be a problem and it wouldn't happen with the project is requested. VisualVM should resolve it one way or another in any case. One other thing: is there anything conventional about where the project/images are stored? The need for a reboot makes me think there could be an operating system component. I've never seen it myself and don't recall anyone having reported it before.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611
https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611:655,Availability,reboot,reboot,655,"If you use VisualVM then you should be able to find exactly what takes time. Thumbnail generation can't safely be done in parallel because there's no guarantee the images will be pyramidal, so there is a high risk of out of memory errors. That being said, I'm not certain thumbnail generation is the problem. If it's once per day, there could be some issue associated with update checking... but I can't see why that would be a problem and it wouldn't happen with the project is requested. VisualVM should resolve it one way or another in any case. One other thing: is there anything conventional about where the project/images are stored? The need for a reboot makes me think there could be an operating system component. I've never seen it myself and don't recall anyone having reported it before.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611
https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611:373,Deployability,update,update,373,"If you use VisualVM then you should be able to find exactly what takes time. Thumbnail generation can't safely be done in parallel because there's no guarantee the images will be pyramidal, so there is a high risk of out of memory errors. That being said, I'm not certain thumbnail generation is the problem. If it's once per day, there could be some issue associated with update checking... but I can't see why that would be a problem and it wouldn't happen with the project is requested. VisualVM should resolve it one way or another in any case. One other thing: is there anything conventional about where the project/images are stored? The need for a reboot makes me think there could be an operating system component. I've never seen it myself and don't recall anyone having reported it before.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611
https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611:104,Safety,safe,safely,104,"If you use VisualVM then you should be able to find exactly what takes time. Thumbnail generation can't safely be done in parallel because there's no guarantee the images will be pyramidal, so there is a high risk of out of memory errors. That being said, I'm not certain thumbnail generation is the problem. If it's once per day, there could be some issue associated with update checking... but I can't see why that would be a problem and it wouldn't happen with the project is requested. VisualVM should resolve it one way or another in any case. One other thing: is there anything conventional about where the project/images are stored? The need for a reboot makes me think there could be an operating system component. I've never seen it myself and don't recall anyone having reported it before.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611
https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611:209,Safety,risk,risk,209,"If you use VisualVM then you should be able to find exactly what takes time. Thumbnail generation can't safely be done in parallel because there's no guarantee the images will be pyramidal, so there is a high risk of out of memory errors. That being said, I'm not certain thumbnail generation is the problem. If it's once per day, there could be some issue associated with update checking... but I can't see why that would be a problem and it wouldn't happen with the project is requested. VisualVM should resolve it one way or another in any case. One other thing: is there anything conventional about where the project/images are stored? The need for a reboot makes me think there could be an operating system component. I've never seen it myself and don't recall anyone having reported it before.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325599611
https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212:246,Deployability,update,update,246,"> is there anything conventional about where the project/images are stored?. The project is stored on the C drive, same physical SSD as the OS. The images are stored on the E drive, a separate 2TB SSD. Both have at least 300Gb of free space. The update check is printed in the log and occurs prior to loading any project, so I don't suspect it's affecting project loading. Will check out VisualVM and see if I can use it to monitor the initial project creation step.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212
https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212:424,Energy Efficiency,monitor,monitor,424,"> is there anything conventional about where the project/images are stored?. The project is stored on the C drive, same physical SSD as the OS. The images are stored on the E drive, a separate 2TB SSD. Both have at least 300Gb of free space. The update check is printed in the log and occurs prior to loading any project, so I don't suspect it's affecting project loading. Will check out VisualVM and see if I can use it to monitor the initial project creation step.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212
https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212:301,Performance,load,loading,301,"> is there anything conventional about where the project/images are stored?. The project is stored on the C drive, same physical SSD as the OS. The images are stored on the E drive, a separate 2TB SSD. Both have at least 300Gb of free space. The update check is printed in the log and occurs prior to loading any project, so I don't suspect it's affecting project loading. Will check out VisualVM and see if I can use it to monitor the initial project creation step.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212
https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212:364,Performance,load,loading,364,"> is there anything conventional about where the project/images are stored?. The project is stored on the C drive, same physical SSD as the OS. The images are stored on the E drive, a separate 2TB SSD. Both have at least 300Gb of free space. The update check is printed in the log and occurs prior to loading any project, so I don't suspect it's affecting project loading. Will check out VisualVM and see if I can use it to monitor the initial project creation step.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212
https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212:277,Testability,log,log,277,"> is there anything conventional about where the project/images are stored?. The project is stored on the C drive, same physical SSD as the OS. The images are stored on the E drive, a separate 2TB SSD. Both have at least 300Gb of free space. The update check is printed in the log and occurs prior to loading any project, so I don't suspect it's affecting project loading. Will check out VisualVM and see if I can use it to monitor the initial project creation step.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1325606212
https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753:1482,Availability,down,down,1482,"Thanks, that would be good - it sounds like it would be difficult and time-consuming for anyone else to replicate the problem, and might not be possible if it turns out to be something more specific to your system. So solving this will likely require any any info you can get from VisualVM's CPU sampling. I'll try to write up info about VisualVM + QuPath at some point, but there are brief instructions at https://forum.image.sc/t/designing-a-qupath-workstation/54849/14. QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches. v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this *could* potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. For slightly more info in the log, you can switch the log level in the preferences from `INFO` to `DEBUG`. Not sure if that will help narrow things down or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753
https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753:766,Security,access,access,766,"Thanks, that would be good - it sounds like it would be difficult and time-consuming for anyone else to replicate the problem, and might not be possible if it turns out to be something more specific to your system. So solving this will likely require any any info you can get from VisualVM's CPU sampling. I'll try to write up info about VisualVM + QuPath at some point, but there are brief instructions at https://forum.image.sc/t/designing-a-qupath-workstation/54849/14. QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches. v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this *could* potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. For slightly more info in the log, you can switch the log level in the preferences from `INFO` to `DEBUG`. Not sure if that will help narrow things down or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753
https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753:1112,Security,access,access,1112,"Thanks, that would be good - it sounds like it would be difficult and time-consuming for anyone else to replicate the problem, and might not be possible if it turns out to be something more specific to your system. So solving this will likely require any any info you can get from VisualVM's CPU sampling. I'll try to write up info about VisualVM + QuPath at some point, but there are brief instructions at https://forum.image.sc/t/designing-a-qupath-workstation/54849/14. QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches. v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this *could* potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. For slightly more info in the log, you can switch the log level in the preferences from `INFO` to `DEBUG`. Not sure if that will help narrow things down or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753
https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753:1364,Testability,log,log,1364,"Thanks, that would be good - it sounds like it would be difficult and time-consuming for anyone else to replicate the problem, and might not be possible if it turns out to be something more specific to your system. So solving this will likely require any any info you can get from VisualVM's CPU sampling. I'll try to write up info about VisualVM + QuPath at some point, but there are brief instructions at https://forum.image.sc/t/designing-a-qupath-workstation/54849/14. QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches. v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this *could* potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. For slightly more info in the log, you can switch the log level in the preferences from `INFO` to `DEBUG`. Not sure if that will help narrow things down or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753
https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753:1388,Testability,log,log,1388,"Thanks, that would be good - it sounds like it would be difficult and time-consuming for anyone else to replicate the problem, and might not be possible if it turns out to be something more specific to your system. So solving this will likely require any any info you can get from VisualVM's CPU sampling. I'll try to write up info about VisualVM + QuPath at some point, but there are brief instructions at https://forum.image.sc/t/designing-a-qupath-workstation/54849/14. QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches. v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this *could* potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. For slightly more info in the log, you can switch the log level in the preferences from `INFO` to `DEBUG`. Not sure if that will help narrow things down or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326026753
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:333,Deployability,install,installing,333,"> So solving this will likely require any any info you can get from VisualVM's CPU sampling. Since I wasn't sure which outputs to provide you with from VisualVM, I made a quick recording of the profiling as it ran while QuPath was loading the project: https://youtu.be/_GHn556qEAk. I wasn't able to get the profiler to work, despite installing a 64 bit version of Java 17, but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:231,Performance,load,loading,231,"> So solving this will likely require any any info you can get from VisualVM's CPU sampling. Since I wasn't sure which outputs to provide you with from VisualVM, I made a quick recording of the profiling as it ran while QuPath was loading the project: https://youtu.be/_GHn556qEAk. I wasn't able to get the profiler to work, despite installing a 64 bit version of Java 17, but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:1408,Performance,load,load,1408," but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. In this recording, I've left the analysis pane open, and purposely triggered the ""not responding"" faded effect to show when the QuPath was loading the project. I've also opened a few demo images to show that read speeds weren't an issue. Feel free to let me know if there's anything else I can provide to aid in resolving this issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:2178,Performance,load,loading,2178," but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. In this recording, I've left the analysis pane open, and purposely triggered the ""not responding"" faded effect to show when the QuPath was loading the project. I've also opened a few demo images to show that read speeds weren't an issue. Feel free to let me know if there's anything else I can provide to aid in resolving this issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:851,Security,access,access,851,"> So solving this will likely require any any info you can get from VisualVM's CPU sampling. Since I wasn't sure which outputs to provide you with from VisualVM, I made a quick recording of the profiling as it ran while QuPath was loading the project: https://youtu.be/_GHn556qEAk. I wasn't able to get the profiler to work, despite installing a 64 bit version of Java 17, but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166:1195,Security,access,access,1195,"ick recording of the profiling as it ran while QuPath was loading the project: https://youtu.be/_GHn556qEAk. I wasn't able to get the profiler to work, despite installing a 64 bit version of Java 17, but the sampler and all other tools seemed to work. I've uploaded the thread and heap dumps to: https://drive.google.com/drive/folders/1akRolrnUwbryc3YMSRR_aXhJ5H6AgBWO?usp=sharing. > QuPath shouldn't be regenerating thumbnails when a project is opened, and it shouldn't be remembering anything (other than the preferences) across relaunches.; v0.4.0 should generating missing thumbnails only, and do so in a background thread that doesn't block. Both v0.3 and v0.4 will try to access the thumbnail images in the project when it is opened; this could potentially block the UI, because it needs to be done in the UI thread (and there can only be one). However these should generally be small JPEGs so I've never known that to be a problem. Therefore I'd only expect this to be troublesome if there is some other reason why access to the disk is exceptionally slow. Based on my limited interpretation of the VisualVM results, I'd say that you're right. The lowest-level QuPath method I could find which was responsible for the ~4 minute load time is `qupath.lib.io.UriUpdater$SingleUriItem.getStatus()` which invokes `java.nio.file.File.exists()`. ![image](https://user-images.githubusercontent.com/52012166/203870112-0ecd0822-7efd-4360-af2e-0858b8a03df7.png). My guess is that there is some kind of checking going on, comparing the URI listed in the project, with the file path, to verify that each project entry is pointing to the correct image, and that's what's taking up CPU time. > I couldn't really tell what was going on in the video, partly because the analysis pane was closed - and when the image was opened I couldn't really see how or when that happened. In this recording, I've left the analysis pane open, and purposely triggered the ""not responding"" faded effect to show when the QuPath ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1326872166
https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045:301,Availability,down,down,301,"Thanks, the screenshot suggests it's the `Files.exists()` check that is so slow. QuPath is probably calling this quite a lot, because it's usually really inexpensive - and *not* calling it leaves open the (admittedly small) possibility that the file has been deleted between calls. I could try to cut down on this, but I'm skeptical that it will help because it sounds a lot like it's only the first call that is slow. In fact, I'd be curious as to whether accessing each file is slow or just the first one on the disk. That should be relatively easy to test by creating a much smaller project and comparing the speed. Either way, it sounds like the problem lurks in the realm of Java, the operating system, and the hard drive. I'm not sure if there's much can be done about it in QuPath. I'd suggest:. * try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful; * try copying the images to a local drive (if possible); * try timing a simple script with a file on the same disk, e.g. ```groovy; import java.nio.file.*; var path = '/path/to/some/file'; println ""Exists: ${Files.exists(Paths.get(path))}""; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045
https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045:457,Security,access,accessing,457,"Thanks, the screenshot suggests it's the `Files.exists()` check that is so slow. QuPath is probably calling this quite a lot, because it's usually really inexpensive - and *not* calling it leaves open the (admittedly small) possibility that the file has been deleted between calls. I could try to cut down on this, but I'm skeptical that it will help because it sounds a lot like it's only the first call that is slow. In fact, I'd be curious as to whether accessing each file is slow or just the first one on the disk. That should be relatively easy to test by creating a much smaller project and comparing the speed. Either way, it sounds like the problem lurks in the realm of Java, the operating system, and the hard drive. I'm not sure if there's much can be done about it in QuPath. I'd suggest:. * try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful; * try copying the images to a local drive (if possible); * try timing a simple script with a file on the same disk, e.g. ```groovy; import java.nio.file.*; var path = '/path/to/some/file'; println ""Exists: ${Files.exists(Paths.get(path))}""; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045
https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045:809,Security,access,accessing,809,"Thanks, the screenshot suggests it's the `Files.exists()` check that is so slow. QuPath is probably calling this quite a lot, because it's usually really inexpensive - and *not* calling it leaves open the (admittedly small) possibility that the file has been deleted between calls. I could try to cut down on this, but I'm skeptical that it will help because it sounds a lot like it's only the first call that is slow. In fact, I'd be curious as to whether accessing each file is slow or just the first one on the disk. That should be relatively easy to test by creating a much smaller project and comparing the speed. Either way, it sounds like the problem lurks in the realm of Java, the operating system, and the hard drive. I'm not sure if there's much can be done about it in QuPath. I'd suggest:. * try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful; * try copying the images to a local drive (if possible); * try timing a simple script with a file on the same disk, e.g. ```groovy; import java.nio.file.*; var path = '/path/to/some/file'; println ""Exists: ${Files.exists(Paths.get(path))}""; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045
https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045:554,Testability,test,test,554,"Thanks, the screenshot suggests it's the `Files.exists()` check that is so slow. QuPath is probably calling this quite a lot, because it's usually really inexpensive - and *not* calling it leaves open the (admittedly small) possibility that the file has been deleted between calls. I could try to cut down on this, but I'm skeptical that it will help because it sounds a lot like it's only the first call that is slow. In fact, I'd be curious as to whether accessing each file is slow or just the first one on the disk. That should be relatively easy to test by creating a much smaller project and comparing the speed. Either way, it sounds like the problem lurks in the realm of Java, the operating system, and the hard drive. I'm not sure if there's much can be done about it in QuPath. I'd suggest:. * try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful; * try copying the images to a local drive (if possible); * try timing a simple script with a file on the same disk, e.g. ```groovy; import java.nio.file.*; var path = '/path/to/some/file'; println ""Exists: ${Files.exists(Paths.get(path))}""; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045
https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045:1028,Usability,simpl,simple,1028,"Thanks, the screenshot suggests it's the `Files.exists()` check that is so slow. QuPath is probably calling this quite a lot, because it's usually really inexpensive - and *not* calling it leaves open the (admittedly small) possibility that the file has been deleted between calls. I could try to cut down on this, but I'm skeptical that it will help because it sounds a lot like it's only the first call that is slow. In fact, I'd be curious as to whether accessing each file is slow or just the first one on the disk. That should be relatively easy to test by creating a much smaller project and comparing the speed. Either way, it sounds like the problem lurks in the realm of Java, the operating system, and the hard drive. I'm not sure if there's much can be done about it in QuPath. I'd suggest:. * try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful; * try copying the images to a local drive (if possible); * try timing a simple script with a file on the same disk, e.g. ```groovy; import java.nio.file.*; var path = '/path/to/some/file'; println ""Exists: ${Files.exists(Paths.get(path))}""; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1327044045
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:422,Availability,down,down,422,"> try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful. I think this is it! I opened the folder containing the images in explorer, and set the thumbnail size to ""large icons"" via `view > large icons`. This would generate thumbnails for all files that are currently displayed on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1711,Availability,reboot,rebooting,1711,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1960,Availability,reboot,rebooting,1960,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:2347,Deployability,install,installed,2347,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:554,Performance,load,load,554,"> try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful. I think this is it! I opened the folder containing the images in explorer, and set the thumbnail size to ""large icons"" via `view > large icons`. This would generate thumbnails for all files that are currently displayed on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1183,Performance,load,loading,1183,"in explorer, and set the thumbnail size to ""large icons"" via `view > large icons`. This would generate thumbnails for all files that are currently displayed on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1191,Performance,perform,performance,1191,"in explorer, and set the thumbnail size to ""large icons"" via `view > large icons`. This would generate thumbnails for all files that are currently displayed on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1337,Performance,perform,performance,1337," on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SS",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1486,Performance,load,loading,1486,"enerated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1840,Performance,perform,performance,1840,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1872,Performance,load,loads,1872,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:2127,Performance,load,load,2127,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:6,Security,access,accessing,6,"> try accessing the images some other way before opening them in QuPath (e.g. through Windows Explorer), in case 'pre-warning' the OS is somehow useful. I think this is it! I opened the folder containing the images in explorer, and set the thumbnail size to ""large icons"" via `view > large icons`. This would generate thumbnails for all files that are currently displayed on screen. After those were generated, I scrolled down, so that the remaining files would also have their thumbnails generated. Then, I launched the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580:1687,Testability,test,test,1687,"hed the QuPath project in 0.4.1, and the load time was nearly instantaneous. Which, while resolving the issue, also means that the issue exists outside of QuPath. So, for some reason, the thumbnail previews are lost after a period of time, and don't seem to coincide with closing the folder or restarting the computer. The first thing I attempted to preserve thumbnails was to ensure ""Always show icons, never thumbnails"" in the folder options was unchecked, however it already was by default:; ![image](https://user-images.githubusercontent.com/52012166/211071879-ac70ef62-925f-4fe5-8ec3-10763d391393.png); Toggling this field didn't seem to have any impact on project loading performance, since in either case, the thumbnails were already generated (just replaced with an icon if the box is checked).; Next, under Windows performance options, I noticed ""save taskbar thumbnail previews"" was unchecked by default. I've checked it, and so far, I don't seem to have trouble loading projects that already have thumbnails generated in explorer. ; ![image](https://user-images.githubusercontent.com/52012166/211072664-c211658b-7aa6-435d-8067-830b4e1620b1.png). I'll continue to test other projects and rebooting my computer, to confirm if this has resolved the issue. TL;DR: **Check ""save taskbar thumbnail previews"" under Windows performance options. Subsequent loads of the project should now be much faster**. EDIT: So far, this fix persists after rebooting the system. EDIT 2: I've opened the project again after a few hours, verifying that the thumbnails exist in Windows Explorer. I'm now getting a long project load time (although anecdotally, it feels a bit faster), which means the above fix might not work as it could be tied to something other than thumbnails generated in Explorer. Currently, the project is located on the OS-installed drive (NVMe SSD), but the images are located on a separate local NVMe SSD. I'll see if moving both the project and images onto the OS drive changes anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1373971580
https://github.com/qupath/qupath/issues/1154#issuecomment-1783294927:85,Testability,log,log,85,"This seems to be fixed in 0.5.0-rc2, although I see no mention of this in the change log. Marking as closed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1783294927
https://github.com/qupath/qupath/issues/1154#issuecomment-1783777373:145,Integrability,depend,dependencies,145,"Thanks for making it as closed. My best guess is that the issue didn't originate in QuPath, so was fixed as a side-effect of updating Java/other dependencies.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1154#issuecomment-1783777373
https://github.com/qupath/qupath/issues/1167#issuecomment-1467865538:6,Deployability,update,update,6,"Small update on this issue for QuPath v0.4.3. I previously mentioned; > It is unclear if this may cause data corruption or any other negative consequences. after closing QuPath to cancel a running script. However, this action now causes a corruption of the .qpdata file for the project entry that the script is currently running on. This corruption results in QuPath being unable to read the hierarchy data for the project entry. See https://forum.image.sc/t/hierarchy-is-null-cannot-invoke-can-anyone-help/78488/10 for details.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1167#issuecomment-1467865538
https://github.com/qupath/qupath/issues/1175#issuecomment-1337428008:15,Usability,clear,clear,15,"Thanks for the clear description, I'll try to fix this for v0.4.1 :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1175#issuecomment-1337428008
https://github.com/qupath/qupath/issues/1176#issuecomment-1354327647:868,Energy Efficiency,efficient,efficient,868,"Hi, I don't think this is a new bug - although maybe its impact is different through the script editor changes. The actual syntax highlighting hasn't changed, and there are lots of reports of `StackOverflowErrors` associated with Java regex. * https://github.com/qupath/qupath/issues/241; * https://github.com/qupath/qupath/issues/314. Here, QuPath is using the same regex as from the RichTextFX project and I guess that's a limitation.; The code is in [`GroovyStyler`](https://github.com/qupath/qupath/blob/v0.4.0/qupath-extension-script-editor/src/main/java/qupath/lib/gui/scripting/richtextfx/stylers/GroovyStyler.java). I'm not much of a regex specialist (improvements welcome!) so don't have a quick solution. An alternative option (which I *think* I prefer) is to abandon regex altogether and compute the styling some other way. It feels like this might be more efficient and less exception-prone, but also feels like something I'll almost certainly get wrong for a few iterations so that it doesn't apply the highlighting properly. Might become a hopefully-small holiday project if I feel inspired.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1176#issuecomment-1354327647
https://github.com/qupath/qupath/issues/1176#issuecomment-1357429790:347,Safety,avoid,avoid,347,"I've made a PR at https://github.com/qupath/qupath/pull/1195. It involved entirely changing how the Groovy syntax highlighting works, and adding support for a few other Groovy features (like using colors to indicate `""string $interpolation""`, or numeric values). It doesn't handle everything, because that would require fully parsing the code too avoid getting mixed up (e.g. mistaking a division operator for the start of a slashy string). The code was very fiddly to write, so I wouldn't be surprised to learn its broken in some places - but as far as I can tell, it's better than the previous version. @Rdornier if you've time to check it out, please let me know if there are problems.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1176#issuecomment-1357429790
https://github.com/qupath/qupath/issues/1176#issuecomment-1357429790:506,Usability,learn,learn,506,"I've made a PR at https://github.com/qupath/qupath/pull/1195. It involved entirely changing how the Groovy syntax highlighting works, and adding support for a few other Groovy features (like using colors to indicate `""string $interpolation""`, or numeric values). It doesn't handle everything, because that would require fully parsing the code too avoid getting mixed up (e.g. mistaking a division operator for the start of a slashy string). The code was very fiddly to write, so I wouldn't be surprised to learn its broken in some places - but as far as I can tell, it's better than the previous version. @Rdornier if you've time to check it out, please let me know if there are problems.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1176#issuecomment-1357429790
https://github.com/qupath/qupath/issues/1176#issuecomment-1362564457:189,Availability,error,error,189,"Hello @petebankhead, . Thank you for your quick consideration of the issue.; From what I have tested until now, it works fine. The number of characters in block comments does not throw the error anymore. and I can still run the scripts.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1176#issuecomment-1362564457
https://github.com/qupath/qupath/issues/1176#issuecomment-1362564457:94,Testability,test,tested,94,"Hello @petebankhead, . Thank you for your quick consideration of the issue.; From what I have tested until now, it works fine. The number of characters in block comments does not throw the error anymore. and I can still run the scripts.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1176#issuecomment-1362564457
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:492,Availability,error,errors,492,"QuPath does not include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:911,Availability,error,error,911,"QuPath does not include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:965,Deployability,update,update,965,"QuPath does not include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1220,Deployability,install,installing,1220,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1810,Deployability,install,installation,1810,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1983,Deployability,install,installed,1983,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:917,Integrability,message,messages,917,"QuPath does not include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1936,Integrability,depend,dependencies,1936,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:423,Security,access,access,423,"QuPath does not include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1754,Security,access,access,1754,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1077,Usability,learn,learning,1077,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127:1423,Usability,simpl,simply,1423,"t include any code that directly relates to the GPU - everything happens through OpenCV/JavaCPP (and sometimes also PyTorch/TensorFlow/DJL). If you search for `the provided PTX was compiled with an unsupported toolchain` you should find lots of discussions separately from QuPath; it seems that the issue is normally related to the driver. I tried to replicate the issue with the only Windows computer I have access to (including a GeForce 1060) and could not - it runs without errors, and `DnnTools.isCudaAvailable()` returns true. > Given that issue https://github.com/qupath/qupath/issues/841 was marked as resolved 5 days ago, it could be linked to that. Perhaps there were some changes to the API such that closing of the model should be scripted differently?. I don't think that can be relevant here. I'm not sure that there is any bug here that can be fixed within QuPath. I have seen such error messages before, but the solution was always to update my graphics card driver. Have you tried this?. Note that QuPath v0.4.0 gives a range of options for deep learning, but CUDA incompatibilities will mean that probably not all can work at once (e.g. I could get PyTorch with GPU acceleration today by installing CUDA 11.7, but TensorFlow seems to require 11.3... I'm not sure there's a combination that gets both working together). I don't see that there's really anything much more we can do apart from simply removing the option of GPU acceleration altogether and not documenting it as an option - but that seems a shame when often it does work. > I have a version of QuPath built on 2022-11-21 which has no problem running StarDist on the GPU, so it's likely tied to any commits between this period. Because QuPath doesn't directly access the GPU, please check the .jar files within each installation. I don't know what the problem could be, unless it is somehow related to the inclusion of some Deep Java Library dependencies - or if you have other extensions installed that are conflicting.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341628127
https://github.com/qupath/qupath/issues/1180#issuecomment-1341741875:162,Deployability,release,release,162,">it seems that the issue is normally related to the driver. You're absolutely correct, after updating my GeForce Game Ready driver to 527.37, which is the latest release at the time of posting this comment, I no longer have the issue, and I'm able to segment cells, confirming that the GPU is being used based on VRAM. Unless anyone else is still having this issue after updating their drivers, I'll close this as resolved. Thanks again for all your help!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1180#issuecomment-1341741875
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:247,Availability,Error,Error,247,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:1305,Integrability,Synchroniz,SynchronizedMap,1305,ion; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurr,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:261,Modifiability,plugin,plugin,261,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:545,Modifiability,plugin,plugins,545,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:632,Modifiability,plugin,plugins,632,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:776,Modifiability,plugin,plugins,776,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:279,Performance,Concurren,ConcurrentModificationException,279,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:322,Performance,concurren,concurrent,322,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:363,Performance,Concurren,ConcurrentModificationException,363,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:419,Performance,concurren,concurrent,419,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:488,Performance,concurren,concurrent,488,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:988,Performance,Concurren,ConcurrentModificationException,988,"; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.con",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:1924,Performance,concurren,concurrent,1924,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:2006,Performance,concurren,concurrent,2006,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:2072,Performance,concurren,concurrent,2072,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:2154,Performance,concurren,concurrent,2154,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:2220,Performance,concurren,concurrent,2220,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:2300,Performance,concurren,concurrent,2300,ath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); ```; I can ask them to share a QuPath project if it's useful to you. . The issue appeared on a built from source linux QuPath if that's of any use. All the best and happy new year,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601:162,Safety,detect,detections,162,"Hi Pete!; Reopening this as it's very similar and still happening in QuPath 0.5.0; A user had an annotation inside which there was another annotation filled with detections (over 5000); When runing ""Delaunay cluster features 2D"" we ran into; ```; Error running plugin: java.util.ConcurrentModificationException; java.util.concurrent.ExecutionException: java.util.ConcurrentModificationException; at java.base/java.util.concurrent.FutureTask.report(Unknown Source); at java.base/java.util.concurrent.FutureTask.get(Unknown Source); at qupath.lib.plugins.AbstractTaskRunner.awaitCompletion(AbstractTaskRunner.java:147); at qupath.lib.plugins.AbstractTaskRunner.runTasks(AbstractTaskRunner.java:117); at qupath.lib.gui.TaskRunnerFX.runTasks(TaskRunnerFX.java:106); at qupath.lib.plugins.AbstractPlugin.runPlugin(AbstractPlugin.java:147); at qupath.lib.gui.ParameterDialogWrapper$1.run(ParameterDialogWrapper.java:177); at java.base/java.lang.Thread.run(Unknown Source); Caused by: java.util.ConcurrentModificationException; at java.base/java.util.ArrayList.checkForComodification(Unknown Source); at java.base/java.util.ArrayList.equals(Unknown Source); at java.base/java.util.WeakHashMap.matchesKey(Unknown Source); at java.base/java.util.WeakHashMap.get(Unknown Source); at java.base/java.util.Collections$SynchronizedMap.get(Unknown Source); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.getNameMap(NumericMeasurementList.java:142); at qupath.lib.measurements.NumericMeasurementList$AbstractNumericMeasurementList.close(NumericMeasurementList.java:133); at qupath.lib.measurements.NumericMeasurementList$FloatList.close(NumericMeasurementList.java:352); at qupath.opencv.features.DelaunayTriangulation.addClusterMeasurements(DelaunayTriangulation.java:466); at qupath.opencv.features.DelaunayClusteringPlugin$DelaunayRunnable.run(DelaunayClusteringPlugin.java:215); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1182#issuecomment-1876997601
https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309:20,Availability,down,download,20,Intriguing - if you download the x86 build does it have the same behavior? I guess you may have to rename any Apple silicon installation beforehand (I'm not sure if/how the general package installer deals with multiple installations with the same name).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309
https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309:124,Deployability,install,installation,124,Intriguing - if you download the x86 build does it have the same behavior? I guess you may have to rename any Apple silicon installation beforehand (I'm not sure if/how the general package installer deals with multiple installations with the same name).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309
https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309:189,Deployability,install,installer,189,Intriguing - if you download the x86 build does it have the same behavior? I guess you may have to rename any Apple silicon installation beforehand (I'm not sure if/how the general package installer deals with multiple installations with the same name).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309
https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309:219,Deployability,install,installations,219,Intriguing - if you download the x86 build does it have the same behavior? I guess you may have to rename any Apple silicon installation beforehand (I'm not sure if/how the general package installer deals with multiple installations with the same name).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1351834309
https://github.com/qupath/qupath/issues/1184#issuecomment-1352058799:221,Availability,error,error,221,"Weirdly I can't get it to open. MacOS says '""QuPath.app"" is damaged and can't be opened. You should move it to the bin'. Even when I go into the package and manually run the QuPath script from the terminal I get the same error. I'll maybe try installing Java JDK 17 x86 and see if I can compile it, unless you have another suggestion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352058799
https://github.com/qupath/qupath/issues/1184#issuecomment-1352058799:243,Deployability,install,installing,243,"Weirdly I can't get it to open. MacOS says '""QuPath.app"" is damaged and can't be opened. You should move it to the bin'. Even when I go into the package and manually run the QuPath script from the terminal I get the same error. I'll maybe try installing Java JDK 17 x86 and see if I can compile it, unless you have another suggestion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352058799
https://github.com/qupath/qupath/issues/1184#issuecomment-1352080849:89,Deployability,install,installation,89,"Did you try right-click, as described at https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#installation ?. Edit: I've occasionally found I need to try to open the app by right-click twice (the first time macOS stops me, the second it relents).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352080849
https://github.com/qupath/qupath/issues/1184#issuecomment-1352080849:107,Deployability,install,installation,107,"Did you try right-click, as described at https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#installation ?. Edit: I've occasionally found I need to try to open the app by right-click twice (the first time macOS stops me, the second it relents).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352080849
https://github.com/qupath/qupath/issues/1184#issuecomment-1352368210:100,Deployability,install,installing,100,"I haven't been able to replicate this - but I was trying to do it by adjusting screen size, and not installing extensions (since creating an extension to add a button would be quite a hassle...). Questions:; * How are you opening the project (e.g. button, menu, drag & drop), and does it matter?; * Can you see the issue *without* any custom extensions installed?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352368210
https://github.com/qupath/qupath/issues/1184#issuecomment-1352368210:353,Deployability,install,installed,353,"I haven't been able to replicate this - but I was trying to do it by adjusting screen size, and not installing extensions (since creating an extension to add a button would be quite a hassle...). Questions:; * How are you opening the project (e.g. button, menu, drag & drop), and does it matter?; * Can you see the issue *without* any custom extensions installed?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352368210
https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017:834,Deployability,toggle,toggle,834,"The method of opening the project doesn't matter. I just tested drag&drop, open dialog and recent dialog. All have the same problem. Regarding your other question, only if I add enough buttons to the source to cause the problem. For example, if I add; ```java; nodes.add(ActionTools.createToggleButton(ActionTools.createAction(() -> {; 	}, ""something"", IconFactory.createNode(QuPathGUI.TOOLBAR_ICON_SIZE, QuPathGUI.TOOLBAR_ICON_SIZE,; 	PathIcons.BRUSH_TOOL), null), true, true));; nodes.add(new Separator(Orientation.VERTICAL));; nodes.add(ActionTools.createButton(ActionTools.createAction(() -> {}, ""Convert""), false));; ```; (sorry for the formatting) to qupath-gui-fx/src/main/java/qupath/lib/gui/ToolBarComponent.java line 170 (just before `toolbar.getItems().setAll(nodes);`) it demonstrates the issue. This is simply adding one toggle button, one separator and one text button to the end (sorry, I'd forgotten about the toggle button). I have no actions on these buttons which would interfere, nor any accelerator etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017
https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017:926,Deployability,toggle,toggle,926,"The method of opening the project doesn't matter. I just tested drag&drop, open dialog and recent dialog. All have the same problem. Regarding your other question, only if I add enough buttons to the source to cause the problem. For example, if I add; ```java; nodes.add(ActionTools.createToggleButton(ActionTools.createAction(() -> {; 	}, ""something"", IconFactory.createNode(QuPathGUI.TOOLBAR_ICON_SIZE, QuPathGUI.TOOLBAR_ICON_SIZE,; 	PathIcons.BRUSH_TOOL), null), true, true));; nodes.add(new Separator(Orientation.VERTICAL));; nodes.add(ActionTools.createButton(ActionTools.createAction(() -> {}, ""Convert""), false));; ```; (sorry for the formatting) to qupath-gui-fx/src/main/java/qupath/lib/gui/ToolBarComponent.java line 170 (just before `toolbar.getItems().setAll(nodes);`) it demonstrates the issue. This is simply adding one toggle button, one separator and one text button to the end (sorry, I'd forgotten about the toggle button). I have no actions on these buttons which would interfere, nor any accelerator etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017
https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017:57,Testability,test,tested,57,"The method of opening the project doesn't matter. I just tested drag&drop, open dialog and recent dialog. All have the same problem. Regarding your other question, only if I add enough buttons to the source to cause the problem. For example, if I add; ```java; nodes.add(ActionTools.createToggleButton(ActionTools.createAction(() -> {; 	}, ""something"", IconFactory.createNode(QuPathGUI.TOOLBAR_ICON_SIZE, QuPathGUI.TOOLBAR_ICON_SIZE,; 	PathIcons.BRUSH_TOOL), null), true, true));; nodes.add(new Separator(Orientation.VERTICAL));; nodes.add(ActionTools.createButton(ActionTools.createAction(() -> {}, ""Convert""), false));; ```; (sorry for the formatting) to qupath-gui-fx/src/main/java/qupath/lib/gui/ToolBarComponent.java line 170 (just before `toolbar.getItems().setAll(nodes);`) it demonstrates the issue. This is simply adding one toggle button, one separator and one text button to the end (sorry, I'd forgotten about the toggle button). I have no actions on these buttons which would interfere, nor any accelerator etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017
https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017:816,Usability,simpl,simply,816,"The method of opening the project doesn't matter. I just tested drag&drop, open dialog and recent dialog. All have the same problem. Regarding your other question, only if I add enough buttons to the source to cause the problem. For example, if I add; ```java; nodes.add(ActionTools.createToggleButton(ActionTools.createAction(() -> {; 	}, ""something"", IconFactory.createNode(QuPathGUI.TOOLBAR_ICON_SIZE, QuPathGUI.TOOLBAR_ICON_SIZE,; 	PathIcons.BRUSH_TOOL), null), true, true));; nodes.add(new Separator(Orientation.VERTICAL));; nodes.add(ActionTools.createButton(ActionTools.createAction(() -> {}, ""Convert""), false));; ```; (sorry for the formatting) to qupath-gui-fx/src/main/java/qupath/lib/gui/ToolBarComponent.java line 170 (just before `toolbar.getItems().setAll(nodes);`) it demonstrates the issue. This is simply adding one toggle button, one separator and one text button to the end (sorry, I'd forgotten about the toggle button). I have no actions on these buttons which would interfere, nor any accelerator etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352389017
https://github.com/qupath/qupath/issues/1184#issuecomment-1352810287:800,Testability,test,test,800,"Thanks for exploring, although I'm now a bit lost in the details. One possibly-important thing that seems missing: what size/resolution of display are you using?. I still haven't managed to replicate the problem on two computers (13"" MBP & Mac Studio with Studio Display. I tried a few different screen resolutions, and adding extra buttons to the toolbar code. The project entries always show up immediately, even whenever the toolbar contains more buttons than can be shown at once. Am I right that the bug appears for you only when; * There is precisely one button too many in the toolbar when QuPath is launched (more or fewer & the bug doesn't appear); * The QuPath window is not resized at all prior to opening the project. Also, does it appear for every project you try? Have you been able to test it on a second computer?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1352810287
https://github.com/qupath/qupath/issues/1184#issuecomment-1353187206:445,Deployability,update,update,445,"* My display is the M1 Macbook Pro 16"", so 3456x2234. However, after your suggestion I switched my main display to a 24"" 1920x1080 display I have and was still able to replicate the problem (after adding the appropriate number of buttons).; * Yes, there needs to be precisely one too many buttons. If the buttons only just fit in the toolbar, no problem. If I have two buttons in the overflow, also no problem.; * Yes, nothing should be done to update the state before opening the project. If, before opening the project, I (slowly) mouse over the red border it will then work, likewise clicking a toolbar button or resizing the window (actually, just clicking when the resize cursor appears is enough - I don't actually have to change the size).; * Yes, it happens on every project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1184#issuecomment-1353187206
https://github.com/qupath/qupath/issues/1199#issuecomment-1363847204:114,Deployability,install,installation,114,"Did you try right-click and Open?. Here's the info from the docs: https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos. The right-click + open trick might be required both for the installer and for the app itself on first launch (I'm not sure, the behavior on a Mac can vary a bit).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1363847204
https://github.com/qupath/qupath/issues/1199#issuecomment-1363847204:199,Deployability,install,installer,199,"Did you try right-click and Open?. Here's the info from the docs: https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos. The right-click + open trick might be required both for the installer and for the app itself on first launch (I'm not sure, the behavior on a Mac can vary a bit).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1363847204
https://github.com/qupath/qupath/issues/1199#issuecomment-1367968638:62,Integrability,message,message,62,The right-click trick seemed to work for me after seeing that message. Very odd! (2022 - M1 Max); Thanks!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1367968638
https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307:75,Deployability,install,installed,75,@andrewjUTSW the right click + open did eventually help for me. I actually installed qupath once more and then I had to do the right click + open twice to get it to open. The first time using right click+open I got the same message about the sw being damaged. The second time I got the same message but it had the option to open the app this time. I am currently running Ventura 13.1 and today I worked with Qupath 0.4.2,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307
https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307:224,Integrability,message,message,224,@andrewjUTSW the right click + open did eventually help for me. I actually installed qupath once more and then I had to do the right click + open twice to get it to open. The first time using right click+open I got the same message about the sw being damaged. The second time I got the same message but it had the option to open the app this time. I am currently running Ventura 13.1 and today I worked with Qupath 0.4.2,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307
https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307:291,Integrability,message,message,291,@andrewjUTSW the right click + open did eventually help for me. I actually installed qupath once more and then I had to do the right click + open twice to get it to open. The first time using right click+open I got the same message about the sw being damaged. The second time I got the same message but it had the option to open the app this time. I am currently running Ventura 13.1 and today I worked with Qupath 0.4.2,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1199#issuecomment-1416478307
https://github.com/qupath/qupath/issues/1201#issuecomment-1366618917:171,Deployability,Toggle,Toggle,171,"Quick answer to 2: you can show/hide multiple channels by selecting them, and then right-clicking on the channel list before choosing 'Show channels', 'Hide channels' or 'Toggle channels'. Ctrl+A should also work to quickly select all channels before right-clicking. I'll look into the limited resizing later.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1201#issuecomment-1366618917
https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014:0,Deployability,Update,Update,0,"Update to 1: I've removed the dialog height limit in v0.4.2, which has just been released. I'll close this issue now since selecting/deselecting all is possible as in my last answer. We might add buttons/checkboxes with these options in the future, but I think we need to explore the whole topic of UX more first - to try to make QuPath's options easier to find, but without making the user interface too cluttered and confused. I don't know what the solution to that is, but I hope someone can figure it out :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014
https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014:81,Deployability,release,released,81,"Update to 1: I've removed the dialog height limit in v0.4.2, which has just been released. I'll close this issue now since selecting/deselecting all is possible as in my last answer. We might add buttons/checkboxes with these options in the future, but I think we need to explore the whole topic of UX more first - to try to make QuPath's options easier to find, but without making the user interface too cluttered and confused. I don't know what the solution to that is, but I hope someone can figure it out :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014
https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014:391,Integrability,interface,interface,391,"Update to 1: I've removed the dialog height limit in v0.4.2, which has just been released. I'll close this issue now since selecting/deselecting all is possible as in my last answer. We might add buttons/checkboxes with these options in the future, but I think we need to explore the whole topic of UX more first - to try to make QuPath's options easier to find, but without making the user interface too cluttered and confused. I don't know what the solution to that is, but I hope someone can figure it out :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014
https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014:299,Usability,UX,UX,299,"Update to 1: I've removed the dialog height limit in v0.4.2, which has just been released. I'll close this issue now since selecting/deselecting all is possible as in my last answer. We might add buttons/checkboxes with these options in the future, but I think we need to explore the whole topic of UX more first - to try to make QuPath's options easier to find, but without making the user interface too cluttered and confused. I don't know what the solution to that is, but I hope someone can figure it out :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1201#issuecomment-1397436014
https://github.com/qupath/qupath/issues/1202#issuecomment-1375325780:307,Deployability,release,release,307,"Thanks @OpenScienceProject I can replicate the problem. The issue comes from how the icon colors are set; ultimately, it's connected to some changes that were made to overcome some awkward JavaFX/ControlsFX behavior that was making the icon colors wrong in dark mode. I'll look into it, but I suspect a new release will be needed to have an effective workaround. > Sidenote: I see that changing the *Default object color* in the preferences doesn't change the icon colors properly; this is probably a related issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1202#issuecomment-1375325780
https://github.com/qupath/qupath/issues/1202#issuecomment-1375336175:555,Usability,simpl,simply,555,"Since you're building from source anyway, commenting out the line 275 - `glyph.setColor(color)` - from `IconFactory.java` should at least stop the exception (the icon color will be wrong, but not the color displayed in the viewer): ; https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/IconFactory.java#L275. The exception is really mysterious though, since it's complaining about a value being bound immediately after it has been explicitly unbound... so I'm really not sure yet what's going on. Setting the color simply sets the `textFillProperty()` so it's very odd.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1202#issuecomment-1375336175
https://github.com/qupath/qupath/issues/1202#issuecomment-1381853809:168,Availability,error,error,168,"I've just compiled QuPath from main and can confirm that this bug has now been fixed (in 0.4.1, setting a point annotation class causes a ""bidirectional binding failed error""). Thanks Pete!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1202#issuecomment-1381853809
https://github.com/qupath/qupath/issues/1202#issuecomment-1381855920:60,Security,validat,validated,60,"Brilliant, thanks @zindy! Very reassuring to have any fixes validated, I hope v0.4.2 can last longer than v0.4.0 and v0.4.1 :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1202#issuecomment-1381855920
https://github.com/qupath/qupath/issues/1202#issuecomment-1397430434:14,Availability,avail,available,14,v0.4.2 is now available so I'll close this,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1202#issuecomment-1397430434
https://github.com/qupath/qupath/issues/1217#issuecomment-1403554482:299,Deployability,release,release,299,"The fix seems straightforward, just to remove the `getPath()` method from; https://github.com/qupath/qupath/blob/v0.4.2/qupath-gui-fx/src/main/java/qupath/lib/gui/images/servers/PathHierarchyImageServer.java#L151. I'll submit a PR, the main question is whether there will be a v0.4.3 or if the next release will be v0.5.0 (further in the future).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1217#issuecomment-1403554482
https://github.com/qupath/qupath/issues/1224#issuecomment-1416687799:201,Usability,simpl,simple,201,"The annotations probably are unlocked. You can check this by trying to move them, or looking for the lock symbol under the annotations tab. You will only see draggable points if the annotation ROI is 'simple', e.g. a rectangle, line or polygon. More complicated ROIs (e.g. containing disconnected pieces or holes) are represented differently and can't be edited by dragging points. However they can be edited using the Brush or Wand tool. Since I don't think there's a bug here, I'll close the issue. Feel free to start a topic [on the forum](https://forum.image.sc/tag/qupath) if you would like to discuss this behavior/QuPath's use, or reopen the issue if my explanation is wrong and there really is a problem with unlock not working.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1224#issuecomment-1416687799
https://github.com/qupath/qupath/issues/1228#issuecomment-1420795098:118,Deployability,install,installation,118,"This isn't really a bug, and is already covered in the documentation: https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1228#issuecomment-1420795098
https://github.com/qupath/qupath/issues/1246#issuecomment-1481503527:101,Deployability,update,updated,101,"I can replicate this if I open the slide label under the 'Image' tab. It turns out, the label **is** updated if it is shown via *View &rarr; Show slide label*. I agree it's confusing to have different behavior, although I'm not sure what is the best way to fix it because both ways of showing the label have different aims:. * Under the 'Image' tab, the aim is to show all the associated images and be able to freely choose.; * With *View &rarr; Show slide label*, QuPath tries to determine which associated image corresponds to the slide label, and uses that. The second command is more complicated, because there's no guarantee that any image will have an associated label - and, if it does, there's no guarantee what precisely it will be called. Here's the awkward code that tries to figure that out:. https://github.com/qupath/qupath/blob/75ec9cebe5e3bc5843fc60b07b455ce1215e1fb9/qupath-gui-fx/src/main/java/qupath/lib/gui/panes/SlideLabelView.java#L130-L148. I'm not sure if either command can or should fully replace the other. Maybe it would be better if *View &rarr; Show slide label* was more prominent (e.g. somewhere under the 'Image' tab as well)?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1246#issuecomment-1481503527
https://github.com/qupath/qupath/issues/1246#issuecomment-1717224921:666,Testability,log,logical,666,"Another option would be to give showing the associated images (i.e. under the 'Image' tab) the same kind of behavior as *View &rarr; Show slide label*. The idea would be that, once you've picked an associated image name by double-clicking, the window remembers the name, e.g. 'macro'. Whenever a new image is opened in QuPath, QuPath will check if the new image also has an associated image called 'macro'. ; * If yes, the new macro image replaces the old one; * If no, the old macro image is removed and the window that contained it becomes black (reporting 'No image' in the title bar). I haven't given it a lot of thought, but I have a feeling that might be more logical - effectively meaning that choosing *View &rarr; Show slide label* and double-clicking on 'label' under the image tab share (more or less...) identical behavior. What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1246#issuecomment-1717224921
https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437:435,Availability,error,error,435,"Thanks @finglis the more I think about this, the more I think we **really** need this. Relatedly, I wonder if we could build on the idea to make auto-estimating the image type smarter?. My first (and entirely untested) idea would be to . * loop through all the known stain vector combinations; * apply the stain vectors to an image; * and calculate the mean absolute value (for example) of the residual; * select the vectors where the error is minimized. This would only be suitable for 2 stains and might not handle artifacts very well, so I imagine it would need some refinement. But perhaps we can incorporate more prior knowledge (e.g. that stains should be negative) while still keeping the method simple and fast to compute. The goal would be to enable a user to have the (probably small) number of stain vectors that are relevant for their images based upon their image sources/scanners, and have QuPath make more intelligent suggestions which to use - rather than relying upon scripting or using *Estimate stain vectors* on every image. But I guess any auto-estimate is likely to be wrong sometimes. So some other related ideas:. * We could incorporate stain selection into the ""Project import"" dialog (alongside where we set the image type) to give another way of ensuring an image batch has consistent stain vectors set.; * We could add a 'Run for project'-like command that specifically exists to transfer the image type and stain vectors from the current image to all images in the project. This can already be scripted easily, but isn't very approachable for people who really don't want to handle scripts. Logging the ideas here for consideration when we come to tackle the original enhancement, and in case any are worth discussing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437
https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437:1697,Modifiability,enhance,enhancement,1697,"Thanks @finglis the more I think about this, the more I think we **really** need this. Relatedly, I wonder if we could build on the idea to make auto-estimating the image type smarter?. My first (and entirely untested) idea would be to . * loop through all the known stain vector combinations; * apply the stain vectors to an image; * and calculate the mean absolute value (for example) of the residual; * select the vectors where the error is minimized. This would only be suitable for 2 stains and might not handle artifacts very well, so I imagine it would need some refinement. But perhaps we can incorporate more prior knowledge (e.g. that stains should be negative) while still keeping the method simple and fast to compute. The goal would be to enable a user to have the (probably small) number of stain vectors that are relevant for their images based upon their image sources/scanners, and have QuPath make more intelligent suggestions which to use - rather than relying upon scripting or using *Estimate stain vectors* on every image. But I guess any auto-estimate is likely to be wrong sometimes. So some other related ideas:. * We could incorporate stain selection into the ""Project import"" dialog (alongside where we set the image type) to give another way of ensuring an image batch has consistent stain vectors set.; * We could add a 'Run for project'-like command that specifically exists to transfer the image type and stain vectors from the current image to all images in the project. This can already be scripted easily, but isn't very approachable for people who really don't want to handle scripts. Logging the ideas here for consideration when we come to tackle the original enhancement, and in case any are worth discussing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437
https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437:1620,Testability,Log,Logging,1620,"Thanks @finglis the more I think about this, the more I think we **really** need this. Relatedly, I wonder if we could build on the idea to make auto-estimating the image type smarter?. My first (and entirely untested) idea would be to . * loop through all the known stain vector combinations; * apply the stain vectors to an image; * and calculate the mean absolute value (for example) of the residual; * select the vectors where the error is minimized. This would only be suitable for 2 stains and might not handle artifacts very well, so I imagine it would need some refinement. But perhaps we can incorporate more prior knowledge (e.g. that stains should be negative) while still keeping the method simple and fast to compute. The goal would be to enable a user to have the (probably small) number of stain vectors that are relevant for their images based upon their image sources/scanners, and have QuPath make more intelligent suggestions which to use - rather than relying upon scripting or using *Estimate stain vectors* on every image. But I guess any auto-estimate is likely to be wrong sometimes. So some other related ideas:. * We could incorporate stain selection into the ""Project import"" dialog (alongside where we set the image type) to give another way of ensuring an image batch has consistent stain vectors set.; * We could add a 'Run for project'-like command that specifically exists to transfer the image type and stain vectors from the current image to all images in the project. This can already be scripted easily, but isn't very approachable for people who really don't want to handle scripts. Logging the ideas here for consideration when we come to tackle the original enhancement, and in case any are worth discussing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437
https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437:703,Usability,simpl,simple,703,"Thanks @finglis the more I think about this, the more I think we **really** need this. Relatedly, I wonder if we could build on the idea to make auto-estimating the image type smarter?. My first (and entirely untested) idea would be to . * loop through all the known stain vector combinations; * apply the stain vectors to an image; * and calculate the mean absolute value (for example) of the residual; * select the vectors where the error is minimized. This would only be suitable for 2 stains and might not handle artifacts very well, so I imagine it would need some refinement. But perhaps we can incorporate more prior knowledge (e.g. that stains should be negative) while still keeping the method simple and fast to compute. The goal would be to enable a user to have the (probably small) number of stain vectors that are relevant for their images based upon their image sources/scanners, and have QuPath make more intelligent suggestions which to use - rather than relying upon scripting or using *Estimate stain vectors* on every image. But I guess any auto-estimate is likely to be wrong sometimes. So some other related ideas:. * We could incorporate stain selection into the ""Project import"" dialog (alongside where we set the image type) to give another way of ensuring an image batch has consistent stain vectors set.; * We could add a 'Run for project'-like command that specifically exists to transfer the image type and stain vectors from the current image to all images in the project. This can already be scripted easily, but isn't very approachable for people who really don't want to handle scripts. Logging the ideas here for consideration when we come to tackle the original enhancement, and in case any are worth discussing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452171437
https://github.com/qupath/qupath/issues/1247#issuecomment-1452421673:662,Performance,perform,performing,662,"Sounds like a great option, as long as it is not the default. Likely to be a somewhat slow process for a lot of images. . It would also be nice to have the stain vectors be (potentially) separated from some of the analysis options like the pixel classifier. Large project often have batch effects of samples from different scanners that require different stain vectors. Right now, I believe that the stain vectors are included in the pixel classifier, so no matter what adjustments are made to any given image, even though the deconvolved pixel values might be the only inputs fed into the pixel classifier, the classifier will use one set of stain vectors when performing the classification. Is that still the case? If different training images are used via ""Load training"", each of which has different color vectors (for the same stain type!), I am guessing it currently ignores those other stain vectors in favor of the ones in effect in the image where the training process started.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452421673
https://github.com/qupath/qupath/issues/1247#issuecomment-1452421673:760,Performance,Load,Load,760,"Sounds like a great option, as long as it is not the default. Likely to be a somewhat slow process for a lot of images. . It would also be nice to have the stain vectors be (potentially) separated from some of the analysis options like the pixel classifier. Large project often have batch effects of samples from different scanners that require different stain vectors. Right now, I believe that the stain vectors are included in the pixel classifier, so no matter what adjustments are made to any given image, even though the deconvolved pixel values might be the only inputs fed into the pixel classifier, the classifier will use one set of stain vectors when performing the classification. Is that still the case? If different training images are used via ""Load training"", each of which has different color vectors (for the same stain type!), I am guessing it currently ignores those other stain vectors in favor of the ones in effect in the image where the training process started.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1247#issuecomment-1452421673
https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136:325,Availability,error,error-building-qupath-with-tensorflow-first-number-in-a-cfbundleversion-cannot-be-zero-or-negative,325,"Yes, at the time the build scripts were written it seemed to be impossible to have a version number starting with 0.x on macOS - at least when building using `jpackage`. Attempting to do this would result in a ""first number in a CFBundleVersion cannot be zero or negative"" exception, as described at https://forum.image.sc/t/error-building-qupath-with-tensorflow-first-number-in-a-cfbundleversion-cannot-be-zero-or-negative/48713. The build script explicitly sets the wrong version number in an attempt to get builds working at all, see https://github.com/qupath/qupath/blob/v0.4.3/qupath-app/build.gradle#L40. I'll check if the situation has changed with more recent `jpackage` releases. If not, I'm afraid we're probably stuck with it until there's eventually a QuPath 1.x release, unless someone can come up with a solution that doesn't overly complicate the build/release process.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136
https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136:679,Deployability,release,releases,679,"Yes, at the time the build scripts were written it seemed to be impossible to have a version number starting with 0.x on macOS - at least when building using `jpackage`. Attempting to do this would result in a ""first number in a CFBundleVersion cannot be zero or negative"" exception, as described at https://forum.image.sc/t/error-building-qupath-with-tensorflow-first-number-in-a-cfbundleversion-cannot-be-zero-or-negative/48713. The build script explicitly sets the wrong version number in an attempt to get builds working at all, see https://github.com/qupath/qupath/blob/v0.4.3/qupath-app/build.gradle#L40. I'll check if the situation has changed with more recent `jpackage` releases. If not, I'm afraid we're probably stuck with it until there's eventually a QuPath 1.x release, unless someone can come up with a solution that doesn't overly complicate the build/release process.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136
https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136:775,Deployability,release,release,775,"Yes, at the time the build scripts were written it seemed to be impossible to have a version number starting with 0.x on macOS - at least when building using `jpackage`. Attempting to do this would result in a ""first number in a CFBundleVersion cannot be zero or negative"" exception, as described at https://forum.image.sc/t/error-building-qupath-with-tensorflow-first-number-in-a-cfbundleversion-cannot-be-zero-or-negative/48713. The build script explicitly sets the wrong version number in an attempt to get builds working at all, see https://github.com/qupath/qupath/blob/v0.4.3/qupath-app/build.gradle#L40. I'll check if the situation has changed with more recent `jpackage` releases. If not, I'm afraid we're probably stuck with it until there's eventually a QuPath 1.x release, unless someone can come up with a solution that doesn't overly complicate the build/release process.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136
https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136:868,Deployability,release,release,868,"Yes, at the time the build scripts were written it seemed to be impossible to have a version number starting with 0.x on macOS - at least when building using `jpackage`. Attempting to do this would result in a ""first number in a CFBundleVersion cannot be zero or negative"" exception, as described at https://forum.image.sc/t/error-building-qupath-with-tensorflow-first-number-in-a-cfbundleversion-cannot-be-zero-or-negative/48713. The build script explicitly sets the wrong version number in an attempt to get builds working at all, see https://github.com/qupath/qupath/blob/v0.4.3/qupath-app/build.gradle#L40. I'll check if the situation has changed with more recent `jpackage` releases. If not, I'm afraid we're probably stuck with it until there's eventually a QuPath 1.x release, unless someone can come up with a solution that doesn't overly complicate the build/release process.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1455033136
https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628:365,Deployability,configurat,configuration,365,"Yes - as a Mac user, it's annoys me too :). Sadly, it looks like the version number is still enforced by `jpackage`. The relevant part is at:. * https://github.com/openjdk/jdk/blob/master/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/CFBundleVersion.java. Attempting to build results in the message:. ```; Bundler Mac Application Image skipped because of a configuration problem: The first number in an app-version cannot be zero or negative. ; Advice to fix: Set a compatible 'app-version' value. Valid versions are one to three integers separated by dots.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628
https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628:299,Integrability,message,message,299,"Yes - as a Mac user, it's annoys me too :). Sadly, it looks like the version number is still enforced by `jpackage`. The relevant part is at:. * https://github.com/openjdk/jdk/blob/master/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/CFBundleVersion.java. Attempting to build results in the message:. ```; Bundler Mac Application Image skipped because of a configuration problem: The first number in an app-version cannot be zero or negative. ; Advice to fix: Set a compatible 'app-version' value. Valid versions are one to three integers separated by dots.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628
https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628:365,Modifiability,config,configuration,365,"Yes - as a Mac user, it's annoys me too :). Sadly, it looks like the version number is still enforced by `jpackage`. The relevant part is at:. * https://github.com/openjdk/jdk/blob/master/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/CFBundleVersion.java. Attempting to build results in the message:. ```; Bundler Mac Application Image skipped because of a configuration problem: The first number in an app-version cannot be zero or negative. ; Advice to fix: Set a compatible 'app-version' value. Valid versions are one to three integers separated by dots.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1467726628
https://github.com/qupath/qupath/issues/1250#issuecomment-1732323504:243,Deployability,release,release,243,"Thanks @core-code I've attempted a fix at https://github.com/qupath/qupath/pull/1344 by splitting the build into two parts and using `PlistBuddy` in between. It seems to be working on my computer, so hopefully this will be working in the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1732323504
https://github.com/qupath/qupath/issues/1250#issuecomment-1750315940:137,Deployability,release,release,137,"Alas, in the end I had to revert these changes as they ended up causing much bigger problems, which only emerged when preparing the next release candidate. More details at https://github.com/qupath/qupath/pull/1379",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1750315940
https://github.com/qupath/qupath/issues/1250#issuecomment-1750320624:129,Testability,test,test,129,"ouch :(. changes to the Info.plist must done before code-signature, not after. is there a build with the version numbers i could test to look into this?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1750320624
https://github.com/qupath/qupath/issues/1250#issuecomment-1750335267:65,Availability,avail,available,65,"We don't have a code signature step... release candidate must be available within the next couple of hours, ahead of a workshop next week, so won't have time to make any more changes ahead of that. The easiest way to explore would be to build for source with gradle: https://qupath.readthedocs.io/en/0.4/docs/reference/building.html. The PR should point towards the parts that needed to be reverted to get things working.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1750335267
https://github.com/qupath/qupath/issues/1250#issuecomment-1750335267:39,Deployability,release,release,39,"We don't have a code signature step... release candidate must be available within the next couple of hours, ahead of a workshop next week, so won't have time to make any more changes ahead of that. The easiest way to explore would be to build for source with gradle: https://qupath.readthedocs.io/en/0.4/docs/reference/building.html. The PR should point towards the parts that needed to be reverted to get things working.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1250#issuecomment-1750335267
https://github.com/qupath/qupath/issues/1252#issuecomment-1468000707:521,Integrability,wrap,wrapped,521,"Upon closer inspection, the solution to this is partly in the code but also partly broken. Specifically around [line 698](https://github.com/qupath/qupath/blob/main/qupath-core/src/main/java/qupath/lib/projects/DefaultProject.java#L698) an `IOException` is expected, but this isn't always what is thrown - @yau-lim's post [here](https://forum.image.sc/t/hierarchy-is-null-cannot-invoke-can-anyone-help/78488/10) shows that a NPE can be thrown instead. So if we make sure that any NPE that occurs when reading is properly wrapped in an `IOException`, then QuPath should automatically switch to use the backup file and log a warning.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1252#issuecomment-1468000707
https://github.com/qupath/qupath/issues/1252#issuecomment-1468000707:617,Testability,log,log,617,"Upon closer inspection, the solution to this is partly in the code but also partly broken. Specifically around [line 698](https://github.com/qupath/qupath/blob/main/qupath-core/src/main/java/qupath/lib/projects/DefaultProject.java#L698) an `IOException` is expected, but this isn't always what is thrown - @yau-lim's post [here](https://forum.image.sc/t/hierarchy-is-null-cannot-invoke-can-anyone-help/78488/10) shows that a NPE can be thrown instead. So if we make sure that any NPE that occurs when reading is properly wrapped in an `IOException`, then QuPath should automatically switch to use the backup file and log a warning.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1252#issuecomment-1468000707
https://github.com/qupath/qupath/issues/1253#issuecomment-1477179288:297,Usability,clear,clear,297,"Hi @viviiviiii, it would help if you could provide more information. Assuming this is a Ventana scanner, the file type could be .bif, .tif, or DICOM. Including the information in, or a screenshot of, the Image tab would help. It sounds like you are only opening the thumbnail image, but it is not clear why.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1253#issuecomment-1477179288
https://github.com/qupath/qupath/issues/1254#issuecomment-1481434738:102,Energy Efficiency,Power,PowerPoint,102,"Hi, I can't replicate the problem on my Mac - at least, the exported image displays fine (in Preview, PowerPoint, PixelMator...). Also, the thumbnail generated with `vipsthumbnail` looks ok to me. Is there any chance you can check if it's Ubuntu-specific?. Also, can you try converting with Bio-Formats alone? The easiest way is likely with `bfconvert`: https://bio-formats.readthedocs.io/en/stable/users/comlinetools/conversion.html. It would be good to confirm if this is a bug that can be addressed in QuPath, or it requires any change in Bio-Formats. For example, this might be relevant:; * https://github.com/ome/bioformats/issues/3856",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1254#issuecomment-1481434738
https://github.com/qupath/qupath/issues/1254#issuecomment-1481590484:275,Safety,detect,detect,275,Unfortunately I only have a linux system... Does the ome.tif from the attached tar.gz in https://github.com/libvips/libvips/issues/3397 look fine in those viewers (exported with QuPath)? . Perhaps the image is exported differently on linux or maybe those viewers are able to detect and correct it.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1254#issuecomment-1481590484
https://github.com/qupath/qupath/issues/1259#issuecomment-1498662837:797,Security,access,accessed,797,"Very good point, I hadn't ever really considered those two things together. In my mind, 'Import objects' was always associated with trying to read objects that are somehow associated with the source image (e.g. ROIs stored as an overlay for ImageJ TIFF, objects from an OMERO image). The ability to add images from another project, on the other hand, was developed separately and intended to always import all the data from that project. This means the entire image data, including stain vectors etc. The object hierarchy comes along with that. I imagined that, if anyone wanted to add the images without objects, they would just add the images in the 'normal way' and not via a project. But I suppose that assumes that projects don't contain very many images scattered across different disks, or accessed via OMERO or elsewhere. In any case, I agree that the current behavior is confusing in the case you describe, and should probably be changed. But I'm not sure if it should be a change of behavior, or a change of documentation + the addition of a new command?. Some ideas:. 1. Don't import *any specific `ImageData`* from a project when the ""Import objects"" checkbox is unselected. This would exclude objects *and everything else*. Potentially also including custom metadata, channel names, stain vectors etc.; * In this case, it would probably be best to rename the checkbox and document this behavior; 2. Keep the behavior as it is, but document it better. A user can always run a one-line script to delete all the objects later.; * I can imagine there might be use cases where someone wants to create a new project with the same images, but no associated data. Exporting the image list and reimporting it should support those cases.; * There is a related issue to this; * https://github.com/qupath/qupath/issues/1177; 4. Add an entirely separate command to import images from another project and/or prompt the users when importing from a project. This would give more control over what exactly",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1259#issuecomment-1498662837
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:293,Availability,recover,recover,293,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:879,Deployability,release,release,879,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:1007,Deployability,release,releases,1007,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:1195,Deployability,release,released,1195,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:58,Integrability,wrap,wrapper,58,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:1286,Integrability,wrap,wrapper,1286,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:293,Safety,recover,recover,293,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346:1294,Safety,avoid,avoids,1294,"Hi @hubutui could you try building with `gradlew` (Gradle wrapper) instead? That's the 'proper' way to build QuPath - see https://qupath.readthedocs.io/en/stable/docs/reference/building.html. The part you link to in `build.gradle` isn't actually trying to specify the toolchain, but rather to recover the Java version for the toolchain that is already being used. When it comes to *specifying* the toolchain, it looks like the example you give is just copied from the code I wrote here :); https://github.com/qupath/qupath/blob/main/buildSrc/src/main/groovy/qupath.java-conventions.gradle#L11. That's what QuPath already uses, so you can already pass it a `-Ptoolchain=20` if you like. **However** I think the problem is that QuPath's build is locked to Gradle 7.5.1 because of ; * https://github.com/bytedeco/gradle-javacpp/issues/28. There hasn't been another `gradle-javacpp` release yet, and I don't want to switch to a snapshot - so I'm waiting for that before updating our build scripts. Since Gradle releases break stuff pretty often, I suspect other changes will be needed. Also, older Gradles can't build using toolchains for newer Javas and Java 20 wasn't around when Gradle 7.5.1 was released - so you're probably stuck building QuPath v0.4.x on Java 17-19. But using Gradle wrapper avoids most of those problems, as long as you use a compatible toolchain version.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1262#issuecomment-1524666346
https://github.com/qupath/qupath/issues/1264#issuecomment-1532779834:560,Availability,error,errors,560,"Adding link back to original discussion: https://forum.image.sc/t/potential-bug-with-load-pixel-classifier-show-as-text-qupath-v0-4-3/80470. Haven't figured out exactly what aspect of the script is troublesome, so haven't come up with a proper minimal non-working example yet :/. Even without that, we can assume that a proper solution involved removing use of regex from the [styler classes](https://github.com/qupath/qupath/tree/v0.4.3/qupath-extension-script-editor/src/main/java/qupath/lib/gui/scripting/richtextfx/stylers)... or at least handling styling errors more quietly, without having an exception pop up.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264#issuecomment-1532779834
https://github.com/qupath/qupath/issues/1264#issuecomment-1532779834:85,Performance,load,load-pixel-classifier-show-as-text-qupath-,85,"Adding link back to original discussion: https://forum.image.sc/t/potential-bug-with-load-pixel-classifier-show-as-text-qupath-v0-4-3/80470. Haven't figured out exactly what aspect of the script is troublesome, so haven't come up with a proper minimal non-working example yet :/. Even without that, we can assume that a proper solution involved removing use of regex from the [styler classes](https://github.com/qupath/qupath/tree/v0.4.3/qupath-extension-script-editor/src/main/java/qupath/lib/gui/scripting/richtextfx/stylers)... or at least handling styling errors more quietly, without having an exception pop up.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1264#issuecomment-1532779834
https://github.com/qupath/qupath/pull/1270#issuecomment-1600861461:59,Safety,avoid,avoid,59,"The ""Pixel value"" label has since been removed as well, to avoid wasting more vertical space.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1270#issuecomment-1600861461
https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737:121,Modifiability,layers,layers,121,"Thanks, I've merged some changes into the `dev` branch for v0.5.0. Basically, SVG export will now add the active overlay layers. It does this using either a vector representation (e.g. for objects or gridlines) or separate images with opacity set according to the overlay display. This means that individual layers should remain editable later. Example SVG below. ![Cells as SVG](https://github.com/qupath/qupath/assets/4690904/518b341c-1c2a-4d95-a70a-115809fe1167). The big limitation is that scalebars etc. aren't included, because these aren't rendered as overlay layers in QuPath - they are separate JavaFX controls sitting on top of the main viewer, which can't easily be converted to SVG using our current approach. We're giving some thought to adding a figure-creating UI in the future that would support scalebars etc. with more customizations, but that doesn't currently exist. PS. @biovoxxel video looks great! QuPath already supported base64 embedding, but now it's the default option (linked & no base image are also supported).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737
https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737:308,Modifiability,layers,layers,308,"Thanks, I've merged some changes into the `dev` branch for v0.5.0. Basically, SVG export will now add the active overlay layers. It does this using either a vector representation (e.g. for objects or gridlines) or separate images with opacity set according to the overlay display. This means that individual layers should remain editable later. Example SVG below. ![Cells as SVG](https://github.com/qupath/qupath/assets/4690904/518b341c-1c2a-4d95-a70a-115809fe1167). The big limitation is that scalebars etc. aren't included, because these aren't rendered as overlay layers in QuPath - they are separate JavaFX controls sitting on top of the main viewer, which can't easily be converted to SVG using our current approach. We're giving some thought to adding a figure-creating UI in the future that would support scalebars etc. with more customizations, but that doesn't currently exist. PS. @biovoxxel video looks great! QuPath already supported base64 embedding, but now it's the default option (linked & no base image are also supported).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737
https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737:567,Modifiability,layers,layers,567,"Thanks, I've merged some changes into the `dev` branch for v0.5.0. Basically, SVG export will now add the active overlay layers. It does this using either a vector representation (e.g. for objects or gridlines) or separate images with opacity set according to the overlay display. This means that individual layers should remain editable later. Example SVG below. ![Cells as SVG](https://github.com/qupath/qupath/assets/4690904/518b341c-1c2a-4d95-a70a-115809fe1167). The big limitation is that scalebars etc. aren't included, because these aren't rendered as overlay layers in QuPath - they are separate JavaFX controls sitting on top of the main viewer, which can't easily be converted to SVG using our current approach. We're giving some thought to adding a figure-creating UI in the future that would support scalebars etc. with more customizations, but that doesn't currently exist. PS. @biovoxxel video looks great! QuPath already supported base64 embedding, but now it's the default option (linked & no base image are also supported).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604048737
https://github.com/qupath/qupath/issues/1272#issuecomment-1604129108:159,Energy Efficiency,adapt,adapts,159,"It could be done, but it would be fiddly to try to get the location of the bar and font size to exactly match what is displayed in QuPath's viewer (since this adapts dynamically based upon the zoom level and background color). And if it doesn't match what's in the viewer anyway, then I think a proper UI component that allows the user to specify the location, size, color etc. of the scalebar would be more useful. The overview image (top right) and pixel coordinate & value control (bottom right) have the same issues - a proper viewer 'snapshot' should really include all of them, if they are present, so the task starts to grow bigger. I'll think about it some more, but I currently think the only workarounds would involve duplicating code from existing JavaFX components and rewriting them in a Java2D-friendly way just for SVG export, which sounds be a bit painful to maintain. Since QuPath's minimally-customizable, auto-adjusting scalebar isn't exactly what everyone wants for creating figures anyway, I like the idea of designing something more specific for the task.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604129108
https://github.com/qupath/qupath/issues/1272#issuecomment-1604129108:159,Modifiability,adapt,adapts,159,"It could be done, but it would be fiddly to try to get the location of the bar and font size to exactly match what is displayed in QuPath's viewer (since this adapts dynamically based upon the zoom level and background color). And if it doesn't match what's in the viewer anyway, then I think a proper UI component that allows the user to specify the location, size, color etc. of the scalebar would be more useful. The overview image (top right) and pixel coordinate & value control (bottom right) have the same issues - a proper viewer 'snapshot' should really include all of them, if they are present, so the task starts to grow bigger. I'll think about it some more, but I currently think the only workarounds would involve duplicating code from existing JavaFX components and rewriting them in a Java2D-friendly way just for SVG export, which sounds be a bit painful to maintain. Since QuPath's minimally-customizable, auto-adjusting scalebar isn't exactly what everyone wants for creating figures anyway, I like the idea of designing something more specific for the task.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604129108
https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841:745,Availability,down,downsample,745,"> but it would be fiddly to try to get the location of the bar and font size to exactly match what is displayed in QuPath's viewer. I don't think this is strictly necessary because in the viewer, the scalebar tries to be unobtrusive, but as part of a figure, I think it would look too small (or that was the case for the figure I was trying to make). So yes, which corner, which physical length / thickness, length displayed (above/below) should ideally all be user defined (IMHO). Maybe an ""export preview"" window would help?. And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure). The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Anyway anyway, I'll compile a v0.5 and check out the new additions. Thank you very much for taking the time to implement this @petebankhead !",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841
https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841:813,Availability,down,downsample,813,"> but it would be fiddly to try to get the location of the bar and font size to exactly match what is displayed in QuPath's viewer. I don't think this is strictly necessary because in the viewer, the scalebar tries to be unobtrusive, but as part of a figure, I think it would look too small (or that was the case for the figure I was trying to make). So yes, which corner, which physical length / thickness, length displayed (above/below) should ideally all be user defined (IMHO). Maybe an ""export preview"" window would help?. And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure). The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Anyway anyway, I'll compile a v0.5 and check out the new additions. Thank you very much for taking the time to implement this @petebankhead !",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841
https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841:920,Availability,down,downsample,920,"> but it would be fiddly to try to get the location of the bar and font size to exactly match what is displayed in QuPath's viewer. I don't think this is strictly necessary because in the viewer, the scalebar tries to be unobtrusive, but as part of a figure, I think it would look too small (or that was the case for the figure I was trying to make). So yes, which corner, which physical length / thickness, length displayed (above/below) should ideally all be user defined (IMHO). Maybe an ""export preview"" window would help?. And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure). The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Anyway anyway, I'll compile a v0.5 and check out the new additions. Thank you very much for taking the time to implement this @petebankhead !",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604160841
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:219,Availability,down,downsample,219,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:287,Availability,down,downsample,287,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:401,Availability,down,downsample,401,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:716,Availability,down,down,716,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:523,Energy Efficiency,adapt,adapting,523,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:631,Energy Efficiency,adapt,adapt,631,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:523,Modifiability,adapt,adapting,523,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:631,Modifiability,adapt,adapt,631,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185:505,Safety,avoid,avoid,505,"> And as in @biovoxxel's video (thanks for the resource!), our users sometimes struggle with the ""DPI/PPI"" calculations. If this was a set parameter in preferences (e.g. 300PPI by default), then you could write next to downsample what would be the maximum figure size for that PPI (e.g. downsample 2, 300PPI -> up to 1200cm x 800cm figure).; > ; > The user would then be able to choose an appropriate downsample for their figure that's say, up to 20cm wide at the requested PPI. Side note:; I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. Boils down to: Less need for thinking and calculating with a better result image!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604299185
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:409,Availability,down,downsampling,409,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:1119,Availability,down,downsample,1119,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:51,Energy Efficiency,adapt,adapting,51,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:794,Energy Efficiency,adapt,adapt,794,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:51,Modifiability,adapt,adapting,51,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:794,Modifiability,adapt,adapt,794,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:33,Safety,avoid,avoid,33,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:509,Usability,clear,clear,509,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:570,Usability,guid,guidelines,570,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665:722,Usability,guid,guidelines,722,"Hey @biovoxxel . > I would fully avoid scaling and adapting to DPI, since this is not very helpful regarding the figure quality. Problem is, the original images in QuPath are whole slide images, and rather large. [OS-2.ndpi for example](https://cytomine.com/collection/os-2/os-2-ndpi) is 126976 pixels wide. So first thing QuPath asks when doing an SVG export (with the image + overlay as background) is what downsampling factor should be applied to the original image. It's a necessary step, but what is not clear, is which factor would actually match some publication guidelines (for example, 300PPI + width of 170 mm for full page width figure [as defined here](https://cancerandmetabolism.biomedcentral.com/submission-guidelines/preparing-your-manuscript)). > Once you have the SVG you can adapt it to the document size without the need of changing any resolution etc. I agree with you, but the background bitmap embedded in the SVG document only needs to be as big as the physical size it will be printed at. Some reviews also impose a maximum file size for the SVG documents (e.g. < 20MB), so we can't just use a downsample of 1 or 2 and hope for the best. Then yes, anything vectoriel on top of the background image (lines, polygons, text...) just needs to be readable at the printed size and could easily be modified in Inkscape if not (fond size, linewidths...). Maybe I'm missing something (wouldn't be the first time), so let me know how you see this work. Cheers,; Egor",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604775665
https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590:77,Availability,down,down,77,"Hey @zindy ,. Ok, I see. For such big images, I would agree that you have to down sample. I would try to stick to a factor divisible by two.; If you want to stick to the 300 PPI to theoretically have a pixel per printed dot (which is plain theory because dependent on printing device and final printing size) you could calculate it as follows (please check it again not that I made a mistake):. 17cm = 17cm / 2.54 cm/inch ~6.7 inches; At 300 PPI you would need an image width of 300 * 6.7 = 2,010 pixels minimally. Principally, you could divide your real original image width by this ~2010 pixels and you have the approximate down sampling factor. I would then use the closest factor, smaller than that and divisible by two to give it slightly more PPI.; So, if you have an original image width of 120,000 pixel, that would be an approximate factor of 120,000 / 2,000 = 60.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590
https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590:626,Availability,down,down,626,"Hey @zindy ,. Ok, I see. For such big images, I would agree that you have to down sample. I would try to stick to a factor divisible by two.; If you want to stick to the 300 PPI to theoretically have a pixel per printed dot (which is plain theory because dependent on printing device and final printing size) you could calculate it as follows (please check it again not that I made a mistake):. 17cm = 17cm / 2.54 cm/inch ~6.7 inches; At 300 PPI you would need an image width of 300 * 6.7 = 2,010 pixels minimally. Principally, you could divide your real original image width by this ~2010 pixels and you have the approximate down sampling factor. I would then use the closest factor, smaller than that and divisible by two to give it slightly more PPI.; So, if you have an original image width of 120,000 pixel, that would be an approximate factor of 120,000 / 2,000 = 60.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590
https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590:255,Integrability,depend,dependent,255,"Hey @zindy ,. Ok, I see. For such big images, I would agree that you have to down sample. I would try to stick to a factor divisible by two.; If you want to stick to the 300 PPI to theoretically have a pixel per printed dot (which is plain theory because dependent on printing device and final printing size) you could calculate it as follows (please check it again not that I made a mistake):. 17cm = 17cm / 2.54 cm/inch ~6.7 inches; At 300 PPI you would need an image width of 300 * 6.7 = 2,010 pixels minimally. Principally, you could divide your real original image width by this ~2010 pixels and you have the approximate down sampling factor. I would then use the closest factor, smaller than that and divisible by two to give it slightly more PPI.; So, if you have an original image width of 120,000 pixel, that would be an approximate factor of 120,000 / 2,000 = 60.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1604913590
https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774:945,Availability,down,downsample,945,"is there a solution for batch processing with qupath script?; below code partly work and export the original picture with detected cells overlay but it does not export the created density map overlay (which is showing in the content view). import qupath.imagej.tools.IJTools; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.regions.RegionRequest; import qupath.lib.analysis.heatmaps.ColorModels; import qupath.lib.analysis.heatmaps.ColorModels.DisplayBand; import qupath.lib.analysis.heatmaps.DensityMaps; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapBuilder; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapParameters ; import qupath.lib.analysis.heatmaps.DensityMaps;; import qupath.lib.objects.classes.PathClass;; import qupath.lib.analysis.heatmaps.ColorModels.ColorModelBuilder; import static qupath.lib.gui.scripting.QPEx.*. double downsample = 1; String path = buildFilePath(PROJECT_BASE_DIR, 'rendered', getProjectEntry().getImageName() +'-smc'+ '.png'); def viewer = getCurrentViewer(); def imageData = getCurrentImageData(); def options = viewer.getOverlayOptions(). def display = new qupath.lib.display.ImageDisplay(imageData); def params = new DensityMaps.DensityMapParameters(); def map = new DensityMaps.DensityMapBuilder(params); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(); .build(); ; // Write or display the rendered image; if (path != null) {; mkdirs(new File(path).getParent()); writeImage(server, path); } else; IJTools.convertToImagePlus(server, RegionRequest.createInstance(server)).getImage().show()",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774
https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774:1429,Availability,down,downsamples,1429,"is there a solution for batch processing with qupath script?; below code partly work and export the original picture with detected cells overlay but it does not export the created density map overlay (which is showing in the content view). import qupath.imagej.tools.IJTools; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.regions.RegionRequest; import qupath.lib.analysis.heatmaps.ColorModels; import qupath.lib.analysis.heatmaps.ColorModels.DisplayBand; import qupath.lib.analysis.heatmaps.DensityMaps; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapBuilder; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapParameters ; import qupath.lib.analysis.heatmaps.DensityMaps;; import qupath.lib.objects.classes.PathClass;; import qupath.lib.analysis.heatmaps.ColorModels.ColorModelBuilder; import static qupath.lib.gui.scripting.QPEx.*. double downsample = 1; String path = buildFilePath(PROJECT_BASE_DIR, 'rendered', getProjectEntry().getImageName() +'-smc'+ '.png'); def viewer = getCurrentViewer(); def imageData = getCurrentImageData(); def options = viewer.getOverlayOptions(). def display = new qupath.lib.display.ImageDisplay(imageData); def params = new DensityMaps.DensityMapParameters(); def map = new DensityMaps.DensityMapBuilder(params); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(); .build(); ; // Write or display the rendered image; if (path != null) {; mkdirs(new File(path).getParent()); writeImage(server, path); } else; IJTools.convertToImagePlus(server, RegionRequest.createInstance(server)).getImage().show()",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774
https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774:1441,Availability,down,downsample,1441,"is there a solution for batch processing with qupath script?; below code partly work and export the original picture with detected cells overlay but it does not export the created density map overlay (which is showing in the content view). import qupath.imagej.tools.IJTools; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.regions.RegionRequest; import qupath.lib.analysis.heatmaps.ColorModels; import qupath.lib.analysis.heatmaps.ColorModels.DisplayBand; import qupath.lib.analysis.heatmaps.DensityMaps; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapBuilder; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapParameters ; import qupath.lib.analysis.heatmaps.DensityMaps;; import qupath.lib.objects.classes.PathClass;; import qupath.lib.analysis.heatmaps.ColorModels.ColorModelBuilder; import static qupath.lib.gui.scripting.QPEx.*. double downsample = 1; String path = buildFilePath(PROJECT_BASE_DIR, 'rendered', getProjectEntry().getImageName() +'-smc'+ '.png'); def viewer = getCurrentViewer(); def imageData = getCurrentImageData(); def options = viewer.getOverlayOptions(). def display = new qupath.lib.display.ImageDisplay(imageData); def params = new DensityMaps.DensityMapParameters(); def map = new DensityMaps.DensityMapBuilder(params); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(); .build(); ; // Write or display the rendered image; if (path != null) {; mkdirs(new File(path).getParent()); writeImage(server, path); } else; IJTools.convertToImagePlus(server, RegionRequest.createInstance(server)).getImage().show()",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774
https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774:1455,Modifiability,layers,layers,1455,"is there a solution for batch processing with qupath script?; below code partly work and export the original picture with detected cells overlay but it does not export the created density map overlay (which is showing in the content view). import qupath.imagej.tools.IJTools; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.regions.RegionRequest; import qupath.lib.analysis.heatmaps.ColorModels; import qupath.lib.analysis.heatmaps.ColorModels.DisplayBand; import qupath.lib.analysis.heatmaps.DensityMaps; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapBuilder; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapParameters ; import qupath.lib.analysis.heatmaps.DensityMaps;; import qupath.lib.objects.classes.PathClass;; import qupath.lib.analysis.heatmaps.ColorModels.ColorModelBuilder; import static qupath.lib.gui.scripting.QPEx.*. double downsample = 1; String path = buildFilePath(PROJECT_BASE_DIR, 'rendered', getProjectEntry().getImageName() +'-smc'+ '.png'); def viewer = getCurrentViewer(); def imageData = getCurrentImageData(); def options = viewer.getOverlayOptions(). def display = new qupath.lib.display.ImageDisplay(imageData); def params = new DensityMaps.DensityMapParameters(); def map = new DensityMaps.DensityMapBuilder(params); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(); .build(); ; // Write or display the rendered image; if (path != null) {; mkdirs(new File(path).getParent()); writeImage(server, path); } else; IJTools.convertToImagePlus(server, RegionRequest.createInstance(server)).getImage().show()",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774
https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774:122,Safety,detect,detected,122,"is there a solution for batch processing with qupath script?; below code partly work and export the original picture with detected cells overlay but it does not export the created density map overlay (which is showing in the content view). import qupath.imagej.tools.IJTools; import qupath.lib.gui.images.servers.RenderedImageServer; import qupath.lib.gui.viewer.overlays.HierarchyOverlay; import qupath.lib.regions.RegionRequest; import qupath.lib.analysis.heatmaps.ColorModels; import qupath.lib.analysis.heatmaps.ColorModels.DisplayBand; import qupath.lib.analysis.heatmaps.DensityMaps; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapBuilder; import qupath.lib.analysis.heatmaps.DensityMaps.DensityMapParameters ; import qupath.lib.analysis.heatmaps.DensityMaps;; import qupath.lib.objects.classes.PathClass;; import qupath.lib.analysis.heatmaps.ColorModels.ColorModelBuilder; import static qupath.lib.gui.scripting.QPEx.*. double downsample = 1; String path = buildFilePath(PROJECT_BASE_DIR, 'rendered', getProjectEntry().getImageName() +'-smc'+ '.png'); def viewer = getCurrentViewer(); def imageData = getCurrentImageData(); def options = viewer.getOverlayOptions(). def display = new qupath.lib.display.ImageDisplay(imageData); def params = new DensityMaps.DensityMapParameters(); def map = new DensityMaps.DensityMapBuilder(params); def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .layers(); .build(); ; // Write or display the rendered image; if (path != null) {; mkdirs(new File(path).getParent()); writeImage(server, path); } else; IJTools.convertToImagePlus(server, RegionRequest.createInstance(server)).getImage().show()",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1636869774
https://github.com/qupath/qupath/issues/1272#issuecomment-1637444330:297,Safety,avoid,avoid,297,"@aliys97 I've hidden this comment as it is really a question about using QuPath and the forum is a better place to discuss that. Also, it looks like you have already posted about it [on the forum here](https://forum.image.sc/t/batch-processing-create-and-save-density-map/82135/7) and I'd like to avoid having two parallel discussions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1637444330
https://github.com/qupath/qupath/issues/1272#issuecomment-1732340239:134,Availability,avail,available,134,"I'll close this issue as part of my Saturday repo-cleaning, since support for overlays in SVG exports has now been merged and will be available in the next release (v0.5.0).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1732340239
https://github.com/qupath/qupath/issues/1272#issuecomment-1732340239:156,Deployability,release,release,156,"I'll close this issue as part of my Saturday repo-cleaning, since support for overlays in SVG exports has now been merged and will be available in the next release (v0.5.0).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1272#issuecomment-1732340239
https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476:870,Integrability,depend,dependent,870,"I think this is an issue of naming/documentation, not behavior. If the caller knows that their string can be converted to a `File`, then it's very easy for them to just call `new File(String)` first and use `getNameWithoutExtension(File)`. But the current behavior is consistent and useful for cases where this isn't the desired result. Although the naming isn't great, `getNameWithoutExtension(String)` does not specify the name to be a *file*name. Although it's natural for the user to think it would be, I don't think the method should silently assume that. Also, QuPath can work with images where the URL doesn't relate to a file system file, or this method could be called with a String that contains characters that are invalid for a filename. I don't *think* `new File(String)` throws an exception in that case, but I'm not certain and behavior might be platform-dependent. For these reasons I would prefer to either; * Rename the method to `stripExtension(String)` (but deprecate the original for removal in the future); * Keep the original but improve the javadoc. (There is also a major refactoring currently under way, so I'm reluctant to merge other PRs in the short term to avoid conflicts.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476
https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476:1097,Modifiability,refactor,refactoring,1097,"I think this is an issue of naming/documentation, not behavior. If the caller knows that their string can be converted to a `File`, then it's very easy for them to just call `new File(String)` first and use `getNameWithoutExtension(File)`. But the current behavior is consistent and useful for cases where this isn't the desired result. Although the naming isn't great, `getNameWithoutExtension(String)` does not specify the name to be a *file*name. Although it's natural for the user to think it would be, I don't think the method should silently assume that. Also, QuPath can work with images where the URL doesn't relate to a file system file, or this method could be called with a String that contains characters that are invalid for a filename. I don't *think* `new File(String)` throws an exception in that case, but I'm not certain and behavior might be platform-dependent. For these reasons I would prefer to either; * Rename the method to `stripExtension(String)` (but deprecate the original for removal in the future); * Keep the original but improve the javadoc. (There is also a major refactoring currently under way, so I'm reluctant to merge other PRs in the short term to avoid conflicts.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476
https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476:1187,Safety,avoid,avoid,1187,"I think this is an issue of naming/documentation, not behavior. If the caller knows that their string can be converted to a `File`, then it's very easy for them to just call `new File(String)` first and use `getNameWithoutExtension(File)`. But the current behavior is consistent and useful for cases where this isn't the desired result. Although the naming isn't great, `getNameWithoutExtension(String)` does not specify the name to be a *file*name. Although it's natural for the user to think it would be, I don't think the method should silently assume that. Also, QuPath can work with images where the URL doesn't relate to a file system file, or this method could be called with a String that contains characters that are invalid for a filename. I don't *think* `new File(String)` throws an exception in that case, but I'm not certain and behavior might be platform-dependent. For these reasons I would prefer to either; * Rename the method to `stripExtension(String)` (but deprecate the original for removal in the future); * Keep the original but improve the javadoc. (There is also a major refactoring currently under way, so I'm reluctant to merge other PRs in the short term to avoid conflicts.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1275#issuecomment-1621077476
https://github.com/qupath/qupath/issues/1277#issuecomment-1621807693:59,Integrability,interface,interface,59,"How exactly are you making the annotations - from the user interface or in a script?. I'm a bit concerned about adding more complexity into QuPath for this, since that might in turn leads to yet more complexity (e.g. a requirement to create tiles from top to bottom....) and we're really trying to simplify. Therefore I'm not sure if changing the `makeTiles` method is the right approach to achieving the end goal.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621807693
https://github.com/qupath/qupath/issues/1277#issuecomment-1621807693:298,Usability,simpl,simplify,298,"How exactly are you making the annotations - from the user interface or in a script?. I'm a bit concerned about adding more complexity into QuPath for this, since that might in turn leads to yet more complexity (e.g. a requirement to create tiles from top to bottom....) and we're really trying to simplify. Therefore I'm not sure if changing the `makeTiles` method is the right approach to achieving the end goal.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621807693
https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178:1861,Deployability,update,update,1861,"ROI; import qupath.lib.roi.RoiTools. // Adjust THIS (n : Number of Tiles); int n = 10; def trimToROI = true; //parentClass = ""IL-left""; childClass = ""Tiles"". // Get the QuPath viewer and check if an object is currently selected; QuPathViewer viewer = QuPathGUI.getInstance().getViewer(); def objSelected = viewer.getSelectedObject(); parentClass = objSelected.getPathClass(). // Calculate the width and height of the ROI; if (objSelected != null && objSelected instanceof PathAnnotationObject){; ROI roi = ((PathAnnotationObject)objSelected).getROI(). int w = roi.getBoundsWidth(); int h = roi.getBoundsHeight(). int tW, tH. // devide tiles based on the width ; tW = Math.floor(w/n)+1; tH = h. // Create a list of ROIs by using the makeTiles method from the RoiTools class, which divides the ROI into tiles based on the specified width and height.; List<ROI> pathROIs = RoiTools.makeTiles(roi, tW, tH, trimToROI). // Create a list of PathObject tiles and assigns a name to each tile; List<PathObject> tiles = new ArrayList<>(pathROIs.size()). Iterator<ROI> iter = pathROIs.iterator(); int idx = 0; while (iter.hasNext()) {; try {; PathObject tile = PathObjects.createAnnotationObject(iter.next(), getPathClass(childClass)) ; if (tile != null) {; idx++; tile.setName(""Tile "" + idx); tiles.add(tile); }; } catch (InterruptedException e) {; lastMessage = ""Tile creation interrupted for "" + objSelected; return; } catch (Exception e) {; iter.remove(); }; }. // Add the tiles to the selected annotation object and update the viewer; ((PathAnnotationObject)objSelected).addPathObjects(tiles);; viewer.getImageData().getHierarchy().fireHierarchyChangedEvent(this, objSelected);; }. parentAnnotation = getAnnotationObjects().findAll{it.getPathClass() == getPathClass(parentClass)}[0]; childAnnotation = getAnnotationObjects().findAll{it.getPathClass() == getPathClass(childClass )}. for (it_Child in childAnnotation) { ; getCurrentHierarchy().addPathObjectBelowParent(parentAnnotation, it_Child, true) }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178
https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178:36,Energy Efficiency,adapt,adapted,36,"We are using the following script - adapted from a script on image.sc : . ```groovy; // File: tileAnnotation2.groovy. import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.viewer.QuPathViewer; import qupath.lib.objects.PathAnnotationObject; import qupath.lib.objects.PathObject; import qupath.lib.objects.PathObjects; import qupath.lib.roi.interfaces.ROI; import qupath.lib.roi.RoiTools. // Adjust THIS (n : Number of Tiles); int n = 10; def trimToROI = true; //parentClass = ""IL-left""; childClass = ""Tiles"". // Get the QuPath viewer and check if an object is currently selected; QuPathViewer viewer = QuPathGUI.getInstance().getViewer(); def objSelected = viewer.getSelectedObject(); parentClass = objSelected.getPathClass(). // Calculate the width and height of the ROI; if (objSelected != null && objSelected instanceof PathAnnotationObject){; ROI roi = ((PathAnnotationObject)objSelected).getROI(). int w = roi.getBoundsWidth(); int h = roi.getBoundsHeight(). int tW, tH. // devide tiles based on the width ; tW = Math.floor(w/n)+1; tH = h. // Create a list of ROIs by using the makeTiles method from the RoiTools class, which divides the ROI into tiles based on the specified width and height.; List<ROI> pathROIs = RoiTools.makeTiles(roi, tW, tH, trimToROI). // Create a list of PathObject tiles and assigns a name to each tile; List<PathObject> tiles = new ArrayList<>(pathROIs.size()). Iterator<ROI> iter = pathROIs.iterator(); int idx = 0; while (iter.hasNext()) {; try {; PathObject tile = PathObjects.createAnnotationObject(iter.next(), getPathClass(childClass)) ; if (tile != null) {; idx++; tile.setName(""Tile "" + idx); tiles.add(tile); }; } catch (InterruptedException e) {; lastMessage = ""Tile creation interrupted for "" + objSelected; return; } catch (Exception e) {; iter.remove(); }; }. // Add the tiles to the selected annotation object and update the viewer; ((PathAnnotationObject)objSelected).addPathObjects(tiles);; viewer.getImageData().getHierarchy().fireHierarchyChangedEven",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178
https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178:341,Integrability,interface,interfaces,341,"We are using the following script - adapted from a script on image.sc : . ```groovy; // File: tileAnnotation2.groovy. import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.viewer.QuPathViewer; import qupath.lib.objects.PathAnnotationObject; import qupath.lib.objects.PathObject; import qupath.lib.objects.PathObjects; import qupath.lib.roi.interfaces.ROI; import qupath.lib.roi.RoiTools. // Adjust THIS (n : Number of Tiles); int n = 10; def trimToROI = true; //parentClass = ""IL-left""; childClass = ""Tiles"". // Get the QuPath viewer and check if an object is currently selected; QuPathViewer viewer = QuPathGUI.getInstance().getViewer(); def objSelected = viewer.getSelectedObject(); parentClass = objSelected.getPathClass(). // Calculate the width and height of the ROI; if (objSelected != null && objSelected instanceof PathAnnotationObject){; ROI roi = ((PathAnnotationObject)objSelected).getROI(). int w = roi.getBoundsWidth(); int h = roi.getBoundsHeight(). int tW, tH. // devide tiles based on the width ; tW = Math.floor(w/n)+1; tH = h. // Create a list of ROIs by using the makeTiles method from the RoiTools class, which divides the ROI into tiles based on the specified width and height.; List<ROI> pathROIs = RoiTools.makeTiles(roi, tW, tH, trimToROI). // Create a list of PathObject tiles and assigns a name to each tile; List<PathObject> tiles = new ArrayList<>(pathROIs.size()). Iterator<ROI> iter = pathROIs.iterator(); int idx = 0; while (iter.hasNext()) {; try {; PathObject tile = PathObjects.createAnnotationObject(iter.next(), getPathClass(childClass)) ; if (tile != null) {; idx++; tile.setName(""Tile "" + idx); tiles.add(tile); }; } catch (InterruptedException e) {; lastMessage = ""Tile creation interrupted for "" + objSelected; return; } catch (Exception e) {; iter.remove(); }; }. // Add the tiles to the selected annotation object and update the viewer; ((PathAnnotationObject)objSelected).addPathObjects(tiles);; viewer.getImageData().getHierarchy().fireHierarchyChangedEven",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178
https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178:36,Modifiability,adapt,adapted,36,"We are using the following script - adapted from a script on image.sc : . ```groovy; // File: tileAnnotation2.groovy. import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.viewer.QuPathViewer; import qupath.lib.objects.PathAnnotationObject; import qupath.lib.objects.PathObject; import qupath.lib.objects.PathObjects; import qupath.lib.roi.interfaces.ROI; import qupath.lib.roi.RoiTools. // Adjust THIS (n : Number of Tiles); int n = 10; def trimToROI = true; //parentClass = ""IL-left""; childClass = ""Tiles"". // Get the QuPath viewer and check if an object is currently selected; QuPathViewer viewer = QuPathGUI.getInstance().getViewer(); def objSelected = viewer.getSelectedObject(); parentClass = objSelected.getPathClass(). // Calculate the width and height of the ROI; if (objSelected != null && objSelected instanceof PathAnnotationObject){; ROI roi = ((PathAnnotationObject)objSelected).getROI(). int w = roi.getBoundsWidth(); int h = roi.getBoundsHeight(). int tW, tH. // devide tiles based on the width ; tW = Math.floor(w/n)+1; tH = h. // Create a list of ROIs by using the makeTiles method from the RoiTools class, which divides the ROI into tiles based on the specified width and height.; List<ROI> pathROIs = RoiTools.makeTiles(roi, tW, tH, trimToROI). // Create a list of PathObject tiles and assigns a name to each tile; List<PathObject> tiles = new ArrayList<>(pathROIs.size()). Iterator<ROI> iter = pathROIs.iterator(); int idx = 0; while (iter.hasNext()) {; try {; PathObject tile = PathObjects.createAnnotationObject(iter.next(), getPathClass(childClass)) ; if (tile != null) {; idx++; tile.setName(""Tile "" + idx); tiles.add(tile); }; } catch (InterruptedException e) {; lastMessage = ""Tile creation interrupted for "" + objSelected; return; } catch (Exception e) {; iter.remove(); }; }. // Add the tiles to the selected annotation object and update the viewer; ((PathAnnotationObject)objSelected).addPathObjects(tiles);; viewer.getImageData().getHierarchy().fireHierarchyChangedEven",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621818178
https://github.com/qupath/qupath/issues/1277#issuecomment-1621867685:20,Usability,simpl,simply,20,"What happens if you simply replace the `makeTiles` line with the following ?. ```groovy; def pathROIs = RoiTools.makeTiles(roi, tW, tH, trimToROI).reverse(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1621867685
https://github.com/qupath/qupath/issues/1277#issuecomment-1738963292:306,Availability,avail,available,306,@ofrag I read this thread again and today I understood :). We've replaced `RoiTools.makeTiles` with a the new `Tiler` class that supports different alignment options. Hopefully it will make things much easier.; * https://github.com/qupath/qupath/pull/1350. I'll close this issue as the new class should be available soon when v0.5.0 is available.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1738963292
https://github.com/qupath/qupath/issues/1277#issuecomment-1738963292:336,Availability,avail,available,336,@ofrag I read this thread again and today I understood :). We've replaced `RoiTools.makeTiles` with a the new `Tiler` class that supports different alignment options. Hopefully it will make things much easier.; * https://github.com/qupath/qupath/pull/1350. I'll close this issue as the new class should be available soon when v0.5.0 is available.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1277#issuecomment-1738963292
https://github.com/qupath/qupath/issues/1278#issuecomment-1630759354:1067,Integrability,depend,dependency,1067,"When importing images to a QuPath project, there is a space to input arguments. Inserting `--no-crop` there will avoid using the OpenSlide bounds. I don't consider this to be a bug, because other software *already* handles the bounds differently. For example, I remember that QuPath started cropping by default because failing to do so gave different image dimensions when using Bio-Formats and OpenSlide. Cropping actually improved consistency, and removed enormous amounts of unnecessary whitespace. The original commit is at https://github.com/qupath/qupath/commit/52c9c32fa2add760d1338b1b81b2c0c6eed8908b. I think it would be more problematic and inconsistent if QuPath started exporting coordinates with a different origin for some images from that seen in the viewer, and then if there was a wish to import the regions in a project where Bio-Formats (rather than OpenSlide) was the default then it wouldn't be easy to identify or fix the problem. > Exports should be wrt. the original image dimensions, so that other SW can work with the data without OpenSlide dependency. That doesn't work for the reasons given above (i.e. at least one other very popular image-reading library will 'crop' at least some relevant formats automatically anyway). I'm curious as to what other software this causes an issue with that doesn't use OpenSlide. > Or, the offset information should be exported along with annotations. May be preferable, but would be awkward because the annotation export aims to follow the GeoJSON spec. Potentially all objects would need to store that info, or else they would need to be export as a `FeatureCollection` with an additional custom property. The second sounds preferably, but would remain very QuPath-specific.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630759354
https://github.com/qupath/qupath/issues/1278#issuecomment-1630759354:113,Safety,avoid,avoid,113,"When importing images to a QuPath project, there is a space to input arguments. Inserting `--no-crop` there will avoid using the OpenSlide bounds. I don't consider this to be a bug, because other software *already* handles the bounds differently. For example, I remember that QuPath started cropping by default because failing to do so gave different image dimensions when using Bio-Formats and OpenSlide. Cropping actually improved consistency, and removed enormous amounts of unnecessary whitespace. The original commit is at https://github.com/qupath/qupath/commit/52c9c32fa2add760d1338b1b81b2c0c6eed8908b. I think it would be more problematic and inconsistent if QuPath started exporting coordinates with a different origin for some images from that seen in the viewer, and then if there was a wish to import the regions in a project where Bio-Formats (rather than OpenSlide) was the default then it wouldn't be easy to identify or fix the problem. > Exports should be wrt. the original image dimensions, so that other SW can work with the data without OpenSlide dependency. That doesn't work for the reasons given above (i.e. at least one other very popular image-reading library will 'crop' at least some relevant formats automatically anyway). I'm curious as to what other software this causes an issue with that doesn't use OpenSlide. > Or, the offset information should be exported along with annotations. May be preferable, but would be awkward because the annotation export aims to follow the GeoJSON spec. Potentially all objects would need to store that info, or else they would need to be export as a `FeatureCollection` with an additional custom property. The second sounds preferably, but would remain very QuPath-specific.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630759354
https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200:259,Availability,avail,available,259,"See also https://github.com/openslide/openslide/issues/353 and the quote. > You can get the bounding box of the actual pixel data from the `openslide.bounds-{x,y,width,height}` properties. This is what the VIPS `autocrop` option uses to trim the slide to the available pixels. While OpenSlide's approach is internally consistent and may be justifiable, it doesn't seem to me that it is more 'correct' than using the 'bounding box of the actual pixel data'... and failing to crop by default to the actual pixel data seems at least as likely to make the problem you describe *worse* rather than better:. > Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything. As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. *-From the description above, it sounds more like QuPath/Bio-Formats *don't pad* than that they crop...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200
https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200:646,Availability,failure,failure,646,"See also https://github.com/openslide/openslide/issues/353 and the quote. > You can get the bounding box of the actual pixel data from the `openslide.bounds-{x,y,width,height}` properties. This is what the VIPS `autocrop` option uses to trim the slide to the available pixels. While OpenSlide's approach is internally consistent and may be justifiable, it doesn't seem to me that it is more 'correct' than using the 'bounding box of the actual pixel data'... and failing to crop by default to the actual pixel data seems at least as likely to make the problem you describe *worse* rather than better:. > Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything. As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. *-From the description above, it sounds more like QuPath/Bio-Formats *don't pad* than that they crop...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200
https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200:798,Energy Efficiency,reduce,reduces,798,"See also https://github.com/openslide/openslide/issues/353 and the quote. > You can get the bounding box of the actual pixel data from the `openslide.bounds-{x,y,width,height}` properties. This is what the VIPS `autocrop` option uses to trim the slide to the available pixels. While OpenSlide's approach is internally consistent and may be justifiable, it doesn't seem to me that it is more 'correct' than using the 'bounding box of the actual pixel data'... and failing to crop by default to the actual pixel data seems at least as likely to make the problem you describe *worse* rather than better:. > Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything. As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. *-From the description above, it sounds more like QuPath/Bio-Formats *don't pad* than that they crop...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200
https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200:832,Integrability,depend,dependency,832,"See also https://github.com/openslide/openslide/issues/353 and the quote. > You can get the bounding box of the actual pixel data from the `openslide.bounds-{x,y,width,height}` properties. This is what the VIPS `autocrop` option uses to trim the slide to the available pixels. While OpenSlide's approach is internally consistent and may be justifiable, it doesn't seem to me that it is more 'correct' than using the 'bounding box of the actual pixel data'... and failing to crop by default to the actual pixel data seems at least as likely to make the problem you describe *worse* rather than better:. > Any change to the OpenSlide, the library, failure to derive these coordinates etc. breaks everything. As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. *-From the description above, it sounds more like QuPath/Bio-Formats *don't pad* than that they crop...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630779200
https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401:594,Energy Efficiency,reduce,reduces,594,"> When importing images to a QuPath project, there is a space to input arguments. Inserting --no-crop there will avoid using the OpenSlide bounds. Thanks, very helpful. > Potentially all objects would need to store that info, or else they would need to be export as a FeatureCollection with an additional custom property. The second sounds preferably but would remain very QuPath-specific. Already `properties` values are very QuPath specific (`isEllipse`...), so I don't see much of a problem here. > As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. I did not know about the Bio-Formats approach. Since DICOM is slowly opening up to the open-source WSI world, I think the problem will arise sooner or later. For now, for performance reasons, we go with TIFF files that do not have this metadata stored, and all software (including quPath) fails to read cropped data, thus having inconsistencies everywhere. Thanks for the insight.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401
https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401:628,Integrability,depend,dependency,628,"> When importing images to a QuPath project, there is a space to input arguments. Inserting --no-crop there will avoid using the OpenSlide bounds. Thanks, very helpful. > Potentially all objects would need to store that info, or else they would need to be export as a FeatureCollection with an additional custom property. The second sounds preferably but would remain very QuPath-specific. Already `properties` values are very QuPath specific (`isEllipse`...), so I don't see much of a problem here. > As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. I did not know about the Bio-Formats approach. Since DICOM is slowly opening up to the open-source WSI world, I think the problem will arise sooner or later. For now, for performance reasons, we go with TIFF files that do not have this metadata stored, and all software (including quPath) fails to read cropped data, thus having inconsistencies everywhere. Thanks for the insight.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401
https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401:1030,Performance,perform,performance,1030,"> When importing images to a QuPath project, there is a space to input arguments. Inserting --no-crop there will avoid using the OpenSlide bounds. Thanks, very helpful. > Potentially all objects would need to store that info, or else they would need to be export as a FeatureCollection with an additional custom property. The second sounds preferably but would remain very QuPath-specific. Already `properties` values are very QuPath specific (`isEllipse`...), so I don't see much of a problem here. > As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. I did not know about the Bio-Formats approach. Since DICOM is slowly opening up to the open-source WSI world, I think the problem will arise sooner or later. For now, for performance reasons, we go with TIFF files that do not have this metadata stored, and all software (including quPath) fails to read cropped data, thus having inconsistencies everywhere. Thanks for the insight.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401
https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401:113,Safety,avoid,avoid,113,"> When importing images to a QuPath project, there is a space to input arguments. Inserting --no-crop there will avoid using the OpenSlide bounds. Thanks, very helpful. > Potentially all objects would need to store that info, or else they would need to be export as a FeatureCollection with an additional custom property. The second sounds preferably but would remain very QuPath-specific. Already `properties` values are very QuPath specific (`isEllipse`...), so I don't see much of a problem here. > As it currently stands, I think QuPath is more internally consistent by cropping - and this reduces rather than increases the dependency on OpenSlide, by making its use interchangeable with Bio-Formats. If there are cases where QuPath crops* and Bio-Formats or other popular libraries don't, then we might need to look at it again, but I don't know of any. I did not know about the Bio-Formats approach. Since DICOM is slowly opening up to the open-source WSI world, I think the problem will arise sooner or later. For now, for performance reasons, we go with TIFF files that do not have this metadata stored, and all software (including quPath) fails to read cropped data, thus having inconsistencies everywhere. Thanks for the insight.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630799401
https://github.com/qupath/qupath/issues/1278#issuecomment-1630820251:15,Performance,perform,performance,15,"> For now, for performance reasons, we go with TIFF files that do not have this metadata stored, and all software (including quPath) fails to read cropped data, thus having inconsistencies everywhere. . I don't understand the issue here, but it sounds like the problem is outside of QuPath, right?. If you are writing the TIFFs in your own software, then the use of [ome-tiff](https://www.openmicroscopy.org/2018/11/29/ometiffpyramid.html) might be one way to improve consistency (but then I'm not sure if it's supported by OpenSlide...).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630820251
https://github.com/qupath/qupath/issues/1278#issuecomment-1630907596:640,Deployability,pipeline,pipeline,640,"I'd like to give generic examples of how others might (and will, IMHO) find this problematic in the future. Let's get more specific then:. My use cases include QuPath exports that do not align with the true image dimensions. The IIPImage server does not auto-crop images or read these bounds from server files. My files do not even store this data. ML researchers work with libraries (TF, pytorch...), and they might rely on OpenSlide/BioFormats to read the data, they might as well be unaware of behind the scenes and be surprised later. The output of a convolutional network is probably misaligned to the original data. We are writing ML pipeline data loaders for OME-TIFF and DICOM that use, for example, [wsidicom](https://github.com/imi-bigpicture/wsidicom). I don't know (but doubt it) whether this library delivers by default cropped data. . >I'll give it some more thought. Thank you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630907596
https://github.com/qupath/qupath/issues/1278#issuecomment-1630907596:654,Performance,load,loaders,654,"I'd like to give generic examples of how others might (and will, IMHO) find this problematic in the future. Let's get more specific then:. My use cases include QuPath exports that do not align with the true image dimensions. The IIPImage server does not auto-crop images or read these bounds from server files. My files do not even store this data. ML researchers work with libraries (TF, pytorch...), and they might rely on OpenSlide/BioFormats to read the data, they might as well be unaware of behind the scenes and be surprised later. The output of a convolutional network is probably misaligned to the original data. We are writing ML pipeline data loaders for OME-TIFF and DICOM that use, for example, [wsidicom](https://github.com/imi-bigpicture/wsidicom). I don't know (but doubt it) whether this library delivers by default cropped data. . >I'll give it some more thought. Thank you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1630907596
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:565,Availability,avail,available,565,"Hmmm, I still fail to see any evidence of a QuPath bug here. Your reference to 'the true image dimensions' is hard to interpret since I don't know where you're getting the 'true' dimensions from, or what is the source of your files. Without actual specifics (e.g. an example file), I don't see why you should assume the 'bug' is in QuPath and not elsewhere. OpenSlide only sets the bounds for a subset of file formats, so most shouldn't be affected anyway. I've only seen it for scn and mrxs, which are the two formats mentioned in the commit that makes the bounds available: https://github.com/openslide/openslide/commit/421cb647acdc8fe35e33c2683949f5098925c8ac. Note my comment above about 'cropping' being arguably the same as 'not padding'... one could argue that QuPath simply removes the padding that OpenSlide has added, because [the bounds define where there is pixel data](https://github.com/openslide/openslide/issues/424#issuecomment-1382416341). QuPath aims to read the pixels from an image consistently, regardless of whether OpenSlide is used or not. As a specific example from my side, see the image `Leica-1.scn` from the OpenSlide freely-distributable data:; https://openslide.cs.cmu.edu/download/openslide-testdata/Leica/. Screenshots below show the image with a full image annotation within QuPath. ## Bio-Formats; <img width=""939"" alt=""SCN-Bio-Formats"" src=""https://github.com/qupath/qupath/assets/4690904/039b2449-5c20-4b93-a4af-d65928324a50"">. ## OpenSlide (default, cropped to bounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg cau",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:1205,Availability,down,download,1205," your files. Without actual specifics (e.g. an example file), I don't see why you should assume the 'bug' is in QuPath and not elsewhere. OpenSlide only sets the bounds for a subset of file formats, so most shouldn't be affected anyway. I've only seen it for scn and mrxs, which are the two formats mentioned in the commit that makes the bounds available: https://github.com/openslide/openslide/commit/421cb647acdc8fe35e33c2683949f5098925c8ac. Note my comment above about 'cropping' being arguably the same as 'not padding'... one could argue that QuPath simply removes the padding that OpenSlide has added, because [the bounds define where there is pixel data](https://github.com/openslide/openslide/issues/424#issuecomment-1382416341). QuPath aims to read the pixels from an image consistently, regardless of whether OpenSlide is used or not. As a specific example from my side, see the image `Leica-1.scn` from the OpenSlide freely-distributable data:; https://openslide.cs.cmu.edu/download/openslide-testdata/Leica/. Screenshots below show the image with a full image annotation within QuPath. ## Bio-Formats; <img width=""939"" alt=""SCN-Bio-Formats"" src=""https://github.com/qupath/qupath/assets/4690904/039b2449-5c20-4b93-a4af-d65928324a50"">. ## OpenSlide (default, cropped to bounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg causes QuPath to ignore what OpenSlide considers to be bounds, and generate a much larger image with extreme padding that causes both much higher memory use and can thwart processing tasks like thresholding or pixel classif",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:2599,Deployability,Configurat,Configuration,2599,"ounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg causes QuPath to ignore what OpenSlide considers to be bounds, and generate a much larger image with extreme padding that causes both much higher memory use and can thwart processing tasks like thresholding or pixel classification. What's more, if I call `tiffinfo Leica-1.scn` I see; ```; === TIFF directory 3 ===; TIFF Directory at offset 0xfe4f444 (266662980); Image Width: 36832 Image Length: 38432; Tile Width: 512 Tile Length: 512; Resolution: 20000, 20000 pixels/cm; Bits/Sample: 8; Compression Scheme: JPEG; Photometric Interpretation: YCbCr; YCbCr Subsampling: 2, 2; Samples/Pixel: 3; Planar Configuration: single image plane; Reference Black/White:; 0: 0 255; 1: 128 255; 2: 128 255; ```; and also; ```xml; <?xml version=""1.0""?>; <scn xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" uuid=""urn:uuid:2b930baa-4b05-4936-a937-ccf5a0b3276d"" xmlns=""http://www.leica-microsystems.com/scn/2010/10/01"">; <collection name=""ImageCollection_0000000128"" uuid=""urn:uuid:d0fa25ee-baa8-48cd-944d-5598a36b3f7b"" sizeX=""26564529"" sizeY=""76734666"">; <barcode>MDQwNTA2MjlD</barcode>; <image name=""image_0000001819"" uuid=""urn:uuid:4a9c1d8d-1f66-4df6-98e7-9d3efe746932"">; <creationDate>2011-05-31T09:33:14.31Z</creationDate>; <device model=""Leica SCN400;Leica SCN"" version=""1.4.0.9691 2011/03/30 10:30:59;1.4.0.9708"" />; <pixels sizeX=""1616"" sizeY=""4668"">; <dimension sizeX=""1616"" sizeY=""4668"" r=""0"" ifd=""0"" />; <dimension sizeX=""404"" sizeY=""1167"" r=""1"" ifd=""1"" />; ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:2599,Modifiability,Config,Configuration,2599,"ounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg causes QuPath to ignore what OpenSlide considers to be bounds, and generate a much larger image with extreme padding that causes both much higher memory use and can thwart processing tasks like thresholding or pixel classification. What's more, if I call `tiffinfo Leica-1.scn` I see; ```; === TIFF directory 3 ===; TIFF Directory at offset 0xfe4f444 (266662980); Image Width: 36832 Image Length: 38432; Tile Width: 512 Tile Length: 512; Resolution: 20000, 20000 pixels/cm; Bits/Sample: 8; Compression Scheme: JPEG; Photometric Interpretation: YCbCr; YCbCr Subsampling: 2, 2; Samples/Pixel: 3; Planar Configuration: single image plane; Reference Black/White:; 0: 0 255; 1: 128 255; 2: 128 255; ```; and also; ```xml; <?xml version=""1.0""?>; <scn xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance"" xmlns:xsd=""http://www.w3.org/2001/XMLSchema"" uuid=""urn:uuid:2b930baa-4b05-4936-a937-ccf5a0b3276d"" xmlns=""http://www.leica-microsystems.com/scn/2010/10/01"">; <collection name=""ImageCollection_0000000128"" uuid=""urn:uuid:d0fa25ee-baa8-48cd-944d-5598a36b3f7b"" sizeX=""26564529"" sizeY=""76734666"">; <barcode>MDQwNTA2MjlD</barcode>; <image name=""image_0000001819"" uuid=""urn:uuid:4a9c1d8d-1f66-4df6-98e7-9d3efe746932"">; <creationDate>2011-05-31T09:33:14.31Z</creationDate>; <device model=""Leica SCN400;Leica SCN"" version=""1.4.0.9691 2011/03/30 10:30:59;1.4.0.9708"" />; <pixels sizeX=""1616"" sizeY=""4668"">; <dimension sizeX=""1616"" sizeY=""4668"" r=""0"" ifd=""0"" />; <dimension sizeX=""404"" sizeY=""1167"" r=""1"" ifd=""1"" />; ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:1224,Testability,test,testdata,1224," your files. Without actual specifics (e.g. an example file), I don't see why you should assume the 'bug' is in QuPath and not elsewhere. OpenSlide only sets the bounds for a subset of file formats, so most shouldn't be affected anyway. I've only seen it for scn and mrxs, which are the two formats mentioned in the commit that makes the bounds available: https://github.com/openslide/openslide/commit/421cb647acdc8fe35e33c2683949f5098925c8ac. Note my comment above about 'cropping' being arguably the same as 'not padding'... one could argue that QuPath simply removes the padding that OpenSlide has added, because [the bounds define where there is pixel data](https://github.com/openslide/openslide/issues/424#issuecomment-1382416341). QuPath aims to read the pixels from an image consistently, regardless of whether OpenSlide is used or not. As a specific example from my side, see the image `Leica-1.scn` from the OpenSlide freely-distributable data:; https://openslide.cs.cmu.edu/download/openslide-testdata/Leica/. Screenshots below show the image with a full image annotation within QuPath. ## Bio-Formats; <img width=""939"" alt=""SCN-Bio-Formats"" src=""https://github.com/qupath/qupath/assets/4690904/039b2449-5c20-4b93-a4af-d65928324a50"">. ## OpenSlide (default, cropped to bounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg causes QuPath to ignore what OpenSlide considers to be bounds, and generate a much larger image with extreme padding that causes both much higher memory use and can thwart processing tasks like thresholding or pixel classif",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660:775,Usability,simpl,simply,775,"Hmmm, I still fail to see any evidence of a QuPath bug here. Your reference to 'the true image dimensions' is hard to interpret since I don't know where you're getting the 'true' dimensions from, or what is the source of your files. Without actual specifics (e.g. an example file), I don't see why you should assume the 'bug' is in QuPath and not elsewhere. OpenSlide only sets the bounds for a subset of file formats, so most shouldn't be affected anyway. I've only seen it for scn and mrxs, which are the two formats mentioned in the commit that makes the bounds available: https://github.com/openslide/openslide/commit/421cb647acdc8fe35e33c2683949f5098925c8ac. Note my comment above about 'cropping' being arguably the same as 'not padding'... one could argue that QuPath simply removes the padding that OpenSlide has added, because [the bounds define where there is pixel data](https://github.com/openslide/openslide/issues/424#issuecomment-1382416341). QuPath aims to read the pixels from an image consistently, regardless of whether OpenSlide is used or not. As a specific example from my side, see the image `Leica-1.scn` from the OpenSlide freely-distributable data:; https://openslide.cs.cmu.edu/download/openslide-testdata/Leica/. Screenshots below show the image with a full image annotation within QuPath. ## Bio-Formats; <img width=""939"" alt=""SCN-Bio-Formats"" src=""https://github.com/qupath/qupath/assets/4690904/039b2449-5c20-4b93-a4af-d65928324a50"">. ## OpenSlide (default, cropped to bounds); <img width=""941"" alt=""SCN-OpenSlide"" src=""https://github.com/qupath/qupath/assets/4690904/771af2d0-2dcb-44ee-95e6-31ff62f0f7e2"">. ## OpenSlide (with `--no-crop` arg); <img width=""941"" alt=""SCN-OpenSlide-no-crop"" src=""https://github.com/qupath/qupath/assets/4690904/3cf52a48-ca91-4dff-8eb4-7e299d851b3e"">. The size is identical when read using QuPath v0.4.3 when using either OpenSlide or Bio-Formats by default (no extra arguments passed to either). Explicitly passing the `--no-crop` arg cau",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631106660
https://github.com/qupath/qupath/issues/1278#issuecomment-1631149690:1247,Integrability,interoperab,interoperability,1247,"Last bit... Aperio ImageScope (the free viewer from the company behind .scn) also reports the image to be 38432 x 36832. I think that's pretty conclusive... From the screenshots and `tiffinfo`, it seems that OpenSlide's default image size is based upon ; ```xml; <view sizeX=""18416000"" sizeY=""19216000"" offsetX=""5389341"" offsetY=""17548313"" spacingZ=""400"" />; ```; where the size of the 'view' is defined in nm. This may be useful in some cases, e.g. trying to align with the macro image in the file, but I think it's more natural to consider the 'true' image size based upon; ```xml; <pixels sizeX=""36832"" sizeY=""38432"">; ```; which is what QuPath does since v0.2.0. In my opinion, the main issues are; * whole slide formats aren't very standardized, so there is plenty of room for ambiguity; * too many people ignore the bounds that OpenSlide provides... and if this involves converting the image or generating objects, then the information is lost. Either way, if QuPath stopped applying the OpenSlide bounds then I believe the result would be far more confusion and inconsistency... and the challenge is rather to get others to recognize that the bounds are important and should be considered when using OpenSlide, at least if the user expects interoperability elsewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631149690
https://github.com/qupath/qupath/issues/1278#issuecomment-1631156949:521,Deployability,Configurat,Configuration,521,"Yes, I have `mirax` file that has dimensions of 105185 X 221772 pixels. By 'true dimensions' I mean the pixel dimensions stored in the raw file. Converted to a tiff image I get:. tiffinfo:; ````; TIFF Directory at offset 0x27e43676 (669267574); Image Width: 105185 Image Length: 221772; Tile Width: 512 Tile Length: 512; Resolution: 10, 10 pixels/cm; Bits/Sample: 8; Sample Format: unsigned integer; Compression Scheme: JPEG; Photometric Interpretation: YCbCr; Orientation: row 0 top, col 0 lhs; Samples/Pixel: 3; Planar Configuration: single image plane; Reference Black/White:; 0: 0 255; 1: 128 255; 2: 128 255; JPEG Tables: (574 bytes); ...; ````. Opening in QuPath (mirax + crop), QuPath (mirax + no crop / tiff), Web Viewer (tiff - IIPImage):; ![image](https://github.com/qupath/qupath/assets/34658867/0e4248ff-add4-469f-a95b-6c5061ad9dbe). Full image annotation rectangle from QuPath (crop):; ```{""type"":""FeatureCollection"",""features"":[{""type"":""Feature"",""id"":""e23c4b41-3966-4e64-af97-665f7edf753d"",""geometry"":{""type"":""Polygon"",""coordinates"":[[[0, 0],[76832, 0],[76832, 190655],[0, 190655],[0, 0]]]},""properties"":{""objectType"":""annotation""}}]}```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631156949
https://github.com/qupath/qupath/issues/1278#issuecomment-1631156949:521,Modifiability,Config,Configuration,521,"Yes, I have `mirax` file that has dimensions of 105185 X 221772 pixels. By 'true dimensions' I mean the pixel dimensions stored in the raw file. Converted to a tiff image I get:. tiffinfo:; ````; TIFF Directory at offset 0x27e43676 (669267574); Image Width: 105185 Image Length: 221772; Tile Width: 512 Tile Length: 512; Resolution: 10, 10 pixels/cm; Bits/Sample: 8; Sample Format: unsigned integer; Compression Scheme: JPEG; Photometric Interpretation: YCbCr; Orientation: row 0 top, col 0 lhs; Samples/Pixel: 3; Planar Configuration: single image plane; Reference Black/White:; 0: 0 255; 1: 128 255; 2: 128 255; JPEG Tables: (574 bytes); ...; ````. Opening in QuPath (mirax + crop), QuPath (mirax + no crop / tiff), Web Viewer (tiff - IIPImage):; ![image](https://github.com/qupath/qupath/assets/34658867/0e4248ff-add4-469f-a95b-6c5061ad9dbe). Full image annotation rectangle from QuPath (crop):; ```{""type"":""FeatureCollection"",""features"":[{""type"":""Feature"",""id"":""e23c4b41-3966-4e64-af97-665f7edf753d"",""geometry"":{""type"":""Polygon"",""coordinates"":[[[0, 0],[76832, 0],[76832, 190655],[0, 190655],[0, 0]]]},""properties"":{""objectType"":""annotation""}}]}```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631156949
https://github.com/qupath/qupath/issues/1278#issuecomment-1631180457:701,Usability,clear,clear,701,"I understand the problem, but it seems to have occurred at the stage the tiff was created because the bounds were ignored. QuPath wasn't involved in that. Alternatively, if you consistently use the tiff in both QuPath and IIIPImage then it should be fine - neither QuPath nor IIIPImage will crop the tiff. As I understand it, the issue only occurs if you try to match an unpadded mrxs image with a padded tiff image. As shown in the scn example, it would be very bad for QuPath to ignore the crop bounds. Because mrxs isn't tiff-based (and seems to be a particularly awkward proprietary format), it's harder to find other sources to resolve what exactly the bounds mean, but in the scn case it's very clear that the most sensible and consistent behavior is to apply OpenSlide's bounds... which is why it's QuPath's default for all OpenSlide images.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631180457
https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136:998,Deployability,install,install,998,"> By 'true dimensions' I mean the pixel dimensions stored in the raw file. I'm curious where you get these from, because I can't find them in the `.ini` file associated with .mrxs. `tiffinfo` isn't really relevant here, since it can only get from a tiff what was written there during the conversion process... and if OpenSlide was used to help convert the file without cropping, then the tiff dimensions will inevitably agree. `tiffinfo` is meaningful for .scn because the original format itself is tiff-based, so no conversion is needed. As shown in that example, it's possible that the true dimensions stored in the original file are the ones you get *after* cropping with OpenSlide's bounds, not before. I can't check the dimensions of any .mrxs image with other software as I don't have any viewer for mrxs files that isn't using OpenSlide (and ImageScope failed to open it). There is supposedly a free viewer from the company behind the .mrxs format, but it requires too much personal info to install so I don't want to use it. There are some [links here](https://qupath.readthedocs.io/en/0.4/docs/intro/formats.html#mrxs-3d-histech) that may help give some idea what it's not exactly my favorite file format for whole slide scans. I have seen examples of mrxs images where failing to crop results in very excessive padding (and the associated computational problems), so I still thing cropping / avoiding padding is the more appropriate choice for QuPath to make as a default... and the .scn example demonstrates that it's the right choice there. In conclusion, it sounds like:; * QuPath isn't doing anything weird or buggy - it's behaving as it should here; * You can use QuPath with your pyramidal tiffs, no matter how they are generated (as long as they can be opened by either OpenSlide and Bio-Formats); * You can use QuPath with the mrxs images used to generate tiffs if you do **one** of the following; * generate the tiffs to give the cropped/unpadded region, e.g.; * using [`libvips` an",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136
https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136:2257,Integrability,depend,depending,2257," personal info to install so I don't want to use it. There are some [links here](https://qupath.readthedocs.io/en/0.4/docs/intro/formats.html#mrxs-3d-histech) that may help give some idea what it's not exactly my favorite file format for whole slide scans. I have seen examples of mrxs images where failing to crop results in very excessive padding (and the associated computational problems), so I still thing cropping / avoiding padding is the more appropriate choice for QuPath to make as a default... and the .scn example demonstrates that it's the right choice there. In conclusion, it sounds like:; * QuPath isn't doing anything weird or buggy - it's behaving as it should here; * You can use QuPath with your pyramidal tiffs, no matter how they are generated (as long as they can be opened by either OpenSlide and Bio-Formats); * You can use QuPath with the mrxs images used to generate tiffs if you do **one** of the following; * generate the tiffs to give the cropped/unpadded region, e.g.; * using [`libvips` and `autocrop`](https://github.com/openslide/openslide/wiki/OpenSlideAndVIPS#slide-bounds); * using QuPath itself (to write an ome-tiff); * import into QuPath with the `--no-crop` option; * correct the coordinates as required when switching between software depending upon whether it adds padding or not; * You *may* be able to use QuPath with other software as long as it doesn't use OpenSlide to read the .mrxs files... but this is untested since very little software seems to support .mrxs directly, and the format is so complex that it doesn't seem at all clear what the 'true' size of an .mrxs file is. Finally (again), OpenSlide Python itself supports conversion to .dzi, which has a [`limit_bounds` option](https://openslide.org/api/python/). All in all, I don't think QuPath is the thing that's making this complicated... it's just unfortunately complicated because of the use of proprietary formats at a lack of standardization around how exactly they *should* be handled.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136
https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136:1402,Safety,avoid,avoiding,1402,"e without cropping, then the tiff dimensions will inevitably agree. `tiffinfo` is meaningful for .scn because the original format itself is tiff-based, so no conversion is needed. As shown in that example, it's possible that the true dimensions stored in the original file are the ones you get *after* cropping with OpenSlide's bounds, not before. I can't check the dimensions of any .mrxs image with other software as I don't have any viewer for mrxs files that isn't using OpenSlide (and ImageScope failed to open it). There is supposedly a free viewer from the company behind the .mrxs format, but it requires too much personal info to install so I don't want to use it. There are some [links here](https://qupath.readthedocs.io/en/0.4/docs/intro/formats.html#mrxs-3d-histech) that may help give some idea what it's not exactly my favorite file format for whole slide scans. I have seen examples of mrxs images where failing to crop results in very excessive padding (and the associated computational problems), so I still thing cropping / avoiding padding is the more appropriate choice for QuPath to make as a default... and the .scn example demonstrates that it's the right choice there. In conclusion, it sounds like:; * QuPath isn't doing anything weird or buggy - it's behaving as it should here; * You can use QuPath with your pyramidal tiffs, no matter how they are generated (as long as they can be opened by either OpenSlide and Bio-Formats); * You can use QuPath with the mrxs images used to generate tiffs if you do **one** of the following; * generate the tiffs to give the cropped/unpadded region, e.g.; * using [`libvips` and `autocrop`](https://github.com/openslide/openslide/wiki/OpenSlideAndVIPS#slide-bounds); * using QuPath itself (to write an ome-tiff); * import into QuPath with the `--no-crop` option; * correct the coordinates as required when switching between software depending upon whether it adds padding or not; * You *may* be able to use QuPath with other software a",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136
https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136:2559,Usability,clear,clear,2559," personal info to install so I don't want to use it. There are some [links here](https://qupath.readthedocs.io/en/0.4/docs/intro/formats.html#mrxs-3d-histech) that may help give some idea what it's not exactly my favorite file format for whole slide scans. I have seen examples of mrxs images where failing to crop results in very excessive padding (and the associated computational problems), so I still thing cropping / avoiding padding is the more appropriate choice for QuPath to make as a default... and the .scn example demonstrates that it's the right choice there. In conclusion, it sounds like:; * QuPath isn't doing anything weird or buggy - it's behaving as it should here; * You can use QuPath with your pyramidal tiffs, no matter how they are generated (as long as they can be opened by either OpenSlide and Bio-Formats); * You can use QuPath with the mrxs images used to generate tiffs if you do **one** of the following; * generate the tiffs to give the cropped/unpadded region, e.g.; * using [`libvips` and `autocrop`](https://github.com/openslide/openslide/wiki/OpenSlideAndVIPS#slide-bounds); * using QuPath itself (to write an ome-tiff); * import into QuPath with the `--no-crop` option; * correct the coordinates as required when switching between software depending upon whether it adds padding or not; * You *may* be able to use QuPath with other software as long as it doesn't use OpenSlide to read the .mrxs files... but this is untested since very little software seems to support .mrxs directly, and the format is so complex that it doesn't seem at all clear what the 'true' size of an .mrxs file is. Finally (again), OpenSlide Python itself supports conversion to .dzi, which has a [`limit_bounds` option](https://openslide.org/api/python/). All in all, I don't think QuPath is the thing that's making this complicated... it's just unfortunately complicated because of the use of proprietary formats at a lack of standardization around how exactly they *should* be handled.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631272136
https://github.com/qupath/qupath/issues/1278#issuecomment-1631311540:555,Safety,avoid,avoid,555,"Thank you. Of course I could not get these dimensions directly from the mirax file either (easily), but since the tiff file was generated 'as-is' from mirax, and since I know how these glass slides look like physically, the 'padded' version is 1:1 to the glass, so naturally what QuPath shows me is not something I consider the whole slide, thus cropped. I did consider these workarounds, but most of them include some effort from the pathologist's side - probably a no go. Re-generating the whole database of 5+years of data is something I would like to avoid. Thanks for the exhaustive list and your effort.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1278#issuecomment-1631311540
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:516,Availability,down,downsampleFactor,516,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:688,Availability,down,downsample,688,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:895,Availability,down,downsample,895,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:666,Deployability,update,updated,666,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:965,Modifiability,refactor,refactoring,965,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:1527,Modifiability,refactor,refactoring,1527,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283:716,Security,expose,exposed,716,"When trying to run this I get; ```; qupath.fx.dialogs.Dialogs - QuPath exception: Exception in Application start method; java.lang.RuntimeException: Exception in Application start method; 	at com.sun.javafx.application.LauncherImpl.launchApplication1(LauncherImpl.java:893); 	at com.sun.javafx.application.LauncherImpl.lambda$launchApplication$2(LauncherImpl.java:195); 	at java.base/java.lang.Thread.run(Thread.java:833); Caused by: java.lang.NullPointerException: Cannot invoke ""qupath.lib.gui.viewer.QuPathViewer.downsampleFactor()"" because ""this.viewer"" is null; ```. But even if this is fixed, would it have any visible impact? The label text should already be updated. I agree that downsample factor should be exposed as a property, but I think it will require a cautious approach; if it's not a `ReadOnlyDoubleProperty` then the user should be able to assume that they can also *set* the downsample via the property, but I expect that would require a bigger refactoring of `QuPathViewer`. It's old-fashioned and suboptimal, but for now adding a [`QuPathViewerListener`](https://github.com/qupath/qupath/blob/007b18108b9f43954279403cb1f796d7ada4b521/qupath-gui-fx/src/main/java/qupath/lib/gui/viewer/QuPathViewerListener.java) is the expected way to identify any kind of viewer change. Definitely a move towards a more property-based approach would be welcome, but then so would a viewer that uses JavaFX more natively (rather than lots of legacy Graphics2D stuff)... so I think the question is whether to invest time in refactoring the current viewer, or take on the task of writing an entirely new viewer?. I definitely think a new viewer would be nice at some point - would be good to discuss what to do along the way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1638638283
https://github.com/qupath/qupath/pull/1279#issuecomment-1639814876:313,Availability,down,downsample,313,"Ah, sorry, I made this change on 0.4.3 where I was working on the extension and switched to main to cherry-pick without testing. The context I spotted it is definitely an edge case. 1. zoom in an arbitrary amount, say past 1x; 2. Click ""Adjust zoom for all images to fit the entire image in the viewer""; 3. Image downsample factor changes but displayed magnification doesn't. But this is fixed in main already it seems. Sorry!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1639814876
https://github.com/qupath/qupath/pull/1279#issuecomment-1639814876:120,Testability,test,testing,120,"Ah, sorry, I made this change on 0.4.3 where I was working on the extension and switched to main to cherry-pick without testing. The context I spotted it is definitely an edge case. 1. zoom in an arbitrary amount, say past 1x; 2. Click ""Adjust zoom for all images to fit the entire image in the viewer""; 3. Image downsample factor changes but displayed magnification doesn't. But this is fixed in main already it seems. Sorry!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1279#issuecomment-1639814876
https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686:222,Availability,down,downloading,222,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor). ; Now my QuPath program doesn't work at all. ; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail. ; Any advice?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686
https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686:256,Availability,down,downloading,256,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor). ; Now my QuPath program doesn't work at all. ; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail. ; Any advice?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686
https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686:282,Availability,avail,avail,282,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor). ; Now my QuPath program doesn't work at all. ; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail. ; Any advice?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686
https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686:11,Deployability,update,updated,11,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor). ; Now my QuPath program doesn't work at all. ; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail. ; Any advice?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686
https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686:134,Integrability,message,message,134,"I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor). ; Now my QuPath program doesn't work at all. ; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail. ; Any advice?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:490,Availability,down,downloading,490,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:524,Availability,down,downloading,524,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:550,Availability,avail,avail,550,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:281,Deployability,update,updated,281,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:402,Integrability,message,message,402,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536:867,Integrability,Message,Message,867,"That is usually Gatekeeper (since the app is not signed and notarized). You can either turn off Gatekeeper or right-click on the program and choose Open (only needs to be done once). Sent from my iPhone. On Jul 19, 2023, at 12:10 PM, ReganFulton ***@***.***> wrote:. ﻿. I recently updated to MacOS 13.5 (Ventura), on my desktop mini (M1 processor).; Now my QuPath program doesn't work at all.; I get a message saying ""This file is corrupted and should be moved to the trash""; I've tried re-downloading QuPath, as well as re-downloading the OS, to no avail.; Any advice?. —; Reply to this email directly, view it on GitHub<https://github.com/qupath/qupath/issues/1280#issuecomment-1642372686>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/ABMJCNSIL52UXHDWZGSRNS3XRABFXANCNFSM6AAAAAA2QBRGYY>.; You are receiving this because you authored the thread.Message ID: ***@***.***>",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1642380536
https://github.com/qupath/qupath/issues/1280#issuecomment-1701617743:210,Deployability,release,release,210,"It looks like this is a JavaFX bug/limitation:. * https://bugs.openjdk.org/browse/JDK-8239590; * https://bugs.openjdk.org/browse/JDK-8241973. I'll explore whether I can find any workarounds for the next QuPath release, but it looks like it could be a more fundamental problem of how JavaFX and macOS work.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1280#issuecomment-1701617743
https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068:103,Deployability,install,installation,103,"Have you tried the troubleshooting instructions here?; https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos. Right-click + open has always worked for me, across multiple Mac computers - but Apple do sometimes change things. Recently, I find I need to right-click + open for the installer, and then also right-click + open for the app itself the *first* time I use it (but a simple double-click works after that).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068
https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068:297,Deployability,install,installer,297,"Have you tried the troubleshooting instructions here?; https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos. Right-click + open has always worked for me, across multiple Mac computers - but Apple do sometimes change things. Recently, I find I need to right-click + open for the installer, and then also right-click + open for the app itself the *first* time I use it (but a simple double-click works after that).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068
https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068:393,Usability,simpl,simple,393,"Have you tried the troubleshooting instructions here?; https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos. Right-click + open has always worked for me, across multiple Mac computers - but Apple do sometimes change things. Recently, I find I need to right-click + open for the installer, and then also right-click + open for the app itself the *first* time I use it (but a simple double-click works after that).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068
https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865:424,Deployability,install,installation,424,"Thanks Pete,. As you can see, I'm not a sophisticated github user, but I love QuPath!. I'll try again. Regan. Regan Fulton, M.D., Ph.D.; CEO and Co-Founder; Array Science, LLC; 475 Gate 5 Road, #100; Sausalito, CA 94965; (415) 577-7360. www.arrayscience.com. On Wed, Jul 19, 2023 at 9:17 AM Pete ***@***.***> wrote:. > Have you tried the troubleshooting instructions here?; > https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos; >; > Right-click + open has always worked for me, across multiple Mac computers; > - but Apple do sometimes change things. Recently, I find I need to; > right-click + open for the installer, and then also right-click + open for; > the app itself the *first* time I use it (but a simple double-click works; > after that).; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ANU5KKI5I3C4RIZ6WYUK5D3XRACBDANCNFSM6AAAAAA2QFEV3E>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865
https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865:629,Deployability,install,installer,629,"Thanks Pete,. As you can see, I'm not a sophisticated github user, but I love QuPath!. I'll try again. Regan. Regan Fulton, M.D., Ph.D.; CEO and Co-Founder; Array Science, LLC; 475 Gate 5 Road, #100; Sausalito, CA 94965; (415) 577-7360. www.arrayscience.com. On Wed, Jul 19, 2023 at 9:17 AM Pete ***@***.***> wrote:. > Have you tried the troubleshooting instructions here?; > https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos; >; > Right-click + open has always worked for me, across multiple Mac computers; > - but Apple do sometimes change things. Recently, I find I need to; > right-click + open for the installer, and then also right-click + open for; > the app itself the *first* time I use it (but a simple double-click works; > after that).; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ANU5KKI5I3C4RIZ6WYUK5D3XRACBDANCNFSM6AAAAAA2QFEV3E>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865
https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865:1091,Integrability,Message,Message,1091,"Thanks Pete,. As you can see, I'm not a sophisticated github user, but I love QuPath!. I'll try again. Regan. Regan Fulton, M.D., Ph.D.; CEO and Co-Founder; Array Science, LLC; 475 Gate 5 Road, #100; Sausalito, CA 94965; (415) 577-7360. www.arrayscience.com. On Wed, Jul 19, 2023 at 9:17 AM Pete ***@***.***> wrote:. > Have you tried the troubleshooting instructions here?; > https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos; >; > Right-click + open has always worked for me, across multiple Mac computers; > - but Apple do sometimes change things. Recently, I find I need to; > right-click + open for the installer, and then also right-click + open for; > the app itself the *first* time I use it (but a simple double-click works; > after that).; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ANU5KKI5I3C4RIZ6WYUK5D3XRACBDANCNFSM6AAAAAA2QFEV3E>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865
https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865:728,Usability,simpl,simple,728,"Thanks Pete,. As you can see, I'm not a sophisticated github user, but I love QuPath!. I'll try again. Regan. Regan Fulton, M.D., Ph.D.; CEO and Co-Founder; Array Science, LLC; 475 Gate 5 Road, #100; Sausalito, CA 94965; (415) 577-7360. www.arrayscience.com. On Wed, Jul 19, 2023 at 9:17 AM Pete ***@***.***> wrote:. > Have you tried the troubleshooting instructions here?; > https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos; >; > Right-click + open has always worked for me, across multiple Mac computers; > - but Apple do sometimes change things. Recently, I find I need to; > right-click + open for the installer, and then also right-click + open for; > the app itself the *first* time I use it (but a simple double-click works; > after that).; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1281#issuecomment-1642383068>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ANU5KKI5I3C4RIZ6WYUK5D3XRACBDANCNFSM6AAAAAA2QFEV3E>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1281#issuecomment-1642387865
https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545:819,Availability,failure,failure,819,"Yeah, I was over-enthusiastic in converting `Collectors.toList()` to simply use `toList()` when updating to Java 17 - this problem has emerged a few times. See https://github.com/qupath/qupath/commit/1710f51e7846b9b85367da2a716a8b67c8805e92 for more info. The reason I didn't just undo it is that `Collectors.toList()` *also* seems to be wrong - at least inasmuch as it makes no guarantees of mutability: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#toList(); So the fact it worked previously was kind of incidental or accidental. Therefore my thinking was that we could stick with `Stream.toList()` where that works, and then where mutability is required we use instead; ```java; stream.collect(Collectors.toCollection(ArrayList::new)); ```. I hadn't spotted this as a failure case, so we certainly should change it - but I think better to make the change that explicitly generates an `ArrayList` to avoid relying upon the happenstance of `Collectors.toList()` being mutable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545
https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545:950,Safety,avoid,avoid,950,"Yeah, I was over-enthusiastic in converting `Collectors.toList()` to simply use `toList()` when updating to Java 17 - this problem has emerged a few times. See https://github.com/qupath/qupath/commit/1710f51e7846b9b85367da2a716a8b67c8805e92 for more info. The reason I didn't just undo it is that `Collectors.toList()` *also* seems to be wrong - at least inasmuch as it makes no guarantees of mutability: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#toList(); So the fact it worked previously was kind of incidental or accidental. Therefore my thinking was that we could stick with `Stream.toList()` where that works, and then where mutability is required we use instead; ```java; stream.collect(Collectors.toCollection(ArrayList::new)); ```. I hadn't spotted this as a failure case, so we certainly should change it - but I think better to make the change that explicitly generates an `ArrayList` to avoid relying upon the happenstance of `Collectors.toList()` being mutable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545
https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545:69,Usability,simpl,simply,69,"Yeah, I was over-enthusiastic in converting `Collectors.toList()` to simply use `toList()` when updating to Java 17 - this problem has emerged a few times. See https://github.com/qupath/qupath/commit/1710f51e7846b9b85367da2a716a8b67c8805e92 for more info. The reason I didn't just undo it is that `Collectors.toList()` *also* seems to be wrong - at least inasmuch as it makes no guarantees of mutability: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#toList(); So the fact it worked previously was kind of incidental or accidental. Therefore my thinking was that we could stick with `Stream.toList()` where that works, and then where mutability is required we use instead; ```java; stream.collect(Collectors.toCollection(ArrayList::new)); ```. I hadn't spotted this as a failure case, so we certainly should change it - but I think better to make the change that explicitly generates an `ArrayList` to avoid relying upon the happenstance of `Collectors.toList()` being mutable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545
https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545:281,Usability,undo,undo,281,"Yeah, I was over-enthusiastic in converting `Collectors.toList()` to simply use `toList()` when updating to Java 17 - this problem has emerged a few times. See https://github.com/qupath/qupath/commit/1710f51e7846b9b85367da2a716a8b67c8805e92 for more info. The reason I didn't just undo it is that `Collectors.toList()` *also* seems to be wrong - at least inasmuch as it makes no guarantees of mutability: https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/Collectors.html#toList(); So the fact it worked previously was kind of incidental or accidental. Therefore my thinking was that we could stick with `Stream.toList()` where that works, and then where mutability is required we use instead; ```java; stream.collect(Collectors.toCollection(ArrayList::new)); ```. I hadn't spotted this as a failure case, so we certainly should change it - but I think better to make the change that explicitly generates an `ArrayList` to avoid relying upon the happenstance of `Collectors.toList()` being mutable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1648260545
https://github.com/qupath/qupath/pull/1282#issuecomment-1649459698:82,Modifiability,refactor,refactoring,82,"Doesn't sound intended... the `main` branch now is in a pretty unstable state mid-refactoring that I haven't had time to get back to, but which affected the extension stuff. The relevant aspect is probably that the 'user directory' is increasingly used for other stuff (including css, localization strings, colormaps....) and not just extensions - so I created a new [`FileCopier`](https://github.com/qupath/qupath/blob/main/qupath-gui-fx/src/main/java/qupath/lib/gui/FileCopier.java) class to help with copying files over into the directory (i.e. when someone drags relevant files onto QuPath, they are copied to the appropriate subdirectory of the user directory... of which 'extensions' is just one). So the whole copying-jar-to-the-extensions-directory stuff changed, and it sounds like I messed up something there and have ended up using the parent rather than subdirectory.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1649459698
https://github.com/qupath/qupath/pull/1282#issuecomment-1649462867:67,Testability,test,testing,67,"Sensible, I'll do my best to fix any of the small bugs I spot when testing the current build. Also semi-related, probably the wsinfer extension should use the same dir?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1649462867
https://github.com/qupath/qupath/pull/1282#issuecomment-1649469444:504,Testability,log,log,504,"Probably should, but it also needs to be v0.4.3 compatible so can't use `FileCopier`. Not sure it matters *too* much which directory it uses, as long as we don't surprise users by writing stuff in unexpected places (or, even worse, overwriting anything...). Sidenote: perhaps the biggest unresolved thing in `main` is that `qupath-fx` should be brought out into a separate repo, and switched to Apache. And *possibly* split even further, so that localization/preference stuff can be used elsewhere (e.g. log viewer, script editor...).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1282#issuecomment-1649469444
https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437:434,Security,hash,hashCode,434,"Thanks, could you describe in more detail what this fixes?. Can you provide any minimal example of the bug - ideally [with a unit test](https://github.com/qupath/qupath/blob/main/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClass.java)?. Based on the other thread I tried running; ```groovy; pc1 = QP.getPathClass(""Right""); pc2 = QP.getDerivedPathClass(pc1, ""hello"").getParentClass(); println pc1 === pc2; println pc1.hashCode(); println pc2.hashCode(); ```; but that behaved properly, so I'm not sure what exactly is wrong.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437
https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437:458,Security,hash,hashCode,458,"Thanks, could you describe in more detail what this fixes?. Can you provide any minimal example of the bug - ideally [with a unit test](https://github.com/qupath/qupath/blob/main/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClass.java)?. Based on the other thread I tried running; ```groovy; pc1 = QP.getPathClass(""Right""); pc2 = QP.getDerivedPathClass(pc1, ""hello"").getParentClass(); println pc1 === pc2; println pc1.hashCode(); println pc2.hashCode(); ```; but that behaved properly, so I'm not sure what exactly is wrong.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437
https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437:130,Testability,test,test,130,"Thanks, could you describe in more detail what this fixes?. Can you provide any minimal example of the bug - ideally [with a unit test](https://github.com/qupath/qupath/blob/main/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClass.java)?. Based on the other thread I tried running; ```groovy; pc1 = QP.getPathClass(""Right""); pc2 = QP.getDerivedPathClass(pc1, ""hello"").getParentClass(); println pc1 === pc2; println pc1.hashCode(); println pc2.hashCode(); ```; but that behaved properly, so I'm not sure what exactly is wrong.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437
https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437:195,Testability,test,test,195,"Thanks, could you describe in more detail what this fixes?. Can you provide any minimal example of the bug - ideally [with a unit test](https://github.com/qupath/qupath/blob/main/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClass.java)?. Based on the other thread I tried running; ```groovy; pc1 = QP.getPathClass(""Right""); pc2 = QP.getDerivedPathClass(pc1, ""hello"").getParentClass(); println pc1 === pc2; println pc1.hashCode(); println pc2.hashCode(); ```; but that behaved properly, so I'm not sure what exactly is wrong.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437
https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437:232,Testability,Test,TestPathClass,232,"Thanks, could you describe in more detail what this fixes?. Can you provide any minimal example of the bug - ideally [with a unit test](https://github.com/qupath/qupath/blob/main/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClass.java)?. Based on the other thread I tried running; ```groovy; pc1 = QP.getPathClass(""Right""); pc2 = QP.getDerivedPathClass(pc1, ""hello"").getParentClass(); println pc1 === pc2; println pc1.hashCode(); println pc2.hashCode(); ```; but that behaved properly, so I'm not sure what exactly is wrong.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670011437
https://github.com/qupath/qupath/pull/1286#issuecomment-1670199442:598,Security,hash,hashCode,598,"this is the minimum example I could write:. ```groovy; import com.google.gson.Gson; import com.google.gson.stream.JsonReader; import qupath.lib.objects.classes.PathClass. String json = ""{ \""name\"": \""Example\"", \""parentClass\"": {\""name\"": \""Parent\""}, \""colorRGB\"": 0}"";; JsonReader jin = new JsonReader(new StringReader(json));; Gson gson = new Gson();; PathClass pathClass = gson.fromJson(jin, PathClass.class);; pathClass = PathClass.getSingleton(pathClass);; PathClass parent1 = pathClass.getParentClass();; PathClass parent2 = PathClass.fromString(""Parent"");; println(""getSingleton: ""+parent1.hashCode()+"" (""+parent1+"")"");; println(""fromString: ""+parent2.hashCode()+"" (""+parent2+"")"");; println(""Are equal: ""+(parent1===parent2)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670199442
https://github.com/qupath/qupath/pull/1286#issuecomment-1670199442:660,Security,hash,hashCode,660,"this is the minimum example I could write:. ```groovy; import com.google.gson.Gson; import com.google.gson.stream.JsonReader; import qupath.lib.objects.classes.PathClass. String json = ""{ \""name\"": \""Example\"", \""parentClass\"": {\""name\"": \""Parent\""}, \""colorRGB\"": 0}"";; JsonReader jin = new JsonReader(new StringReader(json));; Gson gson = new Gson();; PathClass pathClass = gson.fromJson(jin, PathClass.class);; pathClass = PathClass.getSingleton(pathClass);; PathClass parent1 = pathClass.getParentClass();; PathClass parent2 = PathClass.fromString(""Parent"");; println(""getSingleton: ""+parent1.hashCode()+"" (""+parent1+"")"");; println(""fromString: ""+parent2.hashCode()+"" (""+parent2+"")"");; println(""Are equal: ""+(parent1===parent2)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670199442
https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968:57,Testability,test,test,57,Also: a pretty similar code could be used for this empty test; https://github.com/qupath/qupath/blob/ff797d180fbe180bf59e376270e3bfe32c424c82/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClassFactory.java#L188C37-L188C37,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968
https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968:158,Testability,test,test,158,Also: a pretty similar code could be used for this empty test; https://github.com/qupath/qupath/blob/ff797d180fbe180bf59e376270e3bfe32c424c82/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClassFactory.java#L188C37-L188C37,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968
https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968:195,Testability,Test,TestPathClassFactory,195,Also: a pretty similar code could be used for this empty test; https://github.com/qupath/qupath/blob/ff797d180fbe180bf59e376270e3bfe32c424c82/qupath-core/src/test/java/qupath/lib/objects/classes/TestPathClassFactory.java#L188C37-L188C37,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670208968
https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778:668,Deployability,install,installs,668,"Thanks, I understand better now that the bug is connected to deserializing. I see that your JSON uses an 'old' (pre-v0.4) syntax:; ```json; { ""name"": ""Example"", ""parentClass"": {""name"": ""Parent""}, ""colorRGB"": 0}; ```; If I run the following in v0.4.3; ```groovy; def pc = getDerivedPathClass(getPathClass(""First""), ""Second""); println GsonTools.getInstance(true).toJson(pc); ```; I see; ```json; {; ""names"": [; ""First"",; ""Second""; ],; ""color"": [117, 210, 222]; }; ```; which was changed in v0.4 for better readability and easier support in other languages. Also, for deserializing you should use `gson = GsonTools.getInstance()` rather than `new Gson()`, because QuPath installs its own `TypeAdapters` to handle custom classes, including `PathClass`. So I implemented these changes in your script, randomizing the class names to avoid being thwarted by caching:; ```groovy; import qupath.lib.objects.classes.PathClass. for (useLegacyJson in [true, false]) {. String parentName = Math.random() as String; String childName = Math.random() as String; String json; if (useLegacyJson); json = """"""{ ""name"": ""${childName}"", ""parentClass"": {""name"": ""${parentName}""}, ""colorRGB"": 0}""""""; else; json = """"""{ ""names"": [""${parentName}"", ""${childName}""], ""color"": [0, 1, 2]}""""""; ; def gson = GsonTools.getInstance(); PathClass pathClass = gson.fromJson(json, PathClass.class); pathClass = PathClass.getSingleton(pathClass); PathClass parent1 = pathClass.getParentClass(); PathClass parent2 = PathClass.fromString(parentName); ; if (useLegacyJson); println ""With legacy JSON""; else; println ""With v0.4 JSON""; println(""getSingleton: "" + parent1.hashCode() + "" ("" + parent1 + "")""); println(""fromString: "" + parent2.hashCode() + "" ("" + parent2 + "")""); println(""Are equal: "" + (parent1===parent2)) ; println ""----------""; }; ```; From a typical run I see; ```; INFO: With legacy JSON; INFO: getSingleton: 1714766410 (0.07271672325316691); INFO: fromString: 2014375544 (0.07271672325316691); INFO: Are equal: false; INFO: --",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778
https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778:2506,Deployability,release,release,2506,"ing you should use `gson = GsonTools.getInstance()` rather than `new Gson()`, because QuPath installs its own `TypeAdapters` to handle custom classes, including `PathClass`. So I implemented these changes in your script, randomizing the class names to avoid being thwarted by caching:; ```groovy; import qupath.lib.objects.classes.PathClass. for (useLegacyJson in [true, false]) {. String parentName = Math.random() as String; String childName = Math.random() as String; String json; if (useLegacyJson); json = """"""{ ""name"": ""${childName}"", ""parentClass"": {""name"": ""${parentName}""}, ""colorRGB"": 0}""""""; else; json = """"""{ ""names"": [""${parentName}"", ""${childName}""], ""color"": [0, 1, 2]}""""""; ; def gson = GsonTools.getInstance(); PathClass pathClass = gson.fromJson(json, PathClass.class); pathClass = PathClass.getSingleton(pathClass); PathClass parent1 = pathClass.getParentClass(); PathClass parent2 = PathClass.fromString(parentName); ; if (useLegacyJson); println ""With legacy JSON""; else; println ""With v0.4 JSON""; println(""getSingleton: "" + parent1.hashCode() + "" ("" + parent1 + "")""); println(""fromString: "" + parent2.hashCode() + "" ("" + parent2 + "")""); println(""Are equal: "" + (parent1===parent2)) ; println ""----------""; }; ```; From a typical run I see; ```; INFO: With legacy JSON; INFO: getSingleton: 1714766410 (0.07271672325316691); INFO: fromString: 2014375544 (0.07271672325316691); INFO: Are equal: false; INFO: ----------; INFO: With v0.4 JSON; INFO: getSingleton: 489320231 (0.016118546223767072); INFO: fromString: 489320231 (0.016118546223767072); INFO: Are equal: true; INFO: ----------; ```. I think this implies that the bug *only* occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself. Does that sound correct?. I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. In the meantime I'm keen to understand when the bug strikes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778
https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778:827,Safety,avoid,avoid,827,"Thanks, I understand better now that the bug is connected to deserializing. I see that your JSON uses an 'old' (pre-v0.4) syntax:; ```json; { ""name"": ""Example"", ""parentClass"": {""name"": ""Parent""}, ""colorRGB"": 0}; ```; If I run the following in v0.4.3; ```groovy; def pc = getDerivedPathClass(getPathClass(""First""), ""Second""); println GsonTools.getInstance(true).toJson(pc); ```; I see; ```json; {; ""names"": [; ""First"",; ""Second""; ],; ""color"": [117, 210, 222]; }; ```; which was changed in v0.4 for better readability and easier support in other languages. Also, for deserializing you should use `gson = GsonTools.getInstance()` rather than `new Gson()`, because QuPath installs its own `TypeAdapters` to handle custom classes, including `PathClass`. So I implemented these changes in your script, randomizing the class names to avoid being thwarted by caching:; ```groovy; import qupath.lib.objects.classes.PathClass. for (useLegacyJson in [true, false]) {. String parentName = Math.random() as String; String childName = Math.random() as String; String json; if (useLegacyJson); json = """"""{ ""name"": ""${childName}"", ""parentClass"": {""name"": ""${parentName}""}, ""colorRGB"": 0}""""""; else; json = """"""{ ""names"": [""${parentName}"", ""${childName}""], ""color"": [0, 1, 2]}""""""; ; def gson = GsonTools.getInstance(); PathClass pathClass = gson.fromJson(json, PathClass.class); pathClass = PathClass.getSingleton(pathClass); PathClass parent1 = pathClass.getParentClass(); PathClass parent2 = PathClass.fromString(parentName); ; if (useLegacyJson); println ""With legacy JSON""; else; println ""With v0.4 JSON""; println(""getSingleton: "" + parent1.hashCode() + "" ("" + parent1 + "")""); println(""fromString: "" + parent2.hashCode() + "" ("" + parent2 + "")""); println(""Are equal: "" + (parent1===parent2)) ; println ""----------""; }; ```; From a typical run I see; ```; INFO: With legacy JSON; INFO: getSingleton: 1714766410 (0.07271672325316691); INFO: fromString: 2014375544 (0.07271672325316691); INFO: Are equal: false; INFO: --",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778
https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778:1626,Security,hash,hashCode,1626,"ing you should use `gson = GsonTools.getInstance()` rather than `new Gson()`, because QuPath installs its own `TypeAdapters` to handle custom classes, including `PathClass`. So I implemented these changes in your script, randomizing the class names to avoid being thwarted by caching:; ```groovy; import qupath.lib.objects.classes.PathClass. for (useLegacyJson in [true, false]) {. String parentName = Math.random() as String; String childName = Math.random() as String; String json; if (useLegacyJson); json = """"""{ ""name"": ""${childName}"", ""parentClass"": {""name"": ""${parentName}""}, ""colorRGB"": 0}""""""; else; json = """"""{ ""names"": [""${parentName}"", ""${childName}""], ""color"": [0, 1, 2]}""""""; ; def gson = GsonTools.getInstance(); PathClass pathClass = gson.fromJson(json, PathClass.class); pathClass = PathClass.getSingleton(pathClass); PathClass parent1 = pathClass.getParentClass(); PathClass parent2 = PathClass.fromString(parentName); ; if (useLegacyJson); println ""With legacy JSON""; else; println ""With v0.4 JSON""; println(""getSingleton: "" + parent1.hashCode() + "" ("" + parent1 + "")""); println(""fromString: "" + parent2.hashCode() + "" ("" + parent2 + "")""); println(""Are equal: "" + (parent1===parent2)) ; println ""----------""; }; ```; From a typical run I see; ```; INFO: With legacy JSON; INFO: getSingleton: 1714766410 (0.07271672325316691); INFO: fromString: 2014375544 (0.07271672325316691); INFO: Are equal: false; INFO: ----------; INFO: With v0.4 JSON; INFO: getSingleton: 489320231 (0.016118546223767072); INFO: fromString: 489320231 (0.016118546223767072); INFO: Are equal: true; INFO: ----------; ```. I think this implies that the bug *only* occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself. Does that sound correct?. I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. In the meantime I'm keen to understand when the bug strikes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778
https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778:1695,Security,hash,hashCode,1695,"ing you should use `gson = GsonTools.getInstance()` rather than `new Gson()`, because QuPath installs its own `TypeAdapters` to handle custom classes, including `PathClass`. So I implemented these changes in your script, randomizing the class names to avoid being thwarted by caching:; ```groovy; import qupath.lib.objects.classes.PathClass. for (useLegacyJson in [true, false]) {. String parentName = Math.random() as String; String childName = Math.random() as String; String json; if (useLegacyJson); json = """"""{ ""name"": ""${childName}"", ""parentClass"": {""name"": ""${parentName}""}, ""colorRGB"": 0}""""""; else; json = """"""{ ""names"": [""${parentName}"", ""${childName}""], ""color"": [0, 1, 2]}""""""; ; def gson = GsonTools.getInstance(); PathClass pathClass = gson.fromJson(json, PathClass.class); pathClass = PathClass.getSingleton(pathClass); PathClass parent1 = pathClass.getParentClass(); PathClass parent2 = PathClass.fromString(parentName); ; if (useLegacyJson); println ""With legacy JSON""; else; println ""With v0.4 JSON""; println(""getSingleton: "" + parent1.hashCode() + "" ("" + parent1 + "")""); println(""fromString: "" + parent2.hashCode() + "" ("" + parent2 + "")""); println(""Are equal: "" + (parent1===parent2)) ; println ""----------""; }; ```; From a typical run I see; ```; INFO: With legacy JSON; INFO: getSingleton: 1714766410 (0.07271672325316691); INFO: fromString: 2014375544 (0.07271672325316691); INFO: Are equal: false; INFO: ----------; INFO: With v0.4 JSON; INFO: getSingleton: 489320231 (0.016118546223767072); INFO: fromString: 489320231 (0.016118546223767072); INFO: Are equal: true; INFO: ----------; ```. I think this implies that the bug *only* occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself. Does that sound correct?. I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. In the meantime I'm keen to understand when the bug strikes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670267778
https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461:582,Deployability,install,installation,582,">I think this implies that the bug only occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself.; Does that sound correct?. Yeah, I think that is a correct deduction!. > In the meantime I'm keen to understand when the bug strikes. This bug occurs when I open an image in a project with annotations with derived `PathClass`. These sort of project/images are made with [ABBA's extension](https://github.com/BIOP/qupath-extension-abba), however the bug occurs when opening such images in a QuPath v0.4.3 installation without installed extensions, too.; I am not a developer of ABBA extension, but I'm willing to investigate if you think it's necessary. I just need to understand where the serialized `PathClass`es of a project are saved to file!. > I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. Thanks a ton!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461
https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461:603,Deployability,install,installed,603,">I think this implies that the bug only occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself.; Does that sound correct?. Yeah, I think that is a correct deduction!. > In the meantime I'm keen to understand when the bug strikes. This bug occurs when I open an image in a project with annotations with derived `PathClass`. These sort of project/images are made with [ABBA's extension](https://github.com/BIOP/qupath-extension-abba), however the bug occurs when opening such images in a QuPath v0.4.3 installation without installed extensions, too.; I am not a developer of ABBA extension, but I'm willing to investigate if you think it's necessary. I just need to understand where the serialized `PathClass`es of a project are saved to file!. > I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. Thanks a ton!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461
https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461:943,Deployability,release,release,943,">I think this implies that the bug only occurs when deserializing a PathClass written using the 'earlier' syntax, and doesn't affect a PathClass that was written by v0.4 itself.; Does that sound correct?. Yeah, I think that is a correct deduction!. > In the meantime I'm keen to understand when the bug strikes. This bug occurs when I open an image in a project with annotations with derived `PathClass`. These sort of project/images are made with [ABBA's extension](https://github.com/BIOP/qupath-extension-abba), however the bug occurs when opening such images in a QuPath v0.4.3 installation without installed extensions, too.; I am not a developer of ABBA extension, but I'm willing to investigate if you think it's necessary. I just need to understand where the serialized `PathClass`es of a project are saved to file!. > I'm on leave at the moment, but will explore the PR in more detail in a couple of weeks, and before the next QuPath release. Thanks a ton!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1670347461
https://github.com/qupath/qupath/pull/1286#issuecomment-1687573535:708,Deployability,release,release,708,"Hi all!. I'm trying to understand the bottom line of what seems to be a tricky bug. I do not really understand all of it... what I can tell is simply that Oli (@lacan) helped me to make a 'derived path class' in order to label if a Roi is on the left or on the right part of the brain:. https://github.com/BIOP/qupath-extension-abba/blob/d9384ba7e198a454cb8e9da4661988eac7ee285c/src/main/java/qupath/ext/biop/abba/AtlasTools.java#L248. After, the serialisation was delegated to QuPath, there was nothing custom here. The abba extension has been in use since the v0.3, so both projects with the 0.3 serialization way and projects with the 0.4 serialisation way exist in the wild. Since there won't be any new release of QuPath 0.4, I think I should look at solving this issue in the extension. Is there a way to do that ?. Again, sorry for my lack of understanding, I think I need to spend a full hour to understand it and I do not know when I'll be afford it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1687573535
https://github.com/qupath/qupath/pull/1286#issuecomment-1687573535:143,Usability,simpl,simply,143,"Hi all!. I'm trying to understand the bottom line of what seems to be a tricky bug. I do not really understand all of it... what I can tell is simply that Oli (@lacan) helped me to make a 'derived path class' in order to label if a Roi is on the left or on the right part of the brain:. https://github.com/BIOP/qupath-extension-abba/blob/d9384ba7e198a454cb8e9da4661988eac7ee285c/src/main/java/qupath/ext/biop/abba/AtlasTools.java#L248. After, the serialisation was delegated to QuPath, there was nothing custom here. The abba extension has been in use since the v0.3, so both projects with the 0.3 serialization way and projects with the 0.4 serialisation way exist in the wild. Since there won't be any new release of QuPath 0.4, I think I should look at solving this issue in the extension. Is there a way to do that ?. Again, sorry for my lack of understanding, I think I need to spend a full hour to understand it and I do not know when I'll be afford it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1687573535
https://github.com/qupath/qupath/pull/1286#issuecomment-1691692645:927,Testability,test,test,927,"I've merged this because it definitely seems to fix an important bug, even if it's hard to replicate in isolation because it tends to require QuPath to be restarted in between. I've confirmed that it can affect classifications that are deserialized either from JSON or from Java's serialization (e.g. a .qpdata file). To demonstrate the latter, I set a opened and image and set a derived `PathClass` in a script as follows:; ```groovy; def pathClass = getDerivedPathClass(getPathClass(""Right""), ""Here""); getSelectedObject().setPathClass(pathClass); ```; After saving the data and restarting QuPath, I selected the same object and ran; ```groovy; def right = getPathClass(""Right""); println right === getSelectedObject().getPathClass().getParentClass(); ```; Before the change this prints `false`, indicating that the `PathClass` has been deserialized wrongly. With this PR, it prints `true`. I can't think of a good way to unit test this, but the fix seems important. Thanks @carlocastoldi !",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1691692645
https://github.com/qupath/qupath/pull/1286#issuecomment-1691841233:122,Deployability,release,release,122,Finally we got to the bottom of the problem. Thanks you for the patience and for merging it!. When can we expect the next release?; I'm interested in updating all the old (v0.3) installations of QuPath in my laboratory so that we can all use some scripts i wrote taking advantage of a couple of features of v0.4+ ^^,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1691841233
https://github.com/qupath/qupath/pull/1286#issuecomment-1691841233:178,Deployability,install,installations,178,Finally we got to the bottom of the problem. Thanks you for the patience and for merging it!. When can we expect the next release?; I'm interested in updating all the old (v0.3) installations of QuPath in my laboratory so that we can all use some scripts i wrote taking advantage of a couple of features of v0.4+ ^^,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1286#issuecomment-1691841233
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:395,Integrability,depend,depend,395,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:485,Integrability,depend,dependencies,485,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:688,Integrability,depend,dependency,688,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:821,Modifiability,refactor,refactor,821,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:452,Security,access,access,452,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:542,Security,access,accessing,542,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139:606,Security,authenticat,authentication-using-the-json-api,606,"Thanks!. * Where should we place the `ReaderPool` and `ReaderWrapper` classes? Currently there are in the `servers.bioformats` package, but they are not specific to bio-format. `ReaderPool` seems to be currently - it still has quite a lot of `loci.*` imports, which would prevent it from moving to a more core QuPath module. I think that's fine because it makes sense for the OMERO extension to depend upon the Bio-Formats one - at least for raw pixel access via ICE, since many other dependencies are shared. And if we follow the advice of [accessing pixels by Zarr](https://forum.image.sc/t/java-gateway-authentication-using-the-json-api/84307/8) then we might still have a Bio-Formats dependency via `OMEZarrReader` [as described here](https://forum.image.sc/t/getting-started-with-ome-zarr-in-java/85333). * Should I refactor the BioFormatImageServer to use the best practises we have been discussing? I see this file has a few warnings and the constructor takes 500 lines. Yes, that would be good. But we can merge sooner if it helps. * I will now try to use `ReaderPool` and `ReaderWrapper` in the OMERO extension, so I may have to change a few things if I realize that theses classes are not completely generic. I don't think you need to worry too much about making them very generic - just to work well enough for Bio-Formats and OMERO. They both have a quite different way of returning pixel arrays that I haven't seen elsewhere. Based on the recent forum discussion, I have the impression that the current working Zarr support for Java uses [n5-zarr](https://github.com/saalfeldlab/n5-zarr), which in turn relates to (I think...) imglib2. Since we already plan to explore imglib2, there's a chance that a lot of QuPath's `ImageServer` and image reading code may be replaced if we find better approaches with imglib2.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691869139
https://github.com/qupath/qupath/pull/1287#issuecomment-1691948394:476,Security,access,access,476,"> When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it. It is used with *View &rarr; Show slide label* - but is really only relevant for some file formats (although useful when relevant). It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691948394
https://github.com/qupath/qupath/pull/1287#issuecomment-1691948394:134,Testability,test,test,134,"> When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it. It is used with *View &rarr; Show slide label* - but is really only relevant for some file formats (although useful when relevant). It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1691948394
https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104:737,Availability,avail,available,737,"> > When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it; > ; > It is used with _View → Show slide label_ - but is really only relevant for some file formats (although useful when relevant).; > ; > It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different. Do you know a way to test it? This *Show slide label* window always indicates ""No label available"" with the images I have. Apart from that, I think this pull request can be merged. The bio-format and omero ice image servers seem to be working with these new changes. I may still have to clean the code a bit but I think having the OMERO extension working properly is more important for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104
https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104:486,Security,access,access,486,"> > When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it; > ; > It is used with _View → Show slide label_ - but is really only relevant for some file formats (although useful when relevant).; > ; > It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different. Do you know a way to test it? This *Show slide label* window always indicates ""No label available"" with the images I have. Apart from that, I think this pull request can be merged. The bio-format and omero ice image servers seem to be working with these new changes. I may still have to clean the code a bit but I think having the OMERO extension working properly is more important for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104
https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104:136,Testability,test,test,136,"> > When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it; > ; > It is used with _View → Show slide label_ - but is really only relevant for some file formats (although useful when relevant).; > ; > It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different. Do you know a way to test it? This *Show slide label* window always indicates ""No label available"" with the images I have. Apart from that, I think this pull request can be merged. The bio-format and omero ice image servers seem to be working with these new changes. I may still have to clean the code a bit but I think having the OMERO extension working properly is more important for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104
https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104:670,Testability,test,test,670,"> > When does the `getAssociatedImage(String)` function of `qupath.lib.images.servers.ImageServer` is used? I don't think I was able to test it; > ; > It is used with _View → Show slide label_ - but is really only relevant for some file formats (although useful when relevant).; > ; > It's inspired by the 'associated images' provided by [OpenSlide here](https://openslide.org/api/python/#openslide.OpenSlide.associated_images) - since otherwise QuPath would have had no way to provide access to the label etc. But it doesn't map so easily to images from other readers, including Bio-Formats, which doesn't identify label images as being different. Do you know a way to test it? This *Show slide label* window always indicates ""No label available"" with the images I have. Apart from that, I think this pull request can be merged. The bio-format and omero ice image servers seem to be working with these new changes. I may still have to clean the code a bit but I think having the OMERO extension working properly is more important for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1706263104
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:582,Availability,error,error,582,"Thanks for the feedback!. > The main question (maybe to discuss with @alanocallaghan and @finglis) is whether we should use Optional instead of just returning null. I am slightly in favor of using it sometimes - especially when the return really is optional - but here it seems to be used where throwing an exception would be preferable.; > ; > Returning null can be informative, inasmuch as it suggests we have a sparse image without pixels for every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:703,Availability,error,error,703,"Thanks for the feedback!. > The main question (maybe to discuss with @alanocallaghan and @finglis) is whether we should use Optional instead of just returning null. I am slightly in favor of using it sometimes - especially when the return really is optional - but here it seems to be used where throwing an exception would be preferable.; > ; > Returning null can be informative, inasmuch as it suggests we have a sparse image without pixels for every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:2289,Modifiability,inherit,inheritance,2289,"> ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `ReaderWrapper`, and a parent of `BioFormatsReaderWrapper` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrap",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3568,Modifiability,refactor,refactoring,3568," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3604,Modifiability,refactor,refactoring,3604," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3706,Safety,avoid,avoid,3706," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:998,Testability,log,logic,998,"Thanks for the feedback!. > The main question (maybe to discuss with @alanocallaghan and @finglis) is whether we should use Optional instead of just returning null. I am slightly in favor of using it sometimes - especially when the return really is optional - but here it seems to be used where throwing an exception would be preferable.; > ; > Returning null can be informative, inasmuch as it suggests we have a sparse image without pixels for every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:1477,Testability,log,logic,1477,"or every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `ReaderWrapper`, and a parent of `BioFormatsReaderWrapper` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:2777,Testability,log,logic,2777,"ted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `ReaderWrapper`, and a parent of `BioFormatsReaderWrapper` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3055,Testability,log,logical,3055,"` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic fo",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3130,Testability,log,logic,3130,"r. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I u",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3292,Testability,log,logic,3292," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3976,Testability,log,logic,3976," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:4049,Testability,log,logic,4049," helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic for reading other images. From a Bio-Formats perspective, you might just request the image for a different series. I'm not sure I understood this point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:15,Usability,feedback,feedback,15,"Thanks for the feedback!. > The main question (maybe to discuss with @alanocallaghan and @finglis) is whether we should use Optional instead of just returning null. I am slightly in favor of using it sometimes - especially when the return really is optional - but here it seems to be used where throwing an exception would be preferable.; > ; > Returning null can be informative, inasmuch as it suggests we have a sparse image without pixels for every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:1424,Usability,simpl,simplicity,1424,"or every location - and shouldn't happen whenever there has been an exception. You're right, I was overusing `Optional`. Now, each time an error occurs, an exception is thrown. I kept `Optional` only when a function is not guaranteed to return a result AND no error occurred during its execution. > ReaderWrapper looks very tied to the 'OME' way of doing things (Bio-Formats and OMERO); I'd expect a general image reader to return something more informative than a byte[][], which can only be interpreted with a lot of other return values and Bio-Formats logic. So it isn't very easy to use in a standalone way.; > ; > That isn't in itself a problem, but if writing a general image reader for use with the OMERO web API or [IIIPImage Server](https://iipimage.sourceforge.io/documentation/server) (for example) I imagine it would be far harder to return a byte[][] than a BufferedImage.; > ; > So I think it should either 1) embrace being Bio-Formats/OMERO-specific, and prioritise simplicity, or 2) incorporate more of the processing logic that converts the byte[][] into a BufferedImage, and prioritise reusability. If the goal is for ReaderWrapper and ReaderPool to be reusable, it needs to be easy to generate and work with their return values. I changed `ReaderWrapper` to be as generic as possible (its read function now returns a `BufferedImage`). However, I wanted a `ReaderWrapper` class common to Bio-Formats and OMERO (because they have a lot of code in common), so I created the `OMEReaderWrapper` class (not sure of the name) that is a child of `ReaderWrapper`, and a parent of `BioFormatsReaderWrapper` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979:3037,Usability,clear,clear,3037,"` and `IceOmeroReaderWrapper`. > ReaderPool then is abstract, but has very few abstract methods. One is to create a ReaderWrapper. This probably isn't helpful outside the class. It could also be handled with composition rather than inheritance by passing a Supplier<ReaderWrapper> as an argument to its constructor if really necessary, like when creating a ThreadLocal. If this change is made, ReaderPool could still be subclassed, but wouldn't have to be subclassed. I made `ReaderPool` a concrete class by using a `Supplier` like you suggested (well, not exactly a `Supplier` but a `Callable` because I needed to throw exceptions). I removed the child classes of `ReaderPool`. > Elsewhere ReaderPool contains a lot of logic for image reading, which feels like it belongs in the reader itself - not the pool for managing readers. And it's also quite Bio-Formats-focussed, since the idea of a series within an image is quite Bio-Formats-specific.; > ; > So overall I don't have a clear idea of the logical separation between ReaderWrapper and ReaderPool. It feels like the logic of image reading is now more split across more classes + Bio-Formats itself, and it's quite hard to trace what is happening.; > . I moved the image reading logic from `ReaderPool` to `ReaderWrapper`. > It only supports returning all pixels for all channels simultaneously. In preparation for the future, it would be beneficial to have an API that optionally supports returning individual channels.; > ; > * This isn't needed if the refactoring is minor. But any major refactoring has a chance of regression (in terms of some obscure images failing), so we should try to avoid doing it multiple times. Should I add a `openImage(TileRequest tileRequest, int series, int channel, boolean isRGB, ColorModel colorModel)` function to `ReaderPool`?. > Associated images can sometimes be very big - even pyramidal or with multiple channels. So the logic for reading them doesn't have to be fundamentally different to the logic fo",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1709836979
https://github.com/qupath/qupath/pull/1287#issuecomment-1713942917:344,Security,access,accessing,344,"I marked the comments that I completely understood as resolved. About the rest, am I correct if a recap of what you ask is:; * Metadata parsing is fragmented between `BioFormatsImageServer` and `OMEReaderWrapper` / `OMETileReader`. This should not happen. Metadata should be requested only once and not lazily. * One tile reader should support accessing only one `series`. * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. However I didn't understand where the `OMEPixelParser` class would be in all of this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1713942917
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:268,Availability,down,downloads,268,"> About the rest, am I correct if a recap of what you ask is:; > * Metadata parsing is fragmented between `BioFormatsImageServer` and `OMEReaderWrapper` / `OMETileReader`. This should not happen. Metadata should be requested only once and not lazily. Yes. See https://downloads.openmicroscopy.org/images/Vectra-QPTIFF/perkinelmer/PKI_fields/ and `HnE_3_1x1component_data.tif` for an example where it is a problem. This contains a 32-bit float image, along with an 8-bit thumbnail. If I try to open the thumbnail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get a",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4861,Availability,reliab,reliably,4861,"ed from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4949,Availability,error,error-with-large-images,4949,"ass to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrap",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:3458,Deployability,release,release,3458,". This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsIm",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4533,Deployability,update,update,4533,"` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. I",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1623,Energy Efficiency,reduce,reduce,1623,"reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileReque",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:3072,Energy Efficiency,reduce,reduce,3072,"t's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, bu",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1356,Integrability,synchroniz,synchronization,1356,"elmer/PKI_fields/ and `HnE_3_1x1component_data.tif` for an example where it is a problem. This contains a 32-bit float image, along with an 8-bit thumbnail. If I try to open the thumbnail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1404,Integrability,synchroniz,synchronization,1404," contains a 32-bit float image, along with an 8-bit thumbnail. If I try to open the thumbnail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1643,Integrability,synchroniz,synchronization,1643,"reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileReque",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1870,Integrability,synchroniz,synchronize,1870,"he series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:2011,Integrability,synchroniz,synchronization,2011,"he series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `g",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:2286,Integrability,synchroniz,synchronization,2286,"iving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4013,Integrability,wrap,wrappers,4013,"t assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:5724,Integrability,wrap,wrapper,5724,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:5828,Integrability,wrap,wrapper,5828,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:5853,Integrability,wrap,wrapper,5853,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:5922,Integrability,wrap,wrapper,5922,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:5947,Integrability,wrap,wrapper,5947,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:6016,Integrability,wrap,wrapper,6016,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:6041,Integrability,wrap,wrapper,6041,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:6110,Integrability,wrap,wrapper,6110,"tithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = getCurrentServer().readerPool.getDedicatedReaderWrapper(). println ""Original interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(0); println ""Series 0 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(1); println ""Series 1 interleaved: "" + wrapper.isInterleaved(); wrapper.getReader().setSeries(2); println ""Series 2 interleaved: "" + wrapper.isInterleaved(); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4623,Modifiability,refactor,refactoring,4623,"ed from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is related to the 'interleaved' interpretation: there's no exception thrown, but the image obtained via the PR is incorrect. If you open the image in QuPath, this Groovy script shows that the `isInterleaved()` status changes for different series, which I think is the explanation:. ```groovy; def wrapper = ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1431,Performance,perform,performance,1431," contains a 32-bit float image, along with an 8-bit thumbnail. If I try to open the thumbnail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:2506,Performance,perform,performance,2506," reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** T",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:3408,Safety,safe,safest,3408,"e caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the byte",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4505,Safety,safe,safest,4505,"n be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:733,Security,access,accessing,733,"> About the rest, am I correct if a recap of what you ask is:; > * Metadata parsing is fragmented between `BioFormatsImageServer` and `OMEReaderWrapper` / `OMETileReader`. This should not happen. Metadata should be requested only once and not lazily. Yes. See https://downloads.openmicroscopy.org/images/Vectra-QPTIFF/perkinelmer/PKI_fields/ and `HnE_3_1x1component_data.tif` for an example where it is a problem. This contains a 32-bit float image, along with an 8-bit thumbnail. If I try to open the thumbnail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get a",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1554,Security,access,accessed,1554,"ail with this PR it fails, I believe because it is using a mixture of metadata (i.e. assuming that it has enough bytes for 32-bit data, and failing with an `ArrayIndexOutOfBoundsException`. > * One tile reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in per",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:1759,Security,access,accessed,1759,"reader should support accessing only one `series`. Possibly - it is one option to overcome the issue. Currently, the implementation of `BioFormatsReaderWrapper` in this PR has two `getPixelValues()` methods. One of them sets the series and then resets it back to its original value, the other sets it but doesn't reset it. Without the reset, then the reader has changed into a different state - and the values returned by any call that requests metadata from the reader are subject to giving different results *(example at the end of this post)*. Additionally, both methods are potentially broken in a multithreading context because there is no synchronization done on the reader. . Excessive synchronization could harm performance. Forbidding the series and ID to be changed anywhere inside the class - *and* forbidding the reader from being accessed outside (i.e. not providing a `getReader()` option) - would reduce the need for synchronization, but probably not eliminate it because I am not sure that Bio-Formats guarantees that pixels can be accessed simultaneously from different threads even if the series and ID aren't changed. The alternative is to synchronize everything that uses the reader, and then taking care to design the class in such a way that it's not possible to get around the synchronization. To do that, the `getReader()` option should again be removed. A third option is to make the class *really* minimal and keep the `getReader()` option - but document that it is entirely up to the caller what they do with the reader, and they must take care of synchronization etc. The third option puts much more responsibility on the caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileReque",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:3623,Testability,log,logic,3623," > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about ab",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:4378,Testability,log,logic,4378,"n be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the bytes-to-BufferedImage logic in an entirely threadsafe way, and leave as much as possible of `BioFormatsImageServer` as it is, then that could be the safest way to make a v0.5.0 update and help with the OMERO extension. In general, I am cautious about about extensive refactoring of `BioFormatsImageServer` because I've written so many subtly broken versions of it myself throughout in QuPath's history :) It's really hard to get 'right'; the previous version was messy, but the code seemed to work pretty reliably (well, except for [this...](https://forum.image.sc/t/qupath-stardist-extension-error-with-large-images/80221/19)). ---. I realise it's *incredibly hard* (/ impossible) to write this without failing examples, and most public examples *won't* fail because we get lucky with the different series types. My guess is that .czi is one of the more awkward formats. Based on that, I found another failing example here: https://zenodo.org/record/7149674. Specifically, check out the label and macro images with the PR vs. in QuPath v0.4.4. In this case, the problem is ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547:3395,Usability,simpl,simplest,3395,"e caller, but has the advantage of allowing the same reader to be reused for different images / series. This might have some small improvements in performance (especially if initializing a reader is slow), but could be brittle and easy to get wrong. > * The `T getImage(int series);` function should be removed, and the `T getImage(TileRequest tileRequest, int[] channels, boolean isRGB, ColorModel colorModel, int series)` function should be used instead. Ideally yes. As the `HnE_3_1x1component_data.tif` example, shows, we don't know what kind of image will be returned by `getImage(int series)`, and so having a separate API that assumes a single-resolution, non-pyramidal, 2D image seems to add (rather than reduce) complexity. > However I didn't understand where the `OMEPixelParser` class would be in all of this. As seen with the `HnE_3_1x1component_data.tif` example, we don't know for sure what. I think we should go back to thinking about the *ideal* design here, based upon what needs to be reusable - and also what are the simplest and safest changes that can be made before the v0.5.0 release. My understanding of the original requirements is. 1. **Essential** The OMERO `Gateway` returns byte arrays in a format very similar to Bio-Formats, and the logic convert these into a `BufferedImage` (with suitable `ColorModel` etc.) is complex. This should be extracted from `BioFormatsImageServer` for reuse.; 2. **Nice to have** The `BioFormatsImageServer` also has a reader pool concept, which *might* be beneficial for the OMERO image server as well.; ; Achieving 1. requires a class to do the parsing, but doesn't necessarily require reader wrappers and reader pools at all. These seem to be where the main dangers lie, because Bio-Formats is complex to use in a multithreaded context. On the other hand, the parsing doesn't need to know anything about an `IFormatReader` - it just needs the minimal, immutable info required to convert bytes-to-BufferedImage. If you can extract the byte",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1287#issuecomment-1714232547
https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182:252,Integrability,interface,interface,252,"I couldn't replicate this, although I haven't yet tried with czi images specifically. Does the problem occur with any other kind of images?. Whenever the issue occurs, does *View &rarr; Show log* contain any relevant information? Or are any other user interface elements within QuPath unclickable, or is it just the 'Image' tab?. (Apart from that, note that there's an command *View &rarr; Show slide label* that might be helpful for your workflow.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182
https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182:191,Testability,log,log,191,"I couldn't replicate this, although I haven't yet tried with czi images specifically. Does the problem occur with any other kind of images?. Whenever the issue occurs, does *View &rarr; Show log* contain any relevant information? Or are any other user interface elements within QuPath unclickable, or is it just the 'Image' tab?. (Apart from that, note that there's an command *View &rarr; Show slide label* that might be helpful for your workflow.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182
https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769:901,Integrability,interface,interface,901,"Hi Pete,. This has happened with Aperio svs images as well. In that specific case, it; was the Annotation tab that became unclickable (I was probably in the; process of creating many ROIs in a short period of time, or checking; something to do with the Annotaions). I did not check the log,; unfortunately. Next time it happens, I’ll be sure to see if something there; pops up and let you know. As far as I can tell, it is just the tab I was using frequently that; becomes unclickable. The other tabs and buttons are still functional. Thank you for the command tip!. Best,. Kristin. On Sat, Aug 12, 2023 at 3:46 AM Pete ***@***.***> wrote:. > I couldn't replicate this, although I haven't yet tried with czi images; > specifically. Does the problem occur with any other kind of images?; >; > Whenever the issue occurs, does *View → Show log* contain any relevant; > information? Or are any other user interface elements within QuPath; > unclickable, or is it just the 'Image' tab?; >; > (Apart from that, note that there's an command *View → Show slide label*; > that might be helpful for your workflow.); >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AUUIDLYPMLAAW5VXSI2FH2DXU4YGTANCNFSM6AAAAAA3LVSPFM>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >; -- ; Kristin Gallik, Ph.D",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769
https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769:1426,Integrability,Message,Message,1426,"Hi Pete,. This has happened with Aperio svs images as well. In that specific case, it; was the Annotation tab that became unclickable (I was probably in the; process of creating many ROIs in a short period of time, or checking; something to do with the Annotaions). I did not check the log,; unfortunately. Next time it happens, I’ll be sure to see if something there; pops up and let you know. As far as I can tell, it is just the tab I was using frequently that; becomes unclickable. The other tabs and buttons are still functional. Thank you for the command tip!. Best,. Kristin. On Sat, Aug 12, 2023 at 3:46 AM Pete ***@***.***> wrote:. > I couldn't replicate this, although I haven't yet tried with czi images; > specifically. Does the problem occur with any other kind of images?; >; > Whenever the issue occurs, does *View → Show log* contain any relevant; > information? Or are any other user interface elements within QuPath; > unclickable, or is it just the 'Image' tab?; >; > (Apart from that, note that there's an command *View → Show slide label*; > that might be helpful for your workflow.); >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AUUIDLYPMLAAW5VXSI2FH2DXU4YGTANCNFSM6AAAAAA3LVSPFM>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >; -- ; Kristin Gallik, Ph.D",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769
https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769:286,Testability,log,log,286,"Hi Pete,. This has happened with Aperio svs images as well. In that specific case, it; was the Annotation tab that became unclickable (I was probably in the; process of creating many ROIs in a short period of time, or checking; something to do with the Annotaions). I did not check the log,; unfortunately. Next time it happens, I’ll be sure to see if something there; pops up and let you know. As far as I can tell, it is just the tab I was using frequently that; becomes unclickable. The other tabs and buttons are still functional. Thank you for the command tip!. Best,. Kristin. On Sat, Aug 12, 2023 at 3:46 AM Pete ***@***.***> wrote:. > I couldn't replicate this, although I haven't yet tried with czi images; > specifically. Does the problem occur with any other kind of images?; >; > Whenever the issue occurs, does *View → Show log* contain any relevant; > information? Or are any other user interface elements within QuPath; > unclickable, or is it just the 'Image' tab?; >; > (Apart from that, note that there's an command *View → Show slide label*; > that might be helpful for your workflow.); >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AUUIDLYPMLAAW5VXSI2FH2DXU4YGTANCNFSM6AAAAAA3LVSPFM>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >; -- ; Kristin Gallik, Ph.D",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769
https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769:837,Testability,log,log,837,"Hi Pete,. This has happened with Aperio svs images as well. In that specific case, it; was the Annotation tab that became unclickable (I was probably in the; process of creating many ROIs in a short period of time, or checking; something to do with the Annotaions). I did not check the log,; unfortunately. Next time it happens, I’ll be sure to see if something there; pops up and let you know. As far as I can tell, it is just the tab I was using frequently that; becomes unclickable. The other tabs and buttons are still functional. Thank you for the command tip!. Best,. Kristin. On Sat, Aug 12, 2023 at 3:46 AM Pete ***@***.***> wrote:. > I couldn't replicate this, although I haven't yet tried with czi images; > specifically. Does the problem occur with any other kind of images?; >; > Whenever the issue occurs, does *View → Show log* contain any relevant; > information? Or are any other user interface elements within QuPath; > unclickable, or is it just the 'Image' tab?; >; > (Apart from that, note that there's an command *View → Show slide label*; > that might be helpful for your workflow.); >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1288#issuecomment-1675771182>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AUUIDLYPMLAAW5VXSI2FH2DXU4YGTANCNFSM6AAAAAA3LVSPFM>; > .; > You are receiving this because you authored the thread.Message ID:; > ***@***.***>; >; -- ; Kristin Gallik, Ph.D",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1675900769
https://github.com/qupath/qupath/issues/1288#issuecomment-1714301244:149,Testability,log,log,149,"I'll close this issue because it hasn't been possible to reproduce it. @kgallik please feel free to reopen if you find an explanation, info from the log, or steps we can use to recreate the problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1714301244
https://github.com/qupath/qupath/issues/1288#issuecomment-1721348517:145,Deployability,update,updated,145,Hi Mike and Pete. Thanks for looking into it. I haven't been able to get the issue to reproduce on my end either since I made the report. I also updated to 4.4 and haven't encountered the issue with this version either. Perhaps it was just a weird day with a strange software gremlin. 🤷🏼,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1288#issuecomment-1721348517
https://github.com/qupath/qupath/issues/1289#issuecomment-1675769245:303,Safety,risk,risk,303,"Can you explain in more detail what would need to change to support this?. I don't have much experience of OMERO tags, but it sounds like what you're suggesting could either be handled entirely in the OMERO extension already (using QuPath's existing metadata support for project entries), or else could risk projects becoming more OMERO-specific (which I'd like to avoid).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1675769245
https://github.com/qupath/qupath/issues/1289#issuecomment-1675769245:365,Safety,avoid,avoid,365,"Can you explain in more detail what would need to change to support this?. I don't have much experience of OMERO tags, but it sounds like what you're suggesting could either be handled entirely in the OMERO extension already (using QuPath's existing metadata support for project entries), or else could risk projects becoming more OMERO-specific (which I'd like to avoid).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1675769245
https://github.com/qupath/qupath/issues/1289#issuecomment-1687567852:382,Safety,safe,safe,382,"> Actually, tags are one key-word annotation. Ah... makes sense. > My suggestion is to add a one-keyword metadata field. Sounds sensible, but I wonder is it possible that people will then want tags with different interpretations?. The alternative I'm thinking is to simply have a dictionary entry ; ```json; {; ""omeroTags"": ""tag1, tag2, tag3""; }; ```; but I don't know whether it's safe to use a comma (or anything else) as a delimiter. Otherwise, I guess there could be a general `tags` list in a QuPath project entry. Do you think either option is strongly preferable to the other?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687567852
https://github.com/qupath/qupath/issues/1289#issuecomment-1687567852:266,Usability,simpl,simply,266,"> Actually, tags are one key-word annotation. Ah... makes sense. > My suggestion is to add a one-keyword metadata field. Sounds sensible, but I wonder is it possible that people will then want tags with different interpretations?. The alternative I'm thinking is to simply have a dictionary entry ; ```json; {; ""omeroTags"": ""tag1, tag2, tag3""; }; ```; but I don't know whether it's safe to use a comma (or anything else) as a delimiter. Otherwise, I guess there could be a general `tags` list in a QuPath project entry. Do you think either option is strongly preferable to the other?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687567852
https://github.com/qupath/qupath/issues/1289#issuecomment-1687762439:269,Safety,safe,safe,269,"> but I wonder is it possible that people will then want tags with different interpretations?. Yes, this is also true. > The alternative I'm thinking is to simply have a dictionary entry; > {; > ""omeroTags"": ""tag1, tag2, tag3""; > }; > ; > but I don't know whether it's safe to use a comma (or anything else) as a delimiter. Actually, I already thought of the solution but our final goal would be to sort the images within the current project according to one or more tags. > Otherwise, I guess there could be a general tags list in a QuPath project entry. I would rather go for this solution as I think it is the best way to make them independant and searchable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687762439
https://github.com/qupath/qupath/issues/1289#issuecomment-1687762439:156,Usability,simpl,simply,156,"> but I wonder is it possible that people will then want tags with different interpretations?. Yes, this is also true. > The alternative I'm thinking is to simply have a dictionary entry; > {; > ""omeroTags"": ""tag1, tag2, tag3""; > }; > ; > but I don't know whether it's safe to use a comma (or anything else) as a delimiter. Actually, I already thought of the solution but our final goal would be to sort the images within the current project according to one or more tags. > Otherwise, I guess there could be a general tags list in a QuPath project entry. I would rather go for this solution as I think it is the best way to make them independant and searchable.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687762439
https://github.com/qupath/qupath/issues/1289#issuecomment-1687774301:98,Testability,log,logic,98,"How would the sorting look? Would there need to be multi-level sorting?. QuPath's current sorting logic based upon the 'metadata' dictionary is... not great. I don't think it can really increase in complexity without breaking, so my feeling is we should also think broadly about how projects are displayed, sorted, and incorporate both metadata and tags.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687774301
https://github.com/qupath/qupath/issues/1289#issuecomment-1687972577:258,Testability,log,logic,258,"Well, with the current way of sorting, I wasn't expect more than one-level sorting (i.e. sort by tag1, or tag2).; Ideally, it would be great to sort by more than one tag (i.e. sort by tag1 and tag2, like the way it is done in OMERO => multiple levels). This logic could also be mimic for metadata by having multiple nested expend trees. ![qptags](https://github.com/qupath/qupath/assets/64911638/89702ef5-d6fa-43eb-8216-e6e14fbb7b82). I think both metadata and tag could follow the same sorting logic. The key(s) / tag(s) used to sort the images could be written in the project tab, like in this example. ![qptags_sorting_logic](https://github.com/qupath/qupath/assets/64911638/3ed30659-760f-4e5e-b920-73bf806d386f). Also, having a default option to sort by image name would be nice :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687972577
https://github.com/qupath/qupath/issues/1289#issuecomment-1687972577:495,Testability,log,logic,495,"Well, with the current way of sorting, I wasn't expect more than one-level sorting (i.e. sort by tag1, or tag2).; Ideally, it would be great to sort by more than one tag (i.e. sort by tag1 and tag2, like the way it is done in OMERO => multiple levels). This logic could also be mimic for metadata by having multiple nested expend trees. ![qptags](https://github.com/qupath/qupath/assets/64911638/89702ef5-d6fa-43eb-8216-e6e14fbb7b82). I think both metadata and tag could follow the same sorting logic. The key(s) / tag(s) used to sort the images could be written in the project tab, like in this example. ![qptags_sorting_logic](https://github.com/qupath/qupath/assets/64911638/3ed30659-760f-4e5e-b920-73bf806d386f). Also, having a default option to sort by image name would be nice :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1289#issuecomment-1687972577
https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114:161,Availability,error,error,161,"Hi @GiuseppeAntoniazzi, as indicated during issue creation, non-bugs are better for the forum. As an aside, it is also far more helpful to post the text of your error messages rather than a screenshot, as screenshots cannot be searched or copied from.; The error itself indicates that you have created objects with negative area and sounds like the sort of thing that happens with Warpy or transforming objects from another image resulting in the objects existing partially outside of the image area. I found [this forum post ](https://forum.image.sc/t/too-many-annotations-gives-me-data-export-error/81659/5?u=mike_nelson)when searching for the error. . You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems.See this forum post. You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems. Either way, this does not sound like a bug with QuPath, but more specific to your use case, and thus better placed on the forum.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114
https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114:257,Availability,error,error,257,"Hi @GiuseppeAntoniazzi, as indicated during issue creation, non-bugs are better for the forum. As an aside, it is also far more helpful to post the text of your error messages rather than a screenshot, as screenshots cannot be searched or copied from.; The error itself indicates that you have created objects with negative area and sounds like the sort of thing that happens with Warpy or transforming objects from another image resulting in the objects existing partially outside of the image area. I found [this forum post ](https://forum.image.sc/t/too-many-annotations-gives-me-data-export-error/81659/5?u=mike_nelson)when searching for the error. . You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems.See this forum post. You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems. Either way, this does not sound like a bug with QuPath, but more specific to your use case, and thus better placed on the forum.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114
https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114:595,Availability,error,error,595,"Hi @GiuseppeAntoniazzi, as indicated during issue creation, non-bugs are better for the forum. As an aside, it is also far more helpful to post the text of your error messages rather than a screenshot, as screenshots cannot be searched or copied from.; The error itself indicates that you have created objects with negative area and sounds like the sort of thing that happens with Warpy or transforming objects from another image resulting in the objects existing partially outside of the image area. I found [this forum post ](https://forum.image.sc/t/too-many-annotations-gives-me-data-export-error/81659/5?u=mike_nelson)when searching for the error. . You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems.See this forum post. You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems. Either way, this does not sound like a bug with QuPath, but more specific to your use case, and thus better placed on the forum.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114
https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114:646,Availability,error,error,646,"Hi @GiuseppeAntoniazzi, as indicated during issue creation, non-bugs are better for the forum. As an aside, it is also far more helpful to post the text of your error messages rather than a screenshot, as screenshots cannot be searched or copied from.; The error itself indicates that you have created objects with negative area and sounds like the sort of thing that happens with Warpy or transforming objects from another image resulting in the objects existing partially outside of the image area. I found [this forum post ](https://forum.image.sc/t/too-many-annotations-gives-me-data-export-error/81659/5?u=mike_nelson)when searching for the error. . You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems.See this forum post. You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems. Either way, this does not sound like a bug with QuPath, but more specific to your use case, and thus better placed on the forum.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114
https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114:167,Integrability,message,messages,167,"Hi @GiuseppeAntoniazzi, as indicated during issue creation, non-bugs are better for the forum. As an aside, it is also far more helpful to post the text of your error messages rather than a screenshot, as screenshots cannot be searched or copied from.; The error itself indicates that you have created objects with negative area and sounds like the sort of thing that happens with Warpy or transforming objects from another image resulting in the objects existing partially outside of the image area. I found [this forum post ](https://forum.image.sc/t/too-many-annotations-gives-me-data-export-error/81659/5?u=mike_nelson)when searching for the error. . You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems.See this forum post. You do seem to have a very large number of tiles, so if your tile size is close to a single pixel, that also might be causing problems. Either way, this does not sound like a bug with QuPath, but more specific to your use case, and thus better placed on the forum.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1679084114
https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165:114,Availability,error,error,114,"I can't replicate this issue. @GiuseppeAntoniazzi can you provide more detailed step-by-step instructions see the error?. It helps if the error can be reproduced using a publicly-available image, e.g. one from https://qupath.readthedocs.io/en/0.4/docs/intro/acknowledgements.html. If this isn't possible, then it would help to provide the actual objects you are using. These can be exported using *File &rarr; Export objects as GeoJSON*",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165
https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165:138,Availability,error,error,138,"I can't replicate this issue. @GiuseppeAntoniazzi can you provide more detailed step-by-step instructions see the error?. It helps if the error can be reproduced using a publicly-available image, e.g. one from https://qupath.readthedocs.io/en/0.4/docs/intro/acknowledgements.html. If this isn't possible, then it would help to provide the actual objects you are using. These can be exported using *File &rarr; Export objects as GeoJSON*",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165
https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165:179,Availability,avail,available,179,"I can't replicate this issue. @GiuseppeAntoniazzi can you provide more detailed step-by-step instructions see the error?. It helps if the error can be reproduced using a publicly-available image, e.g. one from https://qupath.readthedocs.io/en/0.4/docs/intro/acknowledgements.html. If this isn't possible, then it would help to provide the actual objects you are using. These can be exported using *File &rarr; Export objects as GeoJSON*",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1290#issuecomment-1685767165
https://github.com/qupath/qupath/pull/1298#issuecomment-1691277627:296,Testability,benchmark,benchmark,296,"Nice regex :). Makes me a bit nervous, since I'm not aware of anything currently being broken. Definitely worth considering `File.exists()` instead of `Files.exists(path)` when it's called a lot in a loop (and I guess anything *could* be called a lot in a loop by other code). Any way to quickly benchmark the difference?. I guess we also want to know if one method is substantially faster or slower for checking files over a network, as well as local files. (Conceivably we might also add our own method, e.g. `GeneralTools.checkFileExists()` or something and then use our preferred implementation in one place... but not sure if that's just adding awkwardness.)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691277627
https://github.com/qupath/qupath/pull/1298#issuecomment-1691285421:106,Performance,perform,performance,106,"I'll benchmark Files.exists(file) vs file.exists() locally later, though it'll probably be worth checking performance on a samba mount as well as nfs/sshfs",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691285421
https://github.com/qupath/qupath/pull/1298#issuecomment-1691285421:5,Testability,benchmark,benchmark,5,"I'll benchmark Files.exists(file) vs file.exists() locally later, though it'll probably be worth checking performance on a samba mount as well as nfs/sshfs",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691285421
https://github.com/qupath/qupath/pull/1298#issuecomment-1691547995:57,Testability,benchmark,benchmarking,57,"I got curious too and tried an extremely rough and messy benchmarking as well - `Files.exist(path)` was quicker for me too (although I checked the same files multiple times, and lots of files that didn't exist). Maybe a Windows, Java version, or network issue...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691547995
https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799:600,Availability,checkpoint,checkpointAndRun,600,"I was seeing a bigger difference (`Files.exist(path)` taking about 1/3 the time). Here's my awful test, run through QuPath:. ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 10000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }. ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799
https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799:672,Availability,checkpoint,checkpointAndRun,672,"I was seeing a bigger difference (`Files.exist(path)` taking about 1/3 the time). Here's my awful test, run through QuPath:. ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 10000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }. ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799
https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799:98,Testability,test,test,98,"I was seeing a bigger difference (`Files.exist(path)` taking about 1/3 the time). Here's my awful test, run through QuPath:. ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 10000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=0) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }. ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691548799
https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026:52,Availability,reboot,reboot,52,Should revisit this and print the counts (I need to reboot to switch OS). On Ubuntu:. ```; INFO: Starting script at Thu Aug 24 14:00:58 BST 2023; INFO: Same: true; INFO: Paths 	4.703 s; Files 	3.655 s; Total duration	8.358 s; Average per checkpoint: 4.179 s; INFO: Total run time: 10.93 seconds; ```. On windows:. ```; INFO: Same: true; INFO: Paths 	37.279 s; Files 	17.887 s; Total duration	55.166 s; Average per checkpoint: 27.583 s; ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026
https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026:238,Availability,checkpoint,checkpoint,238,Should revisit this and print the counts (I need to reboot to switch OS). On Ubuntu:. ```; INFO: Starting script at Thu Aug 24 14:00:58 BST 2023; INFO: Same: true; INFO: Paths 	4.703 s; Files 	3.655 s; Total duration	8.358 s; Average per checkpoint: 4.179 s; INFO: Total run time: 10.93 seconds; ```. On windows:. ```; INFO: Same: true; INFO: Paths 	37.279 s; Files 	17.887 s; Total duration	55.166 s; Average per checkpoint: 27.583 s; ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026
https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026:414,Availability,checkpoint,checkpoint,414,Should revisit this and print the counts (I need to reboot to switch OS). On Ubuntu:. ```; INFO: Starting script at Thu Aug 24 14:00:58 BST 2023; INFO: Same: true; INFO: Paths 	4.703 s; Files 	3.655 s; Total duration	8.358 s; Average per checkpoint: 4.179 s; INFO: Total run time: 10.93 seconds; ```. On windows:. ```; INFO: Same: true; INFO: Paths 	37.279 s; Files 	17.887 s; Total duration	55.166 s; Average per checkpoint: 27.583 s; ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691595026
https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125:678,Availability,checkpoint,checkpointAndRun,678,"Slightly updated script showing there is indeed some badness going on (note the counts don't match!). ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 1000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))); println(""Count files: "" + countFilesExist(files)); println(""Count paths: "" + countPathsExist(paths)). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }; ```. Windows:; ```; INFO: Same: false; INFO: Count files: 51; INFO: Count paths: 38; INFO: Paths 	4.273 s; Files 	1.838 s; Total duration	6.111 s; Average per checkpoint: 3.055 s; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125
https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125:750,Availability,checkpoint,checkpointAndRun,750,"Slightly updated script showing there is indeed some badness going on (note the counts don't match!). ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 1000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))); println(""Count files: "" + countFilesExist(files)); println(""Count paths: "" + countPathsExist(paths)). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }; ```. Windows:; ```; INFO: Same: false; INFO: Count files: 51; INFO: Count paths: 38; INFO: Paths 	4.273 s; Files 	1.838 s; Total duration	6.111 s; Average per checkpoint: 3.055 s; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125
https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125:1429,Availability,checkpoint,checkpoint,1429,"Slightly updated script showing there is indeed some badness going on (note the counts don't match!). ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 1000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))); println(""Count files: "" + countFilesExist(files)); println(""Count paths: "" + countPathsExist(paths)). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }; ```. Windows:; ```; INFO: Same: false; INFO: Count files: 51; INFO: Count paths: 38; INFO: Paths 	4.273 s; Files 	1.838 s; Total duration	6.111 s; Average per checkpoint: 3.055 s; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125
https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125:9,Deployability,update,updated,9,"Slightly updated script showing there is indeed some badness going on (note the counts don't match!). ```groovy; import groovy.transform.CompileStatic; import qupath.lib.common.Timeit. import java.nio.file.Files; import java.nio.file.Path. List<File> files = new File(System.getProperty(""user.home"")).listFiles() as List. for (int i = 0; i < 10; i++); files.add(new File(Math.random() as String)). List<Path> paths = files.collect(f -> f.toPath()) as List. int nIterations = 1000; println(""Same: "" + (countFilesExist(files) == countPathsExist(paths))); println(""Count files: "" + countFilesExist(files)); println(""Count paths: "" + countPathsExist(paths)). println new Timeit(); .checkpointAndRun(""Paths "", () -> countPathsExist(paths, nIterations)); .checkpointAndRun(""Files "", () -> countFilesExist(files, nIterations)); .stop(); .summarizeCheckpoints(). @CompileStatic; int countFilesExist(List<File> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (f.exists()); count++;; }; }; return count;; }. @CompileStatic; int countPathsExist(List<Path> files, int iterations=1) {; int count = 0;; for (int i = 0; i < iterations; i++) {; for (def f : files) {; if (Files.exists(f)); count++;; }; }; return count;; }; ```. Windows:; ```; INFO: Same: false; INFO: Count files: 51; INFO: Count paths: 38; INFO: Paths 	4.273 s; Files 	1.838 s; Total duration	6.111 s; Average per checkpoint: 3.055 s; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691680125
https://github.com/qupath/qupath/pull/1298#issuecomment-1691717326:289,Availability,checkpoint,checkpoint,289,"Ubuntu/PopOS results, pretty much what I expected, more files less time, no inconsistency:. ```; INFO: Starting script at Thu Aug 24 14:47:27 BST 2023; INFO: Same: true; INFO: Count files: 208; INFO: Count paths: 208; INFO: Paths 	598 ms; Files 	319 ms; Total duration	917 ms; Average per checkpoint: 458 ms; INFO: Total run time: 2.68 seconds; ```. > Also... why do they not match?!?. The unholy combination that is Windows and Java, I guess",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691717326
https://github.com/qupath/qupath/pull/1298#issuecomment-1691770235:169,Security,access,accessible,169,"The files that mismatch are things like `C:\Users\alano\Application Data`, which doesn't seem to exist, at least when I paste it into explorer I get `[directory] is not accessible. Access is denied`, and they're not visible when viewing the parent dir in explorer or cmd. Somewhat bizarre behaviour, can chalk it up to Windows I think",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691770235
https://github.com/qupath/qupath/pull/1298#issuecomment-1691770235:181,Security,Access,Access,181,"The files that mismatch are things like `C:\Users\alano\Application Data`, which doesn't seem to exist, at least when I paste it into explorer I get `[directory] is not accessible. Access is denied`, and they're not visible when viewing the parent dir in explorer or cmd. Somewhat bizarre behaviour, can chalk it up to Windows I think",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691770235
https://github.com/qupath/qupath/pull/1298#issuecomment-1691801388:379,Performance,perform,performance,379,"Hmmm, in that case though we might prefer `paths` for not creating the impression that they exist?. I have the impression there isn't a clear winner here, and so I tend towards prefering `Files.exist` for its modern nature (and I see the implementation is at least partly different in an upcoming JDK) - although that could change it one turns out to have exceptionally horrible performance, e.g. for a network share.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691801388
https://github.com/qupath/qupath/pull/1298#issuecomment-1691801388:136,Usability,clear,clear,136,"Hmmm, in that case though we might prefer `paths` for not creating the impression that they exist?. I have the impression there isn't a clear winner here, and so I tend towards prefering `Files.exist` for its modern nature (and I see the implementation is at least partly different in an upcoming JDK) - although that could change it one turns out to have exceptionally horrible performance, e.g. for a network share.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1298#issuecomment-1691801388
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:151,Deployability,release,release,151,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:220,Deployability,release,release,220,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:809,Deployability,update,update,809,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:263,Testability,test,tests,263,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:326,Testability,test,tests,326,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030:965,Testability,test,tests,965,"Because I'm not great with git :) Could probably have cherry-picked it, but `main` has a *lot* of other changes, since the intention was that the next release would be v0.5.0 - and these should not be part of any v0.4.4 release. My aim this morning was to create tests, working off the original v0.4.3 code to ensure that the tests were failing initially. This revealed another issue that wasn't covered through your fix (namely that deserializing a `PathClass` only works properly via a `PathObject`). So I approached it a different way by first introducing a new `PathClass.readResolve()` method, which solved that problem and also most of the original issue. I then found it was still possible to work around the use of `readResolve()` alone when deserializing legacy JSON - so I followed your approach to update the `getSingleton` method as you'd suggested as well to try to cover all scenarios. The end result is that there are now 4 different deserialization tests, but it required the combination of approaches to pass all of them.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1307#issuecomment-1699143030
https://github.com/qupath/qupath/issues/1309#issuecomment-1703759077:266,Deployability,release,releases,266,"I have replicated the issue on:; * MacBook Pro (M1, macOS Ventura 13.5.1); * MacBook Pro (Intel, macOS Big Sur 11.7.9). I could **not** replicate it on a Windows 10 laptop - colors using both screenshot methods were identical. Therefore it seems to affect all macOS releases, but probably not other platforms (although Linux hasn't been checked yet).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1309#issuecomment-1703759077
https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614:389,Availability,down,downloading,389,"> my Mac automatically offloads them to the cloud if I haven't opened them for a few days. My best guess is that there is a cloud-related factor. Where is the project stored - is it only on your local computer, or is it also in OneDrive/iCloud/similar?. If the project is in a cloud folder, please try copying it to a local directory that doesn't experience any automatic cloud-offloading/downloading. Also, when this happens, please check under *View &rarr; Show log* for any messages or other information that could be helpful.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614
https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614:477,Integrability,message,messages,477,"> my Mac automatically offloads them to the cloud if I haven't opened them for a few days. My best guess is that there is a cloud-related factor. Where is the project stored - is it only on your local computer, or is it also in OneDrive/iCloud/similar?. If the project is in a cloud folder, please try copying it to a local directory that doesn't experience any automatic cloud-offloading/downloading. Also, when this happens, please check under *View &rarr; Show log* for any messages or other information that could be helpful.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614
https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614:464,Testability,log,log,464,"> my Mac automatically offloads them to the cloud if I haven't opened them for a few days. My best guess is that there is a cloud-related factor. Where is the project stored - is it only on your local computer, or is it also in OneDrive/iCloud/similar?. If the project is in a cloud folder, please try copying it to a local directory that doesn't experience any automatic cloud-offloading/downloading. Also, when this happens, please check under *View &rarr; Show log* for any messages or other information that could be helpful.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1705956614
https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325:439,Safety,safe,safer,439,"Hi Pete,. Thank you for the swift reply! The actual project file itself is stored in a local-only folder, since it is a much smaller size than the image files themselves. I apologize for not including the log, I was in full panic mode when I first realized what had happened and didn't think about looking through the log or at the version until much later. Do you think there is any way to get this data back? And do you think it will be safer if I have everything on an external hard drive for my next project, including all image and project files? I can also make individual project files for each image to avoid losing too much data at once, but that seems like a pretty time-consuming/ computationally intense option.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325
https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325:611,Safety,avoid,avoid,611,"Hi Pete,. Thank you for the swift reply! The actual project file itself is stored in a local-only folder, since it is a much smaller size than the image files themselves. I apologize for not including the log, I was in full panic mode when I first realized what had happened and didn't think about looking through the log or at the version until much later. Do you think there is any way to get this data back? And do you think it will be safer if I have everything on an external hard drive for my next project, including all image and project files? I can also make individual project files for each image to avoid losing too much data at once, but that seems like a pretty time-consuming/ computationally intense option.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325
https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325:205,Testability,log,log,205,"Hi Pete,. Thank you for the swift reply! The actual project file itself is stored in a local-only folder, since it is a much smaller size than the image files themselves. I apologize for not including the log, I was in full panic mode when I first realized what had happened and didn't think about looking through the log or at the version until much later. Do you think there is any way to get this data back? And do you think it will be safer if I have everything on an external hard drive for my next project, including all image and project files? I can also make individual project files for each image to avoid losing too much data at once, but that seems like a pretty time-consuming/ computationally intense option.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325
https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325:318,Testability,log,log,318,"Hi Pete,. Thank you for the swift reply! The actual project file itself is stored in a local-only folder, since it is a much smaller size than the image files themselves. I apologize for not including the log, I was in full panic mode when I first realized what had happened and didn't think about looking through the log or at the version until much later. Do you think there is any way to get this data back? And do you think it will be safer if I have everything on an external hard drive for my next project, including all image and project files? I can also make individual project files for each image to avoid losing too much data at once, but that seems like a pretty time-consuming/ computationally intense option.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1706882325
https://github.com/qupath/qupath/issues/1313#issuecomment-1706900693:237,Usability,usab,usable,237,"QuPath already stores the data for each image in separate files called `data.qpdata`, so splitting up the project probably won't help. You can find these `data.qpdata` files by hunting through the subfolders of your project. If they are usable, it should be possible to open a `data.qpdata` file by dragging it onto QuPath directly (ideally without a project open, since otherwise QuPath will attempt to import the image to the project). Working off a local disk should be best, especially for project data. The images *can* be elsewhere, but using cloud storage can be really troublesome - unless you've made sure that they are also kept on your device, and there is no possibility of them being automatically offloaded. The file format of your images may also be relevant: .mrxs and .vsi have lots of little files for a single image, which complicates things even more with cloud storage since some might be present and some not. The forum is probably a better place to discuss that, since lots more users are active there, and using QuPath in different scenarios to me: https://forum.image.sc/tag/qupath",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1313#issuecomment-1706900693
https://github.com/qupath/qupath/pull/1316#issuecomment-1708403361:31,Modifiability,refactor,refactoring,31,Looks good. ; I'm assuming the refactoring would address the pane changing slightly on the second open? ; ![image](https://github.com/qupath/qupath/assets/42358257/c7235023-f29e-43d3-ab20-2c422a2a7cb4); vs; ![image](https://github.com/qupath/qupath/assets/42358257/a525b76b-e3ab-4d39-ab08-2495525a9887),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1316#issuecomment-1708403361
https://github.com/qupath/qupath/pull/1316#issuecomment-1708431678:129,Availability,down,down,129,"Potentially, although I'm not seeing any difference on my Mac. . Made a small guess and something that would help - can you pull down the latest code and try it out please?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1316#issuecomment-1708431678
https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939:168,Availability,mainten,maintenance,168,"> Is this a feature anyone really wants?. The answer to that is almost always ""yes""; the better question is whether it is worthwhile to implement given the refactoring/maintenance burden it entails. > Is it likely to be more helpful or confusing for new users?. It seems like the sort of thing that would be confusing if done accidentally, so we should try to make that difficult if possible, but as Leo says in imaging software it's common to have multiple images open. > Detaching one viewer (and leaving the rest of the 'viewer grid' intact). Does this mean that you'd have (eg) one button that toggles visible annotations on both images? If so, this seems restrictive, though I don't know if it would be annoyingly so. > Breaking up the UI entirely, so that there is no longer a grid and instead we have separate windows (including for the toolbar and analysis pane, more like ImageJ). It seems to me like at least some UI elements should be broken up across windows. For example I'd want to be able to view/edit the object hierarchy in each image separately (e.g. for training classifiers). If we wanted to emulate the other mode you described, then being able to hide UI elements would be a good start. > Is there a need to have the same image open in multiple viewers? . Probably a natural behaviour, as long as we lock the imageData when a viewer is interacting with it. There's a related issue in here to improve support for QuPath windows in tiling window managers, but I suspect I'm the only person who cares about that right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939
https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939:598,Deployability,toggle,toggles,598,"> Is this a feature anyone really wants?. The answer to that is almost always ""yes""; the better question is whether it is worthwhile to implement given the refactoring/maintenance burden it entails. > Is it likely to be more helpful or confusing for new users?. It seems like the sort of thing that would be confusing if done accidentally, so we should try to make that difficult if possible, but as Leo says in imaging software it's common to have multiple images open. > Detaching one viewer (and leaving the rest of the 'viewer grid' intact). Does this mean that you'd have (eg) one button that toggles visible annotations on both images? If so, this seems restrictive, though I don't know if it would be annoyingly so. > Breaking up the UI entirely, so that there is no longer a grid and instead we have separate windows (including for the toolbar and analysis pane, more like ImageJ). It seems to me like at least some UI elements should be broken up across windows. For example I'd want to be able to view/edit the object hierarchy in each image separately (e.g. for training classifiers). If we wanted to emulate the other mode you described, then being able to hide UI elements would be a good start. > Is there a need to have the same image open in multiple viewers? . Probably a natural behaviour, as long as we lock the imageData when a viewer is interacting with it. There's a related issue in here to improve support for QuPath windows in tiling window managers, but I suspect I'm the only person who cares about that right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939
https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939:156,Modifiability,refactor,refactoring,156,"> Is this a feature anyone really wants?. The answer to that is almost always ""yes""; the better question is whether it is worthwhile to implement given the refactoring/maintenance burden it entails. > Is it likely to be more helpful or confusing for new users?. It seems like the sort of thing that would be confusing if done accidentally, so we should try to make that difficult if possible, but as Leo says in imaging software it's common to have multiple images open. > Detaching one viewer (and leaving the rest of the 'viewer grid' intact). Does this mean that you'd have (eg) one button that toggles visible annotations on both images? If so, this seems restrictive, though I don't know if it would be annoyingly so. > Breaking up the UI entirely, so that there is no longer a grid and instead we have separate windows (including for the toolbar and analysis pane, more like ImageJ). It seems to me like at least some UI elements should be broken up across windows. For example I'd want to be able to view/edit the object hierarchy in each image separately (e.g. for training classifiers). If we wanted to emulate the other mode you described, then being able to hide UI elements would be a good start. > Is there a need to have the same image open in multiple viewers? . Probably a natural behaviour, as long as we lock the imageData when a viewer is interacting with it. There's a related issue in here to improve support for QuPath windows in tiling window managers, but I suspect I'm the only person who cares about that right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708675939
https://github.com/qupath/qupath/issues/1317#issuecomment-1708690679:328,Usability,user experience,user experience,328,"Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction. Otherwise it could both be a lot of work and even end up with ambiguity in user experience (eg ""if I press this button, which image is affected...? or both...?"")",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708690679
https://github.com/qupath/qupath/issues/1317#issuecomment-1708749225:537,Integrability,synchroniz,synchronize,537,"One of the things I have often preferred about QuPath is how neatly it arranges most of the windows into a single UI, where I don't have to fight with ""is what I want to use on top and accessible"" like with Fiji and MicroManager etc. . If implemented, there really should be ways to quickly and easily organize the windows, like the Tile and Cascade options in Fiji. > Is there a need to have the same image open in multiple viewers?. This has been one of the things I have often wanted to be able to do for multiplex images (along with synchronize for panning). Having the same image open, but with different sets of channels visible in each MultiView. . It was something I remember being able to do in earlier versions that has since been removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708749225
https://github.com/qupath/qupath/issues/1317#issuecomment-1708749225:185,Security,access,accessible,185,"One of the things I have often preferred about QuPath is how neatly it arranges most of the windows into a single UI, where I don't have to fight with ""is what I want to use on top and accessible"" like with Fiji and MicroManager etc. . If implemented, there really should be ways to quickly and easily organize the windows, like the Tile and Cascade options in Fiji. > Is there a need to have the same image open in multiple viewers?. This has been one of the things I have often wanted to be able to do for multiplex images (along with synchronize for panning). Having the same image open, but with different sets of channels visible in each MultiView. . It was something I remember being able to do in earlier versions that has since been removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708749225
https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081:1173,Deployability,toggle,toggles,1173,"e pretty small. You would detach a viewer by right-clicking on it. It's just intended for exploration - I suspect there will be niggly issues. > I think it can be helpful because this feature is already present in several software like ImageJ, and I don't think it will be confusing for new users as I guess it will just require to add a new button to implement this. I think you're right, although in ImageJ there *is* no main window. In QuPath there is, so having a viewer separated from it feels a bit weirder to me - if nothing else is open, there's a big area of empty space. > Is that a request that has already been mentioned on the Image.sc forum? If not, shouldn't we ask the opinions of the QuPath users there? . Not that I remember - I thought here would be good to start the discussion, could move to the forum if it proves controversial / we need a vote :). > > Detaching one viewer (and leaving the rest of the 'viewer grid' intact); > ; > Does this mean that you'd have (eg) one button that toggles visible annotations on both images? If so, this seems restrictive, though I don't know if it would be annoyingly so. This isn't exactly what I meant, but anyway: it's already the case. You can use *View &rarr; Multi-view... &rarr;* to create a grid of viewers, and the toggles apply across all of them. I agree it's sometimes restrictive, but my feeling is that it would cause more trouble if that didn't happen. What I really meant though was that a single viewer could be extracted into its own window, but the main QuPath window would remain as it always was. That's the approach in the PR. The alternative was that viewers are either all in grid mode or all in 'detached' mode (floating windows), but not a combination of both. > Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081
https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081:1450,Deployability,toggle,toggles,1450,"fusing for new users as I guess it will just require to add a new button to implement this. I think you're right, although in ImageJ there *is* no main window. In QuPath there is, so having a viewer separated from it feels a bit weirder to me - if nothing else is open, there's a big area of empty space. > Is that a request that has already been mentioned on the Image.sc forum? If not, shouldn't we ask the opinions of the QuPath users there? . Not that I remember - I thought here would be good to start the discussion, could move to the forum if it proves controversial / we need a vote :). > > Detaching one viewer (and leaving the rest of the 'viewer grid' intact); > ; > Does this mean that you'd have (eg) one button that toggles visible annotations on both images? If so, this seems restrictive, though I don't know if it would be annoyingly so. This isn't exactly what I meant, but anyway: it's already the case. You can use *View &rarr; Multi-view... &rarr;* to create a grid of viewers, and the toggles apply across all of them. I agree it's sometimes restrictive, but my feeling is that it would cause more trouble if that didn't happen. What I really meant though was that a single viewer could be extracted into its own window, but the main QuPath window would remain as it always was. That's the approach in the PR. The alternative was that viewers are either all in grid mode or all in 'detached' mode (floating windows), but not a combination of both. > Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction. Otherwise it could both be a lot of work and even end up with ambiguity in user experience (eg ""if I press this button, which image is affected...? or both...?""). We already have the ambiguity - it's 'resolved' by there being a red boundary around the 'active' window, and it'",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081
https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081:2833,Integrability,synchroniz,synchronized,2833,"yway: it's already the case. You can use *View &rarr; Multi-view... &rarr;* to create a grid of viewers, and the toggles apply across all of them. I agree it's sometimes restrictive, but my feeling is that it would cause more trouble if that didn't happen. What I really meant though was that a single viewer could be extracted into its own window, but the main QuPath window would remain as it always was. That's the approach in the PR. The alternative was that viewers are either all in grid mode or all in 'detached' mode (floating windows), but not a combination of both. > Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction. Otherwise it could both be a lot of work and even end up with ambiguity in user experience (eg ""if I press this button, which image is affected...? or both...?""). We already have the ambiguity - it's 'resolved' by there being a red boundary around the 'active' window, and it's also the title in the title bar. But we might need to make this much more prominent, and I think the PR currently has some focussing surprises (I guess because bringing the main window into focus can grab it away from the detached viewer that we previously had active). I guess the advantage of two QuPath instances is hinted at by your previous comment: that would free you from having synchronized display settings. But it's pretty hard to get two instances launched on macOS - I can get them via the terminal, but double-clicking the app is stubbornly singleton. The big *disadvantage* of multiple QuPath instances is that there are no measures taken to 'lock' projects, and stop things getting messed up by incompatible changes being made in different instances. But I guess that's another problem (and an important one, since people may use QuPath with a project on a server somewhere).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081
https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081:2990,Testability,stub,stubbornly,2990,"yway: it's already the case. You can use *View &rarr; Multi-view... &rarr;* to create a grid of viewers, and the toggles apply across all of them. I agree it's sometimes restrictive, but my feeling is that it would cause more trouble if that didn't happen. What I really meant though was that a single viewer could be extracted into its own window, but the main QuPath window would remain as it always was. That's the approach in the PR. The alternative was that viewers are either all in grid mode or all in 'detached' mode (floating windows), but not a combination of both. > Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction. Otherwise it could both be a lot of work and even end up with ambiguity in user experience (eg ""if I press this button, which image is affected...? or both...?""). We already have the ambiguity - it's 'resolved' by there being a red boundary around the 'active' window, and it's also the title in the title bar. But we might need to make this much more prominent, and I think the PR currently has some focussing surprises (I guess because bringing the main window into focus can grab it away from the detached viewer that we previously had active). I guess the advantage of two QuPath instances is hinted at by your previous comment: that would free you from having synchronized display settings. But it's pretty hard to get two instances launched on macOS - I can get them via the terminal, but double-clicking the app is stubbornly singleton. The big *disadvantage* of multiple QuPath instances is that there are no measures taken to 'lock' projects, and stop things getting messed up by incompatible changes being made in different instances. But I guess that's another problem (and an important one, since people may use QuPath with a project on a server somewhere).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081
https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081:2243,Usability,user experience,user experience,2243,"rictive, though I don't know if it would be annoyingly so. This isn't exactly what I meant, but anyway: it's already the case. You can use *View &rarr; Multi-view... &rarr;* to create a grid of viewers, and the toggles apply across all of them. I agree it's sometimes restrictive, but my feeling is that it would cause more trouble if that didn't happen. What I really meant though was that a single viewer could be extracted into its own window, but the main QuPath window would remain as it always was. That's the approach in the PR. The alternative was that viewers are either all in grid mode or all in 'detached' mode (floating windows), but not a combination of both. > Final thought is, if we implement this, we need to consider what should be the advantage of having one QuPath instance with two viewers over having two QuPath instances open each with one viewer, and we should probably aim our design in that direction. Otherwise it could both be a lot of work and even end up with ambiguity in user experience (eg ""if I press this button, which image is affected...? or both...?""). We already have the ambiguity - it's 'resolved' by there being a red boundary around the 'active' window, and it's also the title in the title bar. But we might need to make this much more prominent, and I think the PR currently has some focussing surprises (I guess because bringing the main window into focus can grab it away from the detached viewer that we previously had active). I guess the advantage of two QuPath instances is hinted at by your previous comment: that would free you from having synchronized display settings. But it's pretty hard to get two instances launched on macOS - I can get them via the terminal, but double-clicking the app is stubbornly singleton. The big *disadvantage* of multiple QuPath instances is that there are no measures taken to 'lock' projects, and stop things getting messed up by incompatible changes being made in different instances. But I guess that's another ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708778081
https://github.com/qupath/qupath/issues/1317#issuecomment-1708795269:15,Usability,undo,undocking,15,"Easily docking/undocking windows and a more modular UI in general would probably be good here. Although personally I don't like most of the dockable UIs I've used, they're very popular so presumably if you get used to them, they're good",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1708795269
https://github.com/qupath/qupath/issues/1317#issuecomment-1709739777:607,Safety,detect,detection,607,"Yeah, I'm not generally a fan of very dockable UIs myself... and there's no native JavaFX support. Lots of docking makes me thing of complex IDEs, which I'd expect only a minority of QuPath users to feel comfortable with (I'm not sure if I'm even one of them, and I use complex IDEs all the time). An entire UI overhaul is certainly a good idea, but much more long term - I'm thinking here about stuff we could do within the next couple of weeks that would meaningfully improve the UX. Meanwhile, the PR shows me there are definite bugs with my proposed approach - at least when it comes to stuff like cell detection, when windows change focus before the processing is complete. The fact that is broken suggests the underlying code to run parallel tasks ought to be strengthened though, so I'm tempted to persist a bit longer with the PR - irrespective of whether we end up exposing the 'detachable viewer' part through the UI or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1709739777
https://github.com/qupath/qupath/issues/1317#issuecomment-1709739777:482,Usability,UX,UX,482,"Yeah, I'm not generally a fan of very dockable UIs myself... and there's no native JavaFX support. Lots of docking makes me thing of complex IDEs, which I'd expect only a minority of QuPath users to feel comfortable with (I'm not sure if I'm even one of them, and I use complex IDEs all the time). An entire UI overhaul is certainly a good idea, but much more long term - I'm thinking here about stuff we could do within the next couple of weeks that would meaningfully improve the UX. Meanwhile, the PR shows me there are definite bugs with my proposed approach - at least when it comes to stuff like cell detection, when windows change focus before the processing is complete. The fact that is broken suggests the underlying code to run parallel tasks ought to be strengthened though, so I'm tempted to persist a bit longer with the PR - irrespective of whether we end up exposing the 'detachable viewer' part through the UI or not.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1709739777
https://github.com/qupath/qupath/issues/1317#issuecomment-1713197089:534,Deployability,release,release,534,"Ok, much revised and extended PR at https://github.com/qupath/qupath/pull/1318. Please do check out the explanation of the changes. I *think* it's a substantial improvement to handling multiple viewers, and other aspects of the code should be healthier than they were before. But there's a good chance it could be improved - and potentially things are broken in ways I haven't yet spotted. Unless something terrible emerges, I will merge the PR soon so there is still a reasonable amount of time to explore and fix anything it before release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1713197089
https://github.com/qupath/qupath/issues/1317#issuecomment-1713197089:21,Modifiability,extend,extended,21,"Ok, much revised and extended PR at https://github.com/qupath/qupath/pull/1318. Please do check out the explanation of the changes. I *think* it's a substantial improvement to handling multiple viewers, and other aspects of the code should be healthier than they were before. But there's a good chance it could be improved - and potentially things are broken in ways I haven't yet spotted. Unless something terrible emerges, I will merge the PR soon so there is still a reasonable amount of time to explore and fix anything it before release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1713197089
https://github.com/qupath/qupath/issues/1317#issuecomment-1713712459:765,Integrability,synchroniz,synchronize,765,"Sorry @MichaelSNelson I entirely missed this until @finglis mentioned it :). > One of the things I have often preferred about QuPath is how neatly it arranges most of the windows into a single UI, where I don't have to fight with ""is what I want to use on top and accessible"" like with Fiji and MicroManager etc.; > ; > If implemented, there really should be ways to quickly and easily organize the windows, like the Tile and Cascade options in Fiji. I strongly agree - if you try https://github.com/qupath/qupath/pull/1318 I'd be curious as to whether you think it gets the balance ok. > > Is there a need to have the same image open in multiple viewers?; > ; > This has been one of the things I have often wanted to be able to do for multiplex images (along with synchronize for panning). Having the same image open, but with different sets of channels visible in each MultiView.; > ; > It was something I remember being able to do in earlier versions that has since been removed. I don't remember that ever being there by design, but it certainly could have been there as a bug :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1713712459
https://github.com/qupath/qupath/issues/1317#issuecomment-1713712459:264,Security,access,accessible,264,"Sorry @MichaelSNelson I entirely missed this until @finglis mentioned it :). > One of the things I have often preferred about QuPath is how neatly it arranges most of the windows into a single UI, where I don't have to fight with ""is what I want to use on top and accessible"" like with Fiji and MicroManager etc.; > ; > If implemented, there really should be ways to quickly and easily organize the windows, like the Tile and Cascade options in Fiji. I strongly agree - if you try https://github.com/qupath/qupath/pull/1318 I'd be curious as to whether you think it gets the balance ok. > > Is there a need to have the same image open in multiple viewers?; > ; > This has been one of the things I have often wanted to be able to do for multiplex images (along with synchronize for panning). Having the same image open, but with different sets of channels visible in each MultiView.; > ; > It was something I remember being able to do in earlier versions that has since been removed. I don't remember that ever being there by design, but it certainly could have been there as a bug :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1317#issuecomment-1713712459
https://github.com/qupath/qupath/pull/1318#issuecomment-1713690482:835,Availability,avail,available,835,"> Run Extensions → ImageJ → Send snapshot to ImageJ; > Try to interact and use accelerators with both ImageJ and QuPath windows in focus. For example, pressing shortcut+L should; > launch the ImageJ command finder if an ImageJ window is in focus; > launch the QuPath command list if a QuPath window is in focus; > not launch either the wrong window, or both at once. This is how it behaves, but I checked on a previous version and it also behaved this way. ""Send snapshot to ImageJ"" always sends the image on the ""primary"" viewer, not the selected one. Is this intended?. Side note: movement/zoom is coupled between viewers, even when different images are open. Is this intended? Seems counterintuitive to me. Also is not great if you have an image highly zoomed and then open another, or if two images have different levels of detail available",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1318#issuecomment-1713690482
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:401,Energy Efficiency,GREEN,GREEN,401,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:202,Modifiability,extend,extend,202,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:65,Safety,avoid,avoid,65,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:145,Testability,test,test,145,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:213,Testability,test,test,213,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:537,Testability,test,test,537,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:569,Testability,Test,TestBufferedImageTools,569,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385:761,Testability,test,tested,761,"Yeah, I don't think it's possible without boxing - and better to avoid that. Although since they aren't identical, could you add a corresponding test for the doubles function?. It would also be good to extend the test to handle different channels... One a good way to do that is to create an RGB `BufferedImage` and then draw onto it with `Graphics2D`, after setting the foreground color to be `Color.GREEN` (for example). Similar code is at https://github.com/qupath/qupath/blob/67a1ed7ead8e28c54d120b21d08b7d41562eb8c3/qupath-core/src/test/java/qupath/lib/awt/common/TestBufferedImageTools.java#L176 but the type should be `BufferedImage.TYPE_INT_ARGB`. Sorry to keep adding more, but I think the code is looking good - and it'll be nice to have it more well-tested than many other methods.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1319#issuecomment-1711869385
https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250:244,Availability,avail,available,244,I noticed when running object / pixel classifiers in batches that QuPath would not always clear up the tile cache properly (or that's at least what I thought?) and would occasionally end up running out of memory / being sluggish due to limited available memory. . I added something similar to the snippet below to my scripts and it partially resolved my problems if I recall correctly -- probably worth investigating if nothing else comes up (although my issues were possibly different than the issues brought on image.sc). ```java; Thread.sleep(100). javafx.application.Platform.runLater {; getCurrentViewer().getImageRegionStore().cache.clear(); System.gc(); }. Thread.sleep(100); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250
https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250:108,Performance,cache,cache,108,I noticed when running object / pixel classifiers in batches that QuPath would not always clear up the tile cache properly (or that's at least what I thought?) and would occasionally end up running out of memory / being sluggish due to limited available memory. . I added something similar to the snippet below to my scripts and it partially resolved my problems if I recall correctly -- probably worth investigating if nothing else comes up (although my issues were possibly different than the issues brought on image.sc). ```java; Thread.sleep(100). javafx.application.Platform.runLater {; getCurrentViewer().getImageRegionStore().cache.clear(); System.gc(); }. Thread.sleep(100); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250
https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250:633,Performance,cache,cache,633,I noticed when running object / pixel classifiers in batches that QuPath would not always clear up the tile cache properly (or that's at least what I thought?) and would occasionally end up running out of memory / being sluggish due to limited available memory. . I added something similar to the snippet below to my scripts and it partially resolved my problems if I recall correctly -- probably worth investigating if nothing else comes up (although my issues were possibly different than the issues brought on image.sc). ```java; Thread.sleep(100). javafx.application.Platform.runLater {; getCurrentViewer().getImageRegionStore().cache.clear(); System.gc(); }. Thread.sleep(100); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250
https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250:90,Usability,clear,clear,90,I noticed when running object / pixel classifiers in batches that QuPath would not always clear up the tile cache properly (or that's at least what I thought?) and would occasionally end up running out of memory / being sluggish due to limited available memory. . I added something similar to the snippet below to my scripts and it partially resolved my problems if I recall correctly -- probably worth investigating if nothing else comes up (although my issues were possibly different than the issues brought on image.sc). ```java; Thread.sleep(100). javafx.application.Platform.runLater {; getCurrentViewer().getImageRegionStore().cache.clear(); System.gc(); }. Thread.sleep(100); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250
https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250:639,Usability,clear,clear,639,I noticed when running object / pixel classifiers in batches that QuPath would not always clear up the tile cache properly (or that's at least what I thought?) and would occasionally end up running out of memory / being sluggish due to limited available memory. . I added something similar to the snippet below to my scripts and it partially resolved my problems if I recall correctly -- probably worth investigating if nothing else comes up (although my issues were possibly different than the issues brought on image.sc). ```java; Thread.sleep(100). javafx.application.Platform.runLater {; getCurrentViewer().getImageRegionStore().cache.clear(); System.gc(); }. Thread.sleep(100); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715891250
https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774:160,Performance,cache,cache,160,"Yeah, I think it was me that introduced that script :) https://github.com/qupath/qupath/issues/130#issuecomment-355845333 . There's an option *Run &rarr; Clear cache (batch processing)* built-in now that should do the same thing:; https://github.com/qupath/qupath/blob/533ce0cf50ca2a5627b55a8c1fe351cdc72e0694/qupath-gui-fx/src/main/java/qupath/lib/gui/scripting/DefaultScriptEditor.java#L1681-L1687. I think it's off by default, since emptying the catch is often not welcome. But I still don't have a very clear idea why it continues to prove useful :/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774
https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774:154,Usability,Clear,Clear,154,"Yeah, I think it was me that introduced that script :) https://github.com/qupath/qupath/issues/130#issuecomment-355845333 . There's an option *Run &rarr; Clear cache (batch processing)* built-in now that should do the same thing:; https://github.com/qupath/qupath/blob/533ce0cf50ca2a5627b55a8c1fe351cdc72e0694/qupath-gui-fx/src/main/java/qupath/lib/gui/scripting/DefaultScriptEditor.java#L1681-L1687. I think it's off by default, since emptying the catch is often not welcome. But I still don't have a very clear idea why it continues to prove useful :/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774
https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774:507,Usability,clear,clear,507,"Yeah, I think it was me that introduced that script :) https://github.com/qupath/qupath/issues/130#issuecomment-355845333 . There's an option *Run &rarr; Clear cache (batch processing)* built-in now that should do the same thing:; https://github.com/qupath/qupath/blob/533ce0cf50ca2a5627b55a8c1fe351cdc72e0694/qupath-gui-fx/src/main/java/qupath/lib/gui/scripting/DefaultScriptEditor.java#L1681-L1687. I think it's off by default, since emptying the catch is often not welcome. But I still don't have a very clear idea why it continues to prove useful :/",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715904774
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:344,Availability,down,down,344,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:773,Availability,error,error,773,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:277,Deployability,release,release,277,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:413,Performance,cache,cache,413,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:493,Performance,cache,cache,493,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:402,Usability,clear,clears,402,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498:480,Usability,clear,clearing,480,"@yli-hallila did you spot any patterns when it happened?. Like, was it a high-resolution pixel classifier, and did the memory use accumulate over time?; Would it happen after 3 images, 30 images, or 300 images...?. I'm hoping that there is some place where I'm just failing to release memory used by OpenCV / JavaCPP, but I thought I'd tracked down where that was the case. The script does two things: clears the cache, and calls the garbage collector. If the thing that helps is clearing the cache, then that suggests to me that it is delaying (rather than solving) the problem - and there is probably still a leak somewhere. If the thing that helps is running the garbage collector then... I guess I'm confused, because I think that should happen before an out-of-memory error occurs anyway. I quite like hunting for leaks (as long as they are in code I can control), but here I'm not sure where exactly I should start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1715940498
https://github.com/qupath/qupath/issues/1322#issuecomment-1716011063:128,Availability,down,down,128,"I had 730 slides with 10 different stains, so I ran them in batches of 73 slides and each of them had the same issue of slowing down significantly after the first few slides. I think I faced an OutOfMemoryError once or twice which led me into finding and using that script, which resolved at least running out of memory (or just ""fixed"" it that it never happened with my batch size anymore) and might have sped up the process marginally but not to the same speed as running the script without batching. Below hopefully are the relevant parts of the script and classifiers. ```java; createAnnotationsFromPixelClassifier(""ASMA Classifier"", 100000.0, 200000.0, ""DELETE_EXISTING""); ```. ```json; ""pixel_classifier_type"": ""OpenCVPixelClassifier"",; ...; ""pixelWidth"": {; ""value"": 8.048,; ""unit"": ""µm""; },; ""pixelHeight"": {; ""value"": 8.048,; ""unit"": ""µm""; }; ...; ""inputWidth"": 512,; ""inputHeight"": 512,; ```. I can try running the analysis sometime and see if I can reproduce the OutOfMemoryError or see any patterns with and without the snippet.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1716011063
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:24,Availability,error,error,24,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:813,Availability,ERROR,ERROR,813,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:855,Availability,ERROR,ERROR,855,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:251,Performance,cache,cache,251,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:1383,Performance,concurren,concurrent,1383,"parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourTracing.java:1022); qupath.lib.analysis.images.ContourTracing$$Lambda$2595/0x00000008009b7a18.apply(Unknown Source); qupath.lib.analysis.images.ContourTracing.lambda$invokeAll$8(ContourTracing.java:1000); qupath.lib.analysis.images.ContourTracing$$Lambda$2596/0x00000008009b7c58.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); java.base/java.util.concu",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:2321,Performance,concurren,concurrent,2321,"00000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourTracing.java:1022); qupath.lib.analysis.images.ContourTracing$$Lambda$2595/0x00000008009b7a18.apply(Unknown Source); qupath.lib.analysis.images.ContourTracing.lambda$invokeAll$8(ContourTracing.java:1000); qupath.lib.analysis.images.ContourTracing$$Lambda$2596/0x00000008009b7c58.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); java.base/java.lang.Thread.run(Unknown Source); ``` . ```json; {; ""pixel_classifier_type"": ""OpenCVPixelClassifier"",; ""metadata"": {; ""inputPadding"": 0,; ""inputResolution"": {; ""pixelWidth"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""pixelHeight"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""zSpacing"": {; ""value"": 1.0,; ""unit"": ""z-slice""; },; ""timeUnit"": ""SECONDS"",; ""timepoints"": []; },; ""inputWidth"": 512,; ""inputHeight"": 512,; ""inputNumChannels"": 3,; ""outputType"": ""CLASSIFICATION"",; ""outputChannels"": [],; ""classificationLabels"": {; ""0"": {; ""name"": ""Area"",; ""colorRGB"": -6895466; },; ""1"": {; ""colorRGB"": -12566464; }; }; },; ""op"": {; ""type"": ""data.op.channels"",; ""colorTransforms"": [; {; ""channelName"": ""Red""; }; ],; ""op"": {; ""type"": ""op.core.sequential"",; ""ops"": [; {; ""type"": ""op.gaussian"",; ""sigmaX"": 4.0,; ""sigm",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:2384,Performance,concurren,concurrent,2384,"rent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourTracing.java:1022); qupath.lib.analysis.images.ContourTracing$$Lambda$2595/0x00000008009b7a18.apply(Unknown Source); qupath.lib.analysis.images.ContourTracing.lambda$invokeAll$8(ContourTracing.java:1000); qupath.lib.analysis.images.ContourTracing$$Lambda$2596/0x00000008009b7c58.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); java.base/java.lang.Thread.run(Unknown Source); ``` . ```json; {; ""pixel_classifier_type"": ""OpenCVPixelClassifier"",; ""metadata"": {; ""inputPadding"": 0,; ""inputResolution"": {; ""pixelWidth"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""pixelHeight"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""zSpacing"": {; ""value"": 1.0,; ""unit"": ""z-slice""; },; ""timeUnit"": ""SECONDS"",; ""timepoints"": []; },; ""inputWidth"": 512,; ""inputHeight"": 512,; ""inputNumChannels"": 3,; ""outputType"": ""CLASSIFICATION"",; ""outputChannels"": [],; ""classificationLabels"": {; ""0"": {; ""name"": ""Area"",; ""colorRGB"": -6895466; },; ""1"": {; ""colorRGB"": -12566464; }; }; },; ""op"": {; ""type"": ""data.op.channels"",; ""colorTransforms"": [; {; ""channelName"": ""Red""; }; ],; ""op"": {; ""type"": ""op.core.sequential"",; ""ops"": [; {; ""type"": ""op.gaussian"",; ""sigmaX"": 4.0,; ""sigmaY"": 4.0; },; {; ""type"": ""op.constant"",; ""thresholds"": [; 239.0",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:2461,Performance,concurren,concurrent,2461,"own Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourTracing.java:1022); qupath.lib.analysis.images.ContourTracing$$Lambda$2595/0x00000008009b7a18.apply(Unknown Source); qupath.lib.analysis.images.ContourTracing.lambda$invokeAll$8(ContourTracing.java:1000); qupath.lib.analysis.images.ContourTracing$$Lambda$2596/0x00000008009b7c58.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); java.base/java.lang.Thread.run(Unknown Source); ``` . ```json; {; ""pixel_classifier_type"": ""OpenCVPixelClassifier"",; ""metadata"": {; ""inputPadding"": 0,; ""inputResolution"": {; ""pixelWidth"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""pixelHeight"": {; ""value"": 1.006,; ""unit"": ""µm""; },; ""zSpacing"": {; ""value"": 1.0,; ""unit"": ""z-slice""; },; ""timeUnit"": ""SECONDS"",; ""timepoints"": []; },; ""inputWidth"": 512,; ""inputHeight"": 512,; ""inputNumChannels"": 3,; ""outputType"": ""CLASSIFICATION"",; ""outputChannels"": [],; ""classificationLabels"": {; ""0"": {; ""name"": ""Area"",; ""colorRGB"": -6895466; },; ""1"": {; ""colorRGB"": -12566464; }; }; },; ""op"": {; ""type"": ""data.op.channels"",; ""colorTransforms"": [; {; ""channelName"": ""Red""; }; ],; ""op"": {; ""type"": ""op.core.sequential"",; ""ops"": [; {; ""type"": ""op.gaussian"",; ""sigmaX"": 4.0,; ""sigmaY"": 4.0; },; {; ""type"": ""op.constant"",; ""thresholds"": [; 239.0; ]; }; ]; }; }; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:637,Safety,detect,detect,637,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:257,Usability,clear,clearing,257,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500:474,Usability,simpl,simple,474,"I tried reproducing the error a few times with that classifier with 4 GB of RAM and I wasn't able to reproduce it. I bumped up the resolution to `1,01 µm/px` and two `OutOfMemoryError` came up with only one stacktrace (this happened without any GC or cache clearing; didn't try with it enabled either). **This was running on 0.3.2**, I can give it a try on newer versions if any relevant parts have changed in the code. I've attached the whole classifier below (it's just a simple thersholder to filter out the background). I think the original analysis was done with 6 GB or 8 GB of RAM but I also had other scripts with `qupath.imagej.detect.cells.WatershedCellDetection` running and I can't say for 100% certainty whether it was the Pixel Classifier, Cell Counting or both which caused OutOfMemoryErrors. ```; ERROR: OutOfMemoryError: Java heap space. ERROR: qupath.opencv.tools.OpenCVTools.matToBufferedImage(OpenCVTools.java:765); qupath.opencv.ml.pixel.OpenCVPixelClassifier.applyClassification(OpenCVPixelClassifier.java:115); qupath.lib.classifiers.pixel.PixelClassificationImageServer.readTile(PixelClassificationImageServer.java:299); qupath.lib.images.servers.AbstractTileableImageServer.lambda$getTile$0(AbstractTileableImageServer.java:213); qupath.lib.images.servers.AbstractTileableImageServer$$Lambda$1691/0x0000000800796740.call(Unknown Source); java.base/java.util.concurrent.FutureTask.run(Unknown Source); qupath.lib.images.servers.AbstractTileableImageServer.getTile(AbstractTileableImageServer.java:217); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:287); qupath.lib.images.servers.AbstractTileableImageServer.readBufferedImage(AbstractTileableImageServer.java:60); qupath.lib.analysis.images.ContourTracing.traceGeometriesImpl(ContourTracing.java:1157); qupath.lib.analysis.images.ContourTracing.traceGeometries(ContourTracing.java:1143); qupath.lib.analysis.images.ContourTracing.lambda$traceGeometriesImpl$9(ContourT",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1719699500
https://github.com/qupath/qupath/issues/1322#issuecomment-1722141444:117,Performance,perform,performance,117,"Ah, it might be different in v0.4... but might not. In any case, this PR should substantially improve memory use and performance for at least *some* applications of the pixel classifier: https://github.com/qupath/qupath/pull/1332. There may still be issues, but I couldn't find any other memory leaks - so I'll close this issue for now. I'll explore again if anything emerges that can be reproduced with the latest code. Thanks!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1322#issuecomment-1722141444
https://github.com/qupath/qupath/pull/1325#issuecomment-1714284915:105,Usability,learn,learned,105,"Thanks! What do you think of shifting the OpenSlide extension to a repository of its own?. Now that I've learned about `includeBuild` and `includeFlat`, it's more feasible to develop extensions in separate repos - even if they end up bundled in the distribution by default.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1714284915
https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343:377,Availability,down,down,377,"Looks like I need to also get my head around `includeBuild`, though the gradle documentation is as abstract as ever. I don't really see a huge difference either way. Would we be pushing updates to the openslide (or other ""core"" extensions) without making a new QuPath release?. I guess it would make issue tracking (and responsibilities) more granular if we can gradually slim down the qupath repo, though if that has the side-effect of making issues harder to find, then it's not really great. It is straightforward to extract the git history: https://docs.github.com/en/get-started/using-git/splitting-a-subfolder-out-into-a-new-repository",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343
https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343:186,Deployability,update,updates,186,"Looks like I need to also get my head around `includeBuild`, though the gradle documentation is as abstract as ever. I don't really see a huge difference either way. Would we be pushing updates to the openslide (or other ""core"" extensions) without making a new QuPath release?. I guess it would make issue tracking (and responsibilities) more granular if we can gradually slim down the qupath repo, though if that has the side-effect of making issues harder to find, then it's not really great. It is straightforward to extract the git history: https://docs.github.com/en/get-started/using-git/splitting-a-subfolder-out-into-a-new-repository",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343
https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343:268,Deployability,release,release,268,"Looks like I need to also get my head around `includeBuild`, though the gradle documentation is as abstract as ever. I don't really see a huge difference either way. Would we be pushing updates to the openslide (or other ""core"" extensions) without making a new QuPath release?. I guess it would make issue tracking (and responsibilities) more granular if we can gradually slim down the qupath repo, though if that has the side-effect of making issues harder to find, then it's not really great. It is straightforward to extract the git history: https://docs.github.com/en/get-started/using-git/splitting-a-subfolder-out-into-a-new-repository",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1714324343
https://github.com/qupath/qupath/pull/1325#issuecomment-1715236828:332,Security,Hash,HashMap,332,"Cheers, I put literally zero thought into what we need and not, though some of it definitely looked fishy. I figured it wasn't worth thinking about if it wasn't going to work in principle anyways. The associated image class is useless yeah, it's just a String with a getBufferedImage method. No idea why they use a String -> String HashMap for that. Also renamed ""Openslide"" to ""OpenSlide"" in the server(builder) classes for consistency, which I hope doesn't break anything",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1715236828
https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046:190,Integrability,Message,Message,190,"If we don't end up having properly working bundled openslide, I'd suggest that we should be a bit louder about how to set OpenSlide if loading fails - a `Notification` at least, or maybe a `Message` the first time it happens and then log it afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046
https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046:135,Performance,load,loading,135,"If we don't end up having properly working bundled openslide, I'd suggest that we should be a bit louder about how to set OpenSlide if loading fails - a `Notification` at least, or maybe a `Message` the first time it happens and then log it afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046
https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046:234,Testability,log,log,234,"If we don't end up having properly working bundled openslide, I'd suggest that we should be a bit louder about how to set OpenSlide if loading fails - a `Notification` at least, or maybe a `Message` the first time it happens and then log it afterwards.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1739130046
https://github.com/qupath/qupath/pull/1325#issuecomment-1748498287:39,Integrability,depend,dependencies,39,"For what it's worth, I checked the dll dependencies with `ldd` in git bash, and it was all satisfied. I've had to switch to using their windows build because I ended up with unsatisfied links for SSP and some weird minGW libraries that I wasn't going to be able to fix in time, so it really should be a safe bet.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748498287
https://github.com/qupath/qupath/pull/1325#issuecomment-1748498287:303,Safety,safe,safe,303,"For what it's worth, I checked the dll dependencies with `ldd` in git bash, and it was all satisfied. I've had to switch to using their windows build because I ended up with unsatisfied links for SSP and some weird minGW libraries that I wasn't going to be able to fix in time, so it really should be a safe bet.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748498287
https://github.com/qupath/qupath/pull/1325#issuecomment-1748517478:0,Deployability,Update,Updated,0,"Updated SNAPSHOT is live, @finglis could you try to run this branch and see if OpenSlide loads/works on Windows?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748517478
https://github.com/qupath/qupath/pull/1325#issuecomment-1748517478:89,Performance,load,loads,89,"Updated SNAPSHOT is live, @finglis could you try to run this branch and see if OpenSlide loads/works on Windows?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748517478
https://github.com/qupath/qupath/pull/1325#issuecomment-1748522020:30,Availability,error,errors,30,Its running with no OpenSlide errors in the logs,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748522020
https://github.com/qupath/qupath/pull/1325#issuecomment-1748522020:44,Testability,log,logs,44,Its running with no OpenSlide errors in the logs,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748522020
https://github.com/qupath/qupath/pull/1325#issuecomment-1748617650:34,Deployability,update,updates,34,"@finglis on tenterhooks here, any updates? I've tried it on two different Macs (Intel & Apple Silicon) and it worked on both. What is not positive, and could it be permissions or OS-related?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748617650
https://github.com/qupath/qupath/pull/1325#issuecomment-1748618979:31,Modifiability,plugin,plugin,31,"False alarm, it was the javafx plugin issue solved in https://github.com/qupath/qupath/pull/1325/commits/7043f57591b708d55fc82dc194dafdb5f2f885c9",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1325#issuecomment-1748618979
https://github.com/qupath/qupath/pull/1327#issuecomment-1731324274:121,Testability,log,logic,121,"I think this looks good & much cleaner than my previous version. It works well for all the images I've tried. Should the logic be the same, just organized differently - or are there any changes you think I should look at closely?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1327#issuecomment-1731324274
https://github.com/qupath/qupath/pull/1327#issuecomment-1731411320:4,Testability,log,logic,4,"The logic is the same, I just extracted the databuffer and the sample model creation in two different functions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1327#issuecomment-1731411320
https://github.com/qupath/qupath/issues/1337#issuecomment-1723256378:408,Deployability,install,installers,408,"Hi @Edwinterb this seems to be a duplicate of https://github.com/qupath/qupath/issues/1250 with a potential fix. I'm not sure if/how the proposed fix could be incorporated into the build process using `jpackage` though. Is that something you've explored at all?. There's a description of the build process at https://qupath.readthedocs.io/en/0.4/docs/reference/building.html - it automatically generates the installers, and [jpackage doesn't like versions that start with 0](https://github.com/openjdk/jdk/blob/master/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/CFBundleVersion.java).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1723256378
https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792:604,Deployability,release,releases,604,"Hi @petebankhead, apologies for creating this new enhancement without properly searching exisintg ones! ; I have read up the links and the previous request and I understand the predicament you have now. Unfortunately I do not have any experience with jpackage to be able to offer any insights, other than of course changing the verion to 1.4.4, but I appreciate this may not be desired.; Perhaps the package could be created using Xcode in future? Again not something I have much experience with as I am not a developer, but it may also aid you in future if there is a desire to sign and notorize future releases. Gatekeeper on macOS Ventura is a bit more agreesive with unsigned apps and may notify users on first launch that the app is damaged. This can be bypassed by right clicking and selecting Open. This is when we deploy the Qupath pkg to managed devices using MDM tools:; <img width=""328"" alt=""App is damaged - Gatekeeper warning Ventura"" src=""https://github.com/qupath/qupath/assets/47144936/10b13e47-916f-4ce9-a904-dd4e1c7b97bc"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792
https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792:822,Deployability,deploy,deploy,822,"Hi @petebankhead, apologies for creating this new enhancement without properly searching exisintg ones! ; I have read up the links and the previous request and I understand the predicament you have now. Unfortunately I do not have any experience with jpackage to be able to offer any insights, other than of course changing the verion to 1.4.4, but I appreciate this may not be desired.; Perhaps the package could be created using Xcode in future? Again not something I have much experience with as I am not a developer, but it may also aid you in future if there is a desire to sign and notorize future releases. Gatekeeper on macOS Ventura is a bit more agreesive with unsigned apps and may notify users on first launch that the app is damaged. This can be bypassed by right clicking and selecting Open. This is when we deploy the Qupath pkg to managed devices using MDM tools:; <img width=""328"" alt=""App is damaged - Gatekeeper warning Ventura"" src=""https://github.com/qupath/qupath/assets/47144936/10b13e47-916f-4ce9-a904-dd4e1c7b97bc"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792
https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792:50,Modifiability,enhance,enhancement,50,"Hi @petebankhead, apologies for creating this new enhancement without properly searching exisintg ones! ; I have read up the links and the previous request and I understand the predicament you have now. Unfortunately I do not have any experience with jpackage to be able to offer any insights, other than of course changing the verion to 1.4.4, but I appreciate this may not be desired.; Perhaps the package could be created using Xcode in future? Again not something I have much experience with as I am not a developer, but it may also aid you in future if there is a desire to sign and notorize future releases. Gatekeeper on macOS Ventura is a bit more agreesive with unsigned apps and may notify users on first launch that the app is damaged. This can be bypassed by right clicking and selecting Open. This is when we deploy the Qupath pkg to managed devices using MDM tools:; <img width=""328"" alt=""App is damaged - Gatekeeper warning Ventura"" src=""https://github.com/qupath/qupath/assets/47144936/10b13e47-916f-4ce9-a904-dd4e1c7b97bc"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727468792
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:133,Availability,down,downloaded,133,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:65,Deployability,release,releases,65,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:355,Deployability,install,installation,355,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:459,Deployability,integrat,integrates,459,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:540,Deployability,install,installers,540,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329:459,Integrability,integrat,integrates,459,"Thanks @Edwinterb yes, we used to provide a dmg but recent macOS releases thwarted that - they were particularly unhappy if this was downloaded, and seemed to work extra hard to make it non-runnable. The pkg has proven the 'least painful' distribution method, and the right-click trick is documented [here](https://qupath.readthedocs.io/en/0.4/docs/intro/installation.html#macos). I do most of my development on a Mac, so suffer the pain directly. `jpackage` integrates well with our build tools, and seems to be the 'official' way to make installers for Java applications. I'm not good enough with XCode, build tools or GitHub Actions to figure out a way to piece together an alternative that gives an opportunity to squeeze in a proper version number. @alanocallaghan would have a better chance of figuring it out than I do, but I don't see how I can possibly mention it to him when he's already [embroiled in other macOS-related woes](https://github.com/qupath/qupath/issues/629#issuecomment-1723504495) - without actually being a Mac user.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727694329
https://github.com/qupath/qupath/issues/1337#issuecomment-1727709163:443,Deployability,release,releases,443,"For the macos-latest builds on github actions, it might suffice to add a step (assuming we set the version in an env variable somehow):. ```yaml; - name: Set version number; if: matrix.platform == 'macos-latest'; shell: bash; run: defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString {{env.version}}; ```. and (remembering to) manually run the same command locally for the mac m1 builds, until GitHub finally releases m1 runners into the wild.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727709163
https://github.com/qupath/qupath/issues/1337#issuecomment-1727709163:117,Modifiability,variab,variable,117,"For the macos-latest builds on github actions, it might suffice to add a step (assuming we set the version in an env variable somehow):. ```yaml; - name: Set version number; if: matrix.platform == 'macos-latest'; shell: bash; run: defaults write /Applications/QuPath.app/Contents/Info.plist CFBundleShortVersionString {{env.version}}; ```. and (remembering to) manually run the same command locally for the mac m1 builds, until GitHub finally releases m1 runners into the wild.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727709163
https://github.com/qupath/qupath/issues/1337#issuecomment-1727749527:432,Deployability,release,release,432,"Is this able to add it to the `.pkg`, or only the .`.app`?. If it's only the `.app`, we could build that separately with `jpackage` but then need to somehow get it properly into a `.pkg` (which might not be that hard, but I don't know...). Actually, now that I think of it, it might be doable in Gradle as well - which has the benefit of knowing the version. Will try to look into it, but not sure if I'll have time before the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727749527
https://github.com/qupath/qupath/issues/1337#issuecomment-1727754758:133,Deployability,install,installer,133,"Don't really know the distinction between `.pkg` and `.app`, it'd be the output of `./gradlew jpackage -P git-commit=true -P package=installer mergedJavadoc`. But if possible within gradle that'd be much easier",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727754758
https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157:596,Availability,down,downloading,596,"The `.pkg` wraps up the `.app` in an installer. I think `jpackage` will create the `.app` first, then the `.pkg` if required - but I don't think it gives space in between to do anything useful. I've never used `defaults` (didn't know it existed...) so don't know if it requires the `.app`. We use `package=installer` to get the `.pkg` because otherwise I think the `.app` has all sorts of scary quarantine flags set that mean it can't be launched without recursively removing them all (at least that's my vague memory of what happened, I may well be misremembering). The flags only occurred when downloading - so on my local build I thought all was fine...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157
https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157:37,Deployability,install,installer,37,"The `.pkg` wraps up the `.app` in an installer. I think `jpackage` will create the `.app` first, then the `.pkg` if required - but I don't think it gives space in between to do anything useful. I've never used `defaults` (didn't know it existed...) so don't know if it requires the `.app`. We use `package=installer` to get the `.pkg` because otherwise I think the `.app` has all sorts of scary quarantine flags set that mean it can't be launched without recursively removing them all (at least that's my vague memory of what happened, I may well be misremembering). The flags only occurred when downloading - so on my local build I thought all was fine...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157
https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157:306,Deployability,install,installer,306,"The `.pkg` wraps up the `.app` in an installer. I think `jpackage` will create the `.app` first, then the `.pkg` if required - but I don't think it gives space in between to do anything useful. I've never used `defaults` (didn't know it existed...) so don't know if it requires the `.app`. We use `package=installer` to get the `.pkg` because otherwise I think the `.app` has all sorts of scary quarantine flags set that mean it can't be launched without recursively removing them all (at least that's my vague memory of what happened, I may well be misremembering). The flags only occurred when downloading - so on my local build I thought all was fine...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157
https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157:11,Integrability,wrap,wraps,11,"The `.pkg` wraps up the `.app` in an installer. I think `jpackage` will create the `.app` first, then the `.pkg` if required - but I don't think it gives space in between to do anything useful. I've never used `defaults` (didn't know it existed...) so don't know if it requires the `.app`. We use `package=installer` to get the `.pkg` because otherwise I think the `.app` has all sorts of scary quarantine flags set that mean it can't be launched without recursively removing them all (at least that's my vague memory of what happened, I may well be misremembering). The flags only occurred when downloading - so on my local build I thought all was fine...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1727775157
https://github.com/qupath/qupath/issues/1337#issuecomment-1732323244:166,Availability,avail,available,166,"I've attempted a fix at https://github.com/qupath/qupath/pull/1344 - it seems to be working on my computer, so if no new problems arise the correct version should be available in the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1732323244
https://github.com/qupath/qupath/issues/1337#issuecomment-1732323244:188,Deployability,release,release,188,"I've attempted a fix at https://github.com/qupath/qupath/pull/1344 - it seems to be working on my computer, so if no new problems arise the correct version should be available in the next release.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1732323244
https://github.com/qupath/qupath/issues/1337#issuecomment-1732342967:38,Deployability,release,release,38,"Should definitely mention this in the release notes, because v0.5+ will be newer than v1 (until the ""real"" v1 happens)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1732342967
https://github.com/qupath/qupath/issues/1337#issuecomment-1732345950:226,Deployability,install,installed,226,"Fair enough - I've also gone rogue in including the version number in the name, e.g. `QuPath-0.5.5.app`. It's not the Mac way to do things, but I figure there is a strong possibility people will want to have multiple versions installed (or at least I do... and suspect everyone should).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1732345950
https://github.com/qupath/qupath/issues/1337#issuecomment-1732357842:26,Availability,down,downside,26,"Sensible. That would be a downside of the deb/rpm approach on Linux, unless we do some similar shenanigans with application names",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1732357842
https://github.com/qupath/qupath/issues/1337#issuecomment-1750316605:152,Deployability,release,release,152,"In the end I had to revert the changes that 'fixed' this because they ended up causing much bigger problems, which only emerged when preparing the next release candidate. More details at https://github.com/qupath/qupath/pull/1379",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1750316605
https://github.com/qupath/qupath/issues/1337#issuecomment-1750377772:57,Deployability,update,update,57,hey @petebankhead were you using the defaults command to update the version number? Not sure if you noticed my edit to the original post here:; Edit: you will need to change the permissions of the file after running above command as it will be 600 and should be 664; sudo chmod 664 /Applications/QuPath.app/Contents/Info.plist. Perhaps the plist was seen as damaged after modifying it and the file then had the incorrect permissions?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1750377772
https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372:253,Availability,down,downloading,253,"I tried `defaults` first, but quickly ran into the permissions problem - so switched to `PlistBuddy` as suggested at https://github.com/qupath/qupath/issues/1250. That *seemed* to work, but it turned out to still fail in confusing and subtle ways after downloading & installing. After very many hours spent trying to sort it out, I had to admit defeat because it was blocking the release - details are at https://github.com/qupath/qupath/pull/1379",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372
https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372:267,Deployability,install,installing,267,"I tried `defaults` first, but quickly ran into the permissions problem - so switched to `PlistBuddy` as suggested at https://github.com/qupath/qupath/issues/1250. That *seemed* to work, but it turned out to still fail in confusing and subtle ways after downloading & installing. After very many hours spent trying to sort it out, I had to admit defeat because it was blocking the release - details are at https://github.com/qupath/qupath/pull/1379",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372
https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372:380,Deployability,release,release,380,"I tried `defaults` first, but quickly ran into the permissions problem - so switched to `PlistBuddy` as suggested at https://github.com/qupath/qupath/issues/1250. That *seemed* to work, but it turned out to still fail in confusing and subtle ways after downloading & installing. After very many hours spent trying to sort it out, I had to admit defeat because it was blocking the release - details are at https://github.com/qupath/qupath/pull/1379",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1337#issuecomment-1750386372
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:2623,Availability,ERROR,ERROR,2623,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:2829,Availability,ERROR,ERROR,2829,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:3035,Availability,ERROR,ERROR,3035,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:1784,Security,secur,security,1784,"javafx.event.CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:56); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.event.Event.fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:1793,Security,Access,AccessController,1793,"CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:56); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.event.Event.fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [J",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:1823,Security,Access,AccessController,1823,".dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:56); 	at com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.event.Event.fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Threa",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:2775,Testability,log,log,2775,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:2981,Testability,log,log,2981,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846:3187,Testability,log,log,3187,".fireEvent(Event.java:198); 	at javafx.scene.Scene$DnDGesture.fireEvent(Scene.java:3144); 	at javafx.scene.Scene$DnDGesture.processTargetEnterOver(Scene.java:3316); 	at javafx.scene.Scene$DropTargetListener.dragEnter(Scene.java:3024); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.lambda$handleDragEnter$0(GlassSceneDnDEventHandler.java:83); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:399); 	at com.sun.javafx.tk.quantum.GlassSceneDnDEventHandler.handleDragEnter(GlassSceneDnDEventHandler.java:77); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.lambda$handleDragEnter$9(GlassViewEventHandler.java:733); 	at com.sun.javafx.tk.quantum.QuantumToolkit.runWithoutRenderLock(QuantumToolkit.java:424); 	at com.sun.javafx.tk.quantum.GlassViewEventHandler.handleDragEnter(GlassViewEventHandler.java:732); 	at com.sun.glass.ui.View.handleDragEnter(View.java:684); 	at com.sun.glass.ui.View.notifyDragEnter(View.java:1020); 	at com.sun.glass.ui.gtk.GtkApplication._runLoop(Native Method); 	at com.sun.glass.ui.gtk.GtkApplication.lambda$runLoop$11(GtkApplication.java:316); 	at java.base/java.lang.Thread.run(Thread.java:833); 13:36:13.428 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:13.788 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); 13:36:14.052 [JavaFX Application Thread] [ERROR] q.l.g.QuPathUncaughtExceptionHandler - setDropCompleted can be called only from DRAG_DROPPED handler (see full stack trace above, or use 'debug' log level); ```. This doesn't happen with files or lists. (actually, this happens when the dragboard has a string, because apparently dragging+dropping URLs from a web browser doesn't make them recognised as URLs by dragboard)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1727641846
https://github.com/qupath/qupath/pull/1338#issuecomment-1730992725:327,Safety,avoid,avoided,327,"Thanks, I made a small change to reinstate the imports that had been converted to starred imports* & fixed a few of my old formatting/doc issues. I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. *-I've consistently avoided them & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1730992725
https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750:317,Availability,error,error,317,"> I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. Yeah I suspect it's a Linux issue, either way I think trying to handle Strings as URLs is about the best we can do, as long as it shows the right kind of error. > *-I've consistently avoided [starred imports] & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy. I don't pay any heed to imports; they're automatically hidden for me. The only strong argument I've been exposed to on the topic was that having a) a license and b) every imported class/static method right at the top of the file means that every file you open, you need to page down a couple of times before reading any code. If there was a risk of ambiguity I might be more concerned, but I think when there's a collision Java forces you to use a fully qualified name?. Anyways I think the license and imports are auto-hidden for me, so this doesn't really matter",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750
https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750:759,Availability,down,down,759,"> I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. Yeah I suspect it's a Linux issue, either way I think trying to handle Strings as URLs is about the best we can do, as long as it shows the right kind of error. > *-I've consistently avoided [starred imports] & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy. I don't pay any heed to imports; they're automatically hidden for me. The only strong argument I've been exposed to on the topic was that having a) a license and b) every imported class/static method right at the top of the file means that every file you open, you need to page down a couple of times before reading any code. If there was a risk of ambiguity I might be more concerned, but I think when there's a collision Java forces you to use a fully qualified name?. Anyways I think the license and imports are auto-hidden for me, so this doesn't really matter",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750
https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750:346,Safety,avoid,avoided,346,"> I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. Yeah I suspect it's a Linux issue, either way I think trying to handle Strings as URLs is about the best we can do, as long as it shows the right kind of error. > *-I've consistently avoided [starred imports] & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy. I don't pay any heed to imports; they're automatically hidden for me. The only strong argument I've been exposed to on the topic was that having a) a license and b) every imported class/static method right at the top of the file means that every file you open, you need to page down a couple of times before reading any code. If there was a risk of ambiguity I might be more concerned, but I think when there's a collision Java forces you to use a fully qualified name?. Anyways I think the license and imports are auto-hidden for me, so this doesn't really matter",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750
https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750:822,Safety,risk,risk,822,"> I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. Yeah I suspect it's a Linux issue, either way I think trying to handle Strings as URLs is about the best we can do, as long as it shows the right kind of error. > *-I've consistently avoided [starred imports] & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy. I don't pay any heed to imports; they're automatically hidden for me. The only strong argument I've been exposed to on the topic was that having a) a license and b) every imported class/static method right at the top of the file means that every file you open, you need to page down a couple of times before reading any code. If there was a risk of ambiguity I might be more concerned, but I think when there's a collision Java forces you to use a fully qualified name?. Anyways I think the license and imports are auto-hidden for me, so this doesn't really matter",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750
https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750:586,Security,expose,exposed,586,"> I can't replicate the bug on my Mac - if I drag a URL from chrome, the dragboard contains both a URL and a String - but good if it solves the problem somewhere. Yeah I suspect it's a Linux issue, either way I think trying to handle Strings as URLs is about the best we can do, as long as it shows the right kind of error. > *-I've consistently avoided [starred imports] & convinced my IntelliJ to stop doing it automatically - can discuss later if we want to change that policy. I don't pay any heed to imports; they're automatically hidden for me. The only strong argument I've been exposed to on the topic was that having a) a license and b) every imported class/static method right at the top of the file means that every file you open, you need to page down a couple of times before reading any code. If there was a risk of ambiguity I might be more concerned, but I think when there's a collision Java forces you to use a fully qualified name?. Anyways I think the license and imports are auto-hidden for me, so this doesn't really matter",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731105750
https://github.com/qupath/qupath/pull/1338#issuecomment-1731132912:372,Availability,down,down,372,"> I think when there's a collision Java forces you to use a fully qualified name. It does, but I think they look ugly and weird in code. I tend to prefer the overview of what the class really uses, rather than 'a class here, a class there, some between 0 and absolutely everything from package X...'. I figure that, even with starred imports, there will be a need to page down anyway.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1338#issuecomment-1731132912
https://github.com/qupath/qupath/pull/1339#issuecomment-1729273471:157,Testability,log,log-viewer,157,"Thanks Alan! While you're there, did you happen to see if it can be set more sensible in an automatic way, as @Rylern suggested at https://github.com/qupath/log-viewer/issues/56#issuecomment-1723196589 ? My hard-coded values don't feel great... and, indeed, were wrong as you've shown.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729273471
https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100:341,Performance,perform,perform,341,"> Thanks Alan! While you're there, did you happen to see if it can be set more sensible in an automatic way, as @Rylern suggested at [qupath/log-viewer#56 (comment)](https://github.com/qupath/log-viewer/issues/56#issuecomment-1723196589) ? My hard-coded values don't feel great... and, indeed, were wrong as you've shown. I actually have to perform some small changes to the LogViewer before using its preferred size. I'm looking at it right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100
https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100:141,Testability,log,log-viewer,141,"> Thanks Alan! While you're there, did you happen to see if it can be set more sensible in an automatic way, as @Rylern suggested at [qupath/log-viewer#56 (comment)](https://github.com/qupath/log-viewer/issues/56#issuecomment-1723196589) ? My hard-coded values don't feel great... and, indeed, were wrong as you've shown. I actually have to perform some small changes to the LogViewer before using its preferred size. I'm looking at it right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100
https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100:192,Testability,log,log-viewer,192,"> Thanks Alan! While you're there, did you happen to see if it can be set more sensible in an automatic way, as @Rylern suggested at [qupath/log-viewer#56 (comment)](https://github.com/qupath/log-viewer/issues/56#issuecomment-1723196589) ? My hard-coded values don't feel great... and, indeed, were wrong as you've shown. I actually have to perform some small changes to the LogViewer before using its preferred size. I'm looking at it right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100
https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100:375,Testability,Log,LogViewer,375,"> Thanks Alan! While you're there, did you happen to see if it can be set more sensible in an automatic way, as @Rylern suggested at [qupath/log-viewer#56 (comment)](https://github.com/qupath/log-viewer/issues/56#issuecomment-1723196589) ? My hard-coded values don't feel great... and, indeed, were wrong as you've shown. I actually have to perform some small changes to the LogViewer before using its preferred size. I'm looking at it right now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729286100
https://github.com/qupath/qupath/pull/1339#issuecomment-1729327335:2,Deployability,update,updated,2,I updated my [pull request](https://github.com/qupath/log-viewer/pull/59) with these changes,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729327335
https://github.com/qupath/qupath/pull/1339#issuecomment-1729327335:54,Testability,log,log-viewer,54,I updated my [pull request](https://github.com/qupath/log-viewer/pull/59) with these changes,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729327335
https://github.com/qupath/qupath/pull/1339#issuecomment-1729330883:60,Testability,log,logic,60,Seems missing from the FXML now? But maybe I'm missing some logic,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1729330883
https://github.com/qupath/qupath/pull/1339#issuecomment-1731012559:43,Testability,log,log-viewer,43,"Hmmm, when using https://github.com/qupath/log-viewer/pull/59 via `includeBuild` this PR isn't working for me - I'm getting an exception as soon as I attempt to open the log viewer, and the pref width & height are still being returned as -1; ```; qupath.fx.dialogs.Dialogs - QuPath exception: The width and height must be >= 0. Got: width=-1; height=0; java.lang.IllegalArgumentException: The width and height must be >= 0. Got: width=-1; height=0; ```. Is this working for others? If so, I guess something is wrong with my setup and it's really using the older code...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731012559
https://github.com/qupath/qupath/pull/1339#issuecomment-1731012559:170,Testability,log,log,170,"Hmmm, when using https://github.com/qupath/log-viewer/pull/59 via `includeBuild` this PR isn't working for me - I'm getting an exception as soon as I attempt to open the log viewer, and the pref width & height are still being returned as -1; ```; qupath.fx.dialogs.Dialogs - QuPath exception: The width and height must be >= 0. Got: width=-1; height=0; java.lang.IllegalArgumentException: The width and height must be >= 0. Got: width=-1; height=0; ```. Is this working for others? If so, I guess something is wrong with my setup and it's really using the older code...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731012559
https://github.com/qupath/qupath/pull/1339#issuecomment-1731064209:27,Testability,log,logviewer,27,"Sorry, yes you should use `logviewer.getWidth()` and `logviewer.getHeight()` instead",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731064209
https://github.com/qupath/qupath/pull/1339#issuecomment-1731064209:54,Testability,log,logviewer,54,"Sorry, yes you should use `logviewer.getWidth()` and `logviewer.getHeight()` instead",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731064209
https://github.com/qupath/qupath/pull/1339#issuecomment-1731070755:27,Deployability,update,update,27,"Great, thanks - no need to update here, I'll add that into a new PR I'm making to use the latest changes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731070755
https://github.com/qupath/qupath/pull/1339#issuecomment-1731182428:47,Deployability,update,updated,47,"> Yes, looks good to me!. The pull request was updated",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731182428
https://github.com/qupath/qupath/pull/1339#issuecomment-1731192852:51,Deployability,update,updated,51,"> > Yes, looks good to me!; > The pull request was updated. How should I set the min width / height now on the QuPath side?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731192852
https://github.com/qupath/qupath/pull/1339#issuecomment-1731193745:72,Testability,log,log,72,BTW not planning to merge this one as I have a PR to add badges for the log viewer as well... so it's easier to just add the min sizes there rather than try to merge.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731193745
https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742:57,Deployability,update,updated,57,"> > > Yes, looks good to me!; > > > The pull request was updated; > ; > How should I set the min width / height now on the QuPath side?. `logviewer.getWidth()` and `logviewer.getHeight()` should work",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742
https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742:138,Testability,log,logviewer,138,"> > > Yes, looks good to me!; > > > The pull request was updated; > ; > How should I set the min width / height now on the QuPath side?. `logviewer.getWidth()` and `logviewer.getHeight()` should work",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742
https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742:165,Testability,log,logviewer,165,"> > > Yes, looks good to me!; > > > The pull request was updated; > ; > How should I set the min width / height now on the QuPath side?. `logviewer.getWidth()` and `logviewer.getHeight()` should work",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731204742
https://github.com/qupath/qupath/pull/1339#issuecomment-1731210816:52,Testability,log,log,52,"Ok, that works. Still not ideal, since it means the log viewer always opens at a small size... Is there no way to specify the *minimum* sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. @alanocallaghan thanks, yup - I've added those lines to my code-in-progress.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731210816
https://github.com/qupath/qupath/pull/1339#issuecomment-1731210816:150,Testability,log,log,150,"Ok, that works. Still not ideal, since it means the log viewer always opens at a small size... Is there no way to specify the *minimum* sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. @alanocallaghan thanks, yup - I've added those lines to my code-in-progress.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731210816
https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439:92,Integrability,message,message,92,"I'll merge the PR anyway, because it solves the problem of not being able to access the log message counts - so that bit is great. The minimum size looks good too, so if there's a way to enforce it as the minimum rather than preferred then that would be useful in a future PR.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439
https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439:77,Security,access,access,77,"I'll merge the PR anyway, because it solves the problem of not being able to access the log message counts - so that bit is great. The minimum size looks good too, so if there's a way to enforce it as the minimum rather than preferred then that would be useful in a future PR.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439
https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439:88,Testability,log,log,88,"I'll merge the PR anyway, because it solves the problem of not being able to access the log message counts - so that bit is great. The minimum size looks good too, so if there's a way to enforce it as the minimum rather than preferred then that would be useful in a future PR.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731213439
https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836:57,Testability,log,log,57,"> Is there no way to specify the _minimum_ sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. I tried to set the minimum size of the log viewer to its computed size, and the preferred size to something arbitrary like 800. However, `logviewer.getMinWidth()` returns -1 in that situation. A workaround would be (in the quPath side) to set the width/height of the window after setting its min width:; ```java; dialog.setMinWidth(logviewer.getPrefWidth());; dialog.setMinHeight(logviewer.getPrefHeight());. dialog.setWidth(800);; dialog.setHeight(600);; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836
https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836:220,Testability,log,log,220,"> Is there no way to specify the _minimum_ sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. I tried to set the minimum size of the log viewer to its computed size, and the preferred size to something arbitrary like 800. However, `logviewer.getMinWidth()` returns -1 in that situation. A workaround would be (in the quPath side) to set the width/height of the window after setting its min width:; ```java; dialog.setMinWidth(logviewer.getPrefWidth());; dialog.setMinHeight(logviewer.getPrefHeight());. dialog.setWidth(800);; dialog.setHeight(600);; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836
https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836:319,Testability,log,logviewer,319,"> Is there no way to specify the _minimum_ sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. I tried to set the minimum size of the log viewer to its computed size, and the preferred size to something arbitrary like 800. However, `logviewer.getMinWidth()` returns -1 in that situation. A workaround would be (in the quPath side) to set the width/height of the window after setting its min width:; ```java; dialog.setMinWidth(logviewer.getPrefWidth());; dialog.setMinHeight(logviewer.getPrefHeight());. dialog.setWidth(800);; dialog.setHeight(600);; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836
https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836:513,Testability,log,logviewer,513,"> Is there no way to specify the _minimum_ sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. I tried to set the minimum size of the log viewer to its computed size, and the preferred size to something arbitrary like 800. However, `logviewer.getMinWidth()` returns -1 in that situation. A workaround would be (in the quPath side) to set the width/height of the window after setting its min width:; ```java; dialog.setMinWidth(logviewer.getPrefWidth());; dialog.setMinHeight(logviewer.getPrefHeight());. dialog.setWidth(800);; dialog.setHeight(600);; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836
https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836:561,Testability,log,logviewer,561,"> Is there no way to specify the _minimum_ sizes for the log viewer component, rather than relying on the preferred sizes? The preferred size could (and probably should) be larger. I tried to set the minimum size of the log viewer to its computed size, and the preferred size to something arbitrary like 800. However, `logviewer.getMinWidth()` returns -1 in that situation. A workaround would be (in the quPath side) to set the width/height of the window after setting its min width:; ```java; dialog.setMinWidth(logviewer.getPrefWidth());; dialog.setMinHeight(logviewer.getPrefHeight());. dialog.setWidth(800);; dialog.setHeight(600);; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1339#issuecomment-1731253836
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1168,Availability,Down,Download,1168," that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1436,Availability,redundant,redundant,1436," text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional exten",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1535,Availability,avail,available,1535,"the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1571,Availability,down,download,1571,"the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1740,Availability,Down,Download,1740," at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit technical for what this GUI component is. I'd have done core vs non-core, but is there a way of distinguishing between core and non-core extensions? The only d",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1800,Availability,down,download,1800,"e; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit technical for what this GUI component is. I'd have done core vs non-core, but is there a way of distinguishing between core and non-core extensions? The only distinction I could dig out was those that implement GitHubProject (or ImageServerProvider). I ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:919,Deployability,update,update,919,"- [x] 'Owner' is higher than 'Repository'; - [x] The gap before 'Cancel' seems to be using space that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1018,Deployability,update,update,1018," that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1036,Deployability,update,updates,1036," that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1057,Deployability,update,update,1057," that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1179,Deployability,install,install,1179," that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1454,Deployability,update,update,1454,"thing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1472,Deployability,update,updates,1472,"thing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1493,Deployability,update,update,1493,"thing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1516,Deployability,update,updates,1516,"the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1751,Deployability,install,install,1751," at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit technical for what this GUI component is. I'd have done core vs non-core, but is there a way of distinguishing between core and non-core extensions? The only d",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:3008,Deployability,install,installed,3008,"and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit technical for what this GUI component is. I'd have done core vs non-core, but is there a way of distinguishing between core and non-core extensions? The only distinction I could dig out was those that implement GitHubProject (or ImageServerProvider). I could hard code them, but that seems a bit fragile. What I have gone with in the current version is ""Editable"" vs ""non-editable"", but this is... well just wrong really. Relatedly, that means that some of the user-installed extensions also can't be updated, so those buttons will need to be disabled also.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:3043,Deployability,update,updated,3043,"and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional extensions'. That might help explain the differences in behavior. I don't think ""Server"" vs ""extension"" is useful yeah, it seems a bit technical for what this GUI component is. I'd have done core vs non-core, but is there a way of distinguishing between core and non-core extensions? The only distinction I could dig out was those that implement GitHubProject (or ImageServerProvider). I could hard code them, but that seems a bit fragile. What I have gone with in the current version is ""Editable"" vs ""non-editable"", but this is... well just wrong really. Relatedly, that means that some of the user-installed extensions also can't be updated, so those buttons will need to be disabled also.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:1436,Safety,redund,redundant,1436," text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the bottom isn't. The titles are obviously WIP (see below). Same with the extensions dir button not being full-width (although I don't truly love that personally, it's up to you). > Finally, I think splitting the lists at the top into different sections would make sense, if they have different purposes. Rather than 'servers' and 'extensions', they could be split between 'Built-in extensions' and 'Optional exten",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490:340,Usability,clear,clear,340,"- [x] 'Owner' is higher than 'Repository'; - [x] The gap before 'Cancel' seems to be using space that 'Repository' could have; - [x] There should be some separation between the owner text field and repository label; - [x] After clicking 'Add extension' once, the other options appear - but then clicking it again has no effect. So it's not clear what exactly is the purpose of the button, or if it has the right text on it.; - [x] It's confusing that there's a list, but nothing can be selected. If I click on the list, the top item can take the focus, but nothing else.; - [x] I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start; I think centred vertical alignment for the version and buttons would look bette; - [x] The description text would ideally be lighter in color (e.g. using opacity); - [x] The purpose of the 'remove' and 'update' buttons is unclear - especially for built-in extension that can't be changed. ; - [x] Does update 'Check for updates' or actually update?; - [x] I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. > I'm not sure if the version needs some indication of what it is, either by using a table (and column heading) or adding a v at the start;. I'd be more inclined to even do ""version: 0.1.0"" rather than having column headers that would be largely redundant. > Does update 'Check for updates' or actually update?. It checks for updates; if one is available, it asks if you'd like to download it. If not, it pops up a notification saying it's up-to-date. > I'm not sure that 'Cancel' and 'Accept' are the right terms; I assume 'Accept' basically means 'Download & install'?. Yes, similarly it asks if you want to download before going ahead. ![Screenshot from 2023-10-02 22-37-08](https://github.com/qupath/qupath/assets/10779688/b0404e3f-320d-4fbf-b990-3cad161dee24). Note that here the top list is focusable, the",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1743806490
https://github.com/qupath/qupath/pull/1342#issuecomment-1744758115:0,Deployability,Update,Updated,0,Updated classifications based on classloaders. ![Screenshot from 2023-10-03 12-09-12](https://github.com/qupath/qupath/assets/10779688/1296295b-28dc-4cd7-9fa4-717c1b2f0842),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1744758115
https://github.com/qupath/qupath/pull/1342#issuecomment-1748473193:336,Usability,clear,clearly,336,"(On a call, so these comments are made with only half my attention...). I like the main split with title panes, but think I was wrong to separate the built-in in this way - it looks odd when one list is full and the other isn't, and sizing doesn't accommodate this. The same list would be fine for both, as long as there is some way to clearly distinguish that some are built-in and that's why they look different. The panes shouldn't be collapsible, to make it harder to create unexpected layouts. I really like opening the URL on double-click, but wonder if that should be a third button? I'm apprehensive about launching a browser without the user knowing that is what will happen.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748473193
https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250:34,Deployability,install,installed,34,"Also, I have an invalid extension installed (the [OMERO one currently isn't compatible](https://github.com/qupath/qupath-extension-omero)). If that could be captured here to easily remove that it would be great; currently, it isn't displayed at all. That might require more refactoring, since it is identified as invalid at the point when there is an attempt to install it... and so isn't added to the extensions list. Finally, could / should there be a way to list additional jars that are in the extensions directory but not actual extensions? Even just a count would be informative. I'm thinking of the scenario when a user deletes an extension, but doesn't have any knowledge of the fact that its dependencies are lingering. I know we don't have proper management of the dependencies, but some indication it's an issue would be good.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250
https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250:362,Deployability,install,install,362,"Also, I have an invalid extension installed (the [OMERO one currently isn't compatible](https://github.com/qupath/qupath-extension-omero)). If that could be captured here to easily remove that it would be great; currently, it isn't displayed at all. That might require more refactoring, since it is identified as invalid at the point when there is an attempt to install it... and so isn't added to the extensions list. Finally, could / should there be a way to list additional jars that are in the extensions directory but not actual extensions? Even just a count would be informative. I'm thinking of the scenario when a user deletes an extension, but doesn't have any knowledge of the fact that its dependencies are lingering. I know we don't have proper management of the dependencies, but some indication it's an issue would be good.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250
https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250:701,Integrability,depend,dependencies,701,"Also, I have an invalid extension installed (the [OMERO one currently isn't compatible](https://github.com/qupath/qupath-extension-omero)). If that could be captured here to easily remove that it would be great; currently, it isn't displayed at all. That might require more refactoring, since it is identified as invalid at the point when there is an attempt to install it... and so isn't added to the extensions list. Finally, could / should there be a way to list additional jars that are in the extensions directory but not actual extensions? Even just a count would be informative. I'm thinking of the scenario when a user deletes an extension, but doesn't have any knowledge of the fact that its dependencies are lingering. I know we don't have proper management of the dependencies, but some indication it's an issue would be good.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250
https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250:775,Integrability,depend,dependencies,775,"Also, I have an invalid extension installed (the [OMERO one currently isn't compatible](https://github.com/qupath/qupath-extension-omero)). If that could be captured here to easily remove that it would be great; currently, it isn't displayed at all. That might require more refactoring, since it is identified as invalid at the point when there is an attempt to install it... and so isn't added to the extensions list. Finally, could / should there be a way to list additional jars that are in the extensions directory but not actual extensions? Even just a count would be informative. I'm thinking of the scenario when a user deletes an extension, but doesn't have any knowledge of the fact that its dependencies are lingering. I know we don't have proper management of the dependencies, but some indication it's an issue would be good.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250
https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250:274,Modifiability,refactor,refactoring,274,"Also, I have an invalid extension installed (the [OMERO one currently isn't compatible](https://github.com/qupath/qupath-extension-omero)). If that could be captured here to easily remove that it would be great; currently, it isn't displayed at all. That might require more refactoring, since it is identified as invalid at the point when there is an attempt to install it... and so isn't added to the extensions list. Finally, could / should there be a way to list additional jars that are in the extensions directory but not actual extensions? Even just a count would be informative. I'm thinking of the scenario when a user deletes an extension, but doesn't have any knowledge of the fact that its dependencies are lingering. I know we don't have proper management of the dependencies, but some indication it's an issue would be good.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748479250
https://github.com/qupath/qupath/pull/1342#issuecomment-1748510267:261,Availability,down,down,261,"It looks good, got a few bugs/points (sorry ignore if any are repeats from what's already been discussed) ; 1. The extension text is black in dark mode; 2. For the order, should ""Core Extensions"" be first since this will be relevant for all users? Then filters down to those wanting to explore extensions further? I do like the idea of combining the ""Manage Extension"" section into a bar at the top of the ""User Extensions"" section.; 3. Also the ""Core Extensions"" section could have a max height defined since we know the number of extensions?; 4. Width of window on opening squishes the ""Manage Extension"" section, increase width or change ""download"" to the symbol also used in WSInfer?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748510267
https://github.com/qupath/qupath/pull/1342#issuecomment-1748510267:642,Availability,down,download,642,"It looks good, got a few bugs/points (sorry ignore if any are repeats from what's already been discussed) ; 1. The extension text is black in dark mode; 2. For the order, should ""Core Extensions"" be first since this will be relevant for all users? Then filters down to those wanting to explore extensions further? I do like the idea of combining the ""Manage Extension"" section into a bar at the top of the ""User Extensions"" section.; 3. Also the ""Core Extensions"" section could have a max height defined since we know the number of extensions?; 4. Width of window on opening squishes the ""Manage Extension"" section, increase width or change ""download"" to the symbol also used in WSInfer?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748510267
https://github.com/qupath/qupath/pull/1342#issuecomment-1748590254:107,Availability,down,down,107,"> For the order, should ""Core Extensions"" be first since this will be relevant for all users? Then filters down to those wanting to explore extensions further? I do like the idea of combining the ""Manage Extension"" section into a bar at the top of the ""User Extensions"" section. My logic was that you can't actually *do* anything with core extensions, but I remain undecided there. The rest are all good points, unlikely to be able to address them all today",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748590254
https://github.com/qupath/qupath/pull/1342#issuecomment-1748590254:282,Testability,log,logic,282,"> For the order, should ""Core Extensions"" be first since this will be relevant for all users? Then filters down to those wanting to explore extensions further? I do like the idea of combining the ""Manage Extension"" section into a bar at the top of the ""User Extensions"" section. My logic was that you can't actually *do* anything with core extensions, but I remain undecided there. The rest are all good points, unlikely to be able to address them all today",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1748590254
https://github.com/qupath/qupath/pull/1342#issuecomment-1749116788:255,Availability,avail,avail,255,"Thanks for the feedback - I much prefer the look of this. Remaining issues:. - Probably lots I've not noticed; - When you make the height large, it drags out into empty unused space at the bottom (pictured). Have tried various VBox.vgrow settings, but no avail. ![Screenshot from 2023-10-05 16-16-21](https://github.com/qupath/qupath/assets/10779688/547cea53-f03c-4f01-9ec1-ca5828082f61)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1749116788
https://github.com/qupath/qupath/pull/1342#issuecomment-1749116788:15,Usability,feedback,feedback,15,"Thanks for the feedback - I much prefer the look of this. Remaining issues:. - Probably lots I've not noticed; - When you make the height large, it drags out into empty unused space at the bottom (pictured). Have tried various VBox.vgrow settings, but no avail. ![Screenshot from 2023-10-05 16-16-21](https://github.com/qupath/qupath/assets/10779688/547cea53-f03c-4f01-9ec1-ca5828082f61)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1342#issuecomment-1749116788
https://github.com/qupath/qupath/pull/1353#issuecomment-1740764803:332,Testability,log,logic,332,"Not sure about the first point; I still struggle with JavaFX's min/max/pref sizes, and other more annoying bugs persist (like the growing dialog when training a pixel classifier). For the second, the possibly-cleanest way would be to make it a command in the main menubar. If it's fired, then it hunts for the in-focus window using logic somewhat like https://github.com/qupath/qupath-fxtras/blob/9b043792b3b454f1376e57c32e36f8a74aa482ad/src/main/java/qupath/fx/dialogs/Dialogs.java#L486. That way it should work for stages that don't have menubars, for whom the events propagate to the main stage... or at least I think it would. I've failed with menubars and accelerators before, and the behavior across platforms also varies a bit - so it needs careful checking.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1353#issuecomment-1740764803
https://github.com/qupath/qupath/pull/1353#issuecomment-1740766092:50,Testability,log,log,50,shortcut+w already works in the script editor and log viewer (but only because they explicitly add that as an accelerator).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1353#issuecomment-1740766092
https://github.com/qupath/qupath/issues/1354#issuecomment-1741726252:13,Deployability,update,updated,13,"Thanks, I've updated the javadoc to; ```java; /**; 	 * Create ROIs from labels in an image.; 	 *; 	 * @param ipLabels the labeled image; generally this should be a ByteProcessor or ShortProcessor; 	 * @param n the total number of labels; often this is equal to the maximum value in the image; 	 * @return an array of length n; output[i] is the ROI for label i+1, or null if no Roi is found; 	 * with that label.; 	 */; ```; The class generally remains awkward to use and could benefit from some less ambiguous methods, but they aren't really used much for any new QuPath commands.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1354#issuecomment-1741726252
https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473:64,Deployability,release,release,64,"Since I think the trouble started with JavaFX 21.0.1, from the [release notes](https://gluonhq.com/products/javafx/openjfx-21-release-notes/#21.0.1) my guess was the webkit update... but not sure..",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473
https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473:126,Deployability,release,release-notes,126,"Since I think the trouble started with JavaFX 21.0.1, from the [release notes](https://gluonhq.com/products/javafx/openjfx-21-release-notes/#21.0.1) my guess was the webkit update... but not sure..",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473
https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473:173,Deployability,update,update,173,"Since I think the trouble started with JavaFX 21.0.1, from the [release notes](https://gluonhq.com/products/javafx/openjfx-21-release-notes/#21.0.1) my guess was the webkit update... but not sure..",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1358#issuecomment-2056313473
https://github.com/qupath/qupath/pull/1366#issuecomment-1747765767:25,Security,hash,hashes,25,"Ah yes! Forgot about the hashes, should be an easy fix",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1366#issuecomment-1747765767
https://github.com/qupath/qupath/pull/1368#issuecomment-1748159654:37,Deployability,update,updated,37,"This wasn't working for me, but I've updated the PR and also incorporating the architecture into the package name for macOS (since it should then be easier to have x64 and aarch64 installed side-by-side)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1368#issuecomment-1748159654
https://github.com/qupath/qupath/pull/1368#issuecomment-1748159654:180,Deployability,install,installed,180,"This wasn't working for me, but I've updated the PR and also incorporating the architecture into the package name for macOS (since it should then be easier to have x64 and aarch64 installed side-by-side)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1368#issuecomment-1748159654
https://github.com/qupath/qupath/pull/1388#issuecomment-1762376097:264,Deployability,release,release,264,"No, it just picks up my system libopenslide.so before the Jar version, which I think is not ideal, but hopefully fine once the versions get pushed to homebrew/apt/rpm. So yeah @petebankhead if this works on apple silicon and x86 Mac it should be good to publish a release of the natives and be done. Linux seems to work fine for me, and I'm grabbing the windows binary directly from them",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1762376097
https://github.com/qupath/qupath/pull/1388#issuecomment-1764462455:347,Deployability,release,release,347,"> No, it just picks up my system libopenslide.so before the Jar version, which I think is not ideal. Hmmm, is this something we should address through JNA?. In any case, it seems to be working fine here (just tried running from Gradle on M1, and both the x86_64 and aarch64 builds were working) - so I think that's good news for making the native release, or we can stick with the versioned snapshot for now if you prefer. The aim is to get rc2 out shortly, but the final v0.5.0 won't be until next week at least. We'll also need to update the info at https://github.com/qupath/qupath/tree/main/qupath-extension-openslide/src/main/resources/licenses/OpenSlide. My guess is that taking the licenses from the Windows build should be sufficient, or is anything radically different / missing if we do that?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764462455
https://github.com/qupath/qupath/pull/1388#issuecomment-1764462455:533,Deployability,update,update,533,"> No, it just picks up my system libopenslide.so before the Jar version, which I think is not ideal. Hmmm, is this something we should address through JNA?. In any case, it seems to be working fine here (just tried running from Gradle on M1, and both the x86_64 and aarch64 builds were working) - so I think that's good news for making the native release, or we can stick with the versioned snapshot for now if you prefer. The aim is to get rc2 out shortly, but the final v0.5.0 won't be until next week at least. We'll also need to update the info at https://github.com/qupath/qupath/tree/main/qupath-extension-openslide/src/main/resources/licenses/OpenSlide. My guess is that taking the licenses from the Windows build should be sufficient, or is anything radically different / missing if we do that?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764462455
https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338:117,Deployability,install,installed,117,"> Hmmm, is this something we should address through JNA?. Not sure honestly, in retrospect maybe respecting people's installed OpenSlide version is good, only falling back on the version we bundle if we have to? But at the moment it's a bit backwards, with the apt version behind ours. > In any case, it seems to be working fine here (just tried running from Gradle on M1, and both the x86_64 and aarch64 builds were working) - so I think that's good news for making the native release, or we can stick with the versioned snapshot for now if you prefer. Great, I want to make sure the main artifact (without qualifiers) includes everything, and to include the sources on maven, will do that before the main release. > My guess is that taking the licenses from the Windows build should be sufficient, or is anything radically different / missing if we do that?. I *think* the licenses should be the same across versions now for the most part - the extra windows libraries are removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338
https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338:478,Deployability,release,release,478,"> Hmmm, is this something we should address through JNA?. Not sure honestly, in retrospect maybe respecting people's installed OpenSlide version is good, only falling back on the version we bundle if we have to? But at the moment it's a bit backwards, with the apt version behind ours. > In any case, it seems to be working fine here (just tried running from Gradle on M1, and both the x86_64 and aarch64 builds were working) - so I think that's good news for making the native release, or we can stick with the versioned snapshot for now if you prefer. Great, I want to make sure the main artifact (without qualifiers) includes everything, and to include the sources on maven, will do that before the main release. > My guess is that taking the licenses from the Windows build should be sufficient, or is anything radically different / missing if we do that?. I *think* the licenses should be the same across versions now for the most part - the extra windows libraries are removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338
https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338:707,Deployability,release,release,707,"> Hmmm, is this something we should address through JNA?. Not sure honestly, in retrospect maybe respecting people's installed OpenSlide version is good, only falling back on the version we bundle if we have to? But at the moment it's a bit backwards, with the apt version behind ours. > In any case, it seems to be working fine here (just tried running from Gradle on M1, and both the x86_64 and aarch64 builds were working) - so I think that's good news for making the native release, or we can stick with the versioned snapshot for now if you prefer. Great, I want to make sure the main artifact (without qualifiers) includes everything, and to include the sources on maven, will do that before the main release. > My guess is that taking the licenses from the Windows build should be sufficient, or is anything radically different / missing if we do that?. I *think* the licenses should be the same across versions now for the most part - the extra windows libraries are removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764471338
https://github.com/qupath/qupath/pull/1388#issuecomment-1764629994:19,Performance,load,load,19,"Last commit should load directly the file from the jar, unless the openslide path is set in prefs",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764629994
https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837:33,Deployability,release,release,33,"Licenses are up-to-date. For the release of the natives Jar for the final 0.5 release I'd like to have everything semi-cleanly coming from one repo, rather than currently taking their dll directly from openslide.org for windows. Therefore this is good to go, unless you want to clean up the loading code",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837
https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837:78,Deployability,release,release,78,"Licenses are up-to-date. For the release of the natives Jar for the final 0.5 release I'd like to have everything semi-cleanly coming from one repo, rather than currently taking their dll directly from openslide.org for windows. Therefore this is good to go, unless you want to clean up the loading code",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837
https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837:291,Performance,load,loading,291,"Licenses are up-to-date. For the release of the natives Jar for the final 0.5 release I'd like to have everything semi-cleanly coming from one repo, rather than currently taking their dll directly from openslide.org for windows. Therefore this is good to go, unless you want to clean up the loading code",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1388#issuecomment-1764700837
https://github.com/qupath/qupath/issues/1397#issuecomment-1772455277:200,Testability,test,test,200,"Are there public example images to replicate this issue?. QuPath v0.5.0 will include OpenSlide 4.0.0, and this provides dicom WSI support. So the behavior may change then - but we have no examples to test with.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1772455277
https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935:24,Availability,down,download,24,You can try these. Just download and unzip. https://openslide.cs.cmu.edu/download/openslide-testdata/DICOM/,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935
https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935:73,Availability,down,download,73,You can try these. Just download and unzip. https://openslide.cs.cmu.edu/download/openslide-testdata/DICOM/,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935
https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935:92,Testability,test,testdata,92,You can try these. Just download and unzip. https://openslide.cs.cmu.edu/download/openslide-testdata/DICOM/,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1772871935
https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854:38,Deployability,release,release,38,"Thanks, can you try the QuPath v0.5.0 release candidate - https://github.com/qupath/qupath/releases/tag/v0.5.0-rc1 ?. This behaves different from v0.4.4, using OpenSlide to read the image. To me, it appears to behave properly - although has the limitation that if you add more than one of the dicom files, then the same image is effectively duplicated in the project. I'm not sure if that's expected or acceptable, but addressing it is probably not straightforward. Dicom is the only format I know that behaves in this way, and QuPath tries to avoid having to treat formats as a special case (relying upon OpenSlide or Bio-Formats to untangle the meaning of the image file paths provided).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854
https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854:91,Deployability,release,releases,91,"Thanks, can you try the QuPath v0.5.0 release candidate - https://github.com/qupath/qupath/releases/tag/v0.5.0-rc1 ?. This behaves different from v0.4.4, using OpenSlide to read the image. To me, it appears to behave properly - although has the limitation that if you add more than one of the dicom files, then the same image is effectively duplicated in the project. I'm not sure if that's expected or acceptable, but addressing it is probably not straightforward. Dicom is the only format I know that behaves in this way, and QuPath tries to avoid having to treat formats as a special case (relying upon OpenSlide or Bio-Formats to untangle the meaning of the image file paths provided).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854
https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854:544,Safety,avoid,avoid,544,"Thanks, can you try the QuPath v0.5.0 release candidate - https://github.com/qupath/qupath/releases/tag/v0.5.0-rc1 ?. This behaves different from v0.4.4, using OpenSlide to read the image. To me, it appears to behave properly - although has the limitation that if you add more than one of the dicom files, then the same image is effectively duplicated in the project. I'm not sure if that's expected or acceptable, but addressing it is probably not straightforward. Dicom is the only format I know that behaves in this way, and QuPath tries to avoid having to treat formats as a special case (relying upon OpenSlide or Bio-Formats to untangle the meaning of the image file paths provided).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1773053854
https://github.com/qupath/qupath/issues/1397#issuecomment-1779286034:46,Deployability,release,release,46,"Thanks for your help, yes that (QuPath v0.5.0 release candidate) seems to be opening the WSI as one image rather than several separate dcm images. However like you said it still displays the list of dcm files in the Image List which may not be desired. . Not sure what's next in terms of this ticket - the main concern is addressed but the open UX issue may want to be handled separately.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1779286034
https://github.com/qupath/qupath/issues/1397#issuecomment-1779286034:345,Usability,UX,UX,345,"Thanks for your help, yes that (QuPath v0.5.0 release candidate) seems to be opening the WSI as one image rather than several separate dcm images. However like you said it still displays the list of dcm files in the Image List which may not be desired. . Not sure what's next in terms of this ticket - the main concern is addressed but the open UX issue may want to be handled separately.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1779286034
https://github.com/qupath/qupath/issues/1397#issuecomment-1826759128:115,Usability,UX,UX,115,"Thanks, I'll close this issue since the main concern is addressed. We don't really have the capacity to tackle the UX issue, since it is a particularly awkward one. Any 'quick' solution would likely add considerable complexity to import code that is already very convoluted, and any 'thorough' solution could take weeks of effort - so for the foreseeable future it'll need to be up to the user to select just one dcm file.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1397#issuecomment-1826759128
https://github.com/qupath/qupath/issues/1400#issuecomment-1779756531:52,Testability,test,test,52,"I can't replicate it with any of the openslide .svs test images, so I think so too",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1400#issuecomment-1779756531
https://github.com/qupath/qupath/issues/1400#issuecomment-1781795461:173,Deployability,release,releases,173,This was closed automatically when I merged the PR... but I *think* it's fixed. Feel free to reopen if you can replicate it in [v0.5.0-rc2](https://github.com/qupath/qupath/releases/tag/v0.5.0-rc2).,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1400#issuecomment-1781795461
https://github.com/qupath/qupath/issues/1406#issuecomment-1782786354:344,Availability,down,download,344,"> Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta2 on the Intel build, since this would give an alternative. Previously it failed, but it's worth checking again with the latest DeepJavaLibrary. Can confirm this definitely does **not** work... in fact, it causes QuPath to abruptly quit when just trying to download TensorFlow and load the engine.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406#issuecomment-1782786354
https://github.com/qupath/qupath/issues/1406#issuecomment-1782786354:368,Performance,load,load,368,"> Before deciding, one thing to check is whether or not TensorFlow can work via Rosetta2 on the Intel build, since this would give an alternative. Previously it failed, but it's worth checking again with the latest DeepJavaLibrary. Can confirm this definitely does **not** work... in fact, it causes QuPath to abruptly quit when just trying to download TensorFlow and load the engine.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406#issuecomment-1782786354
https://github.com/qupath/qupath/issues/1406#issuecomment-1782837510:697,Deployability,release,release,697,"More info on using x64 build on Apple Silicon + OpenCV DNN:. * OpenCV 4.6.0 - **works!** But warns JavaCPP versions are incompatible (mixing 1.5.9 and 1.5.8); * OpenCV 4.7.0 - **fails**; * OpenCV 4.8.1 - **works!** But requires JavaCPP snapshot, `4.8.1-1.5.10-SNAPSHOT`, and a small change to QuPath's source due to an API difference (related to `Model.setScale(Scalar)`). So there seems to be 3 options, none ideal:; * Revert to OpenCV 4.6.0, *solely* for the benefit of Apple Silicon users with .czi images; * Use OpenCV 4.7.0, but require Apple Silicon users with .czi images to convert the images if they want to use StarDist; * Use OpenCV 4.8.1, but be relying on a snapshot rather than full release (of JavaCPP)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1406#issuecomment-1782837510
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:949,Availability,avail,available,949,"When splitting annotations by lines, my expectation is that the thickness will usually be 0. Supporting different units risks increasing the code complexity considerably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintain",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:1280,Deployability,toggle,toggle,1280,"erably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintainability and generalizability in the code. Anyone else can create a new extension to provide an alternative implementation for any of the commands if they want to.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:1993,Modifiability,maintainab,maintainability,1993,"erably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintainability and generalizability in the code. Anyone else can create a new extension to provide an alternative implementation for any of the commands if they want to.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:1478,Performance,perform,performance,1478,"erably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintainability and generalizability in the code. Anyone else can create a new extension to provide an alternative implementation for any of the commands if they want to.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:120,Safety,risk,risks,120,"When splitting annotations by lines, my expectation is that the thickness will usually be 0. Supporting different units risks increasing the code complexity considerably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintain",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:1534,Security,access,accessed,1534,"erably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintainability and generalizability in the code. Anyone else can create a new extension to provide an alternative implementation for any of the commands if they want to.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:800,Usability,clear,clear,800,"When splitting annotations by lines, my expectation is that the thickness will usually be 0. Supporting different units risks increasing the code complexity considerably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintain",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932:1981,Usability,simpl,simplicity,1981,"erably, because the command must also be scriptable and then somehow the units need to incorporated into any script. Additionally, QuPath is moving towards greater generality. It is increasingly used for images where µm is an inappropriate unit, so I'm reluctant to add additional code that assumes µm as the only alternative to pixels. And a properly generic system will take a lot more effort to develop (not helped by the fact that Java has no built-in support for converting units... it's a recurring theme, e.g. [here](https://jcp.org/en/jsr/detail?id=385), but as far as I'm aware there are a multiple implementations and it's not clear which, if any, we should use). This also affects the sparse image server: at the point the dialog is shown, we don't know if the pixel size is available in µm for the regions that will be required to generate the server. Furthermore, the dialog itself is [auto-generated from a `ParameterList`](https://github.com/qupath/qupath/blob/main/qupath-extension-processing/src/main/java/qupath/process/gui/commands/CreateTrainingImageCommand.java#L90), which limits the ability to toggle between units. Added to that, I'm not terribly happy with the generation of 'dynamic' training images generally; the code is really complex (since the images can be quite heterogeneous), and performance can be poor whenever many images need to be accessed to create the final result. Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. I'll leave this open for a while in case there are further comments, but my feeling is that the development-and-maintainence-time-to-benefit ratio isn't favorable enough to work on this in the core QuPath software; there are too many higher priorities, and if I'd rather focus efforts on simplicity, maintainability and generalizability in the code. Anyone else can create a new extension to provide an alternative implementation for any of the commands if they want to.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783782932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932:1045,Energy Efficiency,reduce,reduce,1045,"Fair enough, this was also an issue with Definiens back when they were porting their platform from their geospatial analysis predecessor [eCognition](https://geospatial.trimble.com/en/products/software/trimble-ecognition). Much of the backend had hardcoded units of km, which broke a lot when transitioning to a um default. I imagine this would also be an issue if QuPath was applied for the analysis of macroscopic data such as geospatial analysis. > Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. That would be useful, as I've noticed a substantially increased image load time when opening a sparse image consisting of images hosted on a NAS. One idea would be to write an ome.tiff of the sparse image inside the QuPath project on the first instance that the sparse image is loaded, and each subsequent time it's opened, it'll read that image. If the image is removed, it'll be regenerated the next time it's corresponding project entry is opened (i.e. if you want to reduce file size when sending it to a collaborator). Tangentially related, but many scripts will break when running it on a sparse image with an empty region:; ![image](https://github.com/qupath/qupath/assets/52012166/e8f61447-87a5-4e31-8c9d-377c6182ccdf); (0.5.0-rc2)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932:644,Performance,load,load,644,"Fair enough, this was also an issue with Definiens back when they were porting their platform from their geospatial analysis predecessor [eCognition](https://geospatial.trimble.com/en/products/software/trimble-ecognition). Much of the backend had hardcoded units of km, which broke a lot when transitioning to a um default. I imagine this would also be an issue if QuPath was applied for the analysis of macroscopic data such as geospatial analysis. > Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. That would be useful, as I've noticed a substantially increased image load time when opening a sparse image consisting of images hosted on a NAS. One idea would be to write an ome.tiff of the sparse image inside the QuPath project on the first instance that the sparse image is loaded, and each subsequent time it's opened, it'll read that image. If the image is removed, it'll be regenerated the next time it's corresponding project entry is opened (i.e. if you want to reduce file size when sending it to a collaborator). Tangentially related, but many scripts will break when running it on a sparse image with an empty region:; ![image](https://github.com/qupath/qupath/assets/52012166/e8f61447-87a5-4e31-8c9d-377c6182ccdf); (0.5.0-rc2)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932
https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932:852,Performance,load,loaded,852,"Fair enough, this was also an issue with Definiens back when they were porting their platform from their geospatial analysis predecessor [eCognition](https://geospatial.trimble.com/en/products/software/trimble-ecognition). Much of the backend had hardcoded units of km, which broke a lot when transitioning to a um default. I imagine this would also be an issue if QuPath was applied for the analysis of macroscopic data such as geospatial analysis. > Therefore I wonder if creating a new command that defaults to writing the image as a new file would be preferable anyway. That would be useful, as I've noticed a substantially increased image load time when opening a sparse image consisting of images hosted on a NAS. One idea would be to write an ome.tiff of the sparse image inside the QuPath project on the first instance that the sparse image is loaded, and each subsequent time it's opened, it'll read that image. If the image is removed, it'll be regenerated the next time it's corresponding project entry is opened (i.e. if you want to reduce file size when sending it to a collaborator). Tangentially related, but many scripts will break when running it on a sparse image with an empty region:; ![image](https://github.com/qupath/qupath/assets/52012166/e8f61447-87a5-4e31-8c9d-377c6182ccdf); (0.5.0-rc2)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1783927932
https://github.com/qupath/qupath/issues/1407#issuecomment-1826754801:134,Performance,load,loaded,134,"> One idea would be to write an ome.tiff of the sparse image inside the QuPath project on the first instance that the sparse image is loaded, and each subsequent time it's opened, it'll read that image. It's tempting, but OME-TIFF can take a long time to write, and that requires some decisions to be made regarding compression (which could impact pixel classifiers). Therefore I think writing any image needs to be explicitly triggered by the user to avoid unwelcome surprises. > Tangentially related, but many scripts will break when running it on a sparse image with an empty region:. I tried but couldn't replicate this. Given the intention to revisit sparse images generally, I wouldn't plan to spend time fixing it unless it is shown to be problematic in a normal workflow, with a reproducible failing example (which would really belong in a separate issue).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1826754801
https://github.com/qupath/qupath/issues/1407#issuecomment-1826754801:452,Safety,avoid,avoid,452,"> One idea would be to write an ome.tiff of the sparse image inside the QuPath project on the first instance that the sparse image is loaded, and each subsequent time it's opened, it'll read that image. It's tempting, but OME-TIFF can take a long time to write, and that requires some decisions to be made regarding compression (which could impact pixel classifiers). Therefore I think writing any image needs to be explicitly triggered by the user to avoid unwelcome surprises. > Tangentially related, but many scripts will break when running it on a sparse image with an empty region:. I tried but couldn't replicate this. Given the intention to revisit sparse images generally, I wouldn't plan to spend time fixing it unless it is shown to be problematic in a normal workflow, with a reproducible failing example (which would really belong in a separate issue).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1407#issuecomment-1826754801
https://github.com/qupath/qupath/issues/1408#issuecomment-1789215814:115,Testability,test,test,115,"Can confirm I'm not seeing (the bug) on Mac with #1410 merged, also not seeing it on the normal rc2 on Mac so will test on Windows this evening and get back to you.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1408#issuecomment-1789215814
https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843:672,Integrability,interface,interface,672,"Good question... there's no command for that currently. I think a 'Flatten hierarchy' command would make sense, but I'm not 100% sure if we should add it. The risk I can think of is that objects wouldn't necessarily end up where they started in terms of the hierarchy after using 'flatten-then-resolve', and that might be confusing. Another option is to use *Objects &rarr; Annotations... &rarr; Duplicate selected annotations* (Shift + D). The duplicated annotations have no child objects, so you can detect within them - and then delete the new annotations afterwards if you want to, and resolve the hierarchy then if you need to. That should work both through the user interface and scripting. Would that work as an alternative in your case?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843
https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843:159,Safety,risk,risk,159,"Good question... there's no command for that currently. I think a 'Flatten hierarchy' command would make sense, but I'm not 100% sure if we should add it. The risk I can think of is that objects wouldn't necessarily end up where they started in terms of the hierarchy after using 'flatten-then-resolve', and that might be confusing. Another option is to use *Objects &rarr; Annotations... &rarr; Duplicate selected annotations* (Shift + D). The duplicated annotations have no child objects, so you can detect within them - and then delete the new annotations afterwards if you want to, and resolve the hierarchy then if you need to. That should work both through the user interface and scripting. Would that work as an alternative in your case?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843
https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843:502,Safety,detect,detect,502,"Good question... there's no command for that currently. I think a 'Flatten hierarchy' command would make sense, but I'm not 100% sure if we should add it. The risk I can think of is that objects wouldn't necessarily end up where they started in terms of the hierarchy after using 'flatten-then-resolve', and that might be confusing. Another option is to use *Objects &rarr; Annotations... &rarr; Duplicate selected annotations* (Shift + D). The duplicated annotations have no child objects, so you can detect within them - and then delete the new annotations afterwards if you want to, and resolve the hierarchy then if you need to. That should work both through the user interface and scripting. Would that work as an alternative in your case?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411#issuecomment-1788879843
https://github.com/qupath/qupath/issues/1411#issuecomment-1790260581:658,Safety,detect,detectObjects,658,"Hi Pete, . Thanks for the suggestion. using duplicate works well, and it is better solution for me than deleting all the annotations and restoring them back. . as a comment for others: ; I didn't find an easy way to select the all the duplicated annotations (as only one is selected after duplication) ; so I had to loop through the selected annotations and for each of them : Select, Duplicate, run StarDist, Delete. `def Anns = getAnnotationObjects().findAll{it.getPathClass().toString()==Class1 || it.getPathClass().toString()==Class2 }; for (ann in Anns) ; {; selectObjects(ann); duplicateSelectedAnnotations() ; dup_ann = getSelectedObjects(); stardist.detectObjects(imageData, dup_ann); } ; removeObjects(Anns, true) // keep children of the removed annotation. `; best; Ofra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411#issuecomment-1790260581
https://github.com/qupath/qupath/issues/1411#issuecomment-1790289826:181,Safety,detect,detection,181,"> (as only one is selected after duplication). That's strange, when I try with two annotations selected, I see that both the duplicated annotations are selected (and I can run cell detection immediately on both of them). Although either way i'm glad it works :). Will think some more about a flatten hierarchy command for the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1411#issuecomment-1790289826
https://github.com/qupath/qupath/pull/1415#issuecomment-1798044775:405,Deployability,install,install,405,"I'll merge this because I think it solves the initial problem with exceptions due to the extensions directory not existing. I couldn't replicate the other issue on my Mac, although I'm not certain I was following the steps correctly. I first dragged https://github.com/qupath/qupath-extension-wsinfer from a browser, and then https://github.com/qupath/qupath-extension-stardist. Both extensions seemed to install 'properly', except WSInfer wasn't compatible so that confused things slightly by throwing exceptions (rightly). Immediately after installation, the extension manager wrongly showed the StarDist extension version as being v0.5.0-SNAPSHOT, but after relaunching QuPath this was corrected to v0.4.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1415#issuecomment-1798044775
https://github.com/qupath/qupath/pull/1415#issuecomment-1798044775:543,Deployability,install,installation,543,"I'll merge this because I think it solves the initial problem with exceptions due to the extensions directory not existing. I couldn't replicate the other issue on my Mac, although I'm not certain I was following the steps correctly. I first dragged https://github.com/qupath/qupath-extension-wsinfer from a browser, and then https://github.com/qupath/qupath-extension-stardist. Both extensions seemed to install 'properly', except WSInfer wasn't compatible so that confused things slightly by throwing exceptions (rightly). Immediately after installation, the extension manager wrongly showed the StarDist extension version as being v0.5.0-SNAPSHOT, but after relaunching QuPath this was corrected to v0.4.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1415#issuecomment-1798044775
https://github.com/qupath/qupath/pull/1415#issuecomment-1798055787:116,Availability,down,down,116,"I have a very strong suspicion that it's a Linux issue with the system dragboard, but I've not managed to narrow it down. When I said . > come from the same source. I think I was maybe wrong - I tried dragging the same URL from a text editor, and it still didn't work as expected. I did get a `file://` link to overwrite a `https://` link, but I couldn't do the reverse...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1415#issuecomment-1798055787
https://github.com/qupath/qupath/pull/1419#issuecomment-1803479767:97,Performance,load,loading,97,"I had the issue of not being able to delete extensions when QuPath was running. Somewhere in the loading process of the extension the ClassLoader (?) was never closed which left the operating system thinking that the file is still open by some process. I just closed the ClassLoader after initializing the extension, which allowed me to then delete the extension. . Unsure if closing the ClassLoader has consequences such as not being access the Resource files or such?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419#issuecomment-1803479767
https://github.com/qupath/qupath/pull/1419#issuecomment-1803479767:435,Security,access,access,435,"I had the issue of not being able to delete extensions when QuPath was running. Somewhere in the loading process of the extension the ClassLoader (?) was never closed which left the operating system thinking that the file is still open by some process. I just closed the ClassLoader after initializing the extension, which allowed me to then delete the extension. . Unsure if closing the ClassLoader has consequences such as not being access the Resource files or such?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419#issuecomment-1803479767
https://github.com/qupath/qupath/pull/1419#issuecomment-1803511027:410,Performance,load,loading,410,"Interesting, thanks! I didn't realize classloaders can be closed... I see they can't generally, but the URLClassLoader can:; https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/net/URLClassLoader.html#close(). I suspect that would mean no new extensions can be added, but if the user obediently restarts QuPath at that point then it wouldn't matter. Or there might be a more clever way to manage loading extensions with different classloaders. In any case, that does indeed make it possible to delete extensions on Windows - thanks!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419#issuecomment-1803511027
https://github.com/qupath/qupath/pull/1419#issuecomment-1803804365:89,Energy Efficiency,battery,battery,89,"Thanks, I *only* tested it on Windows so far (which isn't much fun with a 13"" screen, no battery life, and continually pressing the keys that would correspond to the Mac shortcuts).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419#issuecomment-1803804365
https://github.com/qupath/qupath/pull/1419#issuecomment-1803804365:17,Testability,test,tested,17,"Thanks, I *only* tested it on Windows so far (which isn't much fun with a 13"" screen, no battery life, and continually pressing the keys that would correspond to the Mac shortcuts).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1419#issuecomment-1803804365
https://github.com/qupath/qupath/pull/1430#issuecomment-1833531086:216,Deployability,configurat,configuration,216,"@alanocallaghan @Rylern @finglis can anyone think of a reason not to do this...?. The main goal is to be able to set awkward DJL/CUDA options from a command line (e.g. .bat file or shell script), rather than needing configuration later. May or may not be successful; if it works, it may make https://github.com/qupath/qupath/pull/1429 unnecessary (but probably worth keeping anyway).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1430#issuecomment-1833531086
https://github.com/qupath/qupath/pull/1430#issuecomment-1833531086:216,Modifiability,config,configuration,216,"@alanocallaghan @Rylern @finglis can anyone think of a reason not to do this...?. The main goal is to be able to set awkward DJL/CUDA options from a command line (e.g. .bat file or shell script), rather than needing configuration later. May or may not be successful; if it works, it may make https://github.com/qupath/qupath/pull/1429 unnecessary (but probably worth keeping anyway).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1430#issuecomment-1833531086
https://github.com/qupath/qupath/pull/1432#issuecomment-1835923514:143,Modifiability,flexible,flexible,143,"@alanocallaghan yes, I had an integer version along the way. I changed mostly because it's not clear what the usual font size is, and the more flexible alternative allows the user to specify a percentage instead. Don't think this is a great implementation, but I've heard the script editor is likely to be replaced soon anyway.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1432#issuecomment-1835923514
https://github.com/qupath/qupath/pull/1432#issuecomment-1835923514:95,Usability,clear,clear,95,"@alanocallaghan yes, I had an integer version along the way. I changed mostly because it's not clear what the usual font size is, and the more flexible alternative allows the user to specify a percentage instead. Don't think this is a great implementation, but I've heard the script editor is likely to be replaced soon anyway.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1432#issuecomment-1835923514
https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017:131,Deployability,update,update,131,I've just built v0.6.0-SNAPSHOT from source and this problem seems to have gone anyway... I guess through a Java/JavaFX dependency update. So I think we can close this since it'll be fixed in the next release (even though we didn't intentionally change anything to fix it)?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017
https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017:201,Deployability,release,release,201,I've just built v0.6.0-SNAPSHOT from source and this problem seems to have gone anyway... I guess through a Java/JavaFX dependency update. So I think we can close this since it'll be fixed in the next release (even though we didn't intentionally change anything to fix it)?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017
https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017:120,Integrability,depend,dependency,120,I've just built v0.6.0-SNAPSHOT from source and this problem seems to have gone anyway... I guess through a Java/JavaFX dependency update. So I think we can close this since it'll be fixed in the next release (even though we didn't intentionally change anything to fix it)?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1436#issuecomment-2256309017
https://github.com/qupath/qupath/issues/1438#issuecomment-1851926777:503,Availability,avail,available,503,"Hmm, I worry about burying the option in the preferences. It reminds me of ImageJ's 'Black background' option where a hidden preference causes different results for different users, making it harder to give instructions to anyone else. If you want to run as script as a command (with menu item), you can use this:; ```groovy; getQuPath().installGroovyCommand(""Objects>Select children"", ; """"""; def children = getSelectedObject().getChildObjects(); selectObjects(children); """"""; ); ```. To make it always available without the hassle of creating an extension, you can include it in a startup script file - basically any Groovy file, which can be set in the preferences under 'Startup script path'. This should allow you to add multiple custom commands in menus of your choosing, to run any short scripts.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1438#issuecomment-1851926777
https://github.com/qupath/qupath/issues/1438#issuecomment-1851926777:338,Deployability,install,installGroovyCommand,338,"Hmm, I worry about burying the option in the preferences. It reminds me of ImageJ's 'Black background' option where a hidden preference causes different results for different users, making it harder to give instructions to anyone else. If you want to run as script as a command (with menu item), you can use this:; ```groovy; getQuPath().installGroovyCommand(""Objects>Select children"", ; """"""; def children = getSelectedObject().getChildObjects(); selectObjects(children); """"""; ); ```. To make it always available without the hassle of creating an extension, you can include it in a startup script file - basically any Groovy file, which can be set in the preferences under 'Startup script path'. This should allow you to add multiple custom commands in menus of your choosing, to run any short scripts.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1438#issuecomment-1851926777
https://github.com/qupath/qupath/issues/1438#issuecomment-1852099160:142,Deployability,install,installGroovyCommand,142,"That's perfect Pete.; No need to include a new menu command if I can create it myself :-). Here is my final startup script:. ```; getQuPath().installGroovyCommand(""Objects>Select...>Select children"", ; """"""; def selectedObjects = getSelectedObjects(); if (!selectedObjects); return; def children = []; for(obj in selectedObjects) {; if (obj.isAnnotation()){; //println obj; def tmpchilds = obj.getChildObjects(); children += tmpchilds; }; }; selectObjects(children); """"""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1438#issuecomment-1852099160
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:234,Availability,ERROR,ERROR,234,"Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. ![image](https://github.com/qupath/qupath/assets/154437026/9e4ba23a-f54a-4742-8a5c-ec10b063f7f2). ```; ERROR: Error processing Polygon (7616, 10604, 2099, 1863); java.io.IOException: java.lang.InterruptedException; at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:911); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.p",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:241,Availability,Error,Error,241,"Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. ![image](https://github.com/qupath/qupath/assets/154437026/9e4ba23a-f54a-4742-8a5c-ec10b063f7f2). ```; ERROR: Error processing Polygon (7616, 10604, 2099, 1863); java.io.IOException: java.lang.InterruptedException; at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:911); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.p",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2000,Modifiability,plugin,plugins,2000,erver.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.ser,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4634,Modifiability,plugin,plugins,4634,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:594,Performance,concurren,concurrent,594,"Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. ![image](https://github.com/qupath/qupath/assets/154437026/9e4ba23a-f54a-4742-8a5c-ec10b063f7f2). ```; ERROR: Error processing Polygon (7616, 10604, 2099, 1863); java.io.IOException: java.lang.InterruptedException; at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:911); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.p",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:1367,Performance,concurren,concurrent,1367,rs.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:911); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Sou,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2106,Performance,concurren,concurrent,2106,oppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2188,Performance,concurren,concurrent,2188,(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2254,Performance,concurren,concurrent,2254,tTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknow,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2336,Performance,concurren,concurrent,2336,); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTile,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2402,Performance,concurren,concurrent,2402,); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.serv,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2482,Performance,concurren,concurrent,2482,ractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2629,Performance,concurren,concurrent,2629,path.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedIma,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2723,Performance,concurren,concurrent,2723,a:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServ,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2812,Performance,concurren,concurrent,2812,gej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:3228,Performance,concurren,concurrent,3228, java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTi,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4001,Performance,concurren,concurrent,4001,rs.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:909); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Sou,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4740,Performance,concurren,concurrent,4740,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4822,Performance,concurren,concurrent,4822,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4888,Performance,concurren,concurrent,4888,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4970,Performance,concurren,concurrent,4970,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:5036,Performance,concurren,concurrent,5036,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:5116,Performance,concurren,concurrent,5116,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:82,Safety,detect,detection,82,"Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. ![image](https://github.com/qupath/qupath/assets/154437026/9e4ba23a-f54a-4742-8a5c-ec10b063f7f2). ```; ERROR: Error processing Polygon (7616, 10604, 2099, 1863); java.io.IOException: java.lang.InterruptedException; at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormatsImageServer.java:911); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.p",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:1890,Safety,detect,detect,1890,TileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bi,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2008,Safety,Detect,DetectionPluginTools,2008,dImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioForma,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2029,Safety,Detect,DetectionRunnable,2029,dImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioForma,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:2051,Safety,Detect,DetectionPluginTools,2051,.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); Caused by null at java.base/java.util.concurrent.locks.ReentrantLock$Sync.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.locks.ReentrantLock.lockInterruptibly(Unknown Source); at java.base/java.util.concurrent.ArrayBlockingQueue.put(Unknown Source); at qupath.lib.images.servers.bioformats.BioFormatsImageServer$ReaderPool.openImage(BioFormatsImageServer.java:1411); at qupath.lib.images.servers.bioformats.BioFormatsImageServer.readTile(BioFormat,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4524,Safety,detect,detect,4524,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4642,Safety,Detect,DetectionPluginTools,4642,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4663,Safety,Detect,DetectionRunnable,4663,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583:4685,Safety,Detect,DetectionPluginTools,4685,concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:90); at qupath.lib.images.servers.CroppedImageServer.readRegion(CroppedImageServer.java:39); at qupath.lib.images.servers.SparseImageServer.readTile(SparseImageServer.java:265); at qupath.lib.images.servers.AbstractTileableImageServer.lambda$prerequestTiles$2(AbstractTileableImageServer.java:462); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at qupath.lib.images.servers.AbstractTileableImageServer.prerequestTiles(AbstractTileableImageServer.java:464); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:295); at qupath.lib.images.servers.AbstractTileableImageServer.readRegion(AbstractTileableImageServer.java:60); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:863); at qupath.imagej.tools.IJTools.convertToImagePlus(IJTools.java:902); at qupath.imagej.detect.cells.WatershedCellDetection$CellDetector.runDetection(WatershedCellDetection.java:216); at qupath.lib.plugins.DetectionPluginTools$DetectionRunnable.run(DetectionPluginTools.java:112); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Unknown Source); at java.base/java.util.concurrent.FutureTask.run(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(Unknown Source); at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(Unknown Source); at java.base/java.lang.Thread.run(Unknown Source); ```,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1864490583
https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182:206,Availability,error,error,206,"#1465 should fix the first issue. About:. > Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. I wasn't able to reproduce the error. Does it happens on every run? Is it possible to share the project throwing the error?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182
https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182:292,Availability,error,error,292,"#1465 should fix the first issue. About:. > Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. I wasn't able to reproduce the error. Does it happens on every run? Is it possible to share the project throwing the error?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182
https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182:126,Safety,detect,detection,126,"#1465 should fix the first issue. About:. > Quick addition. Defining an area using a polygon no longer works for the in-built detection, just when running a stardist script:. I wasn't able to reproduce the error. Does it happens on every run? Is it possible to share the project throwing the error?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1443#issuecomment-1938648182
https://github.com/qupath/qupath/issues/1444#issuecomment-1936164001:504,Integrability,synchroniz,synchronization,504,"> I can ask them to share a QuPath project if it's useful to you. That would be useful because I was not able to replicate the issue (on MacOS, I will try on Linux later). However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a `CopyOnWriteArrayList` instead of an `ArrayList` may solve this issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936164001
https://github.com/qupath/qupath/issues/1444#issuecomment-1936164001:465,Security,access,accessed,465,"> I can ask them to share a QuPath project if it's useful to you. That would be useful because I was not able to replicate the issue (on MacOS, I will try on Linux later). However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a `CopyOnWriteArrayList` instead of an `ArrayList` may solve this issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936164001
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:334,Integrability,synchroniz,synchronization,334,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:535,Integrability,synchroniz,synchronized,535,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:600,Integrability,synchroniz,synchronized,600,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:295,Security,access,accessed,295,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:465,Security,access,accessed,465,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910:578,Usability,clear,clear,578,"> However, based on the exception, I think the problem is that the [names ArrayList of the AbstractNumericMeasurementList class](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L102) is accessed from multiple threads without synchronization. Using a CopyOnWriteArrayList instead of an ArrayList may solve this issue. I think the list shouldn't be directly accessed elsewhere, and the `put` method (which calles `list.add`) is synchronized. Maybe the issue is that the `clear()` method isn't synchronized?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936207910
https://github.com/qupath/qupath/issues/1444#issuecomment-1936234982:45,Integrability,synchroniz,synchronized,45,"I think both read and write access should be synchronized. Right now, [line 142](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L142) and [line 241](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L241) can be executed at the same time.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936234982
https://github.com/qupath/qupath/issues/1444#issuecomment-1936234982:28,Security,access,access,28,"I think both read and write access should be synchronized. Right now, [line 142](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L142) and [line 241](https://github.com/qupath/qupath/blob/13bdeed047b4d05f35f47308b36b48c0f2bb3a24/qupath-core/src/main/java/qupath/lib/measurements/NumericMeasurementList.java#L241) can be executed at the same time.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936234982
https://github.com/qupath/qupath/issues/1444#issuecomment-1936328342:74,Integrability,Synchroniz,Synchronizing,74,"Ah, interesting... yes that looks like a horribly subtle concurrency bug. Synchronizing `getNameMap()` might fix it?. It does seem that the only time `getNameMap()` can be called at the same time as modifying the list is during a call to `close()`. I'd be concerned about any possible inconsistency if we switch to `CopyOnWriteArrayList` (but perhaps just because I'm not familiar enough with its behavior). I tried to replicate the issue with; ```groovy; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()). java.util.stream.IntStream.range(1, 1000); .parallel(); .each(i -> {; def ml = pathObject.getMeasurementList(); ml.put(""Hello "" + i, Math.random()); ml.close(); }); ```; ...but I failed to get it to throw any exception.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936328342
https://github.com/qupath/qupath/issues/1444#issuecomment-1936328342:57,Performance,concurren,concurrency,57,"Ah, interesting... yes that looks like a horribly subtle concurrency bug. Synchronizing `getNameMap()` might fix it?. It does seem that the only time `getNameMap()` can be called at the same time as modifying the list is during a call to `close()`. I'd be concerned about any possible inconsistency if we switch to `CopyOnWriteArrayList` (but perhaps just because I'm not familiar enough with its behavior). I tried to replicate the issue with; ```groovy; def pathObject = PathObjects.createDetectionObject(ROIs.createEmptyROI()). java.util.stream.IntStream.range(1, 1000); .parallel(); .each(i -> {; def ml = pathObject.getMeasurementList(); ml.put(""Hello "" + i, Math.random()); ml.close(); }); ```; ...but I failed to get it to throw any exception.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936328342
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:2,Integrability,Synchroniz,Synchronizing,2,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:88,Integrability,synchroniz,synchronized,88,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:401,Integrability,synchroniz,synchronized,401,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:213,Performance,perform,performances,213,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:263,Performance,concurren,concurrency,263,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:60,Security,access,access,60,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496:390,Security,access,access,390,"> Synchronizing getNameMap() might fix it?. I think **all** access to `names` should be synchronized. If it's not the case, lines 207 and 241 could be executed at the same time for example. But this may drops the performances of the class. I will read more about concurrency in Java to exactly know what to do in such situations. Switching to `CopyOnWriteArrayList` is not necessary if all access are synchronized.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1936371496
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:63,Integrability,synchroniz,synchronized,63,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:260,Integrability,synchroniz,synchronization,260,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:44,Modifiability,variab,variable,44,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:165,Modifiability,variab,variable,165,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:283,Modifiability,refactor,refactor,283,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:83,Performance,Concurren,Concurrency,83,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:335,Safety,safe,safe,335,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:22,Security,access,access,22,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:142,Security,access,accesses,142,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478:241,Security,access,access,241,"So I confirm that all access to any mutable variable should be synchronized. From ""Concurrency in Practice"":. > Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization. I can refactor `NumericMeasurementList` to make it thread-safe.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1941504478
https://github.com/qupath/qupath/issues/1444#issuecomment-1943353414:960,Performance,perform,performance,960,"I think that I hadn't really appreciated that using the list as key in the map would result in `equals` being called and checking all elements. The purpose was to ensure that identical string lists aren't duplicated for all objects - since there can be millions, which could easily cost hundreds of MB overhead. Basically, we'd like measurements to be accessible like `Map<String, double>`, but that doesn't exist in Java, and `Map<String, Double>` would have much more overhead. Therefore instead we use `List<String>` and either `float[]` or `double[]`, where entries in the list correspond to entries in the array. *Most* of the time, objects will have the same keys/strings - but this isn't enforced (and won't be true when measurements are being added, since the list will be growing). Therefore we want to be able to check when lists are duplicated, and use one instead. The current design is probably very suboptimal, but it's quite core to QuPath (for performance, memory use and serialization) so any major change would need to be very carefully checked.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943353414
https://github.com/qupath/qupath/issues/1444#issuecomment-1943353414:352,Security,access,accessible,352,"I think that I hadn't really appreciated that using the list as key in the map would result in `equals` being called and checking all elements. The purpose was to ensure that identical string lists aren't duplicated for all objects - since there can be millions, which could easily cost hundreds of MB overhead. Basically, we'd like measurements to be accessible like `Map<String, double>`, but that doesn't exist in Java, and `Map<String, Double>` would have much more overhead. Therefore instead we use `List<String>` and either `float[]` or `double[]`, where entries in the list correspond to entries in the array. *Most* of the time, objects will have the same keys/strings - but this isn't enforced (and won't be true when measurements are being added, since the list will be growing). Therefore we want to be able to check when lists are duplicated, and use one instead. The current design is probably very suboptimal, but it's quite core to QuPath (for performance, memory use and serialization) so any major change would need to be very carefully checked.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943353414
https://github.com/qupath/qupath/issues/1444#issuecomment-1943521366:67,Integrability,synchroniz,synchronization,67,"See #1466. I didn't change anything about the design, I just added synchronization. Today I was able to reproduce the exception above. #1466 solved it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943521366
https://github.com/qupath/qupath/issues/1444#issuecomment-1943548331:280,Integrability,synchroniz,synchronization,280,"> Today I was able to reproduce the exception above. Great! How? . > https://github.com/qupath/qupath/pull/1466 solved it. Looks good, is there a way to check if it has any significant performance impact?. I'll check this out as well when I can (I expect it's fine, I've just had synchronization surprise me in the past).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943548331
https://github.com/qupath/qupath/issues/1444#issuecomment-1943548331:185,Performance,perform,performance,185,"> Today I was able to reproduce the exception above. Great! How? . > https://github.com/qupath/qupath/pull/1466 solved it. Looks good, is there a way to check if it has any significant performance impact?. I'll check this out as well when I can (I expect it's fine, I've just had synchronization surprise me in the past).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943548331
https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892:621,Performance,perform,performance,621,"> Great! How?. * I opened `CMU-1.tiff` in a project.; * I defined an annotation covering almost the entire image.; * I defined another annotation also almost covering the entire image.; * I made the 2nd annotation a child of the first.; * I ran `Cell Detection` inside the 2nd annotation with default parameters. I got 99465 detections.; * I saved the image. The exception occurs each time I run `Delaunay cluster features 2D` with `Add cluster measurements` checked. It's a bit weird because I did the same thing yesterday but I didn't have the exception. > Looks good, is there a way to check if it has any significant performance impact?. It has, because running `Delaunay cluster features 2D` takes around 2.67s without the PR and around 3.71s with the PR (for 99465 detections).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892
https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892:251,Safety,Detect,Detection,251,"> Great! How?. * I opened `CMU-1.tiff` in a project.; * I defined an annotation covering almost the entire image.; * I defined another annotation also almost covering the entire image.; * I made the 2nd annotation a child of the first.; * I ran `Cell Detection` inside the 2nd annotation with default parameters. I got 99465 detections.; * I saved the image. The exception occurs each time I run `Delaunay cluster features 2D` with `Add cluster measurements` checked. It's a bit weird because I did the same thing yesterday but I didn't have the exception. > Looks good, is there a way to check if it has any significant performance impact?. It has, because running `Delaunay cluster features 2D` takes around 2.67s without the PR and around 3.71s with the PR (for 99465 detections).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892
https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892:325,Safety,detect,detections,325,"> Great! How?. * I opened `CMU-1.tiff` in a project.; * I defined an annotation covering almost the entire image.; * I defined another annotation also almost covering the entire image.; * I made the 2nd annotation a child of the first.; * I ran `Cell Detection` inside the 2nd annotation with default parameters. I got 99465 detections.; * I saved the image. The exception occurs each time I run `Delaunay cluster features 2D` with `Add cluster measurements` checked. It's a bit weird because I did the same thing yesterday but I didn't have the exception. > Looks good, is there a way to check if it has any significant performance impact?. It has, because running `Delaunay cluster features 2D` takes around 2.67s without the PR and around 3.71s with the PR (for 99465 detections).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892
https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892:771,Safety,detect,detections,771,"> Great! How?. * I opened `CMU-1.tiff` in a project.; * I defined an annotation covering almost the entire image.; * I defined another annotation also almost covering the entire image.; * I made the 2nd annotation a child of the first.; * I ran `Cell Detection` inside the 2nd annotation with default parameters. I got 99465 detections.; * I saved the image. The exception occurs each time I run `Delaunay cluster features 2D` with `Add cluster measurements` checked. It's a bit weird because I did the same thing yesterday but I didn't have the exception. > Looks good, is there a way to check if it has any significant performance impact?. It has, because running `Delaunay cluster features 2D` takes around 2.67s without the PR and around 3.71s with the PR (for 99465 detections).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943644892
https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902:425,Deployability,release,release,425,"Wow, thanks, that replicates the issue for me too. This sounds like a bug / intuitive behavior within the Delaunay triangulation. It's concerning that measurements can be added multiple times to the same objects. It suggests that the results might not be fully deterministic, depending upon the status of the object hierarchy and precisely which annotations are selected. I'm reluctant to fix the underlying issue in a 0.0.x release, but we should try to replace the command entirely. An implementation with [`DelaunayTools`](https://github.com/qupath/qupath/blob/df81345068455f09f42f50e97dc7b69a591e27f7/qupath-core/src/main/java/qupath/lib/analysis/DelaunayTools.java#L77) should be cleaner than the current OpenCV-based one. **As I understand it, this shows that the existing Delaunay command should not be used for nested annotations that contain detections.**. Single annotations, or annotations arranged in a 'flat' way (so that the same detection is not a descendent of more than one selected annotation) should be ok.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902
https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902:276,Integrability,depend,depending,276,"Wow, thanks, that replicates the issue for me too. This sounds like a bug / intuitive behavior within the Delaunay triangulation. It's concerning that measurements can be added multiple times to the same objects. It suggests that the results might not be fully deterministic, depending upon the status of the object hierarchy and precisely which annotations are selected. I'm reluctant to fix the underlying issue in a 0.0.x release, but we should try to replace the command entirely. An implementation with [`DelaunayTools`](https://github.com/qupath/qupath/blob/df81345068455f09f42f50e97dc7b69a591e27f7/qupath-core/src/main/java/qupath/lib/analysis/DelaunayTools.java#L77) should be cleaner than the current OpenCV-based one. **As I understand it, this shows that the existing Delaunay command should not be used for nested annotations that contain detections.**. Single annotations, or annotations arranged in a 'flat' way (so that the same detection is not a descendent of more than one selected annotation) should be ok.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902
https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902:851,Safety,detect,detections,851,"Wow, thanks, that replicates the issue for me too. This sounds like a bug / intuitive behavior within the Delaunay triangulation. It's concerning that measurements can be added multiple times to the same objects. It suggests that the results might not be fully deterministic, depending upon the status of the object hierarchy and precisely which annotations are selected. I'm reluctant to fix the underlying issue in a 0.0.x release, but we should try to replace the command entirely. An implementation with [`DelaunayTools`](https://github.com/qupath/qupath/blob/df81345068455f09f42f50e97dc7b69a591e27f7/qupath-core/src/main/java/qupath/lib/analysis/DelaunayTools.java#L77) should be cleaner than the current OpenCV-based one. **As I understand it, this shows that the existing Delaunay command should not be used for nested annotations that contain detections.**. Single annotations, or annotations arranged in a 'flat' way (so that the same detection is not a descendent of more than one selected annotation) should be ok.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902
https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902:944,Safety,detect,detection,944,"Wow, thanks, that replicates the issue for me too. This sounds like a bug / intuitive behavior within the Delaunay triangulation. It's concerning that measurements can be added multiple times to the same objects. It suggests that the results might not be fully deterministic, depending upon the status of the object hierarchy and precisely which annotations are selected. I'm reluctant to fix the underlying issue in a 0.0.x release, but we should try to replace the command entirely. An implementation with [`DelaunayTools`](https://github.com/qupath/qupath/blob/df81345068455f09f42f50e97dc7b69a591e27f7/qupath-core/src/main/java/qupath/lib/analysis/DelaunayTools.java#L77) should be cleaner than the current OpenCV-based one. **As I understand it, this shows that the existing Delaunay command should not be used for nested annotations that contain detections.**. Single annotations, or annotations arranged in a 'flat' way (so that the same detection is not a descendent of more than one selected annotation) should be ok.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902
https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902:76,Usability,intuit,intuitive,76,"Wow, thanks, that replicates the issue for me too. This sounds like a bug / intuitive behavior within the Delaunay triangulation. It's concerning that measurements can be added multiple times to the same objects. It suggests that the results might not be fully deterministic, depending upon the status of the object hierarchy and precisely which annotations are selected. I'm reluctant to fix the underlying issue in a 0.0.x release, but we should try to replace the command entirely. An implementation with [`DelaunayTools`](https://github.com/qupath/qupath/blob/df81345068455f09f42f50e97dc7b69a591e27f7/qupath-core/src/main/java/qupath/lib/analysis/DelaunayTools.java#L77) should be cleaner than the current OpenCV-based one. **As I understand it, this shows that the existing Delaunay command should not be used for nested annotations that contain detections.**. Single annotations, or annotations arranged in a 'flat' way (so that the same detection is not a descendent of more than one selected annotation) should be ok.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943698902
https://github.com/qupath/qupath/issues/1444#issuecomment-1943759245:158,Performance,perform,performance,158,"OK, so should I discard the PR? If this is the only issue occuring with `NumericMeasurementList`, it means that this class doesn't have to be thread-safe, so performance can be saved by keeping the current implementation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943759245
https://github.com/qupath/qupath/issues/1444#issuecomment-1943759245:149,Safety,safe,safe,149,"OK, so should I discard the PR? If this is the only issue occuring with `NumericMeasurementList`, it means that this class doesn't have to be thread-safe, so performance can be saved by keeping the current implementation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1943759245
https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771:619,Integrability,synchroniz,synchronization,619,"Oh no, please keep the PR for now!. I'll check it out in more detail soon - but you've demonstrated that there is a concurrency bug with the measurement list. It just wouldn't have arisen if the Delaunay command wasn't buggy too. Similarly, the performance probably wouldn't have changed noticeably if the Delaunay command wasn't problematic... so this may not be a major issue in other contexts. One thing to check would be 'Add smoothed measurements' with lots of cells, since this should add a lot of measurements in parallel - but I think only one thread should be accessing each measurement list. Therefore I hope synchronization doesn't cause substantial overhead. . In any case, I think `MeasurementList` implementations *should* be thread-safe - so we should address this in either v0.5.1 or v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771
https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771:116,Performance,concurren,concurrency,116,"Oh no, please keep the PR for now!. I'll check it out in more detail soon - but you've demonstrated that there is a concurrency bug with the measurement list. It just wouldn't have arisen if the Delaunay command wasn't buggy too. Similarly, the performance probably wouldn't have changed noticeably if the Delaunay command wasn't problematic... so this may not be a major issue in other contexts. One thing to check would be 'Add smoothed measurements' with lots of cells, since this should add a lot of measurements in parallel - but I think only one thread should be accessing each measurement list. Therefore I hope synchronization doesn't cause substantial overhead. . In any case, I think `MeasurementList` implementations *should* be thread-safe - so we should address this in either v0.5.1 or v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771
https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771:245,Performance,perform,performance,245,"Oh no, please keep the PR for now!. I'll check it out in more detail soon - but you've demonstrated that there is a concurrency bug with the measurement list. It just wouldn't have arisen if the Delaunay command wasn't buggy too. Similarly, the performance probably wouldn't have changed noticeably if the Delaunay command wasn't problematic... so this may not be a major issue in other contexts. One thing to check would be 'Add smoothed measurements' with lots of cells, since this should add a lot of measurements in parallel - but I think only one thread should be accessing each measurement list. Therefore I hope synchronization doesn't cause substantial overhead. . In any case, I think `MeasurementList` implementations *should* be thread-safe - so we should address this in either v0.5.1 or v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771
https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771:747,Safety,safe,safe,747,"Oh no, please keep the PR for now!. I'll check it out in more detail soon - but you've demonstrated that there is a concurrency bug with the measurement list. It just wouldn't have arisen if the Delaunay command wasn't buggy too. Similarly, the performance probably wouldn't have changed noticeably if the Delaunay command wasn't problematic... so this may not be a major issue in other contexts. One thing to check would be 'Add smoothed measurements' with lots of cells, since this should add a lot of measurements in parallel - but I think only one thread should be accessing each measurement list. Therefore I hope synchronization doesn't cause substantial overhead. . In any case, I think `MeasurementList` implementations *should* be thread-safe - so we should address this in either v0.5.1 or v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771
https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771:569,Security,access,accessing,569,"Oh no, please keep the PR for now!. I'll check it out in more detail soon - but you've demonstrated that there is a concurrency bug with the measurement list. It just wouldn't have arisen if the Delaunay command wasn't buggy too. Similarly, the performance probably wouldn't have changed noticeably if the Delaunay command wasn't problematic... so this may not be a major issue in other contexts. One thing to check would be 'Add smoothed measurements' with lots of cells, since this should add a lot of measurements in parallel - but I think only one thread should be accessing each measurement list. Therefore I hope synchronization doesn't cause substantial overhead. . In any case, I think `MeasurementList` implementations *should* be thread-safe - so we should address this in either v0.5.1 or v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1444#issuecomment-1944052771
https://github.com/qupath/qupath/issues/1445#issuecomment-1881296347:76,Availability,down,download,76,"I can replicate the issue with CMU-1-JP2K from https://openslide.cs.cmu.edu/download/openslide-testdata/DICOM/. In a QuPath script, calling ; ```groovy; getCurrentServer().dumpMetadata(); ```; indicates that the magnification is not present in the OME metadata from Bio-Formats, therefore I don't think this is a QuPath bug. ; ```xml; <?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>; <OME xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""; xsi:schemaLocation=""http://www.openmicroscopy.org/Schemas/OME/2016-06 http://www.openmicroscopy.org/Schemas/OME/2016-06/ome.xsd""; xmlns=""http://www.openmicroscopy.org/Schemas/OME/2016-06"">; <Image ID=""Image:0"" Name=""VOLUME"">; <Description>DERIVED\PRIMARY\VOLUME\NONE</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:0"" Interleaved=""true""; PhysicalSizeX=""4.99E-4"" PhysicalSizeXUnit=""mm"" PhysicalSizeY=""4.99E-4""; PhysicalSizeYUnit=""mm"" SignificantBits=""8"" SizeC=""3"" SizeT=""1"" SizeX=""46000""; SizeY=""32893"" SizeZ=""1"" Type=""uint8"">; <Channel ID=""Channel:0:0"" SamplesPerPixel=""3"">; <LightPath />; </Channel>; <MetadataOnly />; <Plane TheC=""0"" TheT=""0"" TheZ=""0"" />; </Pixels>; </Image>; <Image ID=""Image:1"" Name=""THUMBNAIL"">; <Description>DERIVED\PRIMARY\THUMBNAIL\RESAMPLED</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:1"" Interleaved=""true""; PhysicalSizeX=""0.022416015625"" PhysicalSizeXUnit=""mm"" PhysicalSizeY=""0.022416015625""; PhysicalSizeYUnit=""mm"" SignificantBits=""8"" SizeC=""3"" SizeT=""1"" SizeX=""1024"" SizeY=""732""; SizeZ=""1"" Type=""uint8"">; <Channel ID=""Channel:1:0"" SamplesPerPixel=""3"">; <LightPath />; </Channel>; <MetadataOnly />; <Plane TheC=""0"" TheT=""0"" TheZ=""0"" />; </Pixels>; </Image>; <Image ID=""Image:2"" Name=""OVERVIEW"">; <Description>DERIVED\PRIMARY\OVERVIEW\NONE</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:2"" Interleaved=""true""; PhysicalSizeX=""0.058932714617169"" PhysicalSizeXUnit=""mm""; PhysicalSizeY=""0.058932714617169"" PhysicalSizeYUnit=""mm"" SignificantB",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1445#issuecomment-1881296347
https://github.com/qupath/qupath/issues/1445#issuecomment-1881296347:95,Testability,test,testdata,95,"I can replicate the issue with CMU-1-JP2K from https://openslide.cs.cmu.edu/download/openslide-testdata/DICOM/. In a QuPath script, calling ; ```groovy; getCurrentServer().dumpMetadata(); ```; indicates that the magnification is not present in the OME metadata from Bio-Formats, therefore I don't think this is a QuPath bug. ; ```xml; <?xml version=""1.0"" encoding=""UTF-8"" standalone=""no""?>; <OME xmlns:xsi=""http://www.w3.org/2001/XMLSchema-instance""; xsi:schemaLocation=""http://www.openmicroscopy.org/Schemas/OME/2016-06 http://www.openmicroscopy.org/Schemas/OME/2016-06/ome.xsd""; xmlns=""http://www.openmicroscopy.org/Schemas/OME/2016-06"">; <Image ID=""Image:0"" Name=""VOLUME"">; <Description>DERIVED\PRIMARY\VOLUME\NONE</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:0"" Interleaved=""true""; PhysicalSizeX=""4.99E-4"" PhysicalSizeXUnit=""mm"" PhysicalSizeY=""4.99E-4""; PhysicalSizeYUnit=""mm"" SignificantBits=""8"" SizeC=""3"" SizeT=""1"" SizeX=""46000""; SizeY=""32893"" SizeZ=""1"" Type=""uint8"">; <Channel ID=""Channel:0:0"" SamplesPerPixel=""3"">; <LightPath />; </Channel>; <MetadataOnly />; <Plane TheC=""0"" TheT=""0"" TheZ=""0"" />; </Pixels>; </Image>; <Image ID=""Image:1"" Name=""THUMBNAIL"">; <Description>DERIVED\PRIMARY\THUMBNAIL\RESAMPLED</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:1"" Interleaved=""true""; PhysicalSizeX=""0.022416015625"" PhysicalSizeXUnit=""mm"" PhysicalSizeY=""0.022416015625""; PhysicalSizeYUnit=""mm"" SignificantBits=""8"" SizeC=""3"" SizeT=""1"" SizeX=""1024"" SizeY=""732""; SizeZ=""1"" Type=""uint8"">; <Channel ID=""Channel:1:0"" SamplesPerPixel=""3"">; <LightPath />; </Channel>; <MetadataOnly />; <Plane TheC=""0"" TheT=""0"" TheZ=""0"" />; </Pixels>; </Image>; <Image ID=""Image:2"" Name=""OVERVIEW"">; <Description>DERIVED\PRIMARY\OVERVIEW\NONE</Description>; <Pixels BigEndian=""false"" DimensionOrder=""XYCZT"" ID=""Pixels:2"" Interleaved=""true""; PhysicalSizeX=""0.058932714617169"" PhysicalSizeXUnit=""mm""; PhysicalSizeY=""0.058932714617169"" PhysicalSizeYUnit=""mm"" SignificantB",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1445#issuecomment-1881296347
https://github.com/qupath/qupath/issues/1446#issuecomment-1976088999:348,Performance,perform,performance,348,"Here's a short Groovy script to add lots of duplicate entries to a project:; ```groovy; int nDuplicates = 1000; boolean copyData = false. def project = getProject(); def entry = getProjectEntry(); for (int i = 0; i < nDuplicates; i++) {; project.addDuplicate(entry, copyData); }; getQuPath().refreshProject(); ```. I couldn't identify any specific performance issue with this though, even with thumbnails >100 KB: thumbnail reading was fast enough to exhibit on a very slight lag. But on other hardware / working across a network this might be very different.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1446#issuecomment-1976088999
https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381:56,Performance,load,loader,56,"Original approach wasn't right at all, I forgot how the loader method was being used in the extension class. Small note I don't like about our openslide loading behaviour: if the preference isn't set, we always load from the jar. If it is set, and there's no openslide found there, we may end up using the system openslide, which seems unintuitive to me, but unfortunately is hard to get around because of the JNA search behaviour",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381
https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381:153,Performance,load,loading,153,"Original approach wasn't right at all, I forgot how the loader method was being used in the extension class. Small note I don't like about our openslide loading behaviour: if the preference isn't set, we always load from the jar. If it is set, and there's no openslide found there, we may end up using the system openslide, which seems unintuitive to me, but unfortunately is hard to get around because of the JNA search behaviour",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381
https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381:211,Performance,load,load,211,"Original approach wasn't right at all, I forgot how the loader method was being used in the extension class. Small note I don't like about our openslide loading behaviour: if the preference isn't set, we always load from the jar. If it is set, and there's no openslide found there, we may end up using the system openslide, which seems unintuitive to me, but unfortunately is hard to get around because of the JNA search behaviour",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1896082381
https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753:92,Performance,load,load,92,"I actually dislike the implementation I used here, because the fact that the extension will load the library when checking is only handled with a side effect, because the static block is called when the class is first loaded. A better solution would be for `OpenSlideExtension::isOpenSlideAvailable()` to check the value of `OpenSlideLoader.isOpenSlideAvailable()`, and if not, try to load it using the preference.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753
https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753:218,Performance,load,loaded,218,"I actually dislike the implementation I used here, because the fact that the extension will load the library when checking is only handled with a side effect, because the static block is called when the class is first loaded. A better solution would be for `OpenSlideExtension::isOpenSlideAvailable()` to check the value of `OpenSlideLoader.isOpenSlideAvailable()`, and if not, try to load it using the preference.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753
https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753:385,Performance,load,load,385,"I actually dislike the implementation I used here, because the fact that the extension will load the library when checking is only handled with a side effect, because the static block is called when the class is first loaded. A better solution would be for `OpenSlideExtension::isOpenSlideAvailable()` to check the value of `OpenSlideLoader.isOpenSlideAvailable()`, and if not, try to load it using the preference.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1909135753
https://github.com/qupath/qupath/pull/1447#issuecomment-1912114002:161,Performance,load,load,161,"> A better solution would be for `OpenSlideExtension::isOpenSlideAvailable()` to check the value of `OpenSlideLoader.isOpenSlideAvailable()`, and if not, try to load it using the preference. I agree, but then you will need to call `OpenSlideExtension::isOpenSlideAvailable()` instead of `OpenSlideLoader.isOpenSlideAvailable()` everywhere else in the code. In the current version, `OpenSlideServerBuilder` is using `OpenSlideLoader.isOpenSlideAvailable()`, which won't load OpenSlide in such situation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912114002
https://github.com/qupath/qupath/pull/1447#issuecomment-1912114002:469,Performance,load,load,469,"> A better solution would be for `OpenSlideExtension::isOpenSlideAvailable()` to check the value of `OpenSlideLoader.isOpenSlideAvailable()`, and if not, try to load it using the preference. I agree, but then you will need to call `OpenSlideExtension::isOpenSlideAvailable()` instead of `OpenSlideLoader.isOpenSlideAvailable()` everywhere else in the code. In the current version, `OpenSlideServerBuilder` is using `OpenSlideLoader.isOpenSlideAvailable()`, which won't load OpenSlide in such situation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912114002
https://github.com/qupath/qupath/pull/1447#issuecomment-1912145164:216,Performance,load,loader,216,"Yeah, the idea either way is to funnel all calls through the Extension class method, via JavaDocs at least. There's probably also some way to ensure it by reflection or some such. Or by re-arranging the classes, the loader method could be package-private and the other public, but that's not really ideal either",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912145164
https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311:236,Performance,load,loading,236,"> the idea either way is to funnel all calls through the Extension class method. The extension relies upon `QuPathGUI`, whereas an `OpenSlideImageServer` generally doesn't. It feels questionable to me to allow the UI to get involved in loading OpenSlide. Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter. (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311
https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311:364,Performance,load,loading,364,"> the idea either way is to funnel all calls through the Extension class method. The extension relies upon `QuPathGUI`, whereas an `OpenSlideImageServer` generally doesn't. It feels questionable to me to allow the UI to get involved in loading OpenSlide. Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter. (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311
https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311:486,Performance,load,loads,486,"> the idea either way is to funnel all calls through the Extension class method. The extension relies upon `QuPathGUI`, whereas an `OpenSlideImageServer` generally doesn't. It feels questionable to me to allow the UI to get involved in loading OpenSlide. Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter. (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912309311
https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296:65,Performance,load,loading,65,"> It feels questionable to me to allow the UI to get involved in loading OpenSlide. I agree, as I alluded to, the ""sensible"" way would mean restructuring the code so that the loader and extension are in the same package, but the current design means that doesn't make sense. > Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter.; (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think). I suppose the pertinent question right now is: ""should a preference set in the UI be used when running with the command line?"" I'd say yes, but I can see the argument for no. If yes, something like this solution makes sense for now, until a redesign. If no, then just default to the JNA if the extension class isn't involved",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296
https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296:175,Performance,load,loader,175,"> It feels questionable to me to allow the UI to get involved in loading OpenSlide. I agree, as I alluded to, the ""sensible"" way would mean restructuring the code so that the loader and extension are in the same package, but the current design means that doesn't make sense. > Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter.; (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think). I suppose the pertinent question right now is: ""should a preference set in the UI be used when running with the command line?"" I'd say yes, but I can see the argument for no. If yes, something like this solution makes sense for now, until a redesign. If no, then just default to the JNA if the extension class isn't involved",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296
https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296:386,Performance,load,loading,386,"> It feels questionable to me to allow the UI to get involved in loading OpenSlide. I agree, as I alluded to, the ""sensible"" way would mean restructuring the code so that the loader and extension are in the same package, but the current design means that doesn't make sense. > Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter.; (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think). I suppose the pertinent question right now is: ""should a preference set in the UI be used when running with the command line?"" I'd say yes, but I can see the argument for no. If yes, something like this solution makes sense for now, until a redesign. If no, then just default to the JNA if the extension class isn't involved",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296
https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296:509,Performance,load,loads,509,"> It feels questionable to me to allow the UI to get involved in loading OpenSlide. I agree, as I alluded to, the ""sensible"" way would mean restructuring the code so that the loader and extension are in the same package, but the current design means that doesn't make sense. > Potentially, we could have a cleaner separation of the UI and OpenSlide/image reading, in which case I think loading OpenSlide should very much belong in the latter.; (I realize having preferences in the UI to control how OpenSlide loads complicates things a little... but only a little, I think). I suppose the pertinent question right now is: ""should a preference set in the UI be used when running with the command line?"" I'd say yes, but I can see the argument for no. If yes, something like this solution makes sense for now, until a redesign. If no, then just default to the JNA if the extension class isn't involved",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1912332296
https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889:25,Performance,load,load,25,"Changed to simply try to load, ignoring the preference, in the `buildServer` method, if OpenSlide isn't already loaded, which seems reasonable to me.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889
https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889:112,Performance,load,loaded,112,"Changed to simply try to load, ignoring the preference, in the `buildServer` method, if OpenSlide isn't already loaded, which seems reasonable to me.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889
https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889:11,Usability,simpl,simply,11,"Changed to simply try to load, ignoring the preference, in the `buildServer` method, if OpenSlide isn't already loaded, which seems reasonable to me.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1447#issuecomment-1935892889
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:695,Availability,failure,failure,695,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:738,Availability,down,downloading,738,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:920,Availability,down,downloaded,920,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:24,Deployability,install,installed,24,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:324,Deployability,release,releases,324,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102:599,Deployability,release,release-destroying,599,"I have lots of QuPath's installed, and for me and `QuPath` (presumably v0.1.2) and `QuPath-0.3.0.app` are the only ones that show up in launchpad. v0.4.3 doesn't. To be honest, I forgot launchpad exists. I suspect the issue is related to the macOS version stored in the app. For v0.1.2 this is 0.1.2, but for all subsequent releases it is 1.0.0. The issue has come up a couple of times:; * https://github.com/qupath/qupath/issues/1250; * https://github.com/qupath/qupath/issues/1337. I spent several days trying to address it, but ultimately trying to embed the 'true' version number caused subtle, release-destroying issues: ; * https://github.com/qupath/qupath/pull/1379; Most annoyingly, the failure only emerged at the very end when *downloading* QuPath - local builds were ok, which meant that it's possible to believe it's fixed when it isn't. Therefore unless anyone else can spot a fix and confirm it works with downloaded versions, I'm afraid it's not something we can address. If my theory is correct, it will hopefully go away for QuPath >1.0.0, when we get there. For now, it's a restriction imposed by `jpackage` and macOS.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1448#issuecomment-1898097102
https://github.com/qupath/qupath/pull/1449#issuecomment-1898569139:146,Integrability,Depend,Depends,146,"This issue could also be relevant, but i'm not sure: https://forum.image.sc/t/qupath-project-didnt-save-images-and-annotations-are-wrong/61639/8. Depends how their network drive was mounted!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1898569139
https://github.com/qupath/qupath/pull/1449#issuecomment-1898792339:814,Deployability,release,releases,814,"Thanks @carlocastoldi . The change looks a bit scary to me - although it's possible the existing behavior is already a bit scary. I see the [javadocs](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Files.html#copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)) state the following regarding `Files.copy` with `REPLACE_EXISTING`; > The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities. Nevertheless, I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. Is there any easy way for us to replicate the issue? Or, if not, could you give the full stack trace for what exception you get without these changes?. I wonder whether creating a method for copy/move that attempts the old behavior, and reverts to the new one if that fails for some reason.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1898792339
https://github.com/qupath/qupath/pull/1449#issuecomment-1898792339:788,Energy Efficiency,reduce,reduced,788,"Thanks @carlocastoldi . The change looks a bit scary to me - although it's possible the existing behavior is already a bit scary. I see the [javadocs](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Files.html#copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)) state the following regarding `Files.copy` with `REPLACE_EXISTING`; > The check for the existence of the file and the creation of the new file may not be atomic with respect to other file system activities. Nevertheless, I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. Is there any easy way for us to replicate the issue? Or, if not, could you give the full stack trace for what exception you get without these changes?. I wonder whether creating a method for copy/move that attempts the old behavior, and reverts to the new one if that fails for some reason.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1898792339
https://github.com/qupath/qupath/pull/1449#issuecomment-1898959824:2077,Deployability,install,install,2077,"ackup` (works as we are sure the target doesn't exists already). If this fails, you have the `<file.tmp>` as the newest version; 4. `mv <file>.tmp <file>` (same, as the previous operation worked). If this fails, you have the `<file.backup>` as the backup version; 5. `rm <file>.backup`, if desired. > could you give the full stack trace for what exception you get without these changes?. The ""problem"" is that there is no exception thrown. It just fails on step 3 and/or 4 because `source` is identified as the same file as `target`, so it just [does not do anything](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L363). As if the `target` was the `source`.; This means that a project saved on an SFTP server will always end up with three files, `project.qpproj`, `project.qpproj.backup` and `project.qpproj.tmp`, where the latter is the ""real"" project.; But it also means that when a project is saving the image data it does the following if there was a previous backup:; * `mv <pathData> <pathBackup>` -> **FAILS** : `<pathBackup>`now has the older backup saved, while `<pathData>` still exists.; * `write <pathData>` -> dangerous operation: if it fails for whatever reason, the only saved state is the one from an older backup. > Is there any easy way for us to replicate the issue?. Not that I know of. You have to connect to an SFTP server with windows to do this. Finally, i think `DefaultProject.java` could be the only source file that would need to be modified to improve SSH support from windows. The other operations are internal to QuPath, and I doubt people would install the windows version of QuPath in an Linux server and run it with `sshfs-win` 😅. Regarding the `copy` operation, instead, isn't it only ever used when duplicating an Image? In that case how could there be another file in the new data entry's path? I don't think you evern needed the `REPLACE_EXISTING` attribute over there.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1898959824
https://github.com/qupath/qupath/pull/1449#issuecomment-1898959824:91,Safety,safe,safely,91,"If atomicity of the operation is what worries you, i could implement a method that does it safely, very similarly to what you do with `.qpproj` files.; 1. `write <file>.tmp` (if it already exists, it will just overwrite it). If this fails, you have the previous `<file>`; 2. `rm <file>.backup --if-exists`. If this fails, you have the `<file.tmp>` and `<file>` as the newest versions; 3. `mv <file> <file>.backup` (works as we are sure the target doesn't exists already). If this fails, you have the `<file.tmp>` as the newest version; 4. `mv <file>.tmp <file>` (same, as the previous operation worked). If this fails, you have the `<file.backup>` as the backup version; 5. `rm <file>.backup`, if desired. > could you give the full stack trace for what exception you get without these changes?. The ""problem"" is that there is no exception thrown. It just fails on step 3 and/or 4 because `source` is identified as the same file as `target`, so it just [does not do anything](https://github.com/openjdk/jdk/blob/cbfddf4e1d3ff8dddb95bcb9242b31c175b768fc/src/java.base/windows/classes/sun/nio/fs/WindowsFileCopy.java#L363). As if the `target` was the `source`.; This means that a project saved on an SFTP server will always end up with three files, `project.qpproj`, `project.qpproj.backup` and `project.qpproj.tmp`, where the latter is the ""real"" project.; But it also means that when a project is saving the image data it does the following if there was a previous backup:; * `mv <pathData> <pathBackup>` -> **FAILS** : `<pathBackup>`now has the older backup saved, while `<pathData>` still exists.; * `write <pathData>` -> dangerous operation: if it fails for whatever reason, the only saved state is the one from an older backup. > Is there any easy way for us to replicate the issue?. Not that I know of. You have to connect to an SFTP server with windows to do this. Finally, i think `DefaultProject.java` could be the only source file that would need to be modified to improve SSH support from win",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1898959824
https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126:285,Deployability,release,releases,285,"> I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. I agree, this feels a bit aggressive to me. If the existing copy may not be atomic, I'd rather try to implement an atomic version than to switch to a ""definitely not atomic"" version. > If atomicity of the operation is what worries you, i could implement a method that does it safely, very similarly to what you do with .qpproj files. This sounds good to me, it's important for obvious reasons that user data operations are done as safely as possible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126
https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126:259,Energy Efficiency,reduce,reduced,259,"> I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. I agree, this feels a bit aggressive to me. If the existing copy may not be atomic, I'd rather try to implement an atomic version than to switch to a ""definitely not atomic"" version. > If atomicity of the operation is what worries you, i could implement a method that does it safely, very similarly to what you do with .qpproj files. This sounds good to me, it's important for obvious reasons that user data operations are done as safely as possible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126
https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126:571,Safety,safe,safely,571,"> I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. I agree, this feels a bit aggressive to me. If the existing copy may not be atomic, I'd rather try to implement an atomic version than to switch to a ""definitely not atomic"" version. > If atomicity of the operation is what worries you, i could implement a method that does it safely, very similarly to what you do with .qpproj files. This sounds good to me, it's important for obvious reasons that user data operations are done as safely as possible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126
https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126:726,Safety,safe,safely,726,"> I still feel uneasy about explicitly deleting before attempting any copy or move.... since 'may not be atomic' still gives me some hope that we won't end up in some unfortunate state. Corrupt data files was previously a somewhat common complaint, which has reduced a lot over recent releases. I agree, this feels a bit aggressive to me. If the existing copy may not be atomic, I'd rather try to implement an atomic version than to switch to a ""definitely not atomic"" version. > If atomicity of the operation is what worries you, i could implement a method that does it safely, very similarly to what you do with .qpproj files. This sounds good to me, it's important for obvious reasons that user data operations are done as safely as possible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1908172126
https://github.com/qupath/qupath/pull/1449#issuecomment-1908286981:448,Safety,safe,safely,448,"> I agree, this feels a bit aggressive to me. If the existing copy may not be atomic, I'd rather try to implement an atomic version than to switch to a ""definitely not atomic"" version. I am afraid that copy operations were never guaranteed to be atomic in mainstream OSes. But I agree that this should be something where chance has no room to play. > This sounds good to me, it's important for obvious reasons that user data operations are done as safely as possible. Alright then, I'll work on it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1449#issuecomment-1908286981
https://github.com/qupath/qupath/issues/1451#issuecomment-1907884661:40,Usability,simpl,simply,40,"Thanks, I *think* the solution might be simply to include `System.exit(-1)` in the `catch` clause here:; https://github.com/qupath/qupath/blob/864ac71893a8749ff226c99e51642a5e10ea89ea/qupath-extension-bioformats/src/main/java/qupath/lib/images/writers/ome/ConvertCommand.java#L250-L255. @Rylern could you check this please?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1451#issuecomment-1907884661
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:648,Availability,reliab,reliable,648,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:854,Deployability,release,releases,854,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:664,Energy Efficiency,reduce,reduces,664,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:335,Integrability,depend,depends,335,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:424,Safety,detect,detection,424,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:447,Safety,detect,detection,447,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:794,Safety,detect,detection,794,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:964,Safety,detect,detection,964,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883:1013,Safety,detect,detection,1013,"I'm not sure about this. It has been a long time, but I think the reason I excluded sum from non-nucleus measurements is because it is common for people to train classifiers using all features. Because cell expansion is only distance-based, I felt that sum measurements outside the nucleus could be extremely unreliable. Also, the sum depends upon the resolution at which the measurement is calculated; for the default cell detection, this is the detection resolution, but that might not be what the user expects. The need for a nucleus sum, however, seemed sufficiently common that it should be included - and the nucleus ROI is likely to be more reliable, which reduces the problems slightly. I realise it's a judgement call and people may disagree. I'm reluctant to change the built-in cell detection, since the current behavior hasn't changed across releases and any modifications can impact classifiers. I'd rather we focus on moving away to alternative cell detection methods, and decouple measurement from detection to improve flexibility.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1909779883
https://github.com/qupath/qupath/issues/1454#issuecomment-1911731601:21,Testability,log,logic,21,"Yes I understand the logic behing it and I think @petebankhead's logic is sound. intensty sum means little when the cytoplam and cells are not ""real"" structures but geometrical constructs. And thanks @MichaelSNelson. I ended up using the mean intensity measurement to get what I needed and your explanation was very welcome!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1911731601
https://github.com/qupath/qupath/issues/1454#issuecomment-1911731601:65,Testability,log,logic,65,"Yes I understand the logic behing it and I think @petebankhead's logic is sound. intensty sum means little when the cytoplam and cells are not ""real"" structures but geometrical constructs. And thanks @MichaelSNelson. I ended up using the mean intensity measurement to get what I needed and your explanation was very welcome!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1454#issuecomment-1911731601
https://github.com/qupath/qupath/pull/1455#issuecomment-1910501486:101,Deployability,release,release,101,"Looks good! I'll merge this as it looks small enough to be a good candidate for v0.5.1 (if we make a release). Feel free to refactor according to the new style as a separate PR, but it's not urgent if it's currently working.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1455#issuecomment-1910501486
https://github.com/qupath/qupath/pull/1455#issuecomment-1910501486:124,Modifiability,refactor,refactor,124,"Looks good! I'll merge this as it looks small enough to be a good candidate for v0.5.1 (if we make a release). Feel free to refactor according to the new style as a separate PR, but it's not urgent if it's currently working.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1455#issuecomment-1910501486
https://github.com/qupath/qupath/pull/1457#issuecomment-1916693983:6,Deployability,update,updated,6,"OK, I updated the PR",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1457#issuecomment-1916693983
https://github.com/qupath/qupath/pull/1457#issuecomment-1941489238:0,Usability,Intuit,Intuitively,0,"Intuitively, it feels that if we do it to left/lower, then we should do it to right/upper - is there any reason not to?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1457#issuecomment-1941489238
https://github.com/qupath/qupath/pull/1460#issuecomment-1935805125:43,Deployability,release,release,43,Is it worth revisiting the idea of a draft release pipeline using actions? Manually triggered,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460#issuecomment-1935805125
https://github.com/qupath/qupath/pull/1460#issuecomment-1935805125:51,Deployability,pipeline,pipeline,51,Is it worth revisiting the idea of a draft release pipeline using actions? Manually triggered,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460#issuecomment-1935805125
https://github.com/qupath/qupath/pull/1460#issuecomment-1935865136:71,Deployability,release,release,71,"Sounds good, as long as it doesn't enforce any tag until we *actually* release. Also, if you want to take it on... I think this PR fails because the two mac builds become 'pkg' and only one survives.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460#issuecomment-1935865136
https://github.com/qupath/qupath/pull/1460#issuecomment-1935866859:71,Deployability,release,release,71,"> Sounds good, as long as it doesn't enforce any tag until we actually release. Yeah, was used to software where version bumps are much more liberal. > Also, if you want to take it on... I think this PR fails because the two mac builds become 'pkg' and only one survives. Will have a look now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460#issuecomment-1935866859
https://github.com/qupath/qupath/pull/1460#issuecomment-1936081052:73,Availability,down,download,73,"Because I'm not very good at GitHub Actions. Which is also why I have to download the Linux stuff to make the tar.xz locally (and possibly Windows .zip? not sure if that's fixed), and why we end up with some packaged builds we never use (like the macOS .app).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1460#issuecomment-1936081052
https://github.com/qupath/qupath/pull/1461#issuecomment-1934393163:1084,Modifiability,variab,variables,1084,"Thanks @Rylern this looks good & brings up a couple of minor questions for you, @alanocallaghan and @finglis; * How 'deep' should we search for extensions (i.e. how many sub-directories)?; * Should there be any way to override the depth?. Currently in this PR I think it will search 4 subdirectories deep, and there is no option to override this because the field is `final`. If it *wasn't* `final` then the following script should work:; ```groovy; // Prints, even though it's private; println qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH. // Try to set; qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH = 5. // Print again; println qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH; ```; and that would allow the user to sneakily adjust the depth in a startup script. I've sometimes found such sneaky scripts to be useful - mostly when a user wants to do something I hadn't thought to make in the public API - but I'm not sure if we want to permit or block it. Either way, the script only works because of Groovy's relaxed attitude to private variables - so it's risky for the user to do such things. If no one has strong opinions, I can just merge the PR as it currently is. But it's worth knowing that the choice of `final`/`non-final` has this implication, since Groovy is our scripting language.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1461#issuecomment-1934393163
https://github.com/qupath/qupath/pull/1461#issuecomment-1934393163:1104,Safety,risk,risky,1104,"Thanks @Rylern this looks good & brings up a couple of minor questions for you, @alanocallaghan and @finglis; * How 'deep' should we search for extensions (i.e. how many sub-directories)?; * Should there be any way to override the depth?. Currently in this PR I think it will search 4 subdirectories deep, and there is no option to override this because the field is `final`. If it *wasn't* `final` then the following script should work:; ```groovy; // Prints, even though it's private; println qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH. // Try to set; qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH = 5. // Print again; println qupath.lib.gui.ExtensionClassLoader.MAX_EXTENSION_JARS_DEPTH; ```; and that would allow the user to sneakily adjust the depth in a startup script. I've sometimes found such sneaky scripts to be useful - mostly when a user wants to do something I hadn't thought to make in the public API - but I'm not sure if we want to permit or block it. Either way, the script only works because of Groovy's relaxed attitude to private variables - so it's risky for the user to do such things. If no one has strong opinions, I can just merge the PR as it currently is. But it's worth knowing that the choice of `final`/`non-final` has this implication, since Groovy is our scripting language.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1461#issuecomment-1934393163
https://github.com/qupath/qupath/pull/1462#issuecomment-1973332453:31,Safety,detect,detective,31,"Thanks, this is some excellent detective work!. Closing in favor of https://github.com/qupath/qupath/pull/1476 for v0.5.1 because it is simpler (and written based on the info you posted here), but we may revisit it as this is more listener-friendly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462#issuecomment-1973332453
https://github.com/qupath/qupath/pull/1462#issuecomment-1973332453:136,Usability,simpl,simpler,136,"Thanks, this is some excellent detective work!. Closing in favor of https://github.com/qupath/qupath/pull/1476 for v0.5.1 because it is simpler (and written based on the info you posted here), but we may revisit it as this is more listener-friendly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1462#issuecomment-1973332453
https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636:240,Deployability,update,update,240,"> Would it be possible to avoid duplicating the shortcuts in the properties files, and instead extract them directly from the Action accelerator property?. Yes, it's now the case. > A complication I see is that making the tooltip text auto-update if the accelerator or action 'long description' is changed - but this is not an essential feature (since it should be rare). Right now I have the impression that the tooltip text will auto-update if the language changes. Is that enough?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636
https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636:436,Deployability,update,update,436,"> Would it be possible to avoid duplicating the shortcuts in the properties files, and instead extract them directly from the Action accelerator property?. Yes, it's now the case. > A complication I see is that making the tooltip text auto-update if the accelerator or action 'long description' is changed - but this is not an essential feature (since it should be rare). Right now I have the impression that the tooltip text will auto-update if the language changes. Is that enough?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636
https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636:26,Safety,avoid,avoid,26,"> Would it be possible to avoid duplicating the shortcuts in the properties files, and instead extract them directly from the Action accelerator property?. Yes, it's now the case. > A complication I see is that making the tooltip text auto-update if the accelerator or action 'long description' is changed - but this is not an essential feature (since it should be rare). Right now I have the impression that the tooltip text will auto-update if the language changes. Is that enough?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1463#issuecomment-1941752636
https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233:182,Deployability,release,release,182,"Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version? I imagine sometimes we might want to make builds without creating a release - but having the option to make a draft release as well is a fantastic improvement.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233
https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233:328,Deployability,release,release,328,"Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version? I imagine sometimes we might want to make builds without creating a release - but having the option to make a draft release as well is a fantastic improvement.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233
https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233:376,Deployability,release,release,376,"Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version? I imagine sometimes we might want to make builds without creating a release - but having the option to make a draft release as well is a fantastic improvement.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943515233
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:205,Deployability,release,releases,205,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:308,Deployability,release,release,308,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:390,Deployability,update,update,390,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:401,Deployability,release,release,401,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:589,Deployability,release,release,589,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:727,Deployability,release,release,727,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:776,Deployability,release,release,776,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811:859,Deployability,release,release,859,"> Looks great - is there any way to run it before merging? I think it's possible if it's on a branch of this repo, but not a fork. Here's what it makes on my fork: https://github.com/alanocallaghan/qupath/releases/tag/v0.5.1-SNAPSHOT. If I dispatch it again without making any changes, it just makes another release. There's no issue with tag collision until you try to publish both. I did update the release code so it points at the specific commit SHA that the builds correspond to, though, rather than a moving target (eg `main`). > Is it also possible to separate out the draft of the release - or check what happens if running twice without a change of version?. Yes, I rearranged the workflows so that jpackage and draft release are separate workflows (though ofc draft release does jpackage first). So you can just build binaries, or build and draft a release. Any other wishlist ideas for CI while I'm at it?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943694811
https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304:43,Deployability,release,releases,43,"This looks magnificent! It should make new releases so much less painful. Can't think of any other requests, unless you want to see a better way to handle javadocs: https://github.com/qupath/javadoc. But I've tended to just update javadocs for v0.x.0 releases, since the API shouldn't change substantially and so it's rather less important.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304
https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304:224,Deployability,update,update,224,"This looks magnificent! It should make new releases so much less painful. Can't think of any other requests, unless you want to see a better way to handle javadocs: https://github.com/qupath/javadoc. But I've tended to just update javadocs for v0.x.0 releases, since the API shouldn't change substantially and so it's rather less important.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304
https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304:251,Deployability,release,releases,251,"This looks magnificent! It should make new releases so much less painful. Can't think of any other requests, unless you want to see a better way to handle javadocs: https://github.com/qupath/javadoc. But I've tended to just update javadocs for v0.x.0 releases, since the API shouldn't change substantially and so it's rather less important.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1464#issuecomment-1943720304
https://github.com/qupath/qupath/pull/1465#issuecomment-1971249723:238,Availability,error,error,238,"I think this is a good & elegant way to fix the problem. I haven't merged it yet as I'm trying to think if it could have any other implications that mean we should target v0.6.0 rather than v0.5.1. Were you able to reproduce the original error? I've tried creating some training images with empty regions, but haven't managed to cause the problem yet.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971249723
https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682:492,Availability,error,error,492,"Yes, in a project, start from LuCa-7color_[17572,60173]_3x3component_data.tif, define two annotations with the Region class like this:; ![Screenshot from 2024-02-29 15-14-35](https://github.com/qupath/qupath/assets/60394504/b5c78607-282b-403f-9296-ace2af0a91ad). Then Classify, Training Images, Create Training images, default parameters, and it creates this image:; ![image](https://github.com/qupath/qupath/assets/60394504/1741642f-d89b-4790-bc4f-0fe5130a80c9). Then this script throws the error:. ```groovy; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682
https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682:589,Safety,detect,detect,589,"Yes, in a project, start from LuCa-7color_[17572,60173]_3x3component_data.tif, define two annotations with the Region class like this:; ![Screenshot from 2024-02-29 15-14-35](https://github.com/qupath/qupath/assets/60394504/b5c78607-282b-403f-9296-ace2af0a91ad). Then Classify, Training Images, Create Training images, default parameters, and it creates this image:; ![image](https://github.com/qupath/qupath/assets/60394504/1741642f-d89b-4790-bc4f-0fe5130a80c9). Then this script throws the error:. ```groovy; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682
https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682:630,Safety,detect,detectionImage,630,"Yes, in a project, start from LuCa-7color_[17572,60173]_3x3component_data.tif, define two annotations with the Region class like this:; ![Screenshot from 2024-02-29 15-14-35](https://github.com/qupath/qupath/assets/60394504/b5c78607-282b-403f-9296-ace2af0a91ad). Then Classify, Training Images, Create Training images, default parameters, and it creates this image:; ![image](https://github.com/qupath/qupath/assets/60394504/1741642f-d89b-4790-bc4f-0fe5130a80c9). Then this script throws the error:. ```groovy; setImageType('FLUORESCENCE');; selectAnnotations();; runPlugin('qupath.imagej.detect.cells.WatershedCellDetection', '{""detectionImage"":""DAPI"",""requestedPixelSizeMicrons"":0.1,""backgroundRadiusMicrons"":4.0,""backgroundByReconstruction"":true,""medianRadiusMicrons"":1.0,""sigmaMicrons"":2.5,""minAreaMicrons"":11.0,""maxAreaMicrons"":400.0,""threshold"":1000.0,""watershedPostProcess"":true,""cellExpansionMicrons"":5.0,""includeNuclei"":true,""smoothBoundaries"":true,""makeMeasurements"":true}'); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971362682
https://github.com/qupath/qupath/pull/1465#issuecomment-1971443453:190,Integrability,interface,interface,190,"Great, thanks - can replicate it now. I was trying something similar but the key difference was that I was using an RGB image, and that seems to always work. Well, the current `ImageServer` interface seems to have evolved into a bit of a mess. A note in the javadocs seems to suggest we shouldn't return `null` anyway: https://github.com/qupath/qupath/blob/474c08c13381c87969b7874ea3e5b4850757c7ba/qupath-core/src/main/java/qupath/lib/images/servers/ImageServer.java#L202. But another note suggests that `isEmptyRegion` can be used to determine when `readBufferedImage` (now `readRegion`) would return `null`:; https://github.com/qupath/qupath/blob/474c08c13381c87969b7874ea3e5b4850757c7ba/qupath-core/src/main/java/qupath/lib/images/servers/ImageServer.java#L314. So... definitely need to fix this for v0.6.0, maybe should already tackle it in v0.5.1.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971443453
https://github.com/qupath/qupath/pull/1465#issuecomment-1971443453:214,Modifiability,evolve,evolved,214,"Great, thanks - can replicate it now. I was trying something similar but the key difference was that I was using an RGB image, and that seems to always work. Well, the current `ImageServer` interface seems to have evolved into a bit of a mess. A note in the javadocs seems to suggest we shouldn't return `null` anyway: https://github.com/qupath/qupath/blob/474c08c13381c87969b7874ea3e5b4850757c7ba/qupath-core/src/main/java/qupath/lib/images/servers/ImageServer.java#L202. But another note suggests that `isEmptyRegion` can be used to determine when `readBufferedImage` (now `readRegion`) would return `null`:; https://github.com/qupath/qupath/blob/474c08c13381c87969b7874ea3e5b4850757c7ba/qupath-core/src/main/java/qupath/lib/images/servers/ImageServer.java#L314. So... definitely need to fix this for v0.6.0, maybe should already tackle it in v0.5.1.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-1971443453
https://github.com/qupath/qupath/pull/1465#issuecomment-2085691166:5,Deployability,update,updated,5,"I've updated one of my old incorrect javadocs - assuming it still builds fine I think this is good to merge, thanks!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1465#issuecomment-2085691166
https://github.com/qupath/qupath/pull/1466#issuecomment-2294898133:61,Integrability,synchroniz,synchronization,61,"You were definitely right that `MeasurementList` needed more synchronization. I'll close this because it is now included in https://github.com/qupath/qupath/pull/1592 along with a more substantial revision, and other related bug-fixes.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1466#issuecomment-2294898133
https://github.com/qupath/qupath/pull/1471#issuecomment-1966630170:55,Deployability,release,release,55,"Definitely should axe jet, maybe add turbo in a future release",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1471#issuecomment-1966630170
https://github.com/qupath/qupath/pull/1474#issuecomment-1966588492:88,Deployability,release,release,88,Let me know when this is tested on different platforms so I can do a non-snapshot blosc release,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1966588492
https://github.com/qupath/qupath/pull/1474#issuecomment-1966588492:25,Testability,test,tested,25,Let me know when this is tested on different platforms so I can do a non-snapshot blosc release,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1966588492
https://github.com/qupath/qupath/pull/1474#issuecomment-1971202262:87,Testability,test,test,87,This is huge! I should be able to try it on an Intel Mac - is there a link to any good test image?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1971202262
https://github.com/qupath/qupath/pull/1474#issuecomment-1971320350:388,Availability,down,downsample,388,"About commit [a7b184f](https://github.com/qupath/qupath/pull/1474/commits/a7b184f2bf0134432c52080e394ab51fea02dfe3):. In Zarr files (or at least in the Zarr files I have), the z values are scaled with the resolution. This means that if there is an image of shape (t: 10, c: 20, z: 30, y:40, x: 50) at full resolution, it will have a shape of (t: 10, c: 20, z: **15**, y:20, x: 25) with a downsample of 2 (and not (t: 10, c: 20, z: **30**, y:20, x: 25)). This means that in the BioFormats `IFormatReader.getIndex(z, c, t)` function, `z` can only take values between 0 and **15** (and not **30**) when called for the image of downsample 2. I'm not satisfied with this commit because it's ugly and assumes every Zarr files scale the z values with the resolution (which I was not able to find if it's the case in the [OME-ZARR specs](https://ngff.openmicroscopy.org/latest/)).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1971320350
https://github.com/qupath/qupath/pull/1474#issuecomment-1971320350:624,Availability,down,downsample,624,"About commit [a7b184f](https://github.com/qupath/qupath/pull/1474/commits/a7b184f2bf0134432c52080e394ab51fea02dfe3):. In Zarr files (or at least in the Zarr files I have), the z values are scaled with the resolution. This means that if there is an image of shape (t: 10, c: 20, z: 30, y:40, x: 50) at full resolution, it will have a shape of (t: 10, c: 20, z: **15**, y:20, x: 25) with a downsample of 2 (and not (t: 10, c: 20, z: **30**, y:20, x: 25)). This means that in the BioFormats `IFormatReader.getIndex(z, c, t)` function, `z` can only take values between 0 and **15** (and not **30**) when called for the image of downsample 2. I'm not satisfied with this commit because it's ugly and assumes every Zarr files scale the z values with the resolution (which I was not able to find if it's the case in the [OME-ZARR specs](https://ngff.openmicroscopy.org/latest/)).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1971320350
https://github.com/qupath/qupath/pull/1474#issuecomment-1971366708:33,Deployability,release,release,33,"Great, shall I push out a proper release of the blosc jar, then?. > Will take a bit of thought to figure out how to do it. Maybe we need an 'Open image directory' option? But then people might assume that it opens all the images in a directory (which, I suppose, it something it could do...). Both useful, but should be distinguished semantically in some way",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1971366708
https://github.com/qupath/qupath/pull/1474#issuecomment-1971445743:179,Integrability,depend,dependent,179,I think in JavaFX we can only have a file *or* a directory chooser... and you need to select the right chooser since they can't be mixed (at least on macOS - it might be platform-dependent). Haven't checked out the last commit yet...,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1474#issuecomment-1971445743
https://github.com/qupath/qupath/pull/1476#issuecomment-1973328681:233,Deployability,release,release,233,"Not sure it's better, but quicker for now without changing the API - so if we both think it should solve the issue I'll merge it. Your insights from exploring this ugly bit of the code are welcome any time for refactoring in a major release :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1476#issuecomment-1973328681
https://github.com/qupath/qupath/pull/1476#issuecomment-1973328681:210,Modifiability,refactor,refactoring,210,"Not sure it's better, but quicker for now without changing the API - so if we both think it should solve the issue I'll merge it. Your insights from exploring this ugly bit of the code are welcome any time for refactoring in a major release :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1476#issuecomment-1973328681
https://github.com/qupath/qupath/pull/1478#issuecomment-1976286327:31,Deployability,update,update,31,The TMA core grid view doesn't update when the TMA grid is deleted / re-created / modified. Is that intended?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1478#issuecomment-1976286327
https://github.com/qupath/qupath/pull/1478#issuecomment-1976306381:186,Deployability,release,release,186,"Not really intended, but I think it's a limitation that was always there - I don't think it's a new regression. Not sure how much the grid view is used. We should address it in a future release if it turns out to be extremely useful (to us or others), but I think it's obscure enough to ignore for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1478#issuecomment-1976306381
https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253:833,Availability,down,download,833,"I think this looks good and could be merged any time. I have a few wishlist requests, which would be added here or in a later PR:; * The popover doesn't match the css, which looks especially strange in dark mode.; * Using [`WebViews`](https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/WebViews.java#L38) to create the `WebView` and bind the stylesheet may help, (although I think `PopOver` is generally hard to style in a well-behaved way); * ~~The `i` info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too)~~ *(edit: I was wrong)*; * The `Owner` and `Repository` fields shouldn't be automatically reset whenever a download is requested or fails with an error; * I don't think `Download extension from GitHub` should be collapsible (it doesn't take up much space); * It feels convoluted to me that the user *must* fill in two fields, whenever they might just want to copy and paste one GitHub url. Could/should the `Owner` and `Repository` be able to identify when a full URL has been pasted, and then automatically split it?; * e.g. Pasting `https://github.com/qupath/qupath-extension-py4j` would result in `Owner=qupath` and `Repository=qupath-extension-py4j`. Pinging @Rylern and @finglis for their opinions as well, and include a screenshot to illustrate some of what I'm referring to. <img width=""879"" alt=""extension-manager"" src=""https://github.com/user-attachments/assets/f0fc272d-3b1c-4a09-9f6e-6cecf6e1d5b7"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253
https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253:872,Availability,error,error,872,"I think this looks good and could be merged any time. I have a few wishlist requests, which would be added here or in a later PR:; * The popover doesn't match the css, which looks especially strange in dark mode.; * Using [`WebViews`](https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/WebViews.java#L38) to create the `WebView` and bind the stylesheet may help, (although I think `PopOver` is generally hard to style in a well-behaved way); * ~~The `i` info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too)~~ *(edit: I was wrong)*; * The `Owner` and `Repository` fields shouldn't be automatically reset whenever a download is requested or fails with an error; * I don't think `Download extension from GitHub` should be collapsible (it doesn't take up much space); * It feels convoluted to me that the user *must* fill in two fields, whenever they might just want to copy and paste one GitHub url. Could/should the `Owner` and `Repository` be able to identify when a full URL has been pasted, and then automatically split it?; * e.g. Pasting `https://github.com/qupath/qupath-extension-py4j` would result in `Owner=qupath` and `Repository=qupath-extension-py4j`. Pinging @Rylern and @finglis for their opinions as well, and include a screenshot to illustrate some of what I'm referring to. <img width=""879"" alt=""extension-manager"" src=""https://github.com/user-attachments/assets/f0fc272d-3b1c-4a09-9f6e-6cecf6e1d5b7"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253
https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253:896,Availability,Down,Download,896,"I think this looks good and could be merged any time. I have a few wishlist requests, which would be added here or in a later PR:; * The popover doesn't match the css, which looks especially strange in dark mode.; * Using [`WebViews`](https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/WebViews.java#L38) to create the `WebView` and bind the stylesheet may help, (although I think `PopOver` is generally hard to style in a well-behaved way); * ~~The `i` info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too)~~ *(edit: I was wrong)*; * The `Owner` and `Repository` fields shouldn't be automatically reset whenever a download is requested or fails with an error; * I don't think `Download extension from GitHub` should be collapsible (it doesn't take up much space); * It feels convoluted to me that the user *must* fill in two fields, whenever they might just want to copy and paste one GitHub url. Could/should the `Owner` and `Repository` be able to identify when a full URL has been pasted, and then automatically split it?; * e.g. Pasting `https://github.com/qupath/qupath-extension-py4j` would result in `Owner=qupath` and `Repository=qupath-extension-py4j`. Pinging @Rylern and @finglis for their opinions as well, and include a screenshot to illustrate some of what I'm referring to. <img width=""879"" alt=""extension-manager"" src=""https://github.com/user-attachments/assets/f0fc272d-3b1c-4a09-9f6e-6cecf6e1d5b7"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253
https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253:1381,Availability,Ping,Pinging,1381,"I think this looks good and could be merged any time. I have a few wishlist requests, which would be added here or in a later PR:; * The popover doesn't match the css, which looks especially strange in dark mode.; * Using [`WebViews`](https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/WebViews.java#L38) to create the `WebView` and bind the stylesheet may help, (although I think `PopOver` is generally hard to style in a well-behaved way); * ~~The `i` info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too)~~ *(edit: I was wrong)*; * The `Owner` and `Repository` fields shouldn't be automatically reset whenever a download is requested or fails with an error; * I don't think `Download extension from GitHub` should be collapsible (it doesn't take up much space); * It feels convoluted to me that the user *must* fill in two fields, whenever they might just want to copy and paste one GitHub url. Could/should the `Owner` and `Repository` be able to identify when a full URL has been pasted, and then automatically split it?; * e.g. Pasting `https://github.com/qupath/qupath-extension-py4j` would result in `Owner=qupath` and `Repository=qupath-extension-py4j`. Pinging @Rylern and @finglis for their opinions as well, and include a screenshot to illustrate some of what I'm referring to. <img width=""879"" alt=""extension-manager"" src=""https://github.com/user-attachments/assets/f0fc272d-3b1c-4a09-9f6e-6cecf6e1d5b7"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253
https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253:673,Testability,log,logic,673,"I think this looks good and could be merged any time. I have a few wishlist requests, which would be added here or in a later PR:; * The popover doesn't match the css, which looks especially strange in dark mode.; * Using [`WebViews`](https://github.com/qupath/qupath/blob/f12b38a32906e0257a34ea380e9a66d67e58ae75/qupath-gui-fx/src/main/java/qupath/lib/gui/tools/WebViews.java#L38) to create the `WebView` and bind the stylesheet may help, (although I think `PopOver` is generally hard to style in a well-behaved way); * ~~The `i` info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too)~~ *(edit: I was wrong)*; * The `Owner` and `Repository` fields shouldn't be automatically reset whenever a download is requested or fails with an error; * I don't think `Download extension from GitHub` should be collapsible (it doesn't take up much space); * It feels convoluted to me that the user *must* fill in two fields, whenever they might just want to copy and paste one GitHub url. Could/should the `Owner` and `Repository` be able to identify when a full URL has been pasted, and then automatically split it?; * e.g. Pasting `https://github.com/qupath/qupath-extension-py4j` would result in `Owner=qupath` and `Repository=qupath-extension-py4j`. Pinging @Rylern and @finglis for their opinions as well, and include a screenshot to illustrate some of what I'm referring to. <img width=""879"" alt=""extension-manager"" src=""https://github.com/user-attachments/assets/f0fc272d-3b1c-4a09-9f6e-6cecf6e1d5b7"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2256038253
https://github.com/qupath/qupath/pull/1486#issuecomment-2258155922:156,Testability,log,logic,156,"Re: . > The i info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too). I'm not sure I follow? The buttons seem to follow the same display logic in the main extension manager window and the sub-popup. The colours are different here but that's a weird issue when I take screenshots. Buttons in both are dark with white icon/glyph. As far as I can tell the buttons should always be dark background, light glyph. ![Screenshot from 2024-07-30 12-27-34](https://github.com/user-attachments/assets/37b9da2c-f1ec-4c2f-9e5d-bea72a6e9e25); ![Screenshot from 2024-07-30 12-27-23](https://github.com/user-attachments/assets/2e0e7f21-faf6-4b9a-bee5-1f032aacbbdb)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2258155922
https://github.com/qupath/qupath/pull/1486#issuecomment-2258155922:277,Testability,log,logic,277,"Re: . > The i info button has different styling when highlighted in the sub-popup window (it basically just ignores whether the row is selected - whichever logic is in the main table might be useful here too). I'm not sure I follow? The buttons seem to follow the same display logic in the main extension manager window and the sub-popup. The colours are different here but that's a weird issue when I take screenshots. Buttons in both are dark with white icon/glyph. As far as I can tell the buttons should always be dark background, light glyph. ![Screenshot from 2024-07-30 12-27-34](https://github.com/user-attachments/assets/37b9da2c-f1ec-4c2f-9e5d-bea72a6e9e25); ![Screenshot from 2024-07-30 12-27-23](https://github.com/user-attachments/assets/2e0e7f21-faf6-4b9a-bee5-1f032aacbbdb)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2258155922
https://github.com/qupath/qupath/pull/1486#issuecomment-2258172093:129,Deployability,update,updated,129,"Ah you're right, sorry. I was mixing it up with the appearance whenever the buttons are inactive (because the extension can't be updated). When that is the case, the selection color impacts the button color... but it doesn't if the buttons are active. So the displays are consistent after all.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2258172093
https://github.com/qupath/qupath/pull/1486#issuecomment-2258818054:167,Availability,down,download,167,"I'm afraid this isn't working for me - the externalized strings seem to be missing. If I enter; ```; qupath/qupath-extension-jpen; ```; and agree to the prompts for a download, I end up with an exception. The important part seems to be:; ```; Caused by: java.util.MissingResourceException: Can't find resource for bundle java.util.PropertyResourceBundle, key ExtensionControlPane.tag; 	at java.base/java.util.ResourceBundle.getObject(ResourceBundle.java:567); 	at java.base/java.util.ResourceBundle.getObject(ResourceBundle.java:561); 	at java.base/java.util.ResourceBundle.getString(ResourceBundle.java:523); ```. I also have the feeling the text field is too small, and it should expand (filling all available space would be ok):. <img width=""1154"" alt=""short"" src=""https://github.com/user-attachments/assets/3ffad225-9867-4f62-91ea-afbd60762928"">. If being really picky, I'd also ask for a tiny bit of horizontal space between the label and text field (possibly 5 or so pixels of padding). Lastly, the tooltip is also misleading - it implies that `qupath-extension-stardist` is a valid repository on its own (although maybe just because I have the old strings).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2258818054
https://github.com/qupath/qupath/pull/1486#issuecomment-2258818054:702,Availability,avail,available,702,"I'm afraid this isn't working for me - the externalized strings seem to be missing. If I enter; ```; qupath/qupath-extension-jpen; ```; and agree to the prompts for a download, I end up with an exception. The important part seems to be:; ```; Caused by: java.util.MissingResourceException: Can't find resource for bundle java.util.PropertyResourceBundle, key ExtensionControlPane.tag; 	at java.base/java.util.ResourceBundle.getObject(ResourceBundle.java:567); 	at java.base/java.util.ResourceBundle.getObject(ResourceBundle.java:561); 	at java.base/java.util.ResourceBundle.getString(ResourceBundle.java:523); ```. I also have the feeling the text field is too small, and it should expand (filling all available space would be ok):. <img width=""1154"" alt=""short"" src=""https://github.com/user-attachments/assets/3ffad225-9867-4f62-91ea-afbd60762928"">. If being really picky, I'd also ask for a tiny bit of horizontal space between the label and text field (possibly 5 or so pixels of padding). Lastly, the tooltip is also misleading - it implies that `qupath-extension-stardist` is a valid repository on its own (although maybe just because I have the old strings).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1486#issuecomment-2258818054
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:163,Availability,avail,available,163,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:56,Performance,load,loading,56,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:114,Performance,load,loading,114,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:109,Usability,undo,undo,109,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:146,Usability,undo,undo,146,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726:274,Usability,undo,undo,274,"I also noticed that if you just do the first two steps (loading image and objects) that you won't be able to undo loading the objects anyway. The undo action gets available after doing something else, even selecting and deleting an object. Pretty weird to me, where is that undo action coming from? It is unrelated to actions later. I think it is storing a state with no objects at all somewhere.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2010988726
https://github.com/qupath/qupath/issues/1487#issuecomment-2011332965:9,Usability,undo,undo,9,"QuPath's undo support is pretty bad - I spoke about it recently in this video: https://youtu.be/zFTnfv_XWg4?t=41. Fixing it _properly_ will likely involve making some scarily-large changes to the core behavior, but we'll explore whether it can be made less bad in this specific scenario.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2011332965
https://github.com/qupath/qupath/issues/1487#issuecomment-2277243206:112,Availability,avail,available,112,"@Rylern figured out what's going on, and #1578 helps address this bit of undo/redo weirdness. The fix should be available in v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2277243206
https://github.com/qupath/qupath/issues/1487#issuecomment-2277243206:73,Usability,undo,undo,73,"@Rylern figured out what's going on, and #1578 helps address this bit of undo/redo weirdness. The fix should be available in v0.6.0.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1487#issuecomment-2277243206
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:1172,Deployability,patch,patches,1172,"nsive about merging quickly because it would be quite a significant change, and add complexity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and wh",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:221,Energy Efficiency,reduce,reduce,221,"Thanks, this is an interesting idea and certainly seems to help in the scenario you describe. I'm apprehensive about merging quickly because it would be quite a significant change, and add complexity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a cl",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:1425,Integrability,wrap,wrap,1425,"ity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and which can be used when you can *know* in advance that the image doesn't need to be accessed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:653,Safety,detect,detections,653,"Thanks, this is an interesting idea and certainly seems to help in the scenario you describe. I'm apprehensive about merging quickly because it would be quite a significant change, and add complexity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a cl",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:1554,Safety,avoid,avoids,1554,"ity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and which can be used when you can *know* in advance that the image doesn't need to be accessed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:939,Security,access,access,939,"Thanks, this is an interesting idea and certainly seems to help in the scenario you describe. I'm apprehensive about merging quickly because it would be quite a significant change, and add complexity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a cl",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:1797,Security,access,access,1797,"ity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and which can be used when you can *know* in advance that the image doesn't need to be accessed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:2187,Security,access,accessed,2187,"ity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and which can be used when you can *know* in advance that the image doesn't need to be accessed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811:1127,Usability,learn,learning,1127,"nsive about merging quickly because it would be quite a significant change, and add complexity when we're trying to reduce it. So it will take some thought and I'd like to understand the problem better. > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. > Additionally, allowed to modify `ObjectClassifierCommand` too so that it can read all detections' measurements in the training set without uselessly reading the image files. The [`ObjectClassifier`](https://qupath.github.io/javadoc/docs/qupath/lib/classifiers/object/ObjectClassifier.html) takes an `ImageData` by design because an object classifier *could* require pixel access... and this is very likely to be important in the future. This is because, when I rewrote object classifiers some years ago, I was thinking of future classifiers that will use deep learning models to classify based upon image patches - and not only measurements. That's why there is also a general [`FeatureExtractor`](https://qupath.github.io/javadoc/docs/qupath/opencv/ml/objects/features/FeatureExtractor.html) class. This all basically works, we just haven't yet had time to wrap it up for wider use. > You can now pass a `openImage` boolean to `ProjectImageEntry.readImageData()` that, when false, just avoids getting the default image server, but just uses an instance of `ImageServerStub`. While not identical, the current `ProjectImageEntry.readHierarchy()` is intended for when you need objects but not everything else. This already lets you access all measurements etc. without touching the image. You can then create a new `ImageData` with a dummy `ImageServer` if you need to. So an alternative approach might be to try to script creating a classifier without needing to go through the UI, in a way that doesn't involve any big API changes - and wh",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2021998811
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:3602,Availability,down,downstream,3602," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:612,Deployability,update,update,612,"Thank you for taking your time into understanding our problem and coming up with possible alternative solutions!. I absolutely get your notes on the classifier. I assumed that the ObjectClassifier would _never_ need to read pixels because it currently only uses the detections' measurements. Surely the code must be changed in preparation of the advent of the `FeatureExtractor`. And for this, using `ProjectImageEntry.readHierarchy()` is probably the better option.; > [...] creating a classifier without needing to go through the UI [...]. I am not sure about this, though. You often want to leverage the live-update feature when creating a classifier. That is one of the most handy feature when tweaking a classifier. If that option was removed, it would be unfortunate. -------------------------. However i think you missed a point. The major issue this PR wants to address is the ability to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the be",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:2946,Deployability,pipeline,pipeline,2946," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:3150,Deployability,pipeline,pipeline,3150," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:1848,Integrability,interface,interface,1848,"lity to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scripta",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:2892,Integrability,interface,interface,2892," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:3384,Modifiability,extend,extended,3384," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:3396,Modifiability,plug-in,plug-ins,3396," agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to QuPath's wide user-base. A base experience that can be extended by plug-ins and scripts _outside_ of QuPath's code/responsibility. However, I feel like the ability to run scripts in QuPath is at the **core** of its streghts. It allows to offer an extensible basis on which downstream developers can then build upon.; For this reason I ask you to please also consider future scenarios that this small PR opens up in batch script execution, and not only its implications with the object classifier. Thank you!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:266,Safety,detect,detections,266,"Thank you for taking your time into understanding our problem and coming up with possible alternative solutions!. I absolutely get your notes on the classifier. I assumed that the ObjectClassifier would _never_ need to read pixels because it currently only uses the detections' measurements. Surely the code must be changed in preparation of the advent of the `FeatureExtractor`. And for this, using `ProjectImageEntry.readHierarchy()` is probably the better option.; > [...] creating a classifier without needing to go through the UI [...]. I am not sure about this, though. You often want to leverage the live-update feature when creating a classifier. That is one of the most handy feature when tweaking a classifier. If that option was removed, it would be unfortunate. -------------------------. However i think you missed a point. The major issue this PR wants to address is the ability to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the be",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:1121,Security,access,accessed,1121,"m and coming up with possible alternative solutions!. I absolutely get your notes on the classifier. I assumed that the ObjectClassifier would _never_ need to read pixels because it currently only uses the detections' measurements. Surely the code must be changed in preparation of the advent of the `FeatureExtractor`. And for this, using `ProjectImageEntry.readHierarchy()` is probably the better option.; > [...] creating a classifier without needing to go through the UI [...]. I am not sure about this, though. You often want to leverage the live-update feature when creating a classifier. That is one of the most handy feature when tweaking a classifier. If that option was removed, it would be unfortunate. -------------------------. However i think you missed a point. The major issue this PR wants to address is the ability to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allow",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:1722,Security,access,accessed,1722,"st handy feature when tweaking a classifier. If that option was removed, it would be unfortunate. -------------------------. However i think you missed a point. The major issue this PR wants to address is the ability to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laborato",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:2322,Security,access,accesses,2322,"f21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. > Can you explain why it takes so long? Huge numbers of images? Slow file format, or is it where the images are stored?. Basically All you the above. It accesses ~50 `.czi` images, weighting ~10GiB each. Leaving the the big size aside, it's also known that BioFormats themselves (required by `.czi`) are slow to work with.; Adding up to this scenario, images are often stored on a remote server (be it OMERO or just a sftp/samba server). This is due to the fact that it is hard for every member of a laboratory to have them stored on their own computer, as they all need to collaborate and, even if they wanted, they would soon fill up their local storage. in this scenario, the fact that QuPath offer an highly-scriptable interface is many laboratories' luck. It means that a pipeline of scripts can be applied one after the other, resulting in a full analysis of the whole project. Sometimes, you may even want to tweak some parameters, and for this you have to re-run the whole pipeline in batch again. In the end, I really get you are wary of quickly merging this. I'm sure reducing code is a top priority in order to offer the best bug-free experience to",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076:1142,Usability,clear,clear,1142,"d that the ObjectClassifier would _never_ need to read pixels because it currently only uses the detections' measurements. Surely the code must be changed in preparation of the advent of the `FeatureExtractor`. And for this, using `ProjectImageEntry.readHierarchy()` is probably the better option.; > [...] creating a classifier without needing to go through the UI [...]. I am not sure about this, though. You often want to leverage the live-update feature when creating a classifier. That is one of the most handy feature when tweaking a classifier. If that option was removed, it would be unfortunate. -------------------------. However i think you missed a point. The major issue this PR wants to address is the ability to a script in batch as fast as possible (and when it is possible); > an alternative approach [...] that doesn't involve any big API changes - and which can be used when you can know in advance that the image doesn't need to be accessed. Just to be clear, this PR's only API change is adding in [`ProjectImageEntry.java:L195`](https://github.com/qupath/qupath/pull/1488/files#diff-14ed5cabf5566ab4eb5d1ae31a25d75c8dd49e3c50e1cc05ce10ff21936b9a9fR195), where it adds a new public method `readImageData(boolean)` asking whether to read or not the image file. It also provides a default implementation `readImageData()` that always reads it, so that all previous code relied on this assumption don't break.; Furthermore, as you suggested the current approach can be used when _you know in advance_ that the image doesn't need to be accessed:; ![image](https://github.com/qupath/qupath/assets/34198340/3525d599-2609-422b-a5f8-64c1660d505c). Now, I agree this interface may not be the best one as it could easily just be a checkbox option in the ScriptEditor. For now, though, i think it is enough to enjoy the benefits that this PR brings. > > This last change alone allowed, on my projects, to improve the time when creating an object classifier from ~10/15minutes to ~5seconds. ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022463076
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:1318,Availability,ERROR,ERROR,1318,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:1605,Availability,ERROR,ERROR,1605,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:978,Energy Efficiency,adapt,adapters,978,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:57,Integrability,interface,interface,57,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:978,Integrability,adapter,adapters,978,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:978,Modifiability,adapt,adapters,978,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:861,Performance,cache,cache,861,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:115,Security,access,accessing,115,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:1440,Security,access,accessing,1440,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385:1727,Security,access,accessing,1727,"With the latest commit I also added an option in the CLI interface to run the script for the whole project without accessing the image files.; ```bash; ./gradlew run --args=""script -p '/home/castoldi/426FC/project.qpproj' -n -c 'import qupath.imagej.tools.IJTools; println IJTools.convertToImagePlus(getCurrentServer(), RegionRequest.createInstance(getCurrentServer(), 16))'""; ````; output:; ```; > Task :qupath-app:run; 14:08:12.506 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting default Locale to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for FORMAT to en_US; 14:08:12.507 [main] [INFO ] qupath.lib.gui.prefs.PathPrefs - Setting Locale for DISPLAY to en_US; 14:08:12.513 [main] [INFO ] qupath.lib.common.ThreadTools - Setting parallelism to 31; 14:08:12.513 [main] [INFO ] qupath.ScriptCommand - Setting tile cache size to 8000.00 MB (25.0% max memory); 14:08:12.525 [main] [INFO ] qupath.lib.scripting.QP - Initializing type adapters; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:opencv:4.6.0-1.5.8 do not match.; Warning: Versions of org.bytedeco:javacpp:1.5.9 and org.bytedeco:openblas:0.3.21-1.5.8 do not match.; 14:08:12.860 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.1 FC.czi - Scene #1 (0/48); 14:08:13.205 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files.; [...]; 14:08:24.832 [main] [INFO ] qupath.ScriptCommand - Running script for SILVA_426.6 FC.czi - Scene #8 (48/48); 14:08:25.124 [main] [ERROR] qupath.ScriptCommand - The script tried to read pixels off an image while also requiring to run the script without accessing the image files. BUILD SUCCESSFUL in 18s; 34 actionable tasks: 10 executed, 24 up-to-date. ~/Projects/qupath light-script-runner* 19s; ❯ ; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2022842385
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:463,Availability,failure,failure,463,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:729,Modifiability,maintainab,maintainable,729,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:270,Performance,load,loading,270,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:662,Performance,load,loaded,662,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:456,Safety,avoid,avoids,456,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:629,Safety,avoid,avoid,629,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:52,Usability,clear,clear,52,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:256,Usability,simpl,simply,256,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875:354,Usability,simpl,simpler,354,"I think I do get the point, but want to ensure it's clear what exactly should be solved here, as I suspect there are alternative approached to consider. For example, I quickly drafted a rough alternative at https://github.com/qupath/qupath/pull/1489. This simply delays loading images until the `ImageServer` is requested. It has the advantages of being simpler (no need for different 'Run' actions), doesn't introduce any new `ImageServerStub` class, and avoids failure if pixels are requested. It probably has disadvantages too, as calling code needs to be more careful not to request the server at all (even for metadata), to avoid triggering the image to be loaded. I'm not sure which is best, but we should go with the most maintainable solution that solves the main problem.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2025049875
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:476,Availability,down,down,476,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:671,Integrability,interface,interface,671,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:1137,Integrability,interface,interface,1137,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:506,Modifiability,maintainab,maintainable,506,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:1192,Modifiability,maintainab,maintainable-wise,1192,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:1427,Safety,avoid,avoid,1427,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:330,Security,access,access,330,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:1383,Security,expose,expose,1383,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846:1303,Testability,log,logs,1303,"I really like your draft. It seems the most beautiful, design-wise. The `ImageServerStub` solution in the end may just work as a helper for writing ""good"" fast scripts, exposing exactly where the image files are absolutely needed. I made a small comment on your draft PR about the metadata, as i feel that is an important info to access *offline*. But in the end, if that was sorted out, that solution would be a drop-in replacement to mine. As you said, at last it will come down to which one is the most maintainable. I see pros and cons in both: `ImageServerStub` offers a solution that is segregated in one file, but then requires to punch multiple small holes in QP interface in order to use it; `lazy-server` distributes the code responsibility to multiple classes and requires to be careful in future development of QuPath so that it does not end up requesting for the server when it is not really useful. In the latter case it is due to the solution having a silent behaviour. However, since everything is managed internally in the lazy approach, in the future it may create less problems surging from punching holes in QuPath's interface. Ultimately, I think your solution is better maintainable-wise, granted that a few things are managed:; * have the retrieval of the image server be loud in logs. Perhaps even with some traceback to what portion of code triggered it?; * expose a `getCurrentMetadata()` function to avoid having to do `getServer().getMetadata()`; * check qupath code that requested for the server but may not need it.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1488#issuecomment-2032062846
https://github.com/qupath/qupath/pull/1489#issuecomment-2031984755:297,Availability,avail,available,297,"This approach is much more elegant than #1488, i like it!; However I feel it doesn't exploit all the possible info that can be gathered without reading the image files. Specifically images' metadata for info such as the number of channels and their names or even as well as pixel calibration.; If available, they're available in the `.qpproj` and they're already read when opening the project. Perhaps this could be done by exposing a `getCurrentMetadata()` method, so that it does not require to pass through calling `getServer()`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2031984755
https://github.com/qupath/qupath/pull/1489#issuecomment-2031984755:316,Availability,avail,available,316,"This approach is much more elegant than #1488, i like it!; However I feel it doesn't exploit all the possible info that can be gathered without reading the image files. Specifically images' metadata for info such as the number of channels and their names or even as well as pixel calibration.; If available, they're available in the `.qpproj` and they're already read when opening the project. Perhaps this could be done by exposing a `getCurrentMetadata()` method, so that it does not require to pass through calling `getServer()`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2031984755
https://github.com/qupath/qupath/pull/1489#issuecomment-2266645381:59,Testability,test,test,59,Thank you for the big work on the metadata as well! I will test this PR thoroughly as soon as i can. In the mean time i have a spotted a couple of typos for which i hope i won't pass as annoying if i point them out,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2266645381
https://github.com/qupath/qupath/pull/1489#issuecomment-2266664413:704,Performance,load,loading,704,"Thanks, I've fixed two of the typos but not sure about the other. This is still a draft PR and I'll need to work on it some more. It is a slightly scary change to make since it is so core, and there are (at least) three things I haven't really thought through:; 1. When `ImageServer` metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the `ImageServer` is built... but becomes much more important if the server isn't necessarily built); 2. What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size); 3. How exceptions are handled when lazy loading fails. At the moment, I doubt this PR does the right thing in those cases. I'll mark it was ready to review when I _think_ it's ok - that's probably the better time for thorough testing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2266664413
https://github.com/qupath/qupath/pull/1489#issuecomment-2266664413:890,Testability,test,testing,890,"Thanks, I've fixed two of the typos but not sure about the other. This is still a draft PR and I'll need to work on it some more. It is a slightly scary change to make since it is so core, and there are (at least) three things I haven't really thought through:; 1. When `ImageServer` metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the `ImageServer` is built... but becomes much more important if the server isn't necessarily built); 2. What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size); 3. How exceptions are handled when lazy loading fails. At the moment, I doubt this PR does the right thing in those cases. I'll mark it was ready to review when I _think_ it's ok - that's probably the better time for thorough testing.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2266664413
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:808,Deployability,update,updateServerMetadata,808,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:867,Deployability,update,update,867,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:416,Performance,load,load,416,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:570,Performance,load,loads,570,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:849,Performance,load,load,849,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:1013,Performance,load,loading,1013,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:597,Safety,avoid,avoids,597,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:889,Safety,Avoid,Avoid,889,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629:499,Security,access,accesses,499,"> It is a slightly scary change to make since it is so core. Yes, i get it. It's better being cautious here!. > When ImageServer metadata is written in a project and when it isn't (I see it missing sometimes, which has previously been irrelevant since it's generated when the ImageServer is built... but becomes much more important if the server isn't necessarily built). what I would say that in that case it would load the server, read the metadata and write them in the `.qpproj` file for future accesses. I wouldn't assure that `ImageData.getServerMetadata()` never loads the image server. It avoids it as long as it is possible, otherwise it will. > What happens when a script changes the metadata, but the server itself hasn't been read (e.g. setting channel names or pixel size). Again, if `ImageData.updateServerMetadata()` i would actually load the server()+update `qpproj` file. Avoid doing it lazily, as that would easily lead to unexpected states for the users. > How exceptions are handled when lazy loading fails. What's wrong in behaving the same as when an exception occurs while creating an `ImageServer`?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2271091629
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:699,Availability,avail,available,699,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:745,Availability,avail,available,745,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:486,Deployability,update,updated,486,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:122,Performance,load,loaded,122,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:194,Performance,load,loaded,194,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:654,Performance,load,loaded,654,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:936,Performance,load,loaded,936,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:1641,Performance,load,loading,1641,"ith an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedded within the project. Although it should also usually happen in practice anyway, just through working with the images for some kind of annotation or analysis, so the other solution is... just don't worry about it. If this works properly, you should end up with lazy-loading a lot of the time - just not necessarily quite as often as you'd want.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:2268,Performance,load,loading,2268,"ith an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedded within the project. Although it should also usually happen in practice anyway, just through working with the images for some kind of annotation or analysis, so the other solution is... just don't worry about it. If this works properly, you should end up with lazy-loading a lot of the time - just not necessarily quite as often as you'd want.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:1072,Safety,avoid,avoid,1072,"e testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedded within the project. Although it should also usually happen in ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:68,Testability,test,testing,68,"I've flagged this as ready for review now. It definitely needs more testing. As described by @carlocastoldi the server is loaded whenever *any* change to the metadata is made. The server can be loaded more often might be expected, sometimes for subtle, hard-to-address reasons. Some relevant facts:; * `ImageServerMetadata` *isn't usually saved with an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedd",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037:1552,Usability,simpl,simple-looking,1552,"ith an image when it is first added to a project*. This only happens the first time the data file is saved.; * The `ImageServerMetadata` is updated as soon as an image is opened in a project to ensure that the name specified in the project matches that in the server metadata. This triggers the server to be loaded if; * The `ImageServerMetadata` isn't available, or; * The `ImageServerMetadata` is available, but contains the wrong name (e.g. the name was changed in a project, but then the data file wasn't saved afterwards); * *Run for project* will always force the `ImageServer` to be loaded, because it will always save the data - and this act of saving requires the `ImageServer`. So you can only get advantages if you avoid *Run for project*, e.g. by using *Run for project (without save)* instead.; * We can't rely on not saving if there have been no changes, because the script editor now automatically fires a hierarchy change after completion. This means QuPath *always* thinks that the script may have changed the `ImageData`, so `ImageData.isChanged()` returns true. We didn't used to do this, but then we had to keep telling users to add `fireHierarchyUpdate()` at the end of many otherwise simple-looking scripts, and that was a pain for everyone. This basically means that lazy-loading only works if the data for an image has been saved at least once, and the user hasn't messed around too much with image names within their project. The 'easy' way to trigger an image to be saved once is to do a 'Run for project' script - even if the script doesn't do anything. This should be enough to prompt the `ImageServerMetadata` to become embedded within the project. Although it should also usually happen in practice anyway, just through working with the images for some kind of annotation or analysis, so the other solution is... just don't worry about it. If this works properly, you should end up with lazy-loading a lot of the time - just not necessarily quite as often as you'd want.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2273821037
https://github.com/qupath/qupath/pull/1489#issuecomment-2275920618:23,Safety,avoid,avoid,23,"I'll merge this now to avoid having too many conflicts to resolve, and to have more time to try it in combination with all the other v0.6.0 changes. I'd still be grateful for anyone interested to test this!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2275920618
https://github.com/qupath/qupath/pull/1489#issuecomment-2275920618:196,Testability,test,test,196,"I'll merge this now to avoid having too many conflicts to resolve, and to have more time to try it in combination with all the other v0.6.0 changes. I'd still be grateful for anyone interested to test this!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2275920618
https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548:482,Performance,load,loaded,482,"Thank you, this was pretty fast!. Accordingly to my testing it works all okay and pretty safe. I think the idea to write as soon as something is being modified is worth it. The fact that now it requires that the images are opened & modified at least once is not a problem. I think we can put up with it for the time being and leave it for some future adjustment, if needed. However i think you got something off: it should be possible to write the imagedata if the server was never loaded. The problem is not that the image name is always written to the ImageData's file, as that does not make the metadata different from the old ones when the name was kept as is.; The issue is that, when writing the `.qpdata`, it wants to know the ImageServer unique identifier and summary. Both of these cannot have changed without the server being loaded first (the unique identifier possibly yes if it uses the filepath, but in that case moving the image folder after the ImageData was saved would have the same result).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548
https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548:836,Performance,load,loaded,836,"Thank you, this was pretty fast!. Accordingly to my testing it works all okay and pretty safe. I think the idea to write as soon as something is being modified is worth it. The fact that now it requires that the images are opened & modified at least once is not a problem. I think we can put up with it for the time being and leave it for some future adjustment, if needed. However i think you got something off: it should be possible to write the imagedata if the server was never loaded. The problem is not that the image name is always written to the ImageData's file, as that does not make the metadata different from the old ones when the name was kept as is.; The issue is that, when writing the `.qpdata`, it wants to know the ImageServer unique identifier and summary. Both of these cannot have changed without the server being loaded first (the unique identifier possibly yes if it uses the filepath, but in that case moving the image folder after the ImageData was saved would have the same result).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548
https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548:89,Safety,safe,safe,89,"Thank you, this was pretty fast!. Accordingly to my testing it works all okay and pretty safe. I think the idea to write as soon as something is being modified is worth it. The fact that now it requires that the images are opened & modified at least once is not a problem. I think we can put up with it for the time being and leave it for some future adjustment, if needed. However i think you got something off: it should be possible to write the imagedata if the server was never loaded. The problem is not that the image name is always written to the ImageData's file, as that does not make the metadata different from the old ones when the name was kept as is.; The issue is that, when writing the `.qpdata`, it wants to know the ImageServer unique identifier and summary. Both of these cannot have changed without the server being loaded first (the unique identifier possibly yes if it uses the filepath, but in that case moving the image folder after the ImageData was saved would have the same result).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548
https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548:52,Testability,test,testing,52,"Thank you, this was pretty fast!. Accordingly to my testing it works all okay and pretty safe. I think the idea to write as soon as something is being modified is worth it. The fact that now it requires that the images are opened & modified at least once is not a problem. I think we can put up with it for the time being and leave it for some future adjustment, if needed. However i think you got something off: it should be possible to write the imagedata if the server was never loaded. The problem is not that the image name is always written to the ImageData's file, as that does not make the metadata different from the old ones when the name was kept as is.; The issue is that, when writing the `.qpdata`, it wants to know the ImageServer unique identifier and summary. Both of these cannot have changed without the server being loaded first (the unique identifier possibly yes if it uses the filepath, but in that case moving the image folder after the ImageData was saved would have the same result).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2276459548
https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823:173,Availability,avail,available,173,"One more thing: should we expose the builders in `qupath.lib.images.servers.ImageServers.*` so that you can test what kind of `ImageServer` is being used, if the builder is available?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823
https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823:26,Security,expose,expose,26,"One more thing: should we expose the builders in `qupath.lib.images.servers.ImageServers.*` so that you can test what kind of `ImageServer` is being used, if the builder is available?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823
https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823:108,Testability,test,test,108,"One more thing: should we expose the builders in `qupath.lib.images.servers.ImageServers.*` so that you can test what kind of `ImageServer` is being used, if the builder is available?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2278093823
https://github.com/qupath/qupath/pull/1489#issuecomment-2278151773:15,Security,expose,expose,15,"I'd rather not expose more than necessary. What would it solve?. (I seem to have introduced a big bug in `PathIO`, so currently working on this... v0.6.0-SNAPSHOT isn't in a very usable state right now)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2278151773
https://github.com/qupath/qupath/pull/1489#issuecomment-2278151773:179,Usability,usab,usable,179,"I'd rather not expose more than necessary. What would it solve?. (I seem to have introduced a big bug in `PathIO`, so currently working on this... v0.6.0-SNAPSHOT isn't in a very usable state right now)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2278151773
https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661:36,Integrability,message,message,36,"I am sorry, I must have missed this message!. In my case, I was thinking to help extensions I use to take full advantage of this new feature. Specifically, I was looking into [`qupath-extension-abba`](), but the only thing stopping me from being able to port it is that [it checks](https://github.com/BIOP/qupath-extension-abba/blob/main/src/main/java/qupath/ext/biop/abba/AtlasImporter.java#L203) whether the current image is rotated or not. If it is, it applies a transformation to the imported ROIs. I guess interrogating specific image server is unfeasible (i.e. using `rotated_server.getRotation()`), however we could perhaps avoid requesting for the server if it can't be interrogated. Hence why I was thinking to expose the builders: extensions/scripts can decide whether to make the server concrete based on their implementation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661
https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661:631,Safety,avoid,avoid,631,"I am sorry, I must have missed this message!. In my case, I was thinking to help extensions I use to take full advantage of this new feature. Specifically, I was looking into [`qupath-extension-abba`](), but the only thing stopping me from being able to port it is that [it checks](https://github.com/BIOP/qupath-extension-abba/blob/main/src/main/java/qupath/ext/biop/abba/AtlasImporter.java#L203) whether the current image is rotated or not. If it is, it applies a transformation to the imported ROIs. I guess interrogating specific image server is unfeasible (i.e. using `rotated_server.getRotation()`), however we could perhaps avoid requesting for the server if it can't be interrogated. Hence why I was thinking to expose the builders: extensions/scripts can decide whether to make the server concrete based on their implementation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661
https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661:720,Security,expose,expose,720,"I am sorry, I must have missed this message!. In my case, I was thinking to help extensions I use to take full advantage of this new feature. Specifically, I was looking into [`qupath-extension-abba`](), but the only thing stopping me from being able to port it is that [it checks](https://github.com/BIOP/qupath-extension-abba/blob/main/src/main/java/qupath/ext/biop/abba/AtlasImporter.java#L203) whether the current image is rotated or not. If it is, it applies a transformation to the imported ROIs. I guess interrogating specific image server is unfeasible (i.e. using `rotated_server.getRotation()`), however we could perhaps avoid requesting for the server if it can't be interrogated. Hence why I was thinking to expose the builders: extensions/scripts can decide whether to make the server concrete based on their implementation.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1489#issuecomment-2396452661
https://github.com/qupath/qupath/issues/1491#issuecomment-2032305111:118,Performance,load,loading-issue-when-opening-tiff-images,118,This seems to be a duplicate of https://forum.image.sc/t/qupath-viewer-hangs-on-ubuntu-22-04-due-to-openslide-library-loading-issue-when-opening-tiff-images/94325,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1491#issuecomment-2032305111
https://github.com/qupath/qupath/pull/1492#issuecomment-2048024326:45,Testability,assert,assert,45,"Oh, i guess this choice was done to uniquely assert in which of two adjacent tiles a point is contained?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048024326
https://github.com/qupath/qupath/pull/1492#issuecomment-2048093170:132,Testability,log,logic,132,"Yes, QuPath originally used Java `Shape` for some of the more complex operations (especially Java's `Area` class). Now much of that logic has been replaced by Java Topology Suite, which potentially has a different interpretation of insideness - so there could be an inconsistency if you have a `RectangleROI` vs. a `PolygonROI` or `GeometryROI` that happens to also represent a rectangle. Although from a quick check, it looks like the behavior does seem to generally be consistent:; ```groovy; def roi = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane()); println roi.contains(1, 1). def polygon = ROIs.createPolygonROI(roi.getAllPoints(), roi.getImagePlane()); println polygon.contains(1, 1). def geometry = GeometryTools.geometryToROI(roi.getGeometry(), roi.getImagePlane()); println geometry.contains(1, 1) // Because it actually returns a RectangleROI, not a GeometryROI; ```; I see `false` in all cases there, which fits with my attempts to preserve the same behavior with updating the ROIs to use JTS. But I see `true` with; ```groovy; def geometry2 = new qupath.lib.roi.GeometryROI(roi.getGeometry(), roi.getImagePlane()); println geometry2.contains(1, 1); ```; because it's using JTS logic entirely. However, that is actually calling a package private method - shouldn't happen in normal use, because usually you'd rely upon `GeometryTools.geometryToROI()` and this returns a `RectangleROI` where possible.. I'm a bit apprehensive about changing the behavior, since it has been preserved across versions and is consistent with at least *some* definition of 'contains'. If you meed something more rigorously defined, you should use `roi.getGeometry()` and then you can use the methods of [`Geometry`](https://locationtech.github.io/jts/javadoc/) and the full [DE-9IM Intersection Matrix](https://en.wikipedia.org/wiki/DE-9IM).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048093170
https://github.com/qupath/qupath/pull/1492#issuecomment-2048093170:1205,Testability,log,logic,1205,"Yes, QuPath originally used Java `Shape` for some of the more complex operations (especially Java's `Area` class). Now much of that logic has been replaced by Java Topology Suite, which potentially has a different interpretation of insideness - so there could be an inconsistency if you have a `RectangleROI` vs. a `PolygonROI` or `GeometryROI` that happens to also represent a rectangle. Although from a quick check, it looks like the behavior does seem to generally be consistent:; ```groovy; def roi = ROIs.createRectangleROI(0,0,1,1, ImagePlane.getDefaultPlane()); println roi.contains(1, 1). def polygon = ROIs.createPolygonROI(roi.getAllPoints(), roi.getImagePlane()); println polygon.contains(1, 1). def geometry = GeometryTools.geometryToROI(roi.getGeometry(), roi.getImagePlane()); println geometry.contains(1, 1) // Because it actually returns a RectangleROI, not a GeometryROI; ```; I see `false` in all cases there, which fits with my attempts to preserve the same behavior with updating the ROIs to use JTS. But I see `true` with; ```groovy; def geometry2 = new qupath.lib.roi.GeometryROI(roi.getGeometry(), roi.getImagePlane()); println geometry2.contains(1, 1); ```; because it's using JTS logic entirely. However, that is actually calling a package private method - shouldn't happen in normal use, because usually you'd rely upon `GeometryTools.geometryToROI()` and this returns a `RectangleROI` where possible.. I'm a bit apprehensive about changing the behavior, since it has been preserved across versions and is consistent with at least *some* definition of 'contains'. If you meed something more rigorously defined, you should use `roi.getGeometry()` and then you can use the methods of [`Geometry`](https://locationtech.github.io/jts/javadoc/) and the full [DE-9IM Intersection Matrix](https://en.wikipedia.org/wiki/DE-9IM).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048093170
https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154:688,Testability,test,testing,688,"That is a very interesting read. I am indeed reading about the DE-9IM interesection matrix, thank you for the detailed reply.; Initially I was rather afraid of an inconsistent behaviour of which I really didn't understand much. I wouldn't worry about the private method, tho. I'm closing this PR. However, now it's a lot more clear but I guess the `ROI` documentation could be a little more explicit on its behaviour. Would you accept a PR that simply states that the what the code assumes as ""inside""? I know you said that _potentially_ it has a different interpretation of insideness, but perhaps having a general rule is better than nothing. Just so that you know: I was interested in testing if a point outside of a ROI's bounding box is **always** outside of the ROI itself. Where the bounding box is defined as:; ```java; new Rectangle2D.Double(roi.getBoundsX(), roi.getBoundsY(), roi.getBoundsWidth(), roi.getBoundsHeight()); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154
https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154:326,Usability,clear,clear,326,"That is a very interesting read. I am indeed reading about the DE-9IM interesection matrix, thank you for the detailed reply.; Initially I was rather afraid of an inconsistent behaviour of which I really didn't understand much. I wouldn't worry about the private method, tho. I'm closing this PR. However, now it's a lot more clear but I guess the `ROI` documentation could be a little more explicit on its behaviour. Would you accept a PR that simply states that the what the code assumes as ""inside""? I know you said that _potentially_ it has a different interpretation of insideness, but perhaps having a general rule is better than nothing. Just so that you know: I was interested in testing if a point outside of a ROI's bounding box is **always** outside of the ROI itself. Where the bounding box is defined as:; ```java; new Rectangle2D.Double(roi.getBoundsX(), roi.getBoundsY(), roi.getBoundsWidth(), roi.getBoundsHeight()); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154
https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154:445,Usability,simpl,simply,445,"That is a very interesting read. I am indeed reading about the DE-9IM interesection matrix, thank you for the detailed reply.; Initially I was rather afraid of an inconsistent behaviour of which I really didn't understand much. I wouldn't worry about the private method, tho. I'm closing this PR. However, now it's a lot more clear but I guess the `ROI` documentation could be a little more explicit on its behaviour. Would you accept a PR that simply states that the what the code assumes as ""inside""? I know you said that _potentially_ it has a different interpretation of insideness, but perhaps having a general rule is better than nothing. Just so that you know: I was interested in testing if a point outside of a ROI's bounding box is **always** outside of the ROI itself. Where the bounding box is defined as:; ```java; new Rectangle2D.Double(roi.getBoundsX(), roi.getBoundsY(), roi.getBoundsWidth(), roi.getBoundsHeight()); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048154154
https://github.com/qupath/qupath/pull/1492#issuecomment-2048181477:203,Modifiability,rewrite,rewrite,203,"I suspect that JTS's approach is preferable, and the tests here *should* pass - it does seem weird that they don't. We have two QuPath grants - one to maintain the software (leading to v1.0), and one to rewrite large parts (leading to v2.0 within the next few years). My instinct is to keep the current behavior for v1.0, but look to change it in the longer term for v2.0 - along with a more thorough revision of ROIs generally.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048181477
https://github.com/qupath/qupath/pull/1492#issuecomment-2048181477:53,Testability,test,tests,53,"I suspect that JTS's approach is preferable, and the tests here *should* pass - it does seem weird that they don't. We have two QuPath grants - one to maintain the software (leading to v1.0), and one to rewrite large parts (leading to v2.0 within the next few years). My instinct is to keep the current behavior for v1.0, but look to change it in the longer term for v2.0 - along with a more thorough revision of ROIs generally.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048181477
https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578:663,Safety,avoid,avoiding,663,"That's awesome. Thank you!. I will try to implement it with JTS, then.; However the implication is that ""Polygons do not contain their boundary"", correct? Does that mean that if I'm testing if a point `p` is inside the boundary or **on** the boundary, i should check that `JVT.Geometry.covers(p) || JVT.Geometry.intersects(p)`, right?. I'm saying this because of what the DE-9IM article says about the `contains`/`withIn` predicates; > This issue is caused by the final clause of the Contains definition above: ""at least one point of the interior of B lies in the interior of A"". For this case, the predicate Covers has more intuitive semantics (see definition), avoiding boundary considerations.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578
https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578:182,Testability,test,testing,182,"That's awesome. Thank you!. I will try to implement it with JTS, then.; However the implication is that ""Polygons do not contain their boundary"", correct? Does that mean that if I'm testing if a point `p` is inside the boundary or **on** the boundary, i should check that `JVT.Geometry.covers(p) || JVT.Geometry.intersects(p)`, right?. I'm saying this because of what the DE-9IM article says about the `contains`/`withIn` predicates; > This issue is caused by the final clause of the Contains definition above: ""at least one point of the interior of B lies in the interior of A"". For this case, the predicate Covers has more intuitive semantics (see definition), avoiding boundary considerations.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578
https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578:625,Usability,intuit,intuitive,625,"That's awesome. Thank you!. I will try to implement it with JTS, then.; However the implication is that ""Polygons do not contain their boundary"", correct? Does that mean that if I'm testing if a point `p` is inside the boundary or **on** the boundary, i should check that `JVT.Geometry.covers(p) || JVT.Geometry.intersects(p)`, right?. I'm saying this because of what the DE-9IM article says about the `contains`/`withIn` predicates; > This issue is caused by the final clause of the Contains definition above: ""at least one point of the interior of B lies in the interior of A"". For this case, the predicate Covers has more intuitive semantics (see definition), avoiding boundary considerations.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048226578
https://github.com/qupath/qupath/pull/1492#issuecomment-2048272597:75,Usability,intuit,intuitive,75,"I find the ROI-based (i.e. non-Geometry-based) rules confusing and counter-intuitive, because (0,0) would be inside and (1,1) outside in the above example (including with a `PolygonROI`, not just a `RectangleROI`). I don't have a good answer to your question - my guess would have been that `covers` is sufficient, based on https://javadoc.io/doc/org.locationtech.jts/jts-core/latest/org/locationtech/jts/geom/Geometry.html#covers-org.locationtech.jts.geom.Geometry-; I'm still learning about this stuff though (mostly through getting it wrong).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048272597
https://github.com/qupath/qupath/pull/1492#issuecomment-2048272597:478,Usability,learn,learning,478,"I find the ROI-based (i.e. non-Geometry-based) rules confusing and counter-intuitive, because (0,0) would be inside and (1,1) outside in the above example (including with a `PolygonROI`, not just a `RectangleROI`). I don't have a good answer to your question - my guess would have been that `covers` is sufficient, based on https://javadoc.io/doc/org.locationtech.jts/jts-core/latest/org/locationtech/jts/geom/Geometry.html#covers-org.locationtech.jts.geom.Geometry-; I'm still learning about this stuff though (mostly through getting it wrong).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048272597
https://github.com/qupath/qupath/pull/1492#issuecomment-2048404518:38,Usability,learn,learnt,38,Thank you a lot for your time. I just learnt I still have lots to learn.; Looking forward to seeing how v2.0 implementation ^^,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048404518
https://github.com/qupath/qupath/pull/1492#issuecomment-2048404518:66,Usability,learn,learn,66,Thank you a lot for your time. I just learnt I still have lots to learn.; Looking forward to seeing how v2.0 implementation ^^,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1492#issuecomment-2048404518
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:689,Deployability,install,installCommand,689,"The reason I chose the more general 'Object classification' is thinking about the future. Even though the existing commends mostly focus on object classification for detections only, future commands might not be. And extensions might add commands to classify in a different way. For example, here's a script that adds a basic command to classify annotations based on the shape of the ROI:; ```groovy; import javafx.application.Platform; import javafx.scene.control.MenuItem; import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.dialogs.Dialogs; import qupath.lib.objects.PathObject; import qupath.lib.objects.classes.PathClass. commandName = ""Classify annotations"". Platform.runLater {; installCommand(); Dialogs.showInfoNotification(commandName, ""Command installed!""); }. def installCommand() {; def menu = QuPathGUI.getInstance().getMenu(""Classify > Object classification"", false); def mi = menu.getItems(); .stream(); .filter(m -> commandName.equals(m.getText())); .findAny().orElse(null); if (mi == null) {; mi = new MenuItem(commandName); menu.getItems().add(mi); }; mi.setOnAction {e -> classifyAnnotations()}; }. def classifyAnnotations() {; def imageData = QuPathGUI.getInstance().getImageData(); def annotations = imageData == null ? [] : imageData.getHierarchy().getAnnotationObjects(); if (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either cat",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:758,Deployability,install,installed,758,"The reason I chose the more general 'Object classification' is thinking about the future. Even though the existing commends mostly focus on object classification for detections only, future commands might not be. And extensions might add commands to classify in a different way. For example, here's a script that adds a basic command to classify annotations based on the shape of the ROI:; ```groovy; import javafx.application.Platform; import javafx.scene.control.MenuItem; import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.dialogs.Dialogs; import qupath.lib.objects.PathObject; import qupath.lib.objects.classes.PathClass. commandName = ""Classify annotations"". Platform.runLater {; installCommand(); Dialogs.showInfoNotification(commandName, ""Command installed!""); }. def installCommand() {; def menu = QuPathGUI.getInstance().getMenu(""Classify > Object classification"", false); def mi = menu.getItems(); .stream(); .filter(m -> commandName.equals(m.getText())); .findAny().orElse(null); if (mi == null) {; mi = new MenuItem(commandName); menu.getItems().add(mi); }; mi.setOnAction {e -> classifyAnnotations()}; }. def classifyAnnotations() {; def imageData = QuPathGUI.getInstance().getImageData(); def annotations = imageData == null ? [] : imageData.getHierarchy().getAnnotationObjects(); if (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either cat",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:779,Deployability,install,installCommand,779,"The reason I chose the more general 'Object classification' is thinking about the future. Even though the existing commends mostly focus on object classification for detections only, future commands might not be. And extensions might add commands to classify in a different way. For example, here's a script that adds a basic command to classify annotations based on the shape of the ROI:; ```groovy; import javafx.application.Platform; import javafx.scene.control.MenuItem; import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.dialogs.Dialogs; import qupath.lib.objects.PathObject; import qupath.lib.objects.classes.PathClass. commandName = ""Classify annotations"". Platform.runLater {; installCommand(); Dialogs.showInfoNotification(commandName, ""Command installed!""); }. def installCommand() {; def menu = QuPathGUI.getInstance().getMenu(""Classify > Object classification"", false); def mi = menu.getItems(); .stream(); .filter(m -> commandName.equals(m.getText())); .findAny().orElse(null); if (mi == null) {; mi = new MenuItem(commandName); menu.getItems().add(mi); }; mi.setOnAction {e -> classifyAnnotations()}; }. def classifyAnnotations() {; def imageData = QuPathGUI.getInstance().getImageData(); def annotations = imageData == null ? [] : imageData.getHierarchy().getAnnotationObjects(); if (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either cat",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:2804,Integrability,interface,interface,2804,"otation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probably don't exist yet, but we try to design the software thinking far enough into the future so that they can be added... For that reason, if the fact that most commands under *Object classification* currently only work for detections is confusing, I think we need some other way to resolve that confusion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:3144,Integrability,interface,interface,3144,"otation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probably don't exist yet, but we try to design the software thinking far enough into the future so that they can be added... For that reason, if the fact that most commands under *Object classification* currently only work for detections is confusing, I think we need some other way to resolve that confusion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:166,Safety,detect,detections,166,"The reason I chose the more general 'Object classification' is thinking about the future. Even though the existing commends mostly focus on object classification for detections only, future commands might not be. And extensions might add commands to classify in a different way. For example, here's a script that adds a basic command to classify annotations based on the shape of the ROI:; ```groovy; import javafx.application.Platform; import javafx.scene.control.MenuItem; import qupath.lib.gui.QuPathGUI; import qupath.lib.gui.dialogs.Dialogs; import qupath.lib.objects.PathObject; import qupath.lib.objects.classes.PathClass. commandName = ""Classify annotations"". Platform.runLater {; installCommand(); Dialogs.showInfoNotification(commandName, ""Command installed!""); }. def installCommand() {; def menu = QuPathGUI.getInstance().getMenu(""Classify > Object classification"", false); def mi = menu.getItems(); .stream(); .filter(m -> commandName.equals(m.getText())); .findAny().orElse(null); if (mi == null) {; mi = new MenuItem(commandName); menu.getItems().add(mi); }; mi.setOnAction {e -> classifyAnnotations()}; }. def classifyAnnotations() {; def imageData = QuPathGUI.getInstance().getImageData(); def annotations = imageData == null ? [] : imageData.getHierarchy().getAnnotationObjects(); if (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either cat",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:1880,Safety,Detect,Detection,1880,"alse); def mi = menu.getItems(); .stream(); .filter(m -> commandName.equals(m.getText())); .findAny().orElse(null); if (mi == null) {; mi = new MenuItem(commandName); menu.getItems().add(mi); }; mi.setOnAction {e -> classifyAnnotations()}; }. def classifyAnnotations() {; def imageData = QuPathGUI.getInstance().getImageData(); def annotations = imageData == null ? [] : imageData.getHierarchy().getAnnotationObjects(); if (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, w",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:2297,Safety,detect,detections,2297," (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probabl",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:2323,Safety,detect,detection,2323," (annotations.isEmpty()) {; Dialogs.showWarningNotification(""Classify annotations"", ""No annotations found!""); return; }; for (def annotation in annotations); classifySingleAnnotation(annotation); imageData.getHierarchy().fireObjectClassificationsChangedEvent(this, annotations); }. def classifySingleAnnotation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probabl",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:3522,Safety,detect,detections,3522,"otation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probably don't exist yet, but we try to design the software thinking far enough into the future so that they can be added... For that reason, if the fact that most commands under *Object classification* currently only work for detections is confusing, I think we need some other way to resolve that confusion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110:2913,Usability,learn,learning,2913,"otation(PathObject pathObject) {; def roiName = pathObject.getROI()?.getRoiName(); pathObject.setPathClass(PathClass.getInstance(roiName)); }; ```. I think it makes sense for such classifiers to be added to a single *Object classification* submenu, rather than split between *Detection* and *Annotation* (also, there might one day be a need to classify *TMA cores*, which don't fit into either category). Also, the top of the *Train object classifier* dialog makes it possible to select different types of objects to classify. <img width=""418"" alt=""Train object classifier"" src=""https://github.com/qupath/qupath/assets/4690904/d6977ca8-a018-4d33-bd7c-f31eed611749"">. Admittedly, these are all detections or subtypes of detection... but that's because I couldn't think of a good workflow to use them for annotations (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). The internal representation of the object classifier is capable of specifying the type of object it should be applied to, even though we have no easy way to interactively create annotation classifiers through the user interface, or examples where that is actually used. Perhaps more usefully, we plan to enable the use of deep learning models for classification - and these don't have the complication of needing annotations for training. Much of the code to enable this has already been written, but we need to figure out how best to link it up to the user interface and provide meaningful models for the feature to be useful. When it *is* useful, I expect it to become *very* useful. QuPath's best features probably don't exist yet, but we try to design the software thinking far enough into the future so that they can be added... For that reason, if the fact that most commands under *Object classification* currently only work for detections is confusing, I think we need some other way to resolve that confusion.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2075386110
https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553:486,Availability,error,error,486,"> (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). I'm not actually, sadly I don't get the chance to work in QuPath much as I mostly work with 3D images. This came about because of this post: https://forum.image.sc/t/using-annotations-imported-into-qupath/95333. It seems the user imported ROIs as annotations instead of detections. Ultimately probably more of a user error based on the current design of the system, but I just do feel it is confusing that everything is given the generic label of ""object"" (both the submenu and the filter) when it only works on detections. Perhaps another submenu within the Object classification menu specifically for Detection classification commands? I know that currently that would mean a single submenu item in the Object classification menu, but it would add clarity to the current state of things, and I would imagine that at least some of these commands will be restricted to detections only well into the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553
https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553:439,Safety,detect,detections,439,"> (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). I'm not actually, sadly I don't get the chance to work in QuPath much as I mostly work with 3D images. This came about because of this post: https://forum.image.sc/t/using-annotations-imported-into-qupath/95333. It seems the user imported ROIs as annotations instead of detections. Ultimately probably more of a user error based on the current design of the system, but I just do feel it is confusing that everything is given the generic label of ""object"" (both the submenu and the filter) when it only works on detections. Perhaps another submenu within the Object classification menu specifically for Detection classification commands? I know that currently that would mean a single submenu item in the Object classification menu, but it would add clarity to the current state of things, and I would imagine that at least some of these commands will be restricted to detections only well into the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553
https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553:681,Safety,detect,detections,681,"> (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). I'm not actually, sadly I don't get the chance to work in QuPath much as I mostly work with 3D images. This came about because of this post: https://forum.image.sc/t/using-annotations-imported-into-qupath/95333. It seems the user imported ROIs as annotations instead of detections. Ultimately probably more of a user error based on the current design of the system, but I just do feel it is confusing that everything is given the generic label of ""object"" (both the submenu and the filter) when it only works on detections. Perhaps another submenu within the Object classification menu specifically for Detection classification commands? I know that currently that would mean a single submenu item in the Object classification menu, but it would add clarity to the current state of things, and I would imagine that at least some of these commands will be restricted to detections only well into the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553
https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553:772,Safety,Detect,Detection,772,"> (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). I'm not actually, sadly I don't get the chance to work in QuPath much as I mostly work with 3D images. This came about because of this post: https://forum.image.sc/t/using-annotations-imported-into-qupath/95333. It seems the user imported ROIs as annotations instead of detections. Ultimately probably more of a user error based on the current design of the system, but I just do feel it is confusing that everything is given the generic label of ""object"" (both the submenu and the filter) when it only works on detections. Perhaps another submenu within the Object classification menu specifically for Detection classification commands? I know that currently that would mean a single submenu item in the Object classification menu, but it would add clarity to the current state of things, and I would imagine that at least some of these commands will be restricted to detections only well into the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553
https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553:1038,Safety,detect,detections,1038,"> (since you're using annotations to train the classifier, how should QuPath distinguish between which annotations are for training and which should be classified...?). I'm not actually, sadly I don't get the chance to work in QuPath much as I mostly work with 3D images. This came about because of this post: https://forum.image.sc/t/using-annotations-imported-into-qupath/95333. It seems the user imported ROIs as annotations instead of detections. Ultimately probably more of a user error based on the current design of the system, but I just do feel it is confusing that everything is given the generic label of ""object"" (both the submenu and the filter) when it only works on detections. Perhaps another submenu within the Object classification menu specifically for Detection classification commands? I know that currently that would mean a single submenu item in the Object classification menu, but it would add clarity to the current state of things, and I would imagine that at least some of these commands will be restricted to detections only well into the future.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079438553
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:50,Availability,mainten,maintenance,50,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:712,Deployability,update,update,712,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:571,Energy Efficiency,reduce,reduce,571,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:197,Performance,Load,Load,197,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:255,Safety,detect,detections,255,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:492,Safety,detect,detection,492,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:843,Safety,detect,detection,843,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506:964,Safety,detect,detections,964,"I feel that is likely to cause more confusing and maintenance headaches as the software develops, mostly for the reasons I outlined above. Commands will change and improve. The same command (e.g. *Load object classifier*) might meaningfully only work for detections now, but handle other object types in the future (I think that, in principle, it already *does* support other object types, if you can somehow create and save a classifier that applies to annotations). There had been a *Train detection classifier* in earlier versions, so the renaming in that case was to reduce confusion because there was a transition period during which both commands were maintained in parallel. If we move things, we need to update the documentation - and some of the docs are in the form of videos, so that's not straightforward. And if we push the term 'detection classifier' it will likely confuse *someone* who thinks it isn't relevant to them because they have cells, not detections. I don't think the current arrangement is ideal, but we are always trying to balance the current software with the past, the future, the docs, and a large number of users with very different needs and expectations... and a very small number of developers. Added to that are the people who write extensions, for whom changing menu structures can cause trouble. It is not an easy project to manage.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1501#issuecomment-2079524506
https://github.com/qupath/qupath/pull/1502#issuecomment-2084811597:39,Usability,simpl,simply,39,"Also, the alternative to this PR is to simply make the constructor of `ObjectMerger` public (and, optionally, `sameClassTypePlaneTest`), then this code can live in the extension",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1502#issuecomment-2084811597
https://github.com/qupath/qupath/pull/1504#issuecomment-2082341842:266,Performance,concurren,concurrent,266,"I think the parallelisation makes sense. When moving to a stream, shouldn't we use `filter` *at least* once, rather than rely on `forEach`?. (If looks like `filter` could be used twice and the results added to the `pending` collection - avoiding the need to make it concurrent - but not sure if that's cleaner or not).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1504#issuecomment-2082341842
https://github.com/qupath/qupath/pull/1504#issuecomment-2082341842:237,Safety,avoid,avoiding,237,"I think the parallelisation makes sense. When moving to a stream, shouldn't we use `filter` *at least* once, rather than rely on `forEach`?. (If looks like `filter` could be used twice and the results added to the `pending` collection - avoiding the need to make it concurrent - but not sure if that's cleaner or not).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1504#issuecomment-2082341842
https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683:97,Deployability,release,releases,97,"@alanocallaghan @Rylern @finglis shall we merge this for now, then remember to make non-SNAPSHOT releases before v0.6.0?. Otherwise we need to test things by using `includeBuild` for `qupath-fxtras` and `log-viewer`, or else commit to new releases for them now (but there may be more changes to come).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683
https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683:239,Deployability,release,releases,239,"@alanocallaghan @Rylern @finglis shall we merge this for now, then remember to make non-SNAPSHOT releases before v0.6.0?. Otherwise we need to test things by using `includeBuild` for `qupath-fxtras` and `log-viewer`, or else commit to new releases for them now (but there may be more changes to come).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683
https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683:143,Testability,test,test,143,"@alanocallaghan @Rylern @finglis shall we merge this for now, then remember to make non-SNAPSHOT releases before v0.6.0?. Otherwise we need to test things by using `includeBuild` for `qupath-fxtras` and `log-viewer`, or else commit to new releases for them now (but there may be more changes to come).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683
https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683:204,Testability,log,log-viewer,204,"@alanocallaghan @Rylern @finglis shall we merge this for now, then remember to make non-SNAPSHOT releases before v0.6.0?. Otherwise we need to test things by using `includeBuild` for `qupath-fxtras` and `log-viewer`, or else commit to new releases for them now (but there may be more changes to come).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509#issuecomment-2086262683
https://github.com/qupath/qupath/pull/1509#issuecomment-2087551832:49,Deployability,release,releases,49,"Probs makes sense to allow co-development around releases, so snapshot makes sense to me",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1509#issuecomment-2087551832
https://github.com/qupath/qupath/pull/1513#issuecomment-2088504244:23,Deployability,release,releases,23,Might be an idea to do releases with & without javadocs as I guess many users won't use scripting at all,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2088504244
https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369:46,Availability,down,download,46,"Great! Yes, I think we shouldn't increase the download by too much. My suggestion is to use a command line flag e.g. `-Pdocs=all` to activate this. Possible options:. * `all` - all javadocs, devs building locally may (rarely) want this; * `none` - don't include any javadocs; * `qupath` - jars that include `qupath` as the first element in the name only (should include extensions); * `default` - curated list of jars; I'd say `qupath` + JTS + ImageJ as a starting point. I think the default list should only add ~10MB or so. This also allows the gradle to be simplified and `mergedJavadocs` can be removed as a task (in preparation for a nicer javadoc viewer). **Note:** Currently, I can't build this PR fully with `./gradlew jpackage` because I get either. ```; The specified installation directory '/path/to/qupath/qupath-app/build/install/QuPath-0.6.0-SNAPSHOT' is neither empty nor does it contain an installation for 'QuPath-0.6.0-SNAPSHOT'.; ```; or (if I delete that directory); ```; Entry lib/qupath-gui-fx-0.6.0-SNAPSHOT.jar is a duplicate but no duplicate handling strategy has been set. Please refer to https://docs.gradle.org/8.7/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:duplicatesStrategy for details.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369
https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369:778,Deployability,install,installation,778,"Great! Yes, I think we shouldn't increase the download by too much. My suggestion is to use a command line flag e.g. `-Pdocs=all` to activate this. Possible options:. * `all` - all javadocs, devs building locally may (rarely) want this; * `none` - don't include any javadocs; * `qupath` - jars that include `qupath` as the first element in the name only (should include extensions); * `default` - curated list of jars; I'd say `qupath` + JTS + ImageJ as a starting point. I think the default list should only add ~10MB or so. This also allows the gradle to be simplified and `mergedJavadocs` can be removed as a task (in preparation for a nicer javadoc viewer). **Note:** Currently, I can't build this PR fully with `./gradlew jpackage` because I get either. ```; The specified installation directory '/path/to/qupath/qupath-app/build/install/QuPath-0.6.0-SNAPSHOT' is neither empty nor does it contain an installation for 'QuPath-0.6.0-SNAPSHOT'.; ```; or (if I delete that directory); ```; Entry lib/qupath-gui-fx-0.6.0-SNAPSHOT.jar is a duplicate but no duplicate handling strategy has been set. Please refer to https://docs.gradle.org/8.7/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:duplicatesStrategy for details.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369
https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369:835,Deployability,install,install,835,"Great! Yes, I think we shouldn't increase the download by too much. My suggestion is to use a command line flag e.g. `-Pdocs=all` to activate this. Possible options:. * `all` - all javadocs, devs building locally may (rarely) want this; * `none` - don't include any javadocs; * `qupath` - jars that include `qupath` as the first element in the name only (should include extensions); * `default` - curated list of jars; I'd say `qupath` + JTS + ImageJ as a starting point. I think the default list should only add ~10MB or so. This also allows the gradle to be simplified and `mergedJavadocs` can be removed as a task (in preparation for a nicer javadoc viewer). **Note:** Currently, I can't build this PR fully with `./gradlew jpackage` because I get either. ```; The specified installation directory '/path/to/qupath/qupath-app/build/install/QuPath-0.6.0-SNAPSHOT' is neither empty nor does it contain an installation for 'QuPath-0.6.0-SNAPSHOT'.; ```; or (if I delete that directory); ```; Entry lib/qupath-gui-fx-0.6.0-SNAPSHOT.jar is a duplicate but no duplicate handling strategy has been set. Please refer to https://docs.gradle.org/8.7/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:duplicatesStrategy for details.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369
https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369:906,Deployability,install,installation,906,"Great! Yes, I think we shouldn't increase the download by too much. My suggestion is to use a command line flag e.g. `-Pdocs=all` to activate this. Possible options:. * `all` - all javadocs, devs building locally may (rarely) want this; * `none` - don't include any javadocs; * `qupath` - jars that include `qupath` as the first element in the name only (should include extensions); * `default` - curated list of jars; I'd say `qupath` + JTS + ImageJ as a starting point. I think the default list should only add ~10MB or so. This also allows the gradle to be simplified and `mergedJavadocs` can be removed as a task (in preparation for a nicer javadoc viewer). **Note:** Currently, I can't build this PR fully with `./gradlew jpackage` because I get either. ```; The specified installation directory '/path/to/qupath/qupath-app/build/install/QuPath-0.6.0-SNAPSHOT' is neither empty nor does it contain an installation for 'QuPath-0.6.0-SNAPSHOT'.; ```; or (if I delete that directory); ```; Entry lib/qupath-gui-fx-0.6.0-SNAPSHOT.jar is a duplicate but no duplicate handling strategy has been set. Please refer to https://docs.gradle.org/8.7/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:duplicatesStrategy for details.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369
https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369:560,Usability,simpl,simplified,560,"Great! Yes, I think we shouldn't increase the download by too much. My suggestion is to use a command line flag e.g. `-Pdocs=all` to activate this. Possible options:. * `all` - all javadocs, devs building locally may (rarely) want this; * `none` - don't include any javadocs; * `qupath` - jars that include `qupath` as the first element in the name only (should include extensions); * `default` - curated list of jars; I'd say `qupath` + JTS + ImageJ as a starting point. I think the default list should only add ~10MB or so. This also allows the gradle to be simplified and `mergedJavadocs` can be removed as a task (in preparation for a nicer javadoc viewer). **Note:** Currently, I can't build this PR fully with `./gradlew jpackage` because I get either. ```; The specified installation directory '/path/to/qupath/qupath-app/build/install/QuPath-0.6.0-SNAPSHOT' is neither empty nor does it contain an installation for 'QuPath-0.6.0-SNAPSHOT'.; ```; or (if I delete that directory); ```; Entry lib/qupath-gui-fx-0.6.0-SNAPSHOT.jar is a duplicate but no duplicate handling strategy has been set. Please refer to https://docs.gradle.org/8.7/dsl/org.gradle.api.tasks.Copy.html#org.gradle.api.tasks.Copy:duplicatesStrategy for details.; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2089590369
https://github.com/qupath/qupath/pull/1513#issuecomment-2092892346:80,Availability,error,error,80,"I added the command line flags and removed the `mergedJavadocs` task. About the error, I wasn't able to reproduce it but I added a duplicate handling strategy that should fix it. Opening the results of the new task with the [javadoc viewer](https://github.com/qupath/javadoc-viewer) seems to work correctly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2092892346
https://github.com/qupath/qupath/pull/1513#issuecomment-2095553840:229,Availability,avail,available,229,"When I build QuPath with `./gradlew jpackage` I'm only getting the *non-core* QuPath jars (`qupath-bioimageio-spec` and `qupath-fxtras`). I also don't see any javadocs if I call `./gradlew run`; it would be nice if they could be available, but it isn't crucial since the normal use will be via `jpackage` builds. Lastly, when I open the Javadoc viewer, I see this:; <img width=""659"" alt=""javadoc-screen"" src=""https://github.com/qupath/qupath/assets/4690904/062bcb1e-5604-41c5-b8a3-3901549cf8f2"">; It resolves if I click on the link: the expected page loads at that point. I'm not sure if these can/should be addressed within the current PR - happy to merge this one now if you like, so that we can switch to the new Javadoc viewer and resolve anything that remains at that point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2095553840
https://github.com/qupath/qupath/pull/1513#issuecomment-2095553840:551,Performance,load,loads,551,"When I build QuPath with `./gradlew jpackage` I'm only getting the *non-core* QuPath jars (`qupath-bioimageio-spec` and `qupath-fxtras`). I also don't see any javadocs if I call `./gradlew run`; it would be nice if they could be available, but it isn't crucial since the normal use will be via `jpackage` builds. Lastly, when I open the Javadoc viewer, I see this:; <img width=""659"" alt=""javadoc-screen"" src=""https://github.com/qupath/qupath/assets/4690904/062bcb1e-5604-41c5-b8a3-3901549cf8f2"">; It resolves if I click on the link: the expected page loads at that point. I'm not sure if these can/should be addressed within the current PR - happy to merge this one now if you like, so that we can switch to the new Javadoc viewer and resolve anything that remains at that point.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2095553840
https://github.com/qupath/qupath/pull/1513#issuecomment-2095709470:331,Availability,avail,available,331,"> When I build QuPath with ./gradlew jpackage I'm only getting the non-core QuPath jars (qupath-bioimageio-spec and qupath-fxtras). Does it also happen with `./gradlew clean jpackage`? Since it's a `Copy` task it's safer to `clean` before. > I also don't see any javadocs if I call ./gradlew run; it would be nice if they could be available, but it isn't crucial since the normal use will be via jpackage builds. Added with last commit. > Lastly, when I open the Javadoc viewer, I see this:. There is an automatic redirection that is not triggered on the old Javadoc viewer. It seems to work on the new Javadoc viewer, can you check if it also works on your side?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2095709470
https://github.com/qupath/qupath/pull/1513#issuecomment-2095709470:215,Safety,safe,safer,215,"> When I build QuPath with ./gradlew jpackage I'm only getting the non-core QuPath jars (qupath-bioimageio-spec and qupath-fxtras). Does it also happen with `./gradlew clean jpackage`? Since it's a `Copy` task it's safer to `clean` before. > I also don't see any javadocs if I call ./gradlew run; it would be nice if they could be available, but it isn't crucial since the normal use will be via jpackage builds. Added with last commit. > Lastly, when I open the Javadoc viewer, I see this:. There is an automatic redirection that is not triggered on the old Javadoc viewer. It seems to work on the new Javadoc viewer, can you check if it also works on your side?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2095709470
https://github.com/qupath/qupath/pull/1513#issuecomment-2096277248:91,Availability,avail,available,91,"> I also don't see any javadocs if I call ./gradlew run; it would be nice if they could be available, but it isn't crucial since the normal use will be via jpackage builds. Actually this increases the startup time by a few seconds each time I run QuPath after changing something, which is quite annoying. Should we remove that feature?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2096277248
https://github.com/qupath/qupath/pull/1513#issuecomment-2096382810:648,Integrability,depend,depends,648,"Would there be a way to associate it with a task that isn't required for `run` (e.g. `assemble` or `processResources`), which puts the docs into the required place - but wouldn't be called for someone calling `./gradlew run` alone?. Not sure if this is an option, but `./gradlew run --dry-run` shows the tasks that will be run. If it's not straightforward, I agree that the delay of a few seconds is more annoying than the benefit for the javadocs - so better not to generate them. Edit: simpler alternative to the above might be to just require a separate task to be called if the javadocs should be generated (but which `jpackage` probably still depends upon, either directly or indirectly).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2096382810
https://github.com/qupath/qupath/pull/1513#issuecomment-2096382810:488,Usability,simpl,simpler,488,"Would there be a way to associate it with a task that isn't required for `run` (e.g. `assemble` or `processResources`), which puts the docs into the required place - but wouldn't be called for someone calling `./gradlew run` alone?. Not sure if this is an option, but `./gradlew run --dry-run` shows the tasks that will be run. If it's not straightforward, I agree that the delay of a few seconds is more annoying than the benefit for the javadocs - so better not to generate them. Edit: simpler alternative to the above might be to just require a separate task to be called if the javadocs should be generated (but which `jpackage` probably still depends upon, either directly or indirectly).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1513#issuecomment-2096382810
https://github.com/qupath/qupath/pull/1517#issuecomment-2096390478:117,Testability,test,test,117,"So edited a few more that appeared clickable when they shouldn't be (as they are not collapsible).; I wasn't able to test `ExportChartPane.java`, `KaplanMeierDisplay.java` as I couldn't find them in the running app but I believe the latter doesn't need adjusting.; Additionally, I wasn't able to launch `TMASummaryViewer.java` in the app (File -> TMA data -> launch TMA data viewer) so added it as a comment. Unsure if this is the case for anyone else? ; Lastly I believe the `simplifyTitledPane` class of `PaneTools.java` seems to not be used at all. Unsure if I'm missing something, if not should it be used or removed?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2096390478
https://github.com/qupath/qupath/pull/1517#issuecomment-2096390478:477,Usability,simpl,simplifyTitledPane,477,"So edited a few more that appeared clickable when they shouldn't be (as they are not collapsible).; I wasn't able to test `ExportChartPane.java`, `KaplanMeierDisplay.java` as I couldn't find them in the running app but I believe the latter doesn't need adjusting.; Additionally, I wasn't able to launch `TMASummaryViewer.java` in the app (File -> TMA data -> launch TMA data viewer) so added it as a comment. Unsure if this is the case for anyone else? ; Lastly I believe the `simplifyTitledPane` class of `PaneTools.java` seems to not be used at all. Unsure if I'm missing something, if not should it be used or removed?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2096390478
https://github.com/qupath/qupath/pull/1517#issuecomment-2096398497:17,Usability,simpl,simplifyTitledPane,17,That version of `simplifyTitledPane` was only removed/deprecated a few months ago so I'd be inclined to let it linger until 1.0 at least https://github.com/qupath/qupath/commit/a728924ca0b54f0070801dd3f2d6bbd700bf60a9,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2096398497
https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919:597,Performance,load,load,597,"If I understand correctly, this PR is to make the top title change on hover but *not* the bottom one - because the top one can be expanded/collapsed, but the bottom one can't. https://github.com/qupath/qupath/assets/4690904/d115720b-3ace-41b2-b7e7-017cb21cc4c7. tbh I'd never noticed this or seen it as problematic. If you think it needs a fix, then should it not go into `qupath-fxtras`? This is the new home to [`simplifyTitledPane`](https://github.com/qupath/qupath-fxtras/blob/4a88b9b427ae6c9a17c33702c06f0c536cad6915/src/main/java/qupath/fx/utils/FXUtils.java#L550)... but then you'd need to load an external .css (like with the simplify method), e.g.; ```java; public void makeNonCollapsible(TitledPane pane) {; pane.setCollapsible(false);; // Whatever other styling is needed here; }; ```. Hard-coding a reference to the CSS class feels a bit brittle to me, and is tied very much to QuPath in a way that is unusable elsewhere. And I imagine we'll end up with inconsistencies as we'll forget / extension writers won't know to add this style class... which to me seems potentially worse. You could also change `main.css` to avoid any change on hover at all, but personally I think it looks quite nice and helps titles stand out. Was there any particular user complaint or confusion caused by the default JavaFX approach of slightly changing the behavior on hover, regardless of the 'collapsible' status?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919
https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919:1129,Safety,avoid,avoid,1129,"If I understand correctly, this PR is to make the top title change on hover but *not* the bottom one - because the top one can be expanded/collapsed, but the bottom one can't. https://github.com/qupath/qupath/assets/4690904/d115720b-3ace-41b2-b7e7-017cb21cc4c7. tbh I'd never noticed this or seen it as problematic. If you think it needs a fix, then should it not go into `qupath-fxtras`? This is the new home to [`simplifyTitledPane`](https://github.com/qupath/qupath-fxtras/blob/4a88b9b427ae6c9a17c33702c06f0c536cad6915/src/main/java/qupath/fx/utils/FXUtils.java#L550)... but then you'd need to load an external .css (like with the simplify method), e.g.; ```java; public void makeNonCollapsible(TitledPane pane) {; pane.setCollapsible(false);; // Whatever other styling is needed here; }; ```. Hard-coding a reference to the CSS class feels a bit brittle to me, and is tied very much to QuPath in a way that is unusable elsewhere. And I imagine we'll end up with inconsistencies as we'll forget / extension writers won't know to add this style class... which to me seems potentially worse. You could also change `main.css` to avoid any change on hover at all, but personally I think it looks quite nice and helps titles stand out. Was there any particular user complaint or confusion caused by the default JavaFX approach of slightly changing the behavior on hover, regardless of the 'collapsible' status?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919
https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919:415,Usability,simpl,simplifyTitledPane,415,"If I understand correctly, this PR is to make the top title change on hover but *not* the bottom one - because the top one can be expanded/collapsed, but the bottom one can't. https://github.com/qupath/qupath/assets/4690904/d115720b-3ace-41b2-b7e7-017cb21cc4c7. tbh I'd never noticed this or seen it as problematic. If you think it needs a fix, then should it not go into `qupath-fxtras`? This is the new home to [`simplifyTitledPane`](https://github.com/qupath/qupath-fxtras/blob/4a88b9b427ae6c9a17c33702c06f0c536cad6915/src/main/java/qupath/fx/utils/FXUtils.java#L550)... but then you'd need to load an external .css (like with the simplify method), e.g.; ```java; public void makeNonCollapsible(TitledPane pane) {; pane.setCollapsible(false);; // Whatever other styling is needed here; }; ```. Hard-coding a reference to the CSS class feels a bit brittle to me, and is tied very much to QuPath in a way that is unusable elsewhere. And I imagine we'll end up with inconsistencies as we'll forget / extension writers won't know to add this style class... which to me seems potentially worse. You could also change `main.css` to avoid any change on hover at all, but personally I think it looks quite nice and helps titles stand out. Was there any particular user complaint or confusion caused by the default JavaFX approach of slightly changing the behavior on hover, regardless of the 'collapsible' status?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919
https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919:634,Usability,simpl,simplify,634,"If I understand correctly, this PR is to make the top title change on hover but *not* the bottom one - because the top one can be expanded/collapsed, but the bottom one can't. https://github.com/qupath/qupath/assets/4690904/d115720b-3ace-41b2-b7e7-017cb21cc4c7. tbh I'd never noticed this or seen it as problematic. If you think it needs a fix, then should it not go into `qupath-fxtras`? This is the new home to [`simplifyTitledPane`](https://github.com/qupath/qupath-fxtras/blob/4a88b9b427ae6c9a17c33702c06f0c536cad6915/src/main/java/qupath/fx/utils/FXUtils.java#L550)... but then you'd need to load an external .css (like with the simplify method), e.g.; ```java; public void makeNonCollapsible(TitledPane pane) {; pane.setCollapsible(false);; // Whatever other styling is needed here; }; ```. Hard-coding a reference to the CSS class feels a bit brittle to me, and is tied very much to QuPath in a way that is unusable elsewhere. And I imagine we'll end up with inconsistencies as we'll forget / extension writers won't know to add this style class... which to me seems potentially worse. You could also change `main.css` to avoid any change on hover at all, but personally I think it looks quite nice and helps titles stand out. Was there any particular user complaint or confusion caused by the default JavaFX approach of slightly changing the behavior on hover, regardless of the 'collapsible' status?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2123062919
https://github.com/qupath/qupath/pull/1517#issuecomment-2123069781:221,Safety,avoid,avoid,221,"> tbh I'd never noticed this or seen it as problematic. Fair yeah, it's been bugging me, but I am happy to allow it to continue to bug me if it's not consequential or shared by others. > You could also change main.css to avoid any change on hover at all, but personally I think it looks quite nice and helps titles stand out. It certainly helps for collapsible panes",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1517#issuecomment-2123069781
https://github.com/qupath/qupath/pull/1518#issuecomment-2097819235:376,Availability,avail,available,376,"Excellent, thanks - can confirm that; ```; ./gradlew clean run; ```; doesn't include the javadocs, but; ```; ./gradlew clean getJavadocs run; ```; does. And they are also included with; ```; ./gradlew clean jpackage; ```; Only minor comment is that `getJavadocs` doesn't seem a very gradle-ish task name and isn't so descriptive (use `gradlew tasks` to see all those that are available). What do you think of; ```; assembleJavadocs Copies the Javadoc jars to a directory for access within QuPath; ```; ?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1518#issuecomment-2097819235
https://github.com/qupath/qupath/pull/1518#issuecomment-2097819235:475,Security,access,access,475,"Excellent, thanks - can confirm that; ```; ./gradlew clean run; ```; doesn't include the javadocs, but; ```; ./gradlew clean getJavadocs run; ```; does. And they are also included with; ```; ./gradlew clean jpackage; ```; Only minor comment is that `getJavadocs` doesn't seem a very gradle-ish task name and isn't so descriptive (use `gradlew tasks` to see all those that are available). What do you think of; ```; assembleJavadocs Copies the Javadoc jars to a directory for access within QuPath; ```; ?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1518#issuecomment-2097819235
https://github.com/qupath/qupath/pull/1519#issuecomment-2129386751:74,Testability,log,logic,74,"I only checked that the Javadocs were found when creating a jpackage. The logic to find Javadocs around the executable is present in the javadoc-viewer library, so when running QuPath with Intellij, it searches around the javadoc-viewer library, not around the QuPath executable. I will move this logic from the javadoc-viewer library to QuPath. > (in a serif font that really ought to be sans-serif). I forgot to link the QuPath stylesheet to the `WebView`, I'll also add this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1519#issuecomment-2129386751
https://github.com/qupath/qupath/pull/1519#issuecomment-2129386751:297,Testability,log,logic,297,"I only checked that the Javadocs were found when creating a jpackage. The logic to find Javadocs around the executable is present in the javadoc-viewer library, so when running QuPath with Intellij, it searches around the javadoc-viewer library, not around the QuPath executable. I will move this logic from the javadoc-viewer library to QuPath. > (in a serif font that really ought to be sans-serif). I forgot to link the QuPath stylesheet to the `WebView`, I'll also add this.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1519#issuecomment-2129386751
https://github.com/qupath/qupath/pull/1519#issuecomment-2129621413:26,Deployability,update,updated,26,I fixed the two things. I updated the javadoc-viewer snapshot on maven.scijava.org so Intellij might not directly see it.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1519#issuecomment-2129621413
https://github.com/qupath/qupath/pull/1520#issuecomment-2104104339:107,Modifiability,rewrite,rewrites,107,"Thanks! I've just pushed some changes that I was working on while you were reviewing... since it basically rewrites `createROIs` to make it simpler and less a hack-y adjustment of the original, I think it addresses your last comments.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520#issuecomment-2104104339
https://github.com/qupath/qupath/pull/1520#issuecomment-2104104339:140,Usability,simpl,simpler,140,"Thanks! I've just pushed some changes that I was working on while you were reviewing... since it basically rewrites `createROIs` to make it simpler and less a hack-y adjustment of the original, I think it addresses your last comments.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520#issuecomment-2104104339
https://github.com/qupath/qupath/pull/1520#issuecomment-2104178205:134,Safety,avoid,avoid,134,"Yeah, I didn't come across that myself yet trying a few images, are we using a version of JTS that at least has the exception code to avoid infinite loops?. Aside from style it all looks good and correct to me, but I wouldn't necessarily use that as strong evidence that it is :)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1520#issuecomment-2104178205
https://github.com/qupath/qupath/pull/1524#issuecomment-2117897280:0,Availability,Ping,Pinging,0,"Pinging @petebankhead about the change in the interface as it'll possibly break stuff, if not merge away",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2117897280
https://github.com/qupath/qupath/pull/1524#issuecomment-2117897280:46,Integrability,interface,interface,46,"Pinging @petebankhead about the change in the interface as it'll possibly break stuff, if not merge away",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2117897280
https://github.com/qupath/qupath/pull/1524#issuecomment-2123013964:1041,Integrability,message,message,1041,"If you add a `default` implementation of the new method then nothing should break, but I don't think it really matters here since I'm not aware of anyone being affected by the change. More importantly, the behavior seems a bit unexpected to me. I opened QuPath (no images), opened a script editor, and added text to two editors. Then attempting to quit QuPath results in. <img width=""664"" alt=""Screenshot 2024-05-21 at 17 29 33"" src=""https://github.com/qupath/qupath/assets/4690904/132e58aa-e34e-4bec-9623-072fac532ef5"">. That's fine, but if I choose `Cancel` then the dialog disappears while QuPath remains open. Then if I attempt to quit again, I see. <img width=""664"" alt=""Screenshot 2024-05-21 at 17 30 21"" src=""https://github.com/qupath/qupath/assets/4690904/9353da74-3f5f-4588-a80e-2d65533bc572"">. with no indication that 'Untitled 2' is a script - and no script editor visible. So I think this has the potential to be confusing. I think that:; * Pressing cancel shouldn't result in the script editor window being closed; * The dialog message should somehow distinguish when the quit attempt is being blocked by a script rather than something else",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2123013964
https://github.com/qupath/qupath/pull/1524#issuecomment-2133544271:621,Usability,clear,clearly,621,"I can still reproduce the issue on macOS following the steps Alan mentions (where 'edit 2 scripts' means new ones, not existing scripts). > However, should we prompt users to save scripts when closing the editor, rather than when closing QuPath?. Probably. I think I'll find this annoying sometimes, because I close the script editor as a way of hiding the window - because otherwise it isn't possible to hide a (child) window. So we might need a new hide option, although then we're almost back to the original problem. Another option would be to show the script editor when the user attempts to quit, and at that point clearly notify them that they have unsaved *scripts* (before moving in to whatever other unsaved stuff they might have).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2133544271
https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152:146,Availability,ERROR,ERROR,146,"I also can't close QuPath *without* interacting with the script editor, because I get an exception; ```; 15:17:30.307	[JavaFX Application Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null	java.lang.NullPointerException: Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null; 	at qupath.lib.gui.scripting.DefaultScriptEditor.promptToClose(DefaultScriptEditor.java:518); 	at qupath.lib.gui.QuPathGUI.handleCloseMainStageRequest(QuPathGUI.java:1018); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventHandler.dispatchBubblingEvent(CompositeEventHandler.java:86); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:232); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:189); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at javafx.base@22.0.1/com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at javafx.base@22.0.1/com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.base@22.0.1/javafx.event.Event.fireEvent(Event.java:198); 	at javafx.graphics@22.0.1/com.sun.javafx.stage.WindowPeerListener.closing(WindowPeerListener.java:100); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.lambda$requestClosingAllWindows$3(GlassStage.java:204); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.requestClosingAllWindows(GlassStage.java:203); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.QuantumToolkit$2.handleQuitAct",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152
https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152:1740,Security,secur,security,1740,"ation Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null	java.lang.NullPointerException: Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null; 	at qupath.lib.gui.scripting.DefaultScriptEditor.promptToClose(DefaultScriptEditor.java:518); 	at qupath.lib.gui.QuPathGUI.handleCloseMainStageRequest(QuPathGUI.java:1018); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventHandler.dispatchBubblingEvent(CompositeEventHandler.java:86); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:232); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:189); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at javafx.base@22.0.1/com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at javafx.base@22.0.1/com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.base@22.0.1/javafx.event.Event.fireEvent(Event.java:198); 	at javafx.graphics@22.0.1/com.sun.javafx.stage.WindowPeerListener.closing(WindowPeerListener.java:100); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.lambda$requestClosingAllWindows$3(GlassStage.java:204); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.requestClosingAllWindows(GlassStage.java:203); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.QuantumToolkit$2.handleQuitAction(QuantumToolkit.java:370); 	at javafx.graphics@22.0.1/com.sun.glass.ui.mac.MacApplication$4.action(MacApplication.java:226); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152
https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152:1749,Security,Access,AccessController,1749,"ation Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null	java.lang.NullPointerException: Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null; 	at qupath.lib.gui.scripting.DefaultScriptEditor.promptToClose(DefaultScriptEditor.java:518); 	at qupath.lib.gui.QuPathGUI.handleCloseMainStageRequest(QuPathGUI.java:1018); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventHandler.dispatchBubblingEvent(CompositeEventHandler.java:86); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:232); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:189); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at javafx.base@22.0.1/com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at javafx.base@22.0.1/com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.base@22.0.1/javafx.event.Event.fireEvent(Event.java:198); 	at javafx.graphics@22.0.1/com.sun.javafx.stage.WindowPeerListener.closing(WindowPeerListener.java:100); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.lambda$requestClosingAllWindows$3(GlassStage.java:204); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.requestClosingAllWindows(GlassStage.java:203); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.QuantumToolkit$2.handleQuitAction(QuantumToolkit.java:370); 	at javafx.graphics@22.0.1/com.sun.glass.ui.mac.MacApplication$4.action(MacApplication.java:226); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152
https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152:1779,Security,Access,AccessController,1779,"ation Thread]	ERROR	qupath.lib.gui.QuPathUncaughtExceptionHandler	Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null	java.lang.NullPointerException: Cannot invoke ""javafx.stage.Stage.close()"" because ""this.dialog"" is null; 	at qupath.lib.gui.scripting.DefaultScriptEditor.promptToClose(DefaultScriptEditor.java:518); 	at qupath.lib.gui.QuPathGUI.handleCloseMainStageRequest(QuPathGUI.java:1018); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventHandler.dispatchBubblingEvent(CompositeEventHandler.java:86); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:232); 	at javafx.base@22.0.1/com.sun.javafx.event.EventHandlerManager.dispatchBubblingEvent(EventHandlerManager.java:189); 	at javafx.base@22.0.1/com.sun.javafx.event.CompositeEventDispatcher.dispatchBubblingEvent(CompositeEventDispatcher.java:59); 	at javafx.base@22.0.1/com.sun.javafx.event.BasicEventDispatcher.dispatchEvent(BasicEventDispatcher.java:58); 	at javafx.base@22.0.1/com.sun.javafx.event.EventDispatchChainImpl.dispatchEvent(EventDispatchChainImpl.java:114); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEventImpl(EventUtil.java:74); 	at javafx.base@22.0.1/com.sun.javafx.event.EventUtil.fireEvent(EventUtil.java:54); 	at javafx.base@22.0.1/javafx.event.Event.fireEvent(Event.java:198); 	at javafx.graphics@22.0.1/com.sun.javafx.stage.WindowPeerListener.closing(WindowPeerListener.java:100); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.lambda$requestClosingAllWindows$3(GlassStage.java:204); 	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.GlassStage.requestClosingAllWindows(GlassStage.java:203); 	at javafx.graphics@22.0.1/com.sun.javafx.tk.quantum.QuantumToolkit$2.handleQuitAction(QuantumToolkit.java:370); 	at javafx.graphics@22.0.1/com.sun.glass.ui.mac.MacApplication$4.action(MacApplication.java:226); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1524#issuecomment-2133581152
https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582:1073,Deployability,update,updated,1073,"I briefly explored this, and can confirm that incorporating following logic into `readRegion` **didn't** solve things... ```java; // Fix output size to match tiles, if necessary; 		// See https://github.com/qupath/qupath/issues/1527; 		if (request.getDownsample() > 1 && nResolutions() > 1; 				&& request.getMaxX() <= getWidth() && request.getMaxY() <= getHeight(); 				&& request.getMinX() >= 0 && request.getMinY() >= 0) {; 			int minX = Integer.MAX_VALUE;; 			int minY = Integer.MAX_VALUE;; 			int maxX = -Integer.MAX_VALUE;; 			int maxY = -Integer.MAX_VALUE;; 			for (var tile : tiles) {; 				minX = Math.min(minX, tile.getRegionRequest().getMinX());; 				minY = Math.min(minY, tile.getRegionRequest().getMinY());; 				maxX = Math.max(maxX, tile.getRegionRequest().getMaxX());; 				maxY = Math.max(maxY, tile.getRegionRequest().getMaxY());; 			}; 			if (minX != request.getMinX() || minY != request.getMinY() || maxX != request.getMaxX() || maxY != request.getMaxY()) {; 				var request2 = request.intersect2D(minX, minY, maxX, maxY);; 				logger.debug(""RegionRequest updated from {} -> {}"", request, request2);; 				request = request2;; 			}; 		}; ```; This *did* crop the `RegionRequest`, but the output image was still 1432, due to rounding up after being calculated to be 1431.5... and then Java's rendering pipeline still left the black line. It seems to be especially subtle and hard to address...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582
https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582:1317,Deployability,pipeline,pipeline,1317,"I briefly explored this, and can confirm that incorporating following logic into `readRegion` **didn't** solve things... ```java; // Fix output size to match tiles, if necessary; 		// See https://github.com/qupath/qupath/issues/1527; 		if (request.getDownsample() > 1 && nResolutions() > 1; 				&& request.getMaxX() <= getWidth() && request.getMaxY() <= getHeight(); 				&& request.getMinX() >= 0 && request.getMinY() >= 0) {; 			int minX = Integer.MAX_VALUE;; 			int minY = Integer.MAX_VALUE;; 			int maxX = -Integer.MAX_VALUE;; 			int maxY = -Integer.MAX_VALUE;; 			for (var tile : tiles) {; 				minX = Math.min(minX, tile.getRegionRequest().getMinX());; 				minY = Math.min(minY, tile.getRegionRequest().getMinY());; 				maxX = Math.max(maxX, tile.getRegionRequest().getMaxX());; 				maxY = Math.max(maxY, tile.getRegionRequest().getMaxY());; 			}; 			if (minX != request.getMinX() || minY != request.getMinY() || maxX != request.getMaxX() || maxY != request.getMaxY()) {; 				var request2 = request.intersect2D(minX, minY, maxX, maxY);; 				logger.debug(""RegionRequest updated from {} -> {}"", request, request2);; 				request = request2;; 			}; 		}; ```; This *did* crop the `RegionRequest`, but the output image was still 1432, due to rounding up after being calculated to be 1431.5... and then Java's rendering pipeline still left the black line. It seems to be especially subtle and hard to address...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582
https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582:70,Testability,log,logic,70,"I briefly explored this, and can confirm that incorporating following logic into `readRegion` **didn't** solve things... ```java; // Fix output size to match tiles, if necessary; 		// See https://github.com/qupath/qupath/issues/1527; 		if (request.getDownsample() > 1 && nResolutions() > 1; 				&& request.getMaxX() <= getWidth() && request.getMaxY() <= getHeight(); 				&& request.getMinX() >= 0 && request.getMinY() >= 0) {; 			int minX = Integer.MAX_VALUE;; 			int minY = Integer.MAX_VALUE;; 			int maxX = -Integer.MAX_VALUE;; 			int maxY = -Integer.MAX_VALUE;; 			for (var tile : tiles) {; 				minX = Math.min(minX, tile.getRegionRequest().getMinX());; 				minY = Math.min(minY, tile.getRegionRequest().getMinY());; 				maxX = Math.max(maxX, tile.getRegionRequest().getMaxX());; 				maxY = Math.max(maxY, tile.getRegionRequest().getMaxY());; 			}; 			if (minX != request.getMinX() || minY != request.getMinY() || maxX != request.getMaxX() || maxY != request.getMaxY()) {; 				var request2 = request.intersect2D(minX, minY, maxX, maxY);; 				logger.debug(""RegionRequest updated from {} -> {}"", request, request2);; 				request = request2;; 			}; 		}; ```; This *did* crop the `RegionRequest`, but the output image was still 1432, due to rounding up after being calculated to be 1431.5... and then Java's rendering pipeline still left the black line. It seems to be especially subtle and hard to address...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582
https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582:1045,Testability,log,logger,1045,"I briefly explored this, and can confirm that incorporating following logic into `readRegion` **didn't** solve things... ```java; // Fix output size to match tiles, if necessary; 		// See https://github.com/qupath/qupath/issues/1527; 		if (request.getDownsample() > 1 && nResolutions() > 1; 				&& request.getMaxX() <= getWidth() && request.getMaxY() <= getHeight(); 				&& request.getMinX() >= 0 && request.getMinY() >= 0) {; 			int minX = Integer.MAX_VALUE;; 			int minY = Integer.MAX_VALUE;; 			int maxX = -Integer.MAX_VALUE;; 			int maxY = -Integer.MAX_VALUE;; 			for (var tile : tiles) {; 				minX = Math.min(minX, tile.getRegionRequest().getMinX());; 				minY = Math.min(minY, tile.getRegionRequest().getMinY());; 				maxX = Math.max(maxX, tile.getRegionRequest().getMaxX());; 				maxY = Math.max(maxY, tile.getRegionRequest().getMaxY());; 			}; 			if (minX != request.getMinX() || minY != request.getMinY() || maxX != request.getMaxX() || maxY != request.getMaxY()) {; 				var request2 = request.intersect2D(minX, minY, maxX, maxY);; 				logger.debug(""RegionRequest updated from {} -> {}"", request, request2);; 				request = request2;; 			}; 		}; ```; This *did* crop the `RegionRequest`, but the output image was still 1432, due to rounding up after being calculated to be 1431.5... and then Java's rendering pipeline still left the black line. It seems to be especially subtle and hard to address...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1527#issuecomment-2124491582
https://github.com/qupath/qupath/pull/1528#issuecomment-2124476822:28,Safety,risk,risky,28,"It's tempting, but it feels risky. The choice of `round` and `floor` when converting pixel coordinates has been problematic in the past, e.g. see https://github.com/qupath/qupath/pull/1072#issuecomment-1278540089. I'm not 100% sure, but I think switching this behavior could break or confuse other things whenever we want to try to ensure we obtain a consistent image size.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1528#issuecomment-2124476822
https://github.com/qupath/qupath/pull/1532#issuecomment-2129632815:247,Energy Efficiency,reduce,reduce,247,"This should always find a point on the ROI and connect the name to that. This should make it easier to see which object is named, especially if the object has disconnected parts and holes. The last commit uses the selected object color to further reduce ambiguity.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1532#issuecomment-2129632815
https://github.com/qupath/qupath/pull/1532#issuecomment-2129872833:135,Integrability,synchroniz,synchronization,135,"Looks good to me, just one thing: is `paintOverlay` supposed to be called from multiple threads? Some fields are read/modified without synchronization",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1532#issuecomment-2129872833
https://github.com/qupath/qupath/pull/1532#issuecomment-2130922325:374,Modifiability,variab,variables,374,"@Rylern Very good question... no, but maybe?. Its primary use is for showing overlays in the viewer, where it should really be called on the application thread (or a background thread dedicated to rendering). It *could* also be called when writing out a rendered image + overlays... and *maybe* that would involve writing tiles in parallel. If so, then I'd expect important variables never to be changed: we'd create an overlay per image we want to export. Therefore I can't think of a time when this will be problematic in practice, but it's definitely something to be cautious about. . If we don't find any specific case where the current behavior is problematic, then I'm not sure it's worth making it properly thread-safe - and instead devote the time that would require to an entirely new viewer with overlays that are designed much better than this from the start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1532#issuecomment-2130922325
https://github.com/qupath/qupath/pull/1532#issuecomment-2130922325:721,Safety,safe,safe,721,"@Rylern Very good question... no, but maybe?. Its primary use is for showing overlays in the viewer, where it should really be called on the application thread (or a background thread dedicated to rendering). It *could* also be called when writing out a rendered image + overlays... and *maybe* that would involve writing tiles in parallel. If so, then I'd expect important variables never to be changed: we'd create an overlay per image we want to export. Therefore I can't think of a time when this will be problematic in practice, but it's definitely something to be cautious about. . If we don't find any specific case where the current behavior is problematic, then I'm not sure it's worth making it properly thread-safe - and instead devote the time that would require to an entirely new viewer with overlays that are designed much better than this from the start.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1532#issuecomment-2130922325
https://github.com/qupath/qupath/issues/1536#issuecomment-2138938368:38,Deployability,install,installation,38,"We don't currently officially support installation using package managers, although there have been some community efforts to make it supported for homebrew, see eg: https://forum.image.sc/t/installing-qupath-via-homebrew/92388",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1536#issuecomment-2138938368
https://github.com/qupath/qupath/issues/1536#issuecomment-2138938368:191,Deployability,install,installing-qupath-via-homebrew,191,"We don't currently officially support installation using package managers, although there have been some community efforts to make it supported for homebrew, see eg: https://forum.image.sc/t/installing-qupath-via-homebrew/92388",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1536#issuecomment-2138938368
https://github.com/qupath/qupath/issues/1537#issuecomment-2139690675:226,Availability,robust,robust,226,"Can somewhat resolve item 2 by adding this:. ```java; 				ImageRow selectedImageRow = getSelectedImageRow();; 				refreshTree(selectedImageRow);; ```; to the end of `actionAddMetadataValue`, although this isn't a particularly robust way of doing it in case metadata are edited elsewhere",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2139690675
https://github.com/qupath/qupath/issues/1537#issuecomment-2139786065:51,Integrability,interface,interface,51,"Seems like 1. might require changing the `Project` interface, which is really not ideal",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2139786065
https://github.com/qupath/qupath/issues/1537#issuecomment-2139836229:81,Integrability,interface,interface,81,"Yes. We can make changes, but need to be cautious and ideally keep the `Project` interface as simple as we can. The thinking is that we want projects to not *necessarily* be backed by files on the local file system. So you might have a QuPath project that behaves like a 'view' on an OMERO project (for example). I think this idea is already used by QuPath Edu - see [here](https://github.com/openmicroanatomy/qupath-edu-extension/blob/dd67a5edccd8e548dd0739c6bde624fff276b21f/src/main/java/qupath/edu/EduProject.java#L54).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2139836229
https://github.com/qupath/qupath/issues/1537#issuecomment-2139836229:94,Usability,simpl,simple,94,"Yes. We can make changes, but need to be cautious and ideally keep the `Project` interface as simple as we can. The thinking is that we want projects to not *necessarily* be backed by files on the local file system. So you might have a QuPath project that behaves like a 'view' on an OMERO project (for example). I think this idea is already used by QuPath Edu - see [here](https://github.com/openmicroanatomy/qupath-edu-extension/blob/dd67a5edccd8e548dd0739c6bde624fff276b21f/src/main/java/qupath/edu/EduProject.java#L54).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2139836229
https://github.com/qupath/qupath/issues/1537#issuecomment-2140050177:306,Security,secur,security,306,"An alternative could be to smuggle in an implementation of stored sorting with a `Manager`, but that seems like a bit of abuse of the existing facilities. The obvious way to make one change that permits any future extensions is to add a `Map<[String?], [Object?]>`, but that's got its own set of problems (security would be a big one).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2140050177
https://github.com/qupath/qupath/issues/1537#issuecomment-2140985003:374,Performance,load,loading,374,"> smuggle in an implementation of stored sorting with a Manager, but that seems like a bit of abuse of the existing facilities. Actually wondering is this so bad after all? Could have a class that manages sorting by metadata key(s), then use a manager to store/retrieve associated settings for the project in [something, maybe a file]. Not too dissimilar philosophically to loading/saving classifiers in the grand scheme of things",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2140985003
https://github.com/qupath/qupath/issues/1537#issuecomment-2141273485:529,Modifiability,flexible,flexible,529,"True. I'm not a big fan of managers, especially if we just expect to store one value, but it should work without needing to change much. Or what do you think of a project supporting `Map<String, String>` so it doesn't attempt to handle arbitrary objects?. Thinking about it, we could also easily add a `getSortKey()` method (and setter) with default `null` implementations without breaking anything (and then include a corresponding `String` field in the default project itself). Although I'm not sure the current shorting is as flexible as we'd like, and setting the sort key kind of suggests that it will be applied to `getImageList()` but it wouldn't be. Although now that I think about _that_, it *couldn't* really be applied to `getImageList()` because it's really more of a grouping than a sorting... so you'd need something like `Map<String, List<ProjectImageEntry>> getGroupedImages(String key)` to use it meaningfully. So maybe it's more of a `getGroupingKey()`...",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1537#issuecomment-2141273485
https://github.com/qupath/qupath/issues/1539#issuecomment-2141265988:228,Availability,avail,available,228,"Hi @ipaine01 this sounds like the issue reported at https://forum.image.sc/t/bug-channel-name-changed-when-changing-color/95010/6. If so, I have already fixed it at https://github.com/qupath/qupath/pull/1508 and the fix will be available in the next QuPath release. In the meantime, the workaround is to double-click on the channel (rather than clicking the color box) since this will allow you to choose a custom color in a different way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1539#issuecomment-2141265988
https://github.com/qupath/qupath/issues/1539#issuecomment-2141265988:257,Deployability,release,release,257,"Hi @ipaine01 this sounds like the issue reported at https://forum.image.sc/t/bug-channel-name-changed-when-changing-color/95010/6. If so, I have already fixed it at https://github.com/qupath/qupath/pull/1508 and the fix will be available in the next QuPath release. In the meantime, the workaround is to double-click on the channel (rather than clicking the color box) since this will allow you to choose a custom color in a different way.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1539#issuecomment-2141265988
https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336:1434,Safety,avoid,avoid,1434,"How bad is this really...?. I remember from conversations with @melvingelbard that validating numbers in a text field is far from straightforward... at least if trying to handle `+-.,e`. These might be used for valid numbers, but at the point they are typed the text may not be a valid number. He wrote [this method](https://github.com/qupath/qupath-fxtras/blob/007d91581049d7fd9439fd233211dcecf44d8fef/src/main/java/qupath/fx/utils/FXUtils.java#L260) to help sort that. ControlsFX doesn't handle this so well: you can see it in the preference pane, built using ControlsFX. Find a numeric field, e.g. `Brush diameter`. You can type `50` but you *cannot* type `-50` in the usual way. But you *can* type `50` and then go back to add the `-` (or even `+`). It seems to use a validation that is much too eager. I find this to be more annoying and problematic, so the `ParameterPanelFX` errs on the side of 'type anything, it's up to you for it to make sense'. The main thing is that we shouldn't through exceptions too quickly. But you could try switching the parameter pane to use Melvin's method linked above and see if it behaves better. In any case, I think a solution belongs in `qupath-fxtras` since it is so fiddly. For the number of bins, you can set an upper limit on the parameter - but this will have the effect of using a slider instead. That might be fine in this case; if you need more customisation, then it'd be better to avoid `Parameter` altogether and just got straight to JavaFX (which could be preferable for the measurement table histograms since then it'd be easier to make the selections persistent).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336
https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336:83,Security,validat,validating,83,"How bad is this really...?. I remember from conversations with @melvingelbard that validating numbers in a text field is far from straightforward... at least if trying to handle `+-.,e`. These might be used for valid numbers, but at the point they are typed the text may not be a valid number. He wrote [this method](https://github.com/qupath/qupath-fxtras/blob/007d91581049d7fd9439fd233211dcecf44d8fef/src/main/java/qupath/fx/utils/FXUtils.java#L260) to help sort that. ControlsFX doesn't handle this so well: you can see it in the preference pane, built using ControlsFX. Find a numeric field, e.g. `Brush diameter`. You can type `50` but you *cannot* type `-50` in the usual way. But you *can* type `50` and then go back to add the `-` (or even `+`). It seems to use a validation that is much too eager. I find this to be more annoying and problematic, so the `ParameterPanelFX` errs on the side of 'type anything, it's up to you for it to make sense'. The main thing is that we shouldn't through exceptions too quickly. But you could try switching the parameter pane to use Melvin's method linked above and see if it behaves better. In any case, I think a solution belongs in `qupath-fxtras` since it is so fiddly. For the number of bins, you can set an upper limit on the parameter - but this will have the effect of using a slider instead. That might be fine in this case; if you need more customisation, then it'd be better to avoid `Parameter` altogether and just got straight to JavaFX (which could be preferable for the measurement table histograms since then it'd be easier to make the selections persistent).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336
https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336:772,Security,validat,validation,772,"How bad is this really...?. I remember from conversations with @melvingelbard that validating numbers in a text field is far from straightforward... at least if trying to handle `+-.,e`. These might be used for valid numbers, but at the point they are typed the text may not be a valid number. He wrote [this method](https://github.com/qupath/qupath-fxtras/blob/007d91581049d7fd9439fd233211dcecf44d8fef/src/main/java/qupath/fx/utils/FXUtils.java#L260) to help sort that. ControlsFX doesn't handle this so well: you can see it in the preference pane, built using ControlsFX. Find a numeric field, e.g. `Brush diameter`. You can type `50` but you *cannot* type `-50` in the usual way. But you *can* type `50` and then go back to add the `-` (or even `+`). It seems to use a validation that is much too eager. I find this to be more annoying and problematic, so the `ParameterPanelFX` errs on the side of 'type anything, it's up to you for it to make sense'. The main thing is that we shouldn't through exceptions too quickly. But you could try switching the parameter pane to use Melvin's method linked above and see if it behaves better. In any case, I think a solution belongs in `qupath-fxtras` since it is so fiddly. For the number of bins, you can set an upper limit on the parameter - but this will have the effect of using a slider instead. That might be fine in this case; if you need more customisation, then it'd be better to avoid `Parameter` altogether and just got straight to JavaFX (which could be preferable for the measurement table histograms since then it'd be easier to make the selections persistent).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162178336
https://github.com/qupath/qupath/issues/1541#issuecomment-2162260361:381,Safety,detect,detection,381,"I wanted to switch the measurement table histogram to use JavaFX yesterday, using observable values and making them persistent, but didn't have the time / concentration / will to actually do it. That would give more customisation control - there is no real reason they need to use the `Parameter` stuff (which is primarily to make it easier to write scriptable commands, like cell detection, without needing to code the whole UI). Feel free to make that change. Or, the easy one, just clip a maximum number of histogram bins in the code and log a warning if the user requests something unreasonable that we don't use.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162260361
https://github.com/qupath/qupath/issues/1541#issuecomment-2162260361:541,Testability,log,log,541,"I wanted to switch the measurement table histogram to use JavaFX yesterday, using observable values and making them persistent, but didn't have the time / concentration / will to actually do it. That would give more customisation control - there is no real reason they need to use the `Parameter` stuff (which is primarily to make it easier to write scriptable commands, like cell detection, without needing to code the whole UI). Feel free to make that change. Or, the easy one, just clip a maximum number of histogram bins in the code and log a warning if the user requests something unreasonable that we don't use.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162260361
https://github.com/qupath/qupath/issues/1541#issuecomment-2162652113:35,Modifiability,refactor,refactoring,35,"Sounds sensible, I was planning on refactoring the current version to trial thresholding histograms/gating scatter plots, so I'll close this and do ""something"" when merging that. There's already an internal cap, though I'll add a logged warning",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162652113
https://github.com/qupath/qupath/issues/1541#issuecomment-2162652113:230,Testability,log,logged,230,"Sounds sensible, I was planning on refactoring the current version to trial thresholding histograms/gating scatter plots, so I'll close this and do ""something"" when merging that. There's already an internal cap, though I'll add a logged warning",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1541#issuecomment-2162652113
https://github.com/qupath/qupath/issues/1542#issuecomment-2162851928:12,Availability,down,download,12,1. Clone or download the repository (and extract if necessary); 2. Open a command prompt in the downloaded folder; 3. Run `gradlew clean jpackage`. See https://qupath.readthedocs.io/en/0.5/docs/reference/building.html,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1542#issuecomment-2162851928
https://github.com/qupath/qupath/issues/1542#issuecomment-2162851928:96,Availability,down,downloaded,96,1. Clone or download the repository (and extract if necessary); 2. Open a command prompt in the downloaded folder; 3. Run `gradlew clean jpackage`. See https://qupath.readthedocs.io/en/0.5/docs/reference/building.html,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1542#issuecomment-2162851928
https://github.com/qupath/qupath/pull/1544#issuecomment-2236795538:16,Performance,perform,performance,16,"Closing this as performance is horrible with large numbers of points, but will likely revisit after implementing a binning and/or subsampling strategy",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1544#issuecomment-2236795538
https://github.com/qupath/qupath/issues/1546#issuecomment-2179808502:1369,Integrability,Message,Message,1369,"Works on Ubuntus 18-23.10 too. tor. 20. juni 2024, 06:54 skrev Pete ***@***.***>:. > This works fine for me on my Mac, and I'm pretty sure it works on Windows; > too.; >; > Note that the docs; > <https://qupath.readthedocs.io/en/0.5/docs/reference/shortcuts.html#the-alt-key>; > specify you should hold the Alt key, *not* Alt Gr.; >; > Note also that annotations can be locked, and would need to be unlocked; > for editing; > <https://qupath.readthedocs.io/en/0.5/docs/reference/commands.html#lock-selected-objects>; > .; >; > And finally; >; > expect that smaller objects within the annotation should be erased; >; > That isn't the purpose of the Alt trick - rather, it subtracts from an; > existing annotation as shown in this old video; > <https://youtu.be/lGj3uyxUdgs?t=99>.; >; > Please try these. If you are still sure there is a bug, please describe in; > more details your exact steps - including how you generated the annotation; > originally, preferably with screenshots.; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/qupath/qupath/issues/1546#issuecomment-2179806373>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AH7WSLYZFBJOC2XGWA42FXLZIJN7XAVCNFSM6AAAAABJS6KFTWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDCNZZHAYDMMZXGM>; > .; > You are receiving this because you are subscribed to this thread.Message; > ID: ***@***.***>; >",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1546#issuecomment-2179808502
https://github.com/qupath/qupath/issues/1547#issuecomment-2211025183:255,Modifiability,config,config,255,"How are you connecting to the SSH server, and how are you launching QuPath? It sounds like you've connected without X11 forwarding, and are trying to launch the QuPath GUI. In this case, enable X11 forwarding either by modifying the entry in your `~/.ssh/config` to set `ForwardX11 yes`, eg. ```; Host myhost; HostName hostname.subdomain.domain; ForwardX11 yes; ```. or if specifying on the command line, by adding the relevant flag: `ssh -X myhost`. Then launch QuPath as normal, eg `QuPath --image=/path/to/my/image`",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1547#issuecomment-2211025183
https://github.com/qupath/qupath/issues/1550#issuecomment-2188422166:162,Safety,detect,detections,162,"From memory, I think the reason it prefers cells *when present* is so that it does something sensible in the (common?) scenario that someone is using subcellular detections. I agree that this behavior isn't obvious (and should at least be documented). I'm interested to better understand the use case where heterogenous groups should be treated the same.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2188422166
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:51,Safety,detect,detections,51,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:440,Safety,detect,detection,440,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:611,Safety,detect,detection,611,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:765,Safety,detect,detections,765,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:851,Safety,detect,detections,851,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097:602,Usability,simpl,simply,602,"I agree with @petebankhead here, since subcellular detections would too often get in the way. I think it would make more sense to _force the type of objects you want to have interact in this way to all have the same type_, though I acknowledge users might need dig around on the forum a bit to look up the right lines of script to accomplish this. . I can definitely see situations where different types of cells require different types of detection methods, for example larger macrophages that can be multinucleated requiring something like CellPose to create the boundary, which may, at the time, be simply a detection as there isn't a convenient way to create a multinucleated object. I still feel like it makes more sense to have a more convenient way to force detections to be cells, rather than trying to figure out a way to exclude subcellular detections when you do not want those interactions calculated - aside from removing the measurements after the fact.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2189876097
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:51,Safety,Detect,Detection,51,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:100,Safety,detect,detections,100,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:124,Safety,detect,detections,124,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:167,Safety,detect,detections,167,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:214,Safety,detect,detections,214,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:318,Safety,detect,detections,318,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451:258,Testability,log,logic,258,"Perhaps something making use of the hierarchy? The Detection Centroid Distances should apply to all detections **except for detections that are child objects of other detections**. ; This would exclude subcellular detections from the run, and would keep the logic working. However at that point it could work for both detections and cells?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283403451
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:309,Safety,detect,detections,309,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:347,Safety,detect,detection,347,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:374,Safety,detect,detections,374,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:464,Safety,detect,detections,464,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:542,Safety,detect,detections,542,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:818,Safety,detect,detections,818,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122:934,Safety,detect,detections,934,"I'm not sure which approach is preferable to solve this. I have the feeling there will always be a need for an alternative to whichever default approach we take. As usual, the workaround would be a script. Here's one that shows how to get much more control over which distances are calculated, here using all detections without a parent that is a detection:. ```groovy; def detections = getDetectionObjects().findAll {!it.getParent()?.isDetection()}. def stroma = detections.findAll {it.getPathClass() == getPathClass('Stroma')}; def other = detections.findAll {it.getPathClass() == getPathClass('Other')}. def pixelWidth = getCurrentServer().getPixelCalibration().getPixelWidthMicrons(); def pixelHeight = getCurrentServer().getPixelCalibration().getPixelHeightMicrons(). DistanceTools.centroidToCentroidDistance2D(; detections, other, pixelWidth, pixelHeight, ""Distance to Other µm""; ); DistanceTools.centroidToCentroidDistance2D(; detections, stroma, pixelWidth, pixelHeight, ""Distance to Stroma µm""; ); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1550#issuecomment-2283437122
https://github.com/qupath/qupath/pull/1554#issuecomment-2206208137:158,Integrability,interface,interface,158,"It looks good to me (however I'm not very familiar with the theory behind it). Just 2 things:; * Is there a reason for defining the `BufferedImageNormalizer` interface, instead of just using [`Function<BufferedImage, BufferedImage>`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [`UnaryOperator<BufferedImage>`](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?; * Shouldn't there be unit tests for at least the `ColorTransformer.colorDeconvolveReconvolveRGBArray()` function and the `SubtractOffsetAndScaleNormalizer` class?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2206208137
https://github.com/qupath/qupath/pull/1554#issuecomment-2206208137:455,Testability,test,tests,455,"It looks good to me (however I'm not very familiar with the theory behind it). Just 2 things:; * Is there a reason for defining the `BufferedImageNormalizer` interface, instead of just using [`Function<BufferedImage, BufferedImage>`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [`UnaryOperator<BufferedImage>`](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?; * Shouldn't there be unit tests for at least the `ColorTransformer.colorDeconvolveReconvolveRGBArray()` function and the `SubtractOffsetAndScaleNormalizer` class?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2206208137
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:529,Deployability,update,updated,529,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:257,Integrability,interface,interface,257,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:1044,Integrability,interface,interfaces,1044,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:1084,Safety,avoid,avoid,1084,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:67,Testability,test,tests,67,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698:1210,Testability,test,testing,1210,"Thanks @Rylern and @alanocallaghan - good call making me right the tests, that helped identify and fix some bugs, and address some suboptimal behavior concerning rounding and out-of-range values. > Is there a reason for defining the BufferedImageNormalizer interface, instead of just using [Function<BufferedImage, BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html) or [UnaryOperator<BufferedImage>](https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html)?. I've updated this to use [`BufferedImageOp`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/image/BufferedImageOp.html), which then; 1. allows the classes to be used directly with [`Graphics2D.drawImage`](https://docs.oracle.com/en/java/javase/21/docs/api/java.desktop/java/awt/Graphics2D.html#drawImage(java.awt.image.BufferedImage,java.awt.image.BufferedImageOp,int,int)).; 2. makes it possible to control whether in-place image conversion is used. Potentially one of the other standard Java interfaces could be used, but I want to avoid giving the impression that it's a good idea to use arbitrary methods or lambda expressions. These can be convenient for testing, but will fail when images are added to a project - because we need the methods to be JSON-serializable. The JSON serialization is taken care of through the `ImageServers` class, and we have to explicitly register every normalization class so that it can be used within a project.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1554#issuecomment-2209250698
https://github.com/qupath/qupath/pull/1556#issuecomment-2205968750:353,Performance,perform,performance,353,"The latest commit adds a warning indicator if image files are missing:. <img width=""379"" alt=""Screenshot 2024-07-03 at 12 59 41"" src=""https://github.com/qupath/qupath/assets/4690904/c647426b-42f2-4959-9cbf-36b51ee692a4"">. This can be helpful if you want to remove images from a project, and need to know which have missing files. In case the check is a performance issue, the results are cached until a new project is opened.; It's also possible to turn off the checks with the *'Skip file checks in projects'* preference.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1556#issuecomment-2205968750
https://github.com/qupath/qupath/pull/1556#issuecomment-2205968750:388,Performance,cache,cached,388,"The latest commit adds a warning indicator if image files are missing:. <img width=""379"" alt=""Screenshot 2024-07-03 at 12 59 41"" src=""https://github.com/qupath/qupath/assets/4690904/c647426b-42f2-4959-9cbf-36b51ee692a4"">. This can be helpful if you want to remove images from a project, and need to know which have missing files. In case the check is a performance issue, the results are cached until a new project is opened.; It's also possible to turn off the checks with the *'Skip file checks in projects'* preference.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1556#issuecomment-2205968750
https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834:222,Modifiability,extend,extends,222,"I feel this draws more attention to my dubious design decision: specify nothing and get everything. I suggest deprecating `addShapeMeasurements` and adding; ```java; public static void addAllShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal) {; return addShapeMeasurements(pathObjects, cal, Arrays.asList(ShapeFeatures.values());; }. // Mark as deprecated from v0.6.0; public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, ShapeFeatures... features) {; if (features.length == 0); return addAllShapeMeasurements(pathObjects, cal);; else; return addShapeMeasurements(pathObjects, cal, Arrays.asList(features);; }. public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, Collection<ShapeFeature> shapeFeatures) {; // As you have it, except don't add anything if the collection is empty; }; ```; What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834
https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834:457,Modifiability,extend,extends,457,"I feel this draws more attention to my dubious design decision: specify nothing and get everything. I suggest deprecating `addShapeMeasurements` and adding; ```java; public static void addAllShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal) {; return addShapeMeasurements(pathObjects, cal, Arrays.asList(ShapeFeatures.values());; }. // Mark as deprecated from v0.6.0; public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, ShapeFeatures... features) {; if (features.length == 0); return addAllShapeMeasurements(pathObjects, cal);; else; return addShapeMeasurements(pathObjects, cal, Arrays.asList(features);; }. public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, Collection<ShapeFeature> shapeFeatures) {; // As you have it, except don't add anything if the collection is empty; }; ```; What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834
https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834:754,Modifiability,extend,extends,754,"I feel this draws more attention to my dubious design decision: specify nothing and get everything. I suggest deprecating `addShapeMeasurements` and adding; ```java; public static void addAllShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal) {; return addShapeMeasurements(pathObjects, cal, Arrays.asList(ShapeFeatures.values());; }. // Mark as deprecated from v0.6.0; public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, ShapeFeatures... features) {; if (features.length == 0); return addAllShapeMeasurements(pathObjects, cal);; else; return addShapeMeasurements(pathObjects, cal, Arrays.asList(features);; }. public static void addShapeMeasurements(Collection<? extends PathObject> pathObjects, PixelCalibration cal, Collection<ShapeFeature> shapeFeatures) {; // As you have it, except don't add anything if the collection is empty; }; ```; What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1558#issuecomment-2255786834
https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929:149,Safety,detect,detection,149,"Hmmm, I'm not sure what we gain from this?. We lose the ability to have multiple dialogs open to test the use of different parameters, e.g. for cell detection. And also, we lose the ability to double-click on a past entry under the 'Workflow' tab to open cell detection with the correct parameters. I think this is a really handy and important feature. So I'd tend towards rejecting and closing this, or have I missed a benefit?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929
https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929:260,Safety,detect,detection,260,"Hmmm, I'm not sure what we gain from this?. We lose the ability to have multiple dialogs open to test the use of different parameters, e.g. for cell detection. And also, we lose the ability to double-click on a past entry under the 'Workflow' tab to open cell detection with the correct parameters. I think this is a really handy and important feature. So I'd tend towards rejecting and closing this, or have I missed a benefit?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929
https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929:97,Testability,test,test,97,"Hmmm, I'm not sure what we gain from this?. We lose the ability to have multiple dialogs open to test the use of different parameters, e.g. for cell detection. And also, we lose the ability to double-click on a past entry under the 'Workflow' tab to open cell detection with the correct parameters. I think this is a really handy and important feature. So I'd tend towards rejecting and closing this, or have I missed a benefit?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255802929
https://github.com/qupath/qupath/pull/1560#issuecomment-2255806620:77,Modifiability,plugin,plugin,77,"These are fair points; for me at least within a project being able to open a plugin with the same settings as I used previously seem really handy, though unsure if it outweighs the above",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255806620
https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318:392,Availability,avail,available,392,"Currently, you can do that via the workflow tab - assuming you've run it once before on that image. Or you can leave the window open when switching images - assuming they are the same type... bad things may happen if not, e.g. fluorescence to brightfield. Although that led me to see that bad things happen with this PR when the image type changes: QuPath isn't able to adjust and update the available options. So if I run cell detection for brightfield, then I can't use it for fluorescence within that QuPath session - because it will be stuck with the same available channels the first time it was run.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318
https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318:560,Availability,avail,available,560,"Currently, you can do that via the workflow tab - assuming you've run it once before on that image. Or you can leave the window open when switching images - assuming they are the same type... bad things may happen if not, e.g. fluorescence to brightfield. Although that led me to see that bad things happen with this PR when the image type changes: QuPath isn't able to adjust and update the available options. So if I run cell detection for brightfield, then I can't use it for fluorescence within that QuPath session - because it will be stuck with the same available channels the first time it was run.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318
https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318:381,Deployability,update,update,381,"Currently, you can do that via the workflow tab - assuming you've run it once before on that image. Or you can leave the window open when switching images - assuming they are the same type... bad things may happen if not, e.g. fluorescence to brightfield. Although that led me to see that bad things happen with this PR when the image type changes: QuPath isn't able to adjust and update the available options. So if I run cell detection for brightfield, then I can't use it for fluorescence within that QuPath session - because it will be stuck with the same available channels the first time it was run.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318
https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318:428,Safety,detect,detection,428,"Currently, you can do that via the workflow tab - assuming you've run it once before on that image. Or you can leave the window open when switching images - assuming they are the same type... bad things may happen if not, e.g. fluorescence to brightfield. Although that led me to see that bad things happen with this PR when the image type changes: QuPath isn't able to adjust and update the available options. So if I run cell detection for brightfield, then I can't use it for fluorescence within that QuPath session - because it will be stuck with the same available channels the first time it was run.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2255814318
https://github.com/qupath/qupath/pull/1560#issuecomment-2256352714:69,Safety,detect,detection,69,"Ah, fair enough. To me, it makes sense for there to be a single cell detection window, and I'd put sub-panes in that window if needed, but that sounds like a total pain and pretty useless in terms of overall UX gain",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2256352714
https://github.com/qupath/qupath/pull/1560#issuecomment-2256352714:208,Usability,UX,UX,208,"Ah, fair enough. To me, it makes sense for there to be a single cell detection window, and I'd put sub-panes in that window if needed, but that sounds like a total pain and pretty useless in terms of overall UX gain",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1560#issuecomment-2256352714
https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291:36,Availability,down,down,36,"Thanks for your report and tracking down the problem. We definitely should close any new image tile store that is being created here, although we shouldn't have to if the 'main' tile store used by QuPath is used instead. Could you try modifying your rendered server builder as shown below please?; ```java; def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .store(viewer.getImageRegionStore()) // The new line!; .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ```; I haven't tried it, but from reading the description I think it might help work around the issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291
https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291:384,Availability,down,downsamples,384,"Thanks for your report and tracking down the problem. We definitely should close any new image tile store that is being created here, although we shouldn't have to if the 'main' tile store used by QuPath is used instead. Could you try modifying your rendered server builder as shown below please?; ```java; def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .store(viewer.getImageRegionStore()) // The new line!; .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ```; I haven't tried it, but from reading the description I think it might help work around the issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291
https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291:396,Availability,down,downsample,396,"Thanks for your report and tracking down the problem. We definitely should close any new image tile store that is being created here, although we shouldn't have to if the 'main' tile store used by QuPath is used instead. Could you try modifying your rendered server builder as shown below please?; ```java; def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .store(viewer.getImageRegionStore()) // The new line!; .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ```; I haven't tried it, but from reading the description I think it might help work around the issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291
https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291:465,Modifiability,layers,layers,465,"Thanks for your report and tracking down the problem. We definitely should close any new image tile store that is being created here, although we shouldn't have to if the 'main' tile store used by QuPath is used instead. Could you try modifying your rendered server builder as shown below please?; ```java; def server = new RenderedImageServer.Builder(imageData); .display(display); .downsamples(downsample); .store(viewer.getImageRegionStore()) // The new line!; .layers(new HierarchyOverlay(viewer.getImageRegionStore(), viewer.getOverlayOptions(), imageData)); .build(); ```; I haven't tried it, but from reading the description I think it might help work around the issue.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561#issuecomment-2235714291
https://github.com/qupath/qupath/issues/1561#issuecomment-2241154234:480,Modifiability,evolve,evolved,480,"Yes, I think we'd need to override `close()` to close the store for `ImageServer.close()` to work - but then we should only close the store if it's created internally within the `RenderedImageServer`, and not if it is provided elsewhere. Or maybe a different approach would work better, e.g. using a [`Cleaner`](https://docs.oracle.com/en%2Fjava%2Fjavase%2F22%2Fdocs%2Fapi%2F%2F/java.base/java/lang/ref/Cleaner.html), or by rethinking `DefaultImageRegionStore` entirely (since it evolved in a weird way over the years). Not sure what exactly we should do, it'll probably take some thought to figure out.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1561#issuecomment-2241154234
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:777,Safety,detect,detections,777,"The following image and script show the differences in how objects might be requested from the object hierarchy. The tests that each cell object passes contribute to the classification assigned, so that; * if two cells have the same color you can assume they were returned by the same methods; * if two cells have different colors, then at least one cell was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:856,Safety,detect,detections,856,"The following image and script show the differences in how objects might be requested from the object hierarchy. The tests that each cell object passes contribute to the classification assigned, so that; * if two cells have the same color you can assume they were returned by the same methods; * if two cells have different colors, then at least one cell was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1064,Safety,detect,detections,1064,"ierarchy. The tests that each cell object passes contribute to the classification assigned, so that; * if two cells have the same color you can assume they were returned by the same methods; * if two cells have different colors, then at least one cell was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting RO",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1309,Safety,Detect,Detections,1309,"ll was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROI",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1488,Safety,Detect,Detections,1488,"ssets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1741,Safety,Detect,Detections,1741,"ons everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1943,Safety,Detect,Detections,1943,"dObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classif",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:2137,Safety,Detect,Detections,2137,"hy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classifications += ['nucleus-centroid']}; centroidWithin.each{it.classifications += ['roi-centroid']}; intersecting.each{it.classifications += ['intersecting']}; completelyCovered.each{it.classifications += ['covered']}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:2495,Safety,Detect,Detections,2495,"hy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classifications += ['nucleus-centroid']}; centroidWithin.each{it.classifications += ['roi-centroid']}; intersecting.each{it.classifications += ['intersecting']}; completelyCovered.each{it.classifications += ['covered']}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:2193,Security,access,accessed,2193,"hy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classifications += ['nucleus-centroid']}; centroidWithin.each{it.classifications += ['roi-centroid']}; intersecting.each{it.classifications += ['intersecting']}; completelyCovered.each{it.classifications += ['covered']}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:117,Testability,test,tests,117,"The following image and script show the differences in how objects might be requested from the object hierarchy. The tests that each cell object passes contribute to the classification assigned, so that; * if two cells have the same color you can assume they were returned by the same methods; * if two cells have different colors, then at least one cell was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:1123,Testability,test,test,1123,"ierarchy. The tests that each cell object passes contribute to the classification assigned, so that; * if two cells have the same color you can assume they were returned by the same methods; * if two cells have different colors, then at least one cell was returned by at least one method that didn't return the other cell (e.g. it intersects the selected ROI, but isn't completely covered by it). ![image](https://github.com/user-attachments/assets/ad4a2204-2b96-4d5c-bdda-629fccffe2f6). ```groovy; // Get hierarchy & selected object/ROI; def hierarchy = getCurrentHierarchy(); def selectedObject = getSelectedObject(); def roi = selectedObject.getROI(). // Total number of detections everywhere; def allDetections = getDetectionObjects(); println ""Num detections (all): \t${allDetections.size()}"". // Direct children of the selected object; def childObjects = selectedObject.getChildObjects(); println ""Num child objects: \t${childObjects.size()}"". // Get all detections for the region (rectangular bounding box, quick test); def region = ImageRegion.createInstance(roi); def regionObjects = hierarchy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting RO",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:2384,Testability,assert,assert,2384,"hy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classifications += ['nucleus-centroid']}; centroidWithin.each{it.classifications += ['roi-centroid']}; intersecting.each{it.classifications += ['intersecting']}; completelyCovered.each{it.classifications += ['covered']}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074:2436,Testability,assert,assert,2436,"hy.getAllDetectionsForRegion(region, null); println ""Num in region bounds: \t${regionObjects.size()}"". // Detections within selected object, using hierarchy rules; def hierarchyWithin = hierarchy.getAllDetectionsForROI(roi); println ""Num 'within' ROI: \t${hierarchyWithin.size()}"". // Detections with nucleus (or main ROI) centroids within the selected object; def nucleusCentroidWithin = PathObjectTools.filterByROIContainsNucleusCentroid(roi, allDetections); println ""Num nucleus centroid in ROI: \t${nucleusCentroidWithin.size()}"". // Detections with centroids within the selected object; def centroidWithin = PathObjectTools.filterByROIContainsCentroid(roi, allDetections); println ""Num centroid in ROI: \t${centroidWithin.size()}"". // Detections with ROIs intersecting the selected object; def intersecting = PathObjectTools.filterByROIIntersects(roi, allDetections); println ""Num intersecting ROI: \t${intersecting.size()}"". // Detections with ROIs intersecting the selected object - accessed from region; // This should contain the same elements as intersecting (possibly in a different order); def intersecting2 = PathObjectTools.filterByROIIntersects(roi, regionObjects); assert intersecting.size() == intersecting2.size(); assert (intersecting as Set) == (intersecting2 as Set). // Detections with ROIs completely within the selected object; def completelyCovered = PathObjectTools.filterByROICovers(roi, allDetections); println ""Num completely covered: \t${completelyCovered.size()}"". // Set classifications for visualization; allDetections.each {it.classifications = []}; childObjects.each{it.classifications += ['child']}; regionObjects.each{it.classifications += ['region']}; hierarchyWithin.each{it.classifications += ['within']}; nucleusCentroidWithin.each{it.classifications += ['nucleus-centroid']}; centroidWithin.each{it.classifications += ['roi-centroid']}; intersecting.each{it.classifications += ['intersecting']}; completelyCovered.each{it.classifications += ['covered']}; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264806074
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:52,Testability,test,tests,52,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:79,Testability,test,tests,79,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:146,Testability,test,tests,146,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:169,Testability,test,test,169,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:193,Testability,test,tests,193,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:254,Testability,test,tested,254,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:344,Testability,test,test,344,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:379,Testability,Assert,Assert,379,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:535,Testability,test,test-function,535,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:152,Usability,guid,guidelines,152,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231:490,Usability,guid,guide,490,"It looks good. I just have a few comments regarding tests. Currently, a lot of tests are made within just one function. If we want to follow unit tests guidelines, each test function must only tests one thing. This means that only one function should be tested at the same time, and this function should only be called once. Also, to write the test function, the Arrange / Act / Assert / (cleanup) pattern should be used. All of this is detailed [here](https://github.com/qupath/Java-style-guide/tree/main?tab=readme-ov-file#writing-a-test-function). Also, I think there are a few untested functions, like `PathObjectHierarchy.getAllObjectsForRegion()` or `PathObjectHierarchy.hasObjectsForRegion()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264954231
https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328:49,Testability,test,tests,49,"Thanks, would you be able to provide any example tests for these functions?. I understand it's not great to test a lot in one function, but I wasn't sure how to do it without making the testing code enormous and much more complex - since an appropriate hierarchy needs to be built with objects + ROIs etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328
https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328:108,Testability,test,test,108,"Thanks, would you be able to provide any example tests for these functions?. I understand it's not great to test a lot in one function, but I wasn't sure how to do it without making the testing code enormous and much more complex - since an appropriate hierarchy needs to be built with objects + ROIs etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328
https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328:186,Testability,test,testing,186,"Thanks, would you be able to provide any example tests for these functions?. I understand it's not great to test a lot in one function, but I wasn't sure how to do it without making the testing code enormous and much more complex - since an appropriate hierarchy needs to be built with objects + ROIs etc.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2264991328
https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068:37,Testability,test,test,37,"One option would be to have multiple test classes with different `@BeforeEach` or `@BeforeAll` sections?. Related question: is the style guide for one assert, or just to test one function?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068
https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068:151,Testability,assert,assert,151,"One option would be to have multiple test classes with different `@BeforeEach` or `@BeforeAll` sections?. Related question: is the style guide for one assert, or just to test one function?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068
https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068:170,Testability,test,test,170,"One option would be to have multiple test classes with different `@BeforeEach` or `@BeforeAll` sections?. Related question: is the style guide for one assert, or just to test one function?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068
https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068:137,Usability,guid,guide,137,"One option would be to have multiple test classes with different `@BeforeEach` or `@BeforeAll` sections?. Related question: is the style guide for one assert, or just to test one function?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265062068
https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979:121,Testability,test,tests,121,"> since an appropriate hierarchy needs to be built with objects + ROIs etc. If you have objects that are used in several tests, you can define them as private fields of the test class, or (if their initialization is more complex) you can use `@BeforeAll` as Alan mentionned. If these objects are not immutable, make sure not to modify them inside the test functions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979
https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979:173,Testability,test,test,173,"> since an appropriate hierarchy needs to be built with objects + ROIs etc. If you have objects that are used in several tests, you can define them as private fields of the test class, or (if their initialization is more complex) you can use `@BeforeAll` as Alan mentionned. If these objects are not immutable, make sure not to modify them inside the test functions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979
https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979:351,Testability,test,test,351,"> since an appropriate hierarchy needs to be built with objects + ROIs etc. If you have objects that are used in several tests, you can define them as private fields of the test class, or (if their initialization is more complex) you can use `@BeforeAll` as Alan mentionned. If these objects are not immutable, make sure not to modify them inside the test functions.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265123979
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:47,Testability,assert,assert,47,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:66,Testability,test,test,66,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:112,Testability,test,test,112,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:201,Testability,assert,assert,201,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:334,Testability,assert,assert,334,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232:33,Usability,guid,guide,33,"> Related question: is the style guide for one assert, or just to test one function?. The important thing is to test one function with one set of parameters. To check the result, there is usually one `assert`, but in some situations (for example if the resulting object has no custom `equals` implementation) you can define multiple `assert`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265128232
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:51,Testability,test,tests,51,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:160,Testability,Test,TestPathObjectTools,160,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:1216,Testability,Test,Test,1216,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:1463,Testability,assert,assertEquals,1463,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:1511,Testability,Test,Test,1511,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123:1738,Testability,assert,assertEquals,1738,"> Thanks, would you be able to provide any example tests for these functions?. Here are some for `PathObjectsTools.filterByRoiCovers()`:. ```java; public class TestPathObjectTools {; private final ROI roiRect = ROIs.createRectangleROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiEllipse = ROIs.createEllipseROI(1, 2, 100, 200, ImagePlane.getDefaultPlane());; 	private final ROI roiDiamond = ROIs.createPolygonROI(List.of(; 			new Point2(roiRect.getBoundsX(), roiRect.getCentroidY()),; 			new Point2(roiRect.getCentroidX(), roiRect.getBoundsY()),; 			new Point2(roiRect.getBoundsX()+roiRect.getBoundsWidth(), roiRect.getCentroidY()),; 			new Point2(roiRect.getBoundsX(), roiRect.getBoundsY()+roiRect.getBoundsHeight()); 	), ImagePlane.getDefaultPlane());; 	private final ROI roiOverlaps = roiRect.translate(10, 0);; 	private final ROI roiOverlaps2 = roiRect.translate(0, 10);; 	private final ROI roiSeparate = roiRect.translate(1000, 1000);; 	private final List<ROI> allRois = List.of(roiRect, roiEllipse, roiDiamond, roiOverlaps, roiOverlaps2, roiSeparate);; 	private final List<PathObject> pathObjects = allRois; 			.stream(); 			.map(PathObjects::createDetectionObject); 			.toList();. 	@Test; 	void Check_ROIs_Covered_By_Rectangle() {; 		List<ROI> expectedRois = List.of(roiRect, roiEllipse, roiDiamond);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiRect, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. 	@Test; 	void Check_ROIs_Covered_By_Ellipse() {; 		List<ROI> expectedRois = List.of(roiEllipse);. 		List<ROI> coveredROIs = PathObjectTools.filterByRoiCovers(roiEllipse, pathObjects).stream().map(PathObject::getROI).toList();. 		assertEquals(expectedRois, coveredROIs);; 	}. // other ROIs...; }; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1563#issuecomment-2265155123
https://github.com/qupath/qupath/pull/1566#issuecomment-2260011491:418,Deployability,Update,Updated,418,"> Could you provide an example script showing how it should be used please?. You can find a script using it [here](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/16). I think it's simple enough not to change `TransformedServerBuilder`. > Including the example as a comment here is fine - and we should link to this issue in the CHANGELOG for anyone who wishes to read more. Updated in last commit. > Also: did anything change in the JSON serialization that could have compatibility concerns, i.e. if someone has stored an image in a project using ColorTransform in v0.5.1, can we expect it to work here?. No, the behaviour of the existing classes didn't change.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260011491
https://github.com/qupath/qupath/pull/1566#issuecomment-2260011491:224,Usability,simpl,simple,224,"> Could you provide an example script showing how it should be used please?. You can find a script using it [here](https://forum.image.sc/t/add-additional-channel-in-fluorescence-image-after-scanning/99174/16). I think it's simple enough not to change `TransformedServerBuilder`. > Including the example as a comment here is fine - and we should link to this issue in the CHANGELOG for anyone who wishes to read more. Updated in last commit. > Also: did anything change in the JSON serialization that could have compatibility concerns, i.e. if someone has stored an image in a project using ColorTransform in v0.5.1, can we expect it to work here?. No, the behaviour of the existing classes didn't change.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260011491
https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194:54,Security,access,access,54,"Thanks, this script only works because Groovy permits access to package-private classes/constructors/methods, e.g. [`ChannelTransformFeatureServer`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ChannelTransformFeatureServer.java#L52) and [`ExtractChannel`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ColorTransforms.java#L262). So this couldn't be used (easily) from Java. In my mind, `TransformedServerBuilder` was intended to be the main way to create a new server that applies transforms so that users don't need to learn about other classes. It also limits the main source to [one page on the javadocs](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/TransformedServerBuilder.html). Similarly, static methods of `ColorTransforms` can be used [here](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ColorTransforms.html). To further simplify the script, I'd suggest concatenating lists rather than streams - since this is likely more intuitive for more people. And you can use [`server.nChannels()`](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ImageServer.html#nChannels()) instead of needing to query the metadata and get the size of the channels list. So you might use; ```groovy; def channels = getCurrentServer().getMetadata().getChannels().collect {c -> ColorTransforms.createChannelExtractor(c.name)}; channels += [ColorTransforms.createLinearChannelCombination(coeffs)]; ```; but I think something like this is more readable to more people; ```groovy; def channels = []; for (int c = 0; c < server.nChannels(); c++); channels.add(ColorTransforms.createChannelExtractor(c.name)); channels.add(ColorTransforms.createLinearChannelCombination(coeffs)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194
https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194:693,Usability,learn,learn,693,"Thanks, this script only works because Groovy permits access to package-private classes/constructors/methods, e.g. [`ChannelTransformFeatureServer`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ChannelTransformFeatureServer.java#L52) and [`ExtractChannel`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ColorTransforms.java#L262). So this couldn't be used (easily) from Java. In my mind, `TransformedServerBuilder` was intended to be the main way to create a new server that applies transforms so that users don't need to learn about other classes. It also limits the main source to [one page on the javadocs](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/TransformedServerBuilder.html). Similarly, static methods of `ColorTransforms` can be used [here](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ColorTransforms.html). To further simplify the script, I'd suggest concatenating lists rather than streams - since this is likely more intuitive for more people. And you can use [`server.nChannels()`](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ImageServer.html#nChannels()) instead of needing to query the metadata and get the size of the channels list. So you might use; ```groovy; def channels = getCurrentServer().getMetadata().getChannels().collect {c -> ColorTransforms.createChannelExtractor(c.name)}; channels += [ColorTransforms.createLinearChannelCombination(coeffs)]; ```; but I think something like this is more readable to more people; ```groovy; def channels = []; for (int c = 0; c < server.nChannels(); c++); channels.add(ColorTransforms.createChannelExtractor(c.name)); channels.add(ColorTransforms.createLinearChannelCombination(coeffs)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194
https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194:1041,Usability,simpl,simplify,1041,"Thanks, this script only works because Groovy permits access to package-private classes/constructors/methods, e.g. [`ChannelTransformFeatureServer`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ChannelTransformFeatureServer.java#L52) and [`ExtractChannel`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ColorTransforms.java#L262). So this couldn't be used (easily) from Java. In my mind, `TransformedServerBuilder` was intended to be the main way to create a new server that applies transforms so that users don't need to learn about other classes. It also limits the main source to [one page on the javadocs](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/TransformedServerBuilder.html). Similarly, static methods of `ColorTransforms` can be used [here](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ColorTransforms.html). To further simplify the script, I'd suggest concatenating lists rather than streams - since this is likely more intuitive for more people. And you can use [`server.nChannels()`](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ImageServer.html#nChannels()) instead of needing to query the metadata and get the size of the channels list. So you might use; ```groovy; def channels = getCurrentServer().getMetadata().getChannels().collect {c -> ColorTransforms.createChannelExtractor(c.name)}; channels += [ColorTransforms.createLinearChannelCombination(coeffs)]; ```; but I think something like this is more readable to more people; ```groovy; def channels = []; for (int c = 0; c < server.nChannels(); c++); channels.add(ColorTransforms.createChannelExtractor(c.name)); channels.add(ColorTransforms.createLinearChannelCombination(coeffs)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194
https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194:1142,Usability,intuit,intuitive,1142,"Thanks, this script only works because Groovy permits access to package-private classes/constructors/methods, e.g. [`ChannelTransformFeatureServer`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ChannelTransformFeatureServer.java#L52) and [`ExtractChannel`](https://github.com/qupath/qupath/blob/8136994f8e6ef2f3a33a72467fd7c71c35977ad6/qupath-core/src/main/java/qupath/lib/images/servers/ColorTransforms.java#L262). So this couldn't be used (easily) from Java. In my mind, `TransformedServerBuilder` was intended to be the main way to create a new server that applies transforms so that users don't need to learn about other classes. It also limits the main source to [one page on the javadocs](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/TransformedServerBuilder.html). Similarly, static methods of `ColorTransforms` can be used [here](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ColorTransforms.html). To further simplify the script, I'd suggest concatenating lists rather than streams - since this is likely more intuitive for more people. And you can use [`server.nChannels()`](https://qupath.github.io/javadoc/docs/qupath/lib/images/servers/ImageServer.html#nChannels()) instead of needing to query the metadata and get the size of the channels list. So you might use; ```groovy; def channels = getCurrentServer().getMetadata().getChannels().collect {c -> ColorTransforms.createChannelExtractor(c.name)}; channels += [ColorTransforms.createLinearChannelCombination(coeffs)]; ```; but I think something like this is more readable to more people; ```groovy; def channels = []; for (int c = 0; c < server.nChannels(); c++); channels.add(ColorTransforms.createChannelExtractor(c.name)); channels.add(ColorTransforms.createLinearChannelCombination(coeffs)); ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260153194
https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184:448,Integrability,wrap,wrap,448,I like that solution - and clever use of `concatChannels` to make the script more concise. . It would be interesting to compare it with `applyColorTransforms()` where you pass all the `ColorTransform` objects and avoid `concatChannels()`. I have a feeling that would result in a more concise JSON representation but I'm not certain. There is an unpleasantness in how transformed `ImageServer` tend to include the metadata from all the servers they wrap in the JSON representation. My guess is that the use of `concatChannels()` may result in the same metadata being duplicated multiple times - and also the same image being opened twice when it is used - although even if that happens it should be harmless. I suggest providing both `TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms)` and `TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms)` for convenience. What is the name given to any new channel generated in this way?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184
https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184:875,Modifiability,extend,extends,875,I like that solution - and clever use of `concatChannels` to make the script more concise. . It would be interesting to compare it with `applyColorTransforms()` where you pass all the `ColorTransform` objects and avoid `concatChannels()`. I have a feeling that would result in a more concise JSON representation but I'm not certain. There is an unpleasantness in how transformed `ImageServer` tend to include the metadata from all the servers they wrap in the JSON representation. My guess is that the use of `concatChannels()` may result in the same metadata being duplicated multiple times - and also the same image being opened twice when it is used - although even if that happens it should be harmless. I suggest providing both `TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms)` and `TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms)` for convenience. What is the name given to any new channel generated in this way?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184
https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184:213,Safety,avoid,avoid,213,I like that solution - and clever use of `concatChannels` to make the script more concise. . It would be interesting to compare it with `applyColorTransforms()` where you pass all the `ColorTransform` objects and avoid `concatChannels()`. I have a feeling that would result in a more concise JSON representation but I'm not certain. There is an unpleasantness in how transformed `ImageServer` tend to include the metadata from all the servers they wrap in the JSON representation. My guess is that the use of `concatChannels()` may result in the same metadata being duplicated multiple times - and also the same image being opened twice when it is used - although even if that happens it should be harmless. I suggest providing both `TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms)` and `TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms)` for convenience. What is the name given to any new channel generated in this way?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260286184
https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815:274,Deployability,update,update,274,"> It would be interesting to compare it with applyColorTransforms() where you pass all the ColorTransform objects and avoid concatChannels(). Using `concatChannels`, the JSON entry makes 430 lines, while with only `applyColorTransforms` the JSON entry makes 195 lines. I'll update the Image.sc script with only `applyColorTransforms`. > I suggest providing both TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms) and TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms) for convenience. Added in last commit. > What is the name given to any new channel generated in this way?. * If the channel names are provided with the coefficients, it's the linear combination with the channel names, for example `""-0.25*PDL1 + -0.15*FoxP3 + 1.0*CD8""`; * If only the coefficients are provided, it's the linear combination with `""channel"" + channelIndex` as channel names, for example `""-0.25*channel1 + -0.15*channel3 + 1.0*channel4""`",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815
https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815:501,Modifiability,extend,extends,501,"> It would be interesting to compare it with applyColorTransforms() where you pass all the ColorTransform objects and avoid concatChannels(). Using `concatChannels`, the JSON entry makes 430 lines, while with only `applyColorTransforms` the JSON entry makes 195 lines. I'll update the Image.sc script with only `applyColorTransforms`. > I suggest providing both TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms) and TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms) for convenience. Added in last commit. > What is the name given to any new channel generated in this way?. * If the channel names are provided with the coefficients, it's the linear combination with the channel names, for example `""-0.25*PDL1 + -0.15*FoxP3 + 1.0*CD8""`; * If only the coefficients are provided, it's the linear combination with `""channel"" + channelIndex` as channel names, for example `""-0.25*channel1 + -0.15*channel3 + 1.0*channel4""`",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815
https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815:118,Safety,avoid,avoid,118,"> It would be interesting to compare it with applyColorTransforms() where you pass all the ColorTransform objects and avoid concatChannels(). Using `concatChannels`, the JSON entry makes 430 lines, while with only `applyColorTransforms` the JSON entry makes 195 lines. I'll update the Image.sc script with only `applyColorTransforms`. > I suggest providing both TransformedServerBuilder.applyColorTransforms(ColorTransform... transforms) and TransformedServerBuilder.applyColorTransforms(Collection<? extends ColorTransform> transforms) for convenience. Added in last commit. > What is the name given to any new channel generated in this way?. * If the channel names are provided with the coefficients, it's the linear combination with the channel names, for example `""-0.25*PDL1 + -0.15*FoxP3 + 1.0*CD8""`; * If only the coefficients are provided, it's the linear combination with `""channel"" + channelIndex` as channel names, for example `""-0.25*channel1 + -0.15*channel3 + 1.0*channel4""`",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1566#issuecomment-2260446815
https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612:1012,Availability,robust,robust,1012,"Thanks, I made minor edits to ensure `super.close()` is called as well, and made some variables final. One worry, possibly obscure: it looks like `dedicatedStore` is being set as a side-effect or calling `getStore()`. That's fine if the builder is only used once, but if it is reused and passed a different `store` (or `findViewer()` gives a non-null result) before the second use then I think we could still end up closing a store that is being used elsewhere. Possible workarounds:; 1. Move the `getStore()` logic into `build()` so that `dedicatedStore` doesn't need to be a field of the builder; 2. Reset the value of `dedicatedStore` whenever its value may change (e.g. `findViewer(imageData)` doesn't return `null`, or `store` is updated); 3. Build the store inside the `RenderedImageServer` if the store it is given is `null` - and then set `dedicatedStore` only within `RenderedImageServer` (which knows whether or not it created a store). I tend to think Option 3. might be the easiest to code, and most robust.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612
https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612:735,Deployability,update,updated,735,"Thanks, I made minor edits to ensure `super.close()` is called as well, and made some variables final. One worry, possibly obscure: it looks like `dedicatedStore` is being set as a side-effect or calling `getStore()`. That's fine if the builder is only used once, but if it is reused and passed a different `store` (or `findViewer()` gives a non-null result) before the second use then I think we could still end up closing a store that is being used elsewhere. Possible workarounds:; 1. Move the `getStore()` logic into `build()` so that `dedicatedStore` doesn't need to be a field of the builder; 2. Reset the value of `dedicatedStore` whenever its value may change (e.g. `findViewer(imageData)` doesn't return `null`, or `store` is updated); 3. Build the store inside the `RenderedImageServer` if the store it is given is `null` - and then set `dedicatedStore` only within `RenderedImageServer` (which knows whether or not it created a store). I tend to think Option 3. might be the easiest to code, and most robust.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612
https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612:86,Modifiability,variab,variables,86,"Thanks, I made minor edits to ensure `super.close()` is called as well, and made some variables final. One worry, possibly obscure: it looks like `dedicatedStore` is being set as a side-effect or calling `getStore()`. That's fine if the builder is only used once, but if it is reused and passed a different `store` (or `findViewer()` gives a non-null result) before the second use then I think we could still end up closing a store that is being used elsewhere. Possible workarounds:; 1. Move the `getStore()` logic into `build()` so that `dedicatedStore` doesn't need to be a field of the builder; 2. Reset the value of `dedicatedStore` whenever its value may change (e.g. `findViewer(imageData)` doesn't return `null`, or `store` is updated); 3. Build the store inside the `RenderedImageServer` if the store it is given is `null` - and then set `dedicatedStore` only within `RenderedImageServer` (which knows whether or not it created a store). I tend to think Option 3. might be the easiest to code, and most robust.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612
https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612:510,Testability,log,logic,510,"Thanks, I made minor edits to ensure `super.close()` is called as well, and made some variables final. One worry, possibly obscure: it looks like `dedicatedStore` is being set as a side-effect or calling `getStore()`. That's fine if the builder is only used once, but if it is reused and passed a different `store` (or `findViewer()` gives a non-null result) before the second use then I think we could still end up closing a store that is being used elsewhere. Possible workarounds:; 1. Move the `getStore()` logic into `build()` so that `dedicatedStore` doesn't need to be a field of the builder; 2. Reset the value of `dedicatedStore` whenever its value may change (e.g. `findViewer(imageData)` doesn't return `null`, or `store` is updated); 3. Build the store inside the `RenderedImageServer` if the store it is given is `null` - and then set `dedicatedStore` only within `RenderedImageServer` (which knows whether or not it created a store). I tend to think Option 3. might be the easiest to code, and most robust.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1577#issuecomment-2273859612
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:445,Deployability,update,update,445,"Ah, thank you for investigating this!. The hierarchy event system is horrible, and traces back to the early versions of QuPath where the hierarchy was much more important, undo/redo didn't exist, and we didn't have a good spatial cache from JTS. Then, it was a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:1306,Deployability,update,update,1306,"s a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjec",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:1788,Deployability,update,update,1788,"ngle object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:230,Performance,cache,cache,230,"Ah, thank you for investigating this!. The hierarchy event system is horrible, and traces back to the early versions of QuPath where the hierarchy was much more important, undo/redo didn't exist, and we didn't have a good spatial cache from JTS. Then, it was a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:280,Safety,avoid,avoid,280,"Ah, thank you for investigating this!. The hierarchy event system is horrible, and traces back to the early versions of QuPath where the hierarchy was much more important, undo/redo didn't exist, and we didn't have a good spatial cache from JTS. Then, it was a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:1190,Safety,safe,safer,1190,"s a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjec",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:2089,Safety,avoid,avoid,2089,"t, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dramatically* simplify `PathObjectHierarchyEvent` for future versions - but if we can make undo/redo less bad with a small change, that would be excellent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:2691,Safety,detect,detection,2691,"t, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dramatically* simplify `PathObjectHierarchyEvent` for future versions - but if we can make undo/redo less bad with a small change, that would be excellent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:172,Usability,undo,undo,172,"Ah, thank you for investigating this!. The hierarchy event system is horrible, and traces back to the early versions of QuPath where the hierarchy was much more important, undo/redo didn't exist, and we didn't have a good spatial cache from JTS. Then, it was a continual fight to avoid very expensive processing every time an object changed - because `resolveHierarchy()` was effectively being called automatically, and lots of things needed to update. I thinks this shows event system is *very* overdue a major revision. > I'm sure there is reason behind it, but here a hierarchy changed event is emitted, instead of an object added event. From your post and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:1698,Usability,Undo,UndoRedoManager,1698,"ost and my failing memory, I suspect that the idea was that the 'object added' event would just handle a single object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appe",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:1764,Usability,Undo,UndoRedoManager,1764,"ngle object, but if multiple objects were added then we fired a more general structure change event. I guess this was because, when adding a single object, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:2120,Usability,undo,undoingOrRedoing,2120,"t, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dramatically* simplify `PathObjectHierarchyEvent` for future versions - but if we can make undo/redo less bad with a small change, that would be excellent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:2771,Usability,simpl,simplify,2771,"t, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dramatically* simplify `PathObjectHierarchyEvent` for future versions - but if we can make undo/redo less bad with a small change, that would be excellent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306:2848,Usability,undo,undo,2848,"t, we knew that it could only affect ancestor and descendent objects in QuPath v0.1.2 and earlier. But if we changed multiple objects, then all the *potential* auto-resolved parent/child relationships between objects would be too complex to decipher. Instead, it was easier and safer to fire an event that basically said: _'something big changed, don't try to figure out exactly what, but just update to handle the hierarchy as it now is'_. I'm reluctant to switch to `addObjects` firing an event that doesn't include all the objects that were added, in case there is any legacy code that might be sensitive to the change. Which leads to... > So, [this condition](https://github.com/qupath/qupath/blob/3544e613b40fd123236936d76e2cb5ee08d855f7/qupath-gui-fx/src/main/java/qupath/lib/gui/UndoRedoManager.java#L474) is true, the event is ignored, and the UndoRedoManager doesn't update its state. It looks like I failed to recognize that ; ```java; event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject); ```; would return true when `getChangedObjects().isEmpty()`. What it be sufficient to change the problematic condition to this?. ```java; // Try to avoid calling too often; 		if (undoingOrRedoing || event.isChanging() || maxUndoHierarchySize.get() <= 0); 			return;. 		// During processing, we have ParallelTileObjects changing to show which part of the image is being handled; 		// - but we don't want to record these; 		if (!event.getChangedObjects().isEmpty() && event.getChangedObjects().stream().allMatch(p -> p instanceof ParallelTileObject)); 			return;; ```. From a quick try, I think that's enough to fix #1487 but you're deeper into the code than me. The `ParallelTileObjects` are the squares that appear during certain commands, like cell detection, to indicate what is happening. I expect that we could *dramatically* simplify `PathObjectHierarchyEvent` for future versions - but if we can make undo/redo less bad with a small change, that would be excellent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1578#issuecomment-2276091306
https://github.com/qupath/qupath/pull/1579#issuecomment-2277444939:225,Availability,mainten,maintenance,225,"Thanks!. And generally, thank you a lot for taking the time and the chance to do such a core change to QuPath's architecture. I am certain it will have big impacts on the users, however i hope it won't weight too much on the maintenance burdening.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1579#issuecomment-2277444939
https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467:146,Availability,error,error,146,"It sounds like this might be better addressed on the forum, preferably with an example file hosted and shared, the bio-formats tag added, and the error message from the log (question mark, upper right) included. ; There are some Versa related posts as well, at least one as recently as this year - https://forum.image.sc/t/qupath-cant-open-svs-images-from-aperio-versa-slide-scanner/93502/10",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467
https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467:152,Integrability,message,message,152,"It sounds like this might be better addressed on the forum, preferably with an example file hosted and shared, the bio-formats tag added, and the error message from the log (question mark, upper right) included. ; There are some Versa related posts as well, at least one as recently as this year - https://forum.image.sc/t/qupath-cant-open-svs-images-from-aperio-versa-slide-scanner/93502/10",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467
https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467:169,Testability,log,log,169,"It sounds like this might be better addressed on the forum, preferably with an example file hosted and shared, the bio-formats tag added, and the error message from the log (question mark, upper right) included. ; There are some Versa related posts as well, at least one as recently as this year - https://forum.image.sc/t/qupath-cant-open-svs-images-from-aperio-versa-slide-scanner/93502/10",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2276493467
https://github.com/qupath/qupath/issues/1580#issuecomment-2277143810:764,Performance,perform,performance-slow-crashes-loads,764,"Hi @spatts14 as @MichaelSNelson suggests, please try posting this on the forum at https://forum.image.sc/tag/qupath. If it is related to the specific file formats, then QuPath is reading them through Bio-Formats or OpenSlide - and the developers of both are active on the forum as well. I'm afraid that without an example file there is nothing we can do on the QuPath side (and possibly nothing we can do even _with_ a file, if the problem needs a fix in Bio-Formats or OpenSlide). However, because you mention; > It also causes my computer system wide issues and Ive had to restart twice. One possibility is that it is *Finder* crashing and not QuPath. I've seen that before on a Mac. I describe it a little bit [here](https://forum.image.sc/t/qupath-on-mac-poor-performance-slow-crashes-loads/53243/2) - if that's the issue, relaunching Finder (similar to force quitting) should fix that without a restart. It happens when a whole slide image is selected in Finder, and Finder tries to show a preview thumbnail - but it can't because the image is huge. But there's a good chance it's the problem @MichaelSNelson links to - in which case you can try the creating a new project and [specifying 'Bio-Formats' as the 'Image provider'](https://qupath.readthedocs.io/en/stable/docs/tutorials/projects.html#add-images). You may find the images then open, but could be the wrong color. I'll close this issue as there's a better chance of finding success on the forum, and it's not clear that there's a bug in QuPath that we can do anything about.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2277143810
https://github.com/qupath/qupath/issues/1580#issuecomment-2277143810:1475,Usability,clear,clear,1475,"Hi @spatts14 as @MichaelSNelson suggests, please try posting this on the forum at https://forum.image.sc/tag/qupath. If it is related to the specific file formats, then QuPath is reading them through Bio-Formats or OpenSlide - and the developers of both are active on the forum as well. I'm afraid that without an example file there is nothing we can do on the QuPath side (and possibly nothing we can do even _with_ a file, if the problem needs a fix in Bio-Formats or OpenSlide). However, because you mention; > It also causes my computer system wide issues and Ive had to restart twice. One possibility is that it is *Finder* crashing and not QuPath. I've seen that before on a Mac. I describe it a little bit [here](https://forum.image.sc/t/qupath-on-mac-poor-performance-slow-crashes-loads/53243/2) - if that's the issue, relaunching Finder (similar to force quitting) should fix that without a restart. It happens when a whole slide image is selected in Finder, and Finder tries to show a preview thumbnail - but it can't because the image is huge. But there's a good chance it's the problem @MichaelSNelson links to - in which case you can try the creating a new project and [specifying 'Bio-Formats' as the 'Image provider'](https://qupath.readthedocs.io/en/stable/docs/tutorials/projects.html#add-images). You may find the images then open, but could be the wrong color. I'll close this issue as there's a better chance of finding success on the forum, and it's not clear that there's a bug in QuPath that we can do anything about.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2277143810
https://github.com/qupath/qupath/issues/1580#issuecomment-2277736935:39,Usability,feedback,feedback,39,Thanks so much for the suggestions and feedback!,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1580#issuecomment-2277736935
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:524,Integrability,interface,interface,524,"The use of a manager still feels a bit strange to me, but I'm open to being convinced. It's a reasonable mechanism if we want to ensure that sorting is something handled *entirely* by the UI, and isn't an inherent part of projects. But then we should use the existing [`Project.getResources(String, Class, String)`](https://qupath.github.io/javadoc/docs/qupath/lib/projects/Project.html#getResources(java.lang.String,java.lang.Class,java.lang.String)) rather than introduce a new `Project.getSortingKeys()` to the `Project` interface. I think it's also preferable to store all such resources within a `resources` subdirectory, as done [here](https://github.com/qupath/qupath/blob/db71980322fbdcb47ad54599ef71d21d8f2c5f94/qupath-gui-fx/src/main/java/qupath/lib/display/settings/DisplaySettingUtils.java#L201). With this PR, I get a new `sorting_keys` directory directly within the project. I also got a file `SORT_KEY[IMAGE_NAME].txt` with the only content `true`; I was expecting e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - o",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:1809,Integrability,interface,interface,1809,"01). With this PR, I get a new `sorting_keys` directory directly within the project. I also got a file `SORT_KEY[IMAGE_NAME].txt` with the only content `true`; I was expecting e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - or adding `String` metadata support similar to how it already works with [`ProjectImageEntry`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/projects/ProjectImageEntry.java#L49)?. Then the UI can store keys as a list of strings easily, with any key of its choosing and the result serialized within the project. To me, a `Map<String, String>` feels simpler and more intuitive. The advantages I see of a `Manager` are:; 1. It avoids adding to the `project.qpproj` file size (in case someone attempts to add ridiculously-large strings); 2. The sort order wouldn't be lost if a project is saved in an older version of QuPath. But these are only an issue of the `Map` is serialized directly within `project.qpproj`. We *could* potentially ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:1785,Modifiability,extend,extending,1785,"01). With this PR, I get a new `sorting_keys` directory directly within the project. I also got a file `SORT_KEY[IMAGE_NAME].txt` with the only content `true`; I was expecting e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - or adding `String` metadata support similar to how it already works with [`ProjectImageEntry`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/projects/ProjectImageEntry.java#L49)?. Then the UI can store keys as a list of strings easily, with any key of its choosing and the result serialized within the project. To me, a `Map<String, String>` feels simpler and more intuitive. The advantages I see of a `Manager` are:; 1. It avoids adding to the `project.qpproj` file size (in case someone attempts to add ridiculously-large strings); 2. The sort order wouldn't be lost if a project is saved in an older version of QuPath. But these are only an issue of the `Map` is serialized directly within `project.qpproj`. We *could* potentially ",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:2494,Safety,avoid,avoids,2494,"ing e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - or adding `String` metadata support similar to how it already works with [`ProjectImageEntry`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/projects/ProjectImageEntry.java#L49)?. Then the UI can store keys as a list of strings easily, with any key of its choosing and the result serialized within the project. To me, a `Map<String, String>` feels simpler and more intuitive. The advantages I see of a `Manager` are:; 1. It avoids adding to the `project.qpproj` file size (in case someone attempts to add ridiculously-large strings); 2. The sort order wouldn't be lost if a project is saved in an older version of QuPath. But these are only an issue of the `Map` is serialized directly within `project.qpproj`. We *could* potentially overcome both of these by storing the `Map` in a separate `.json` file anyway within `resources/sorting` - without needing to rely on `Manager` to do so. What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:2418,Usability,simpl,simpler,2418,"ing e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - or adding `String` metadata support similar to how it already works with [`ProjectImageEntry`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/projects/ProjectImageEntry.java#L49)?. Then the UI can store keys as a list of strings easily, with any key of its choosing and the result serialized within the project. To me, a `Map<String, String>` feels simpler and more intuitive. The advantages I see of a `Manager` are:; 1. It avoids adding to the `project.qpproj` file size (in case someone attempts to add ridiculously-large strings); 2. The sort order wouldn't be lost if a project is saved in an older version of QuPath. But these are only an issue of the `Map` is serialized directly within `project.qpproj`. We *could* potentially overcome both of these by storing the `Map` in a separate `.json` file anyway within `resources/sorting` - without needing to rely on `Manager` to do so. What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470:2435,Usability,intuit,intuitive,2435,"ing e.g. a `sort_keys.txt` file with a list of the keys that are used. The purpose of `ResourceManager` (for me at least) is that it supports having several named resources, typically implementations of a specific serializable class. So we might have something like this:. ```java; class SortingKeys {; List<String> keys;. List<String> getKeys() {; return Collections.unmodifiableList(keys);; }. }. var sortingManager = project.getResources(""resources/sorting_keys"", SortingKeys.class, ""json"");; var sortKeys = sortingManager.contains(""sortKeys"") ? sortingManager.getResource(""sortKeys).getKeys() : Collections.emtpyList();; ```; but then it is still 'unconventional' to use a `Manager` when we only have a single resource with a fixed name (here, `""sortKeys""`). ---. What not use the alternative approach of extending the `Project` interface to implement [`MetadataStore`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataStore.java#L37) - or adding `String` metadata support similar to how it already works with [`ProjectImageEntry`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/projects/ProjectImageEntry.java#L49)?. Then the UI can store keys as a list of strings easily, with any key of its choosing and the result serialized within the project. To me, a `Map<String, String>` feels simpler and more intuitive. The advantages I see of a `Manager` are:; 1. It avoids adding to the `project.qpproj` file size (in case someone attempts to add ridiculously-large strings); 2. The sort order wouldn't be lost if a project is saved in an older version of QuPath. But these are only an issue of the `Map` is serialized directly within `project.qpproj`. We *could* potentially overcome both of these by storing the `Map` in a separate `.json` file anyway within `resources/sorting` - without needing to rely on `Manager` to do so. What do you think?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2283509470
https://github.com/qupath/qupath/pull/1584#issuecomment-2284138981:110,Integrability,interface,interface,110,"I removed the use of `Managers` and instead added three functions to set/get/delete metadata in the `Project` interface. In `DefaultProject`, this is implemented by using a `metadata.json` file at the root directory of the project. The sorting key is stored as one metadata value. In the current implementation, we only have one sorting key, but we could add more by converting a list of sorting keys to a `String`. Is that what you had in mind?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2284138981
https://github.com/qupath/qupath/pull/1584#issuecomment-2284332188:43,Modifiability,extend,extend,43,> Do both by updating ProjectImageEntry to extend MetadataStore. I think I'd prefer that option. The only problem I had with `MetadataStore` is that it doesn't have a method to delete a value. Can I add one?,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2284332188
https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913:1370,Integrability,interface,interface,1370,"; ```; that assumes `String` only. The map is documented to be unmodifiable, but [at least once in QuPath's code it is assumed to be modifiable](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/PathObjectTools.java#L1527). *If* we don't need non-string objects (we'd need to check usages), I am thinking that we could deprecate all other methods in `MetadataStore`, leaving only `getMetadataMap()` to return a *modifiable* `Map<String, String>` - and provide default implementations for the other methods. Then, in this case, you could potentially provide a `Map` implementation that takes care of JSON serialization by subclassing [`AbstractMap`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Map.html#get(java.lang.Object)). Since I was responsible for the original `MetadataStore` mess (and the associated [`MetadataMap`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataMap.java#L49)), I can look into how changing the interface might impact `PathObject`, where it is currently used. *If* you think this is a sensible approach, then you could proceed here by adding; ```java; public Map<String, String> getMetadataMap() // Or getMetadata() - see below; ```; and handling its implementation and (JSON) serialization - then any common interface that includes that method can be added later to `Project`, `ProjectImageEntry` and `PathObject`. What do you think?. One benefit of using a standard `Map` implementation is that Groovy scripting is nicer, e.g. see; * https://github.com/qupath/qupath/issues/1085. which is why we can now use `pathObject.measurements['Something'] = 2.0`. In fact, if we simplified the name further to `getMetadata()` the this should work in Groovy:; ```; pathObject.metadata['Something'] = 'A value'; project.metadata['Something'] = 'A value'; entry.metadata['Something'] = 'A value'; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913
https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913:1684,Integrability,interface,interface,1684,"; ```; that assumes `String` only. The map is documented to be unmodifiable, but [at least once in QuPath's code it is assumed to be modifiable](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/PathObjectTools.java#L1527). *If* we don't need non-string objects (we'd need to check usages), I am thinking that we could deprecate all other methods in `MetadataStore`, leaving only `getMetadataMap()` to return a *modifiable* `Map<String, String>` - and provide default implementations for the other methods. Then, in this case, you could potentially provide a `Map` implementation that takes care of JSON serialization by subclassing [`AbstractMap`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Map.html#get(java.lang.Object)). Since I was responsible for the original `MetadataStore` mess (and the associated [`MetadataMap`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataMap.java#L49)), I can look into how changing the interface might impact `PathObject`, where it is currently used. *If* you think this is a sensible approach, then you could proceed here by adding; ```java; public Map<String, String> getMetadataMap() // Or getMetadata() - see below; ```; and handling its implementation and (JSON) serialization - then any common interface that includes that method can be added later to `Project`, `ProjectImageEntry` and `PathObject`. What do you think?. One benefit of using a standard `Map` implementation is that Groovy scripting is nicer, e.g. see; * https://github.com/qupath/qupath/issues/1085. which is why we can now use `pathObject.measurements['Something'] = 2.0`. In fact, if we simplified the name further to `getMetadata()` the this should work in Groovy:; ```; pathObject.metadata['Something'] = 'A value'; project.metadata['Something'] = 'A value'; entry.metadata['Something'] = 'A value'; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913
https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913:2046,Usability,simpl,simplified,2046,"; ```; that assumes `String` only. The map is documented to be unmodifiable, but [at least once in QuPath's code it is assumed to be modifiable](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/PathObjectTools.java#L1527). *If* we don't need non-string objects (we'd need to check usages), I am thinking that we could deprecate all other methods in `MetadataStore`, leaving only `getMetadataMap()` to return a *modifiable* `Map<String, String>` - and provide default implementations for the other methods. Then, in this case, you could potentially provide a `Map` implementation that takes care of JSON serialization by subclassing [`AbstractMap`](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/Map.html#get(java.lang.Object)). Since I was responsible for the original `MetadataStore` mess (and the associated [`MetadataMap`](https://github.com/qupath/qupath/blob/df21dcbaab953837d40aabd856d14b79faca6b7b/qupath-core/src/main/java/qupath/lib/objects/MetadataMap.java#L49)), I can look into how changing the interface might impact `PathObject`, where it is currently used. *If* you think this is a sensible approach, then you could proceed here by adding; ```java; public Map<String, String> getMetadataMap() // Or getMetadata() - see below; ```; and handling its implementation and (JSON) serialization - then any common interface that includes that method can be added later to `Project`, `ProjectImageEntry` and `PathObject`. What do you think?. One benefit of using a standard `Map` implementation is that Groovy scripting is nicer, e.g. see; * https://github.com/qupath/qupath/issues/1085. which is why we can now use `pathObject.measurements['Something'] = 2.0`. In fact, if we simplified the name further to `getMetadata()` the this should work in Groovy:; ```; pathObject.metadata['Something'] = 'A value'; project.metadata['Something'] = 'A value'; entry.metadata['Something'] = 'A value'; ```",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2284505913
https://github.com/qupath/qupath/pull/1584#issuecomment-2285962728:2,Deployability,update,updated,2,"I updated the `MetadataStore` and changed `Project` and `DefaultProject` accordingly. I didn't update other classes that were using `MetadataStore` like `TMACoreObject`, and I didn't make `ProjectImageEntry` implements `MetadataStore`. Should I do that here, or create another PR?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2285962728
https://github.com/qupath/qupath/pull/1584#issuecomment-2285962728:95,Deployability,update,update,95,"I updated the `MetadataStore` and changed `Project` and `DefaultProject` accordingly. I didn't update other classes that were using `MetadataStore` like `TMACoreObject`, and I didn't make `ProjectImageEntry` implements `MetadataStore`. Should I do that here, or create another PR?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2285962728
https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202:614,Integrability,interface,interface,614,"> Should I do that here, or create another PR?. No, I think this PR should focus on adding `Project.getMetadata()` - anything else can/should be done later. Before going further with the general metadata support, I'd like to make sure that I was never using an `Object` with the `MetadataStore` within `PathObject`, in case that could be an issue. We also discussed having a new repo and module (`qupath-lib` perhaps?) similar to `qupath-fxtras` that contains generally-useful stuff that we can make permissively-licensed (i.e. Apache rather than GPL). I'd like to investigate adding a new, simple `MetadataStore` interface to that module, so that we can deprecate the old interface entirely - but I don't want to rush that, and need to find an hour or two to think about it properly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202
https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202:673,Integrability,interface,interface,673,"> Should I do that here, or create another PR?. No, I think this PR should focus on adding `Project.getMetadata()` - anything else can/should be done later. Before going further with the general metadata support, I'd like to make sure that I was never using an `Object` with the `MetadataStore` within `PathObject`, in case that could be an issue. We also discussed having a new repo and module (`qupath-lib` perhaps?) similar to `qupath-fxtras` that contains generally-useful stuff that we can make permissively-licensed (i.e. Apache rather than GPL). I'd like to investigate adding a new, simple `MetadataStore` interface to that module, so that we can deprecate the old interface entirely - but I don't want to rush that, and need to find an hour or two to think about it properly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202
https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202:591,Usability,simpl,simple,591,"> Should I do that here, or create another PR?. No, I think this PR should focus on adding `Project.getMetadata()` - anything else can/should be done later. Before going further with the general metadata support, I'd like to make sure that I was never using an `Object` with the `MetadataStore` within `PathObject`, in case that could be an issue. We also discussed having a new repo and module (`qupath-lib` perhaps?) similar to `qupath-fxtras` that contains generally-useful stuff that we can make permissively-licensed (i.e. Apache rather than GPL). I'd like to investigate adding a new, simple `MetadataStore` interface to that module, so that we can deprecate the old interface entirely - but I don't want to rush that, and need to find an hour or two to think about it properly.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1584#issuecomment-2286003202
https://github.com/qupath/qupath/issues/1586#issuecomment-2339638253:106,Deployability,release,release,106,I've merged a proposed fix at https://github.com/qupath/qupath/pull/1620 which will be in the next QuPath release.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1586#issuecomment-2339638253
https://github.com/qupath/qupath/pull/1588#issuecomment-2317256340:124,Deployability,toggle,toggle,124,"Agree, think it's better to show things with missing class/measurement, imo showing them last is better but that could be a toggle",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2317256340
https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903:917,Availability,avail,available,917,"Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. The name is especially informative for TMA cores, but it looks like we don't currently have a way to display it. Minor thing: when I assign a classification to a core _after_ displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903
https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903:949,Availability,down,down,949,"Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. The name is especially informative for TMA cores, but it looks like we don't currently have a way to display it. Minor thing: when I assign a classification to a core _after_ displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903
https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903:169,Testability,stub,stubbornly,169,"Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. The name is especially informative for TMA cores, but it looks like we don't currently have a way to display it. Minor thing: when I assign a classification to a core _after_ displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2321529903
https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926:1068,Availability,avail,available,1068,"> Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Ah yes, I think I misunderstood what my sorting logic was doing; should now be fixed. > Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. That's intuitive to me, although it does somewhat point to the odd behaviour about unclassified things having a null class, or `PathClass.NULL_CLASS`... > And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. Sounds good, done. > Minor thing: when I assign a classification to a core after displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible. This should be fixed now, with only minor cursing at ControlsFX",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926
https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926:1100,Availability,down,down,1100,"> Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Ah yes, I think I misunderstood what my sorting logic was doing; should now be fixed. > Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. That's intuitive to me, although it does somewhat point to the odd behaviour about unclassified things having a null class, or `PathClass.NULL_CLASS`... > And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. Sounds good, done. > Minor thing: when I assign a classification to a core after displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible. This should be fixed now, with only minor cursing at ControlsFX",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926
https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926:171,Testability,stub,stubbornly,171,"> Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Ah yes, I think I misunderstood what my sorting logic was doing; should now be fixed. > Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. That's intuitive to me, although it does somewhat point to the odd behaviour about unclassified things having a null class, or `PathClass.NULL_CLASS`... > And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. Sounds good, done. > Minor thing: when I assign a classification to a core after displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible. This should be fixed now, with only minor cursing at ControlsFX",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926
https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926:342,Testability,log,logic,342,"> Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Ah yes, I think I misunderstood what my sorting logic was doing; should now be fixed. > Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. That's intuitive to me, although it does somewhat point to the odd behaviour about unclassified things having a null class, or `PathClass.NULL_CLASS`... > And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. Sounds good, done. > Minor thing: when I assign a classification to a core after displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible. This should be fixed now, with only minor cursing at ControlsFX",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926
https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926:548,Usability,intuit,intuitive,548,"> Mmmm, I find I have no way to hide the unclassified TMA cores. And sorting my ascending/descending seems to only impact the two that I gave classes to - the rest remain stubbornly as they were (both before and after the classified core) - so I initially didn't think sorting was implemented. Ah yes, I think I misunderstood what my sorting logic was doing; should now be fixed. > Since we aren't dealing with NaNs, I have the feeling that string sorting would make sense here... even if that means 'Unclassified' being sorted as a string. That's intuitive to me, although it does somewhat point to the odd behaviour about unclassified things having a null class, or `PathClass.NULL_CLASS`... > And actually... what do you think about having 'Name' as another potential 'Measurement'... which we could relabel 'Sort by'? Then we could change 'Show measurement' to 'Show value' - both to save space, and because we're no longer limited to measurements. Sounds good, done. > Minor thing: when I assign a classification to a core after displaying the grid, this becomes available in the 'Classes' drop-down - which is nice. The less nice thing is that all the classes there appear deselected.... but aren't necessarily not visible. This should be fixed now, with only minor cursing at ControlsFX",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1588#issuecomment-2329158926
https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850:436,Deployability,toggle,toggle,436,"1 is clearly wrong to me; should probably be equivalent to selecting the outer rectangle, and definitely not throw a concurrent exception (whether or not it throws another exception, or a warning about undefined behaviour is another question). I think as much as it may not be intuitive, using the object hierarchy here is more flexible (ie, there may be situations where this is what people want to do, and as long as it's possible to toggle between, I tend to prefer flexibility). For 4, I can't decide if I should expect connections between disjoint annotations when both are selected. I think.... no...?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850
https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850:328,Modifiability,flexible,flexible,328,"1 is clearly wrong to me; should probably be equivalent to selecting the outer rectangle, and definitely not throw a concurrent exception (whether or not it throws another exception, or a warning about undefined behaviour is another question). I think as much as it may not be intuitive, using the object hierarchy here is more flexible (ie, there may be situations where this is what people want to do, and as long as it's possible to toggle between, I tend to prefer flexibility). For 4, I can't decide if I should expect connections between disjoint annotations when both are selected. I think.... no...?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850
https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850:117,Performance,concurren,concurrent,117,"1 is clearly wrong to me; should probably be equivalent to selecting the outer rectangle, and definitely not throw a concurrent exception (whether or not it throws another exception, or a warning about undefined behaviour is another question). I think as much as it may not be intuitive, using the object hierarchy here is more flexible (ie, there may be situations where this is what people want to do, and as long as it's possible to toggle between, I tend to prefer flexibility). For 4, I can't decide if I should expect connections between disjoint annotations when both are selected. I think.... no...?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850
https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850:5,Usability,clear,clearly,5,"1 is clearly wrong to me; should probably be equivalent to selecting the outer rectangle, and definitely not throw a concurrent exception (whether or not it throws another exception, or a warning about undefined behaviour is another question). I think as much as it may not be intuitive, using the object hierarchy here is more flexible (ie, there may be situations where this is what people want to do, and as long as it's possible to toggle between, I tend to prefer flexibility). For 4, I can't decide if I should expect connections between disjoint annotations when both are selected. I think.... no...?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850
https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850:277,Usability,intuit,intuitive,277,"1 is clearly wrong to me; should probably be equivalent to selecting the outer rectangle, and definitely not throw a concurrent exception (whether or not it throws another exception, or a warning about undefined behaviour is another question). I think as much as it may not be intuitive, using the object hierarchy here is more flexible (ie, there may be situations where this is what people want to do, and as long as it's possible to toggle between, I tend to prefer flexibility). For 4, I can't decide if I should expect connections between disjoint annotations when both are selected. I think.... no...?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1590#issuecomment-2312272850
https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713:229,Availability,avail,available,229,"The last commit adds a toolbar button to show detection 'connections' (neighbors based on a Delaunay triangulation):. ![image](https://github.com/user-attachments/assets/90878352-9335-4163-aa36-9f1517225b31). This was previously available under the *View* command, but only actively did anything if the *Delaunay cluster features 2D* command had been run. Now, it can be used at any time and will show connecting lines for cells (if available), or detections (if there are no cells). Currently, it is only a visual tool - using the new features require scripts such as those described above.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713
https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713:433,Availability,avail,available,433,"The last commit adds a toolbar button to show detection 'connections' (neighbors based on a Delaunay triangulation):. ![image](https://github.com/user-attachments/assets/90878352-9335-4163-aa36-9f1517225b31). This was previously available under the *View* command, but only actively did anything if the *Delaunay cluster features 2D* command had been run. Now, it can be used at any time and will show connecting lines for cells (if available), or detections (if there are no cells). Currently, it is only a visual tool - using the new features require scripts such as those described above.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713
https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713:46,Safety,detect,detection,46,"The last commit adds a toolbar button to show detection 'connections' (neighbors based on a Delaunay triangulation):. ![image](https://github.com/user-attachments/assets/90878352-9335-4163-aa36-9f1517225b31). This was previously available under the *View* command, but only actively did anything if the *Delaunay cluster features 2D* command had been run. Now, it can be used at any time and will show connecting lines for cells (if available), or detections (if there are no cells). Currently, it is only a visual tool - using the new features require scripts such as those described above.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713
https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713:448,Safety,detect,detections,448,"The last commit adds a toolbar button to show detection 'connections' (neighbors based on a Delaunay triangulation):. ![image](https://github.com/user-attachments/assets/90878352-9335-4163-aa36-9f1517225b31). This was previously available under the *View* command, but only actively did anything if the *Delaunay cluster features 2D* command had been run. Now, it can be used at any time and will show connecting lines for cells (if available), or detections (if there are no cells). Currently, it is only a visual tool - using the new features require scripts such as those described above.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2305236713
https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353:28,Safety,Detect,Detect,28,"I am encountering a bug; 1. Detect cells using something (StarDist, I did it with no cell expansion); 2. Run the script ; ```; def hierarchy = getCurrentHierarchy(); def cells = getDetectionObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size() ; }; ```; 3. Try to remove the neighbors in another script; ```; def hierarchy = getCurrentHierarchy(); hierarchy.resetNeighbors(); ```; This does nothing; 4. Delete the cells and recompute them (by running StarDist again on the same region); 5. The cells still have the connections shown; 6. Run cell detection in a *new* region: The new cells also have connections; 7. Open another image that already had cells detected. Some cell regions also have connections where there were none before; 8. On this other image, trying to add neighbors to detections inside a new parent using the first script results works (Num Neighbors exists) but neighbor conenctions are not drawn in the viewer (although they are still showing for the previous detections)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353
https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353:603,Safety,detect,detection,603,"I am encountering a bug; 1. Detect cells using something (StarDist, I did it with no cell expansion); 2. Run the script ; ```; def hierarchy = getCurrentHierarchy(); def cells = getDetectionObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size() ; }; ```; 3. Try to remove the neighbors in another script; ```; def hierarchy = getCurrentHierarchy(); hierarchy.resetNeighbors(); ```; This does nothing; 4. Delete the cells and recompute them (by running StarDist again on the same region); 5. The cells still have the connections shown; 6. Run cell detection in a *new* region: The new cells also have connections; 7. Open another image that already had cells detected. Some cell regions also have connections where there were none before; 8. On this other image, trying to add neighbors to detections inside a new parent using the first script results works (Num Neighbors exists) but neighbor conenctions are not drawn in the viewer (although they are still showing for the previous detections)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353
https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353:714,Safety,detect,detected,714,"I am encountering a bug; 1. Detect cells using something (StarDist, I did it with no cell expansion); 2. Run the script ; ```; def hierarchy = getCurrentHierarchy(); def cells = getDetectionObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size() ; }; ```; 3. Try to remove the neighbors in another script; ```; def hierarchy = getCurrentHierarchy(); hierarchy.resetNeighbors(); ```; This does nothing; 4. Delete the cells and recompute them (by running StarDist again on the same region); 5. The cells still have the connections shown; 6. Run cell detection in a *new* region: The new cells also have connections; 7. Open another image that already had cells detected. Some cell regions also have connections where there were none before; 8. On this other image, trying to add neighbors to detections inside a new parent using the first script results works (Num Neighbors exists) but neighbor conenctions are not drawn in the viewer (although they are still showing for the previous detections)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353
https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353:845,Safety,detect,detections,845,"I am encountering a bug; 1. Detect cells using something (StarDist, I did it with no cell expansion); 2. Run the script ; ```; def hierarchy = getCurrentHierarchy(); def cells = getDetectionObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size() ; }; ```; 3. Try to remove the neighbors in another script; ```; def hierarchy = getCurrentHierarchy(); hierarchy.resetNeighbors(); ```; This does nothing; 4. Delete the cells and recompute them (by running StarDist again on the same region); 5. The cells still have the connections shown; 6. Run cell detection in a *new* region: The new cells also have connections; 7. Open another image that already had cells detected. Some cell regions also have connections where there were none before; 8. On this other image, trying to add neighbors to detections inside a new parent using the first script results works (Num Neighbors exists) but neighbor conenctions are not drawn in the viewer (although they are still showing for the previous detections)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353
https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353:1039,Safety,detect,detections,1039,"I am encountering a bug; 1. Detect cells using something (StarDist, I did it with no cell expansion); 2. Run the script ; ```; def hierarchy = getCurrentHierarchy(); def cells = getDetectionObjects(); for (cell in cells) {; cell.measurements['Num neighbors'] = hierarchy.findAllNeighbors(cell).size() ; }; ```; 3. Try to remove the neighbors in another script; ```; def hierarchy = getCurrentHierarchy(); hierarchy.resetNeighbors(); ```; This does nothing; 4. Delete the cells and recompute them (by running StarDist again on the same region); 5. The cells still have the connections shown; 6. Run cell detection in a *new* region: The new cells also have connections; 7. Open another image that already had cells detected. Some cell regions also have connections where there were none before; 8. On this other image, trying to add neighbors to detections inside a new parent using the first script results works (Num Neighbors exists) but neighbor conenctions are not drawn in the viewer (although they are still showing for the previous detections)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404588353
https://github.com/qupath/qupath/pull/1597#issuecomment-2404668520:550,Safety,avoid,avoid,550,"Have you run the (deprecated) _Analyze → Spatial analysis → Delaunay cluster features 2D_ command on any of these images, at any time?. If so, this can mess things up... When using the new command only, connections should be generated any time they are requested (including for visualisation). Resetting them only serves to request that they are recalculated on the next request. This behavior is entirely different from the old _Delaunay cluster features 2D_ command, where you had to explicitly request connections to be made. The goal here was to avoid the need for that extra step, so that querying connections is _always_ possible. (But this is also why the work is unfinished... because we don't have a good way to add in extra criteria for the visualisation, such as only generating connections less than a specified distance). If you've run _Delaunay cluster features 2D_ then this causes trouble because it sets a property within `ImageData`, and currently this is visualised instead when it's present. Sometimes the property gets out of sync with the original data, which is even worse, but that isn't a new bug.. and contributes to the reasons why _Delaunay cluster features 2D_ is deprecated.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404668520
https://github.com/qupath/qupath/pull/1597#issuecomment-2404738344:79,Testability,Test,Test,79,"I had not run the command to my knowledge, but seeing as it was an old QuPath ""Test project"" that I keep around it is entirely possible that I *had* run Delaunay at one point in the past. Thanks for the information. I see, so once the neighborhoot information has been asked once, then it will keep on computing it, no matter what, and then we can do what we want with it, with the current limitations you mentioned. ; Thank you for the information. Oli",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1597#issuecomment-2404738344
https://github.com/qupath/qupath/pull/1601#issuecomment-2312153765:58,Usability,Simpl,SimpleBooleanProperty,58,"What's the motivation in switching from ; ```java; public SimpleBooleanProperty(boolean initialValue); ```; to; ```java; public SimpleBooleanProperty(Object bean,; String name,; boolean initialValue); ```; ?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1601#issuecomment-2312153765
https://github.com/qupath/qupath/pull/1601#issuecomment-2312153765:128,Usability,Simpl,SimpleBooleanProperty,128,"What's the motivation in switching from ; ```java; public SimpleBooleanProperty(boolean initialValue); ```; to; ```java; public SimpleBooleanProperty(Object bean,; String name,; boolean initialValue); ```; ?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1601#issuecomment-2312153765
https://github.com/qupath/qupath/pull/1601#issuecomment-2312160962:22,Availability,down,down,22,The lazy code further down where I loop through properties and make them persistent there. Using the name makes it easier to assign them a sensible persistent key.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1601#issuecomment-2312160962
https://github.com/qupath/qupath/pull/1603#issuecomment-2311817615:53,Safety,avoid,avoid,53,Nested record patterns seem a feature I would rather avoid,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1603#issuecomment-2311817615
https://github.com/qupath/qupath/pull/1604#issuecomment-2310704919:24,Deployability,update,update,24,"Ah, yes I was trying to update the javadocs site/action to host multiple versions (a la https://qupath.github.io/qupath-fxtras/stable/qupath.fx/module-summary.html) but without mergedJavadocs, I couldn't get my head around gradle well enough to recreate it from the component pieces",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1604#issuecomment-2310704919
https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023:404,Availability,down,downloads,404,"I'm afraid that, as an open-source project, we don't have the time or resources to provide code signing certificates at this time. We'd potentially need certificates for all operating systems, and it's not something we can work on right now. We provide full instructions to build QuPath from the source code, so if it helps your IT department could build a version themselves, rather than relying on the downloads here: https://qupath.readthedocs.io/en/stable/docs/reference/building.html",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023
https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023:104,Security,certificate,certificates,104,"I'm afraid that, as an open-source project, we don't have the time or resources to provide code signing certificates at this time. We'd potentially need certificates for all operating systems, and it's not something we can work on right now. We provide full instructions to build QuPath from the source code, so if it helps your IT department could build a version themselves, rather than relying on the downloads here: https://qupath.readthedocs.io/en/stable/docs/reference/building.html",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023
https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023:153,Security,certificate,certificates,153,"I'm afraid that, as an open-source project, we don't have the time or resources to provide code signing certificates at this time. We'd potentially need certificates for all operating systems, and it's not something we can work on right now. We provide full instructions to build QuPath from the source code, so if it helps your IT department could build a version themselves, rather than relying on the downloads here: https://qupath.readthedocs.io/en/stable/docs/reference/building.html",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1605#issuecomment-2312201023
https://github.com/qupath/qupath/issues/1609#issuecomment-2316693891:122,Integrability,interface,interface,122,"There is no Chinese translation of QuPath, sorry. We would like to make it possible for people to translate QuPath's user interface in the future, but this will require a lot of additional work and it is currently not possible. The forum is a better place to discuss this. There is already a topic at https://forum.image.sc/t/qupath-internationalize-multi-language-support/77468",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1609#issuecomment-2316693891
https://github.com/qupath/qupath/pull/1620#issuecomment-2328789141:172,Availability,down,downloaded,172,"`.ndpis` should work on Windows and Linux, and with an Intel build on Mac - but not the Apple Silicon build. But the extra files should have the extension `.ndpi` - if you downloaded them on a Mac, the OS might automatically have added `.tiff` to the name and this needs to be removed.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1620#issuecomment-2328789141
https://github.com/qupath/qupath/pull/1620#issuecomment-2328940858:143,Availability,error,error,143,"> Can you rename .tiff to .ndpi? They are .ndpi via the link, and that's what they should be. OK I didn't understand that, but I still got the error:. ![image](https://github.com/user-attachments/assets/dff4b9c4-f1e4-4a48-8fb3-0a85ef356f6a). Anyway this is not related to this PR, so we can skip that for now.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1620#issuecomment-2328940858
https://github.com/qupath/qupath/pull/1623#issuecomment-2332558420:383,Availability,down,downsample,383,"Another example... zoomed in much more, and the distinction is more obvious when the boundaries are tracing pixels. ## Previous. ![Older-unconvincing](https://github.com/user-attachments/assets/53dff476-2374-4ab1-933c-3ef40a8b3300). ### With this PR. ![Newer-questionable](https://github.com/user-attachments/assets/a6f3af0a-c680-4ec2-aedf-3a24b522dcae). Note that when viewing at a downsample ≥ 1, there is no difference in behavior.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623#issuecomment-2332558420
https://github.com/qupath/qupath/pull/1623#issuecomment-2333206629:168,Safety,detect,detections,168,"I've added a new preference so that this can be turned on/off, to help us explore if we like it or not. (If it stays, we might need to tweak the behavior a bit to make detections easier to see in other ways - especially cells, where the boundaries may be too faint currently). <img width=""549"" alt=""Dynamic thickness"" src=""https://github.com/user-attachments/assets/72f3efa3-d3f6-4d47-a79e-13defcc96248"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1623#issuecomment-2333206629
https://github.com/qupath/qupath/pull/1625#issuecomment-2339545085:12,Testability,test,test,12,"The failing test is a mystery - I can confirm it works locally on my Windows (10) computer as well. Re. the temp directories, should it clean up afterwards? From [the javadocs](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/nio/file/Files.html#createTempDirectory(java.nio.file.Path,java.lang.String,java.nio.file.attribute.FileAttribute...)). > As with the `createTempFile` methods, this method is only part of a temporary-file facility. A [shutdown-hook](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Runtime.html#addShutdownHook(java.lang.Thread)), or the [File.deleteOnExit()](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/io/File.html#deleteOnExit()) mechanism may be used to delete the directory automatically.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1625#issuecomment-2339545085
https://github.com/qupath/qupath/issues/1635#issuecomment-2345968313:35,Deployability,update,updated,35,"The stardist extension hasn't been updated for QuPath 0.6 yet. I'd suggest one of these three options:. 1. Test stardist using QuPath 0.5.1; 2. Build the latest stardist extension from source, ideally this branch: https://github.com/qupath/qupath-extension-stardist/pull/36; 3. Use the Jar file attached below in QuPath 0.6.0-rc1. [qupath-extension-stardist-0.6.0-SNAPSHOT.zip](https://github.com/user-attachments/files/16977870/qupath-extension-stardist-0.6.0-SNAPSHOT.zip)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2345968313
https://github.com/qupath/qupath/issues/1635#issuecomment-2345968313:107,Testability,Test,Test,107,"The stardist extension hasn't been updated for QuPath 0.6 yet. I'd suggest one of these three options:. 1. Test stardist using QuPath 0.5.1; 2. Build the latest stardist extension from source, ideally this branch: https://github.com/qupath/qupath-extension-stardist/pull/36; 3. Use the Jar file attached below in QuPath 0.6.0-rc1. [qupath-extension-stardist-0.6.0-SNAPSHOT.zip](https://github.com/user-attachments/files/16977870/qupath-extension-stardist-0.6.0-SNAPSHOT.zip)",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2345968313
https://github.com/qupath/qupath/issues/1635#issuecomment-2346021169:384,Deployability,upgrade,upgrade,384,"Thanks @ofrag and @alanocallaghan, I'll close this issue because it's really one for the StartDist extension repo. We already have an open PR for compatibility at https://github.com/qupath/qupath-extension-stardist/pull/36 and plan to ensure it's compatible when v0.6.0 is finalized. We're reluctant to do it too early, because then QuPath v0.5.x users might receive notifications to upgrade their extension... and the new one won't be compatible with v0.5, which would cause a new set of problems.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2346021169
https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465:37,Deployability,update,updated,37,"> The stardist extension hasn't been updated for QuPath 0.6 yet. I'd suggest one of these three options:; > ; > 1. Test stardist using QuPath 0.5.1; > 2. Build the latest stardist extension from source, ideally this branch: [Update for QuPath v0.6 qupath-extension-stardist#36](https://github.com/qupath/qupath-extension-stardist/pull/36); > 3. Use the Jar file attached below in QuPath 0.6.0-rc1.; > ; > [qupath-extension-stardist-0.6.0-SNAPSHOT.zip](https://github.com/user-attachments/files/16977870/qupath-extension-stardist-0.6.0-SNAPSHOT.zip). Thanks @alanocallaghan . The new jar solved the issue. ; (QP 0.5.1 is working well with Stardist extension 0.5.0). best; Ofra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465
https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465:225,Deployability,Update,Update,225,"> The stardist extension hasn't been updated for QuPath 0.6 yet. I'd suggest one of these three options:; > ; > 1. Test stardist using QuPath 0.5.1; > 2. Build the latest stardist extension from source, ideally this branch: [Update for QuPath v0.6 qupath-extension-stardist#36](https://github.com/qupath/qupath-extension-stardist/pull/36); > 3. Use the Jar file attached below in QuPath 0.6.0-rc1.; > ; > [qupath-extension-stardist-0.6.0-SNAPSHOT.zip](https://github.com/user-attachments/files/16977870/qupath-extension-stardist-0.6.0-SNAPSHOT.zip). Thanks @alanocallaghan . The new jar solved the issue. ; (QP 0.5.1 is working well with Stardist extension 0.5.0). best; Ofra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465
https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465:115,Testability,Test,Test,115,"> The stardist extension hasn't been updated for QuPath 0.6 yet. I'd suggest one of these three options:; > ; > 1. Test stardist using QuPath 0.5.1; > 2. Build the latest stardist extension from source, ideally this branch: [Update for QuPath v0.6 qupath-extension-stardist#36](https://github.com/qupath/qupath-extension-stardist/pull/36); > 3. Use the Jar file attached below in QuPath 0.6.0-rc1.; > ; > [qupath-extension-stardist-0.6.0-SNAPSHOT.zip](https://github.com/user-attachments/files/16977870/qupath-extension-stardist-0.6.0-SNAPSHOT.zip). Thanks @alanocallaghan . The new jar solved the issue. ; (QP 0.5.1 is working well with Stardist extension 0.5.0). best; Ofra",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1635#issuecomment-2346029465
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:97,Availability,down,downloading,97,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:442,Deployability,install,installed,442,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:261,Integrability,depend,dependencies,261,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:330,Integrability,depend,dependencies,330,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:402,Modifiability,variab,variables,402,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:116,Performance,perform,performed,116,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:240,Performance,load,loads,240,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:75,Safety,detect,detection,75,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:865,Safety,avoid,avoid,865,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057:802,Usability,clear,clearly-defined,802,"This relates to https://github.com/qupath/qupath/issues/1634. Because CUDA detection and PyTorch downloading is all performed by DeepJavaLibrary, we are very limited in what we can do on the QuPath side. Then there is the issue of how Java loads native library dependencies - and especially the platform-specific fun of how *sub*-dependencies are handled. And the potential interference of environment variables or other things that could be installed. It is, in short, hard. The page on the docs is currently our best 'general' approach to help with this, based on many hours trying to find something workable across computers: https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#gpu-support. We will continue to try to improve this, but I'll close the issue because I don't think there is any clearly-defined QuPath bug here that we can address. To try to avoid fragmenting the discussion in multiple places, I suggest posting on the forum. There are more users active on the forum who might potentially be able to help from their own experience, and there are already some related discussions, e.g. https://forum.image.sc/search?q=qupath%20gpu%20order%3Alatest",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1636#issuecomment-2346013057
https://github.com/qupath/qupath/pull/1638#issuecomment-2352875401:43,Performance,perform,performance,43,"Merging for now, but still need to improve performance.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1638#issuecomment-2352875401
https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439:524,Deployability,configurat,configurations,524,"I think it would be better to post a question like this on [the forum](https://forum.image.sc/) along with a clear description of what you tried, which software versions you're working with, etc. > So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. DJL generally and InstanSeg specifically should still work with CPU support only. > There just must be a way to make it work more easily. We have indeed done our best to do so; it's not necessarily easy to handle all of the possible configurations people have",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439
https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439:250,Integrability,depend,depend,250,"I think it would be better to post a question like this on [the forum](https://forum.image.sc/) along with a clear description of what you tried, which software versions you're working with, etc. > So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. DJL generally and InstanSeg specifically should still work with CPU support only. > There just must be a way to make it work more easily. We have indeed done our best to do so; it's not necessarily easy to handle all of the possible configurations people have",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439
https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439:524,Modifiability,config,configurations,524,"I think it would be better to post a question like this on [the forum](https://forum.image.sc/) along with a clear description of what you tried, which software versions you're working with, etc. > So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. DJL generally and InstanSeg specifically should still work with CPU support only. > There just must be a way to make it work more easily. We have indeed done our best to do so; it's not necessarily easy to handle all of the possible configurations people have",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439
https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439:109,Usability,clear,clear,109,"I think it would be better to post a question like this on [the forum](https://forum.image.sc/) along with a clear description of what you tried, which software versions you're working with, etc. > So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. DJL generally and InstanSeg specifically should still work with CPU support only. > There just must be a way to make it work more easily. We have indeed done our best to do so; it's not necessarily easy to handle all of the possible configurations people have",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439
https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439:229,Usability,Learn,Learning,229,"I think it would be better to post a question like this on [the forum](https://forum.image.sc/) along with a clear description of what you tried, which software versions you're working with, etc. > So no InstanSeg and other Deep Learning models that depend on this Deep Java Library for me. DJL generally and InstanSeg specifically should still work with CPU support only. > There just must be a way to make it work more easily. We have indeed done our best to do so; it's not necessarily easy to handle all of the possible configurations people have",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352697439
https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001:495,Deployability,configurat,configuration,495,"See also https://github.com/qupath/qupath/issues/1636. > Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. My understanding is that the BIOP CellPose extension will [write all the tiles to disk, then effectively run CellPose from a command line](https://github.com/BIOP/qupath-extension-cellpose/blob/b97efdad82df59ace5a149ca91f7fb963549bcc5/src/main/java/qupath/ext/biop/cellpose/Cellpose2D.java#L390). That may be easier for configuration, but it will surely reduce the benefits of using the GPU. It can be justified for CellPose because it is infeasible to recreate the required postprocessing in Java, but for InstanSeg we would suggest instead; 1. just using the CPU; 2. use InstanSeg [entirely from Python ](https://github.com/instanseg/instanseg) (generating QuPath-compatible output would be a different question for that repo or the forum, not this one); 3. discussing on the forum; perhaps someone there might figure out instructions that work where our existing ones do not. I will close this because there is no bug in QuPath described here that we can fix.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001
https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001:529,Energy Efficiency,reduce,reduce,529,"See also https://github.com/qupath/qupath/issues/1636. > Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. My understanding is that the BIOP CellPose extension will [write all the tiles to disk, then effectively run CellPose from a command line](https://github.com/BIOP/qupath-extension-cellpose/blob/b97efdad82df59ace5a149ca91f7fb963549bcc5/src/main/java/qupath/ext/biop/cellpose/Cellpose2D.java#L390). That may be easier for configuration, but it will surely reduce the benefits of using the GPU. It can be justified for CellPose because it is infeasible to recreate the required postprocessing in Java, but for InstanSeg we would suggest instead; 1. just using the CPU; 2. use InstanSeg [entirely from Python ](https://github.com/instanseg/instanseg) (generating QuPath-compatible output would be a different question for that repo or the forum, not this one); 3. discussing on the forum; perhaps someone there might figure out instructions that work where our existing ones do not. I will close this because there is no bug in QuPath described here that we can fix.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001
https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001:135,Integrability,depend,depend,135,"See also https://github.com/qupath/qupath/issues/1636. > Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. My understanding is that the BIOP CellPose extension will [write all the tiles to disk, then effectively run CellPose from a command line](https://github.com/BIOP/qupath-extension-cellpose/blob/b97efdad82df59ace5a149ca91f7fb963549bcc5/src/main/java/qupath/ext/biop/cellpose/Cellpose2D.java#L390). That may be easier for configuration, but it will surely reduce the benefits of using the GPU. It can be justified for CellPose because it is infeasible to recreate the required postprocessing in Java, but for InstanSeg we would suggest instead; 1. just using the CPU; 2. use InstanSeg [entirely from Python ](https://github.com/instanseg/instanseg) (generating QuPath-compatible output would be a different question for that repo or the forum, not this one); 3. discussing on the forum; perhaps someone there might figure out instructions that work where our existing ones do not. I will close this because there is no bug in QuPath described here that we can fix.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001
https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001:495,Modifiability,config,configuration,495,"See also https://github.com/qupath/qupath/issues/1636. > Maybe just use the python version (like BIOP/Cellpose does). In that case you depend on a single python environment!. My understanding is that the BIOP CellPose extension will [write all the tiles to disk, then effectively run CellPose from a command line](https://github.com/BIOP/qupath-extension-cellpose/blob/b97efdad82df59ace5a149ca91f7fb963549bcc5/src/main/java/qupath/ext/biop/cellpose/Cellpose2D.java#L390). That may be easier for configuration, but it will surely reduce the benefits of using the GPU. It can be justified for CellPose because it is infeasible to recreate the required postprocessing in Java, but for InstanSeg we would suggest instead; 1. just using the CPU; 2. use InstanSeg [entirely from Python ](https://github.com/instanseg/instanseg) (generating QuPath-compatible output would be a different question for that repo or the forum, not this one); 3. discussing on the forum; perhaps someone there might figure out instructions that work where our existing ones do not. I will close this because there is no bug in QuPath described here that we can fix.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352826001
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:183,Deployability,update,updated,183,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:592,Deployability,release,released,592,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:733,Deployability,release,releases,733,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:774,Deployability,update,update,774,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:897,Integrability,depend,dependencies,897,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598:935,Integrability,rout,routinely,935,"**Extra:** CUDA 11.8 suggests to me you were following the instructions for [QuPath v0.5.x here](https://qupath.readthedocs.io/en/stable/docs/deep/gpu.html#pytorch). These need to be updated for v0.6.0.; We will do this when we've time, but my guess is that you'll need a different CUDA version (possibly [12.1](https://publish.djl.ai/pytorch/2.3.1/files.txt)). For reference, QuPath v0.6.0-rc1 uses DJL v0.29.0 - which defaults to PyTorch 2.3.1 according to [this link](http://djl.ai/engines/pytorch/pytorch-engine/). QuPath v0.6.0-rc2 is likely to use DJL v0.30.0, which has only just been released... and may require [CUDA 12.4](https://publish.djl.ai/pytorch/2.4.0/files.txt). We've been incredibly busy trying to make all these releases, and I'd ask for patience as we update the docs and try to stabilize all the final versions. The CUDA question in particular is further complicated by our dependencies updating, and none of us routinely using Windows.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352852598
https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393:100,Deployability,install,installing,100,"Hi. Your right it is (maybe) not a bug. But the beauty of QuPath is/was the ease of use and ease of installing. We run it on 20+ workstations. But these new extensions that use the DeepJava Library are (for me) a big pain. Maybe you (not me) can after installing all the prerequisites and tweaking get it working. But it will be impossible to install it next to many other programs on all our workstations. There must be a easier way. Or a better explanation. And for just using the CPU only. I still had to do all the Cuda and tweaking. Out of the box it does not support CPU only. Best, Ron. And just to be clear. I love your work!!! I love QuPath!!!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393
https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393:252,Deployability,install,installing,252,"Hi. Your right it is (maybe) not a bug. But the beauty of QuPath is/was the ease of use and ease of installing. We run it on 20+ workstations. But these new extensions that use the DeepJava Library are (for me) a big pain. Maybe you (not me) can after installing all the prerequisites and tweaking get it working. But it will be impossible to install it next to many other programs on all our workstations. There must be a easier way. Or a better explanation. And for just using the CPU only. I still had to do all the Cuda and tweaking. Out of the box it does not support CPU only. Best, Ron. And just to be clear. I love your work!!! I love QuPath!!!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393
https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393:343,Deployability,install,install,343,"Hi. Your right it is (maybe) not a bug. But the beauty of QuPath is/was the ease of use and ease of installing. We run it on 20+ workstations. But these new extensions that use the DeepJava Library are (for me) a big pain. Maybe you (not me) can after installing all the prerequisites and tweaking get it working. But it will be impossible to install it next to many other programs on all our workstations. There must be a easier way. Or a better explanation. And for just using the CPU only. I still had to do all the Cuda and tweaking. Out of the box it does not support CPU only. Best, Ron. And just to be clear. I love your work!!! I love QuPath!!!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393
https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393:609,Usability,clear,clear,609,"Hi. Your right it is (maybe) not a bug. But the beauty of QuPath is/was the ease of use and ease of installing. We run it on 20+ workstations. But these new extensions that use the DeepJava Library are (for me) a big pain. Maybe you (not me) can after installing all the prerequisites and tweaking get it working. But it will be impossible to install it next to many other programs on all our workstations. There must be a easier way. Or a better explanation. And for just using the CPU only. I still had to do all the Cuda and tweaking. Out of the box it does not support CPU only. Best, Ron. And just to be clear. I love your work!!! I love QuPath!!!",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1640#issuecomment-2352862393
https://github.com/qupath/qupath/pull/1641#issuecomment-2353587248:657,Deployability,pipeline,pipeline,657,"This looks really good, thanks. I've added one small commit to handle ARGB conversion. Initially, when I converted `CMU-1.svs` to `ome.zarr` I was unable to read it again. This was because `BioFormatsImageServer` recognized that the image should be RGB, and therefore created an `ARGB` `ColorModel` (compatible with a packed int representation). But `OMEPixelParser` created an incompatible `BufferedImage` because it received byte arrays, and didn't previously convert to packed int. The reason that QuPath converts *all* (A)RGB images to a packed int representation is somewhat historical, and because I believe this is more optimized in Java's rendering pipeline. It's possible that this belief is out-of-date though, and we should profile one day to check: perhaps ARGB conversion is no longer required.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1641#issuecomment-2353587248
https://github.com/qupath/qupath/pull/1641#issuecomment-2353587248:627,Performance,optimiz,optimized,627,"This looks really good, thanks. I've added one small commit to handle ARGB conversion. Initially, when I converted `CMU-1.svs` to `ome.zarr` I was unable to read it again. This was because `BioFormatsImageServer` recognized that the image should be RGB, and therefore created an `ARGB` `ColorModel` (compatible with a packed int representation). But `OMEPixelParser` created an incompatible `BufferedImage` because it received byte arrays, and didn't previously convert to packed int. The reason that QuPath converts *all* (A)RGB images to a packed int representation is somewhat historical, and because I believe this is more optimized in Java's rendering pipeline. It's possible that this belief is out-of-date though, and we should profile one day to check: perhaps ARGB conversion is no longer required.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1641#issuecomment-2353587248
https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679:956,Safety,avoid,avoid,956,"> One option for Show/Hide would be to have the right click menu be context sensitive:; > ; > * If one or multiple classifications are selected and visible, the context menu becomes ""Hide selected classes"" (Instead of show/Hide > Hide classes in viewer); > * If one or multiple classifications are selected and hidden, the context menu becomes ""Show selected classes"" (Instead of show/Hide > Show classes in viewer). What about if multiple classifications are selected, some shown and some hidden?. I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. If the core issue is that the common things are too hard to access, would simply moving `Show/hide` higher up the menu be a solution?. My hesitation with that is that currently the top part of the menu (above the divider) is all concerned with adding/removing classifications. So `Show/Hide` would have to go to the *very* top, to avoid interrupting this logical grouping... and, as you say, spacebar does that job, so `Add/Remove` might be needed more often.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679
https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679:685,Security,access,access,685,"> One option for Show/Hide would be to have the right click menu be context sensitive:; > ; > * If one or multiple classifications are selected and visible, the context menu becomes ""Hide selected classes"" (Instead of show/Hide > Hide classes in viewer); > * If one or multiple classifications are selected and hidden, the context menu becomes ""Show selected classes"" (Instead of show/Hide > Show classes in viewer). What about if multiple classifications are selected, some shown and some hidden?. I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. If the core issue is that the common things are too hard to access, would simply moving `Show/hide` higher up the menu be a solution?. My hesitation with that is that currently the top part of the menu (above the divider) is all concerned with adding/removing classifications. So `Show/Hide` would have to go to the *very* top, to avoid interrupting this logical grouping... and, as you say, spacebar does that job, so `Add/Remove` might be needed more often.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679
https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679:980,Testability,log,logical,980,"> One option for Show/Hide would be to have the right click menu be context sensitive:; > ; > * If one or multiple classifications are selected and visible, the context menu becomes ""Hide selected classes"" (Instead of show/Hide > Hide classes in viewer); > * If one or multiple classifications are selected and hidden, the context menu becomes ""Show selected classes"" (Instead of show/Hide > Show classes in viewer). What about if multiple classifications are selected, some shown and some hidden?. I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. If the core issue is that the common things are too hard to access, would simply moving `Show/hide` higher up the menu be a solution?. My hesitation with that is that currently the top part of the menu (above the divider) is all concerned with adding/removing classifications. So `Show/Hide` would have to go to the *very* top, to avoid interrupting this logical grouping... and, as you say, spacebar does that job, so `Add/Remove` might be needed more often.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679
https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679:699,Usability,simpl,simply,699,"> One option for Show/Hide would be to have the right click menu be context sensitive:; > ; > * If one or multiple classifications are selected and visible, the context menu becomes ""Hide selected classes"" (Instead of show/Hide > Hide classes in viewer); > * If one or multiple classifications are selected and hidden, the context menu becomes ""Show selected classes"" (Instead of show/Hide > Show classes in viewer). What about if multiple classifications are selected, some shown and some hidden?. I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. If the core issue is that the common things are too hard to access, would simply moving `Show/hide` higher up the menu be a solution?. My hesitation with that is that currently the top part of the menu (above the divider) is all concerned with adding/removing classifications. So `Show/Hide` would have to go to the *very* top, to avoid interrupting this logical grouping... and, as you say, spacebar does that job, so `Add/Remove` might be needed more often.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2358972679
https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530:299,Security,access,access,299,"> I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. Yeah that makes sense! Maybe context sensitive isn't the way to go. Thank you for considering it though! :). > If the core issue is that the common things are too hard to access, would simply moving Show/hide higher up the menu be a solution?. This could definitely work as well. I would be super happy to have a one menu access for ""Add/Remove"", in the same vibe as ""Estimate stain vectors"" was given its own high-leven location instead of a submenu.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530
https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530:450,Security,access,access,450,"> I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. Yeah that makes sense! Maybe context sensitive isn't the way to go. Thank you for considering it though! :). > If the core issue is that the common things are too hard to access, would simply moving Show/hide higher up the menu be a solution?. This could definitely work as well. I would be super happy to have a one menu access for ""Add/Remove"", in the same vibe as ""Estimate stain vectors"" was given its own high-leven location instead of a submenu.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530
https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530:313,Usability,simpl,simply,313,"> I'm apprehensive about trying to make the code too clever, and confusing people more by the menu changing when they click it. Yeah that makes sense! Maybe context sensitive isn't the way to go. Thank you for considering it though! :). > If the core issue is that the common things are too hard to access, would simply moving Show/hide higher up the menu be a solution?. This could definitely work as well. I would be super happy to have a one menu access for ""Add/Remove"", in the same vibe as ""Estimate stain vectors"" was given its own high-leven location instead of a submenu.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1644#issuecomment-2406685530
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:688,Availability,error,error,688,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:127,Deployability,release,release-memory,127,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:650,Deployability,release,release,650,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:154,Energy Efficiency,monitor,monitor,154,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:88,Integrability,depend,dependent,88,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:535,Performance,cache,cache,535,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105:628,Performance,perform,performance,628,"QuPath is a Java application, and the memory behavior is complicated and implementation-dependent: https://www.baeldung.com/gc-release-memory. The memory monitor uses the `Runtime` class, and makes calls to `System.gc()` for garbage collection.; The [javadocs](https://docs.oracle.com/en/java/javase/22/docs/api/java.base/java/lang/Runtime.html#freeMemory()) contain statements like `""Calling the gc method may result in increasing the value returned by freeMemory`""... where that 'may' is interesting. In some cases (such as the tile cache), QuPath retains a (soft or weak) reference to objects for 'as long as it can' to help performance, but will release them before any out-of-memory error is produced. In short, this doesn't sound like a bug to me. Unless there can be shown to be a memory leak within QuPath itself, there are too many other possible reasons beyond our control why memory use reported by the JVM might increase.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1646#issuecomment-2358859105
https://github.com/qupath/qupath/issues/1652#issuecomment-2456992383:692,Deployability,install,installer,692,"With; ```; ./gradlew clean jpackage; ```. I end up with what I guess is the full list:. ```; ij-1.54k-javadoc.jar; jts-core-1.20.0-javadoc.jar; qupath-app-0.6.0-SNAPSHOT-javadoc.jar; qupath-bioimageio-spec-0.1.0-javadoc.jar; qupath-core-0.6.0-SNAPSHOT-javadoc.jar; qupath-core-processing-0.6.0-SNAPSHOT-javadoc.jar; qupath-extension-bioformats-0.6.0-SNAPSHOT-javadoc.jar; qupath-extension-openslide-0.6.0-SNAPSHOT-javadoc.jar; qupath-extension-processing-0.6.0-SNAPSHOT-javadoc.jar; qupath-extension-script-editor-0.6.0-SNAPSHOT-javadoc.jar; qupath-extension-svg-0.6.0-SNAPSHOT-javadoc.jar; qupath-fxtras-0.1.5-javadoc.jar; qupath-gui-fx-0.6.0-SNAPSHOT-javadoc.jar; ```. If I add `-P package=installer` then I do wonder ""Is this the life?"" (by which I mean, I only get the shorter list).",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652#issuecomment-2456992383
https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276:341,Deployability,update,update,341,"I couldn't spot anything in the ""package"" parts that would change what's included in the output. I can get that list into the output directory by adding `assembleJavadocs` to the gradle build command. I would've guessed that adding `tasks.jpackage.dependsOn(""assembleJavadocs"")` in `build.gradle` would work too, but apparently not... I can update the github action for now, and try to fix the gradle logic after?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276
https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276:248,Integrability,depend,dependsOn,248,"I couldn't spot anything in the ""package"" parts that would change what's included in the output. I can get that list into the output directory by adding `assembleJavadocs` to the gradle build command. I would've guessed that adding `tasks.jpackage.dependsOn(""assembleJavadocs"")` in `build.gradle` would work too, but apparently not... I can update the github action for now, and try to fix the gradle logic after?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276
https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276:401,Testability,log,logic,401,"I couldn't spot anything in the ""package"" parts that would change what's included in the output. I can get that list into the output directory by adding `assembleJavadocs` to the gradle build command. I would've guessed that adding `tasks.jpackage.dependsOn(""assembleJavadocs"")` in `build.gradle` would work too, but apparently not... I can update the github action for now, and try to fix the gradle logic after?",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1652#issuecomment-2457072276
https://github.com/qupath/qupath/pull/1659#issuecomment-2382998283:281,Energy Efficiency,green,green,281,"Last commit avoids showing all the extra color transforms if the `ImageType` is `FLUORESCENCE`. This makes the behaviour of RGB and non-RGB fluorescence images consistent *except* with the limitation that channel colors cannot be adjusted for RGB images: they remain fixed to red, green & blue. However, the same transforms are displayed in the Brightness/Contrast dialog and channel names can be changed. Hopefully this is an improvement on the situation in v0.5.x and before, where channel names were fixed and many (usually irrelevant) 'channels' were displayed in the dialog. Screenshots below show the color is unavailable, while the name can be set. If the transforms are desirable, but the images aren't brightfield, then the `ImageType` can be set to `OTHER`. ### With `ImageType.FLUORESCENCE`; <img width=""330"" alt=""Renaming 'FLUORESCENCE' image"" src=""https://github.com/user-attachments/assets/eda6e7c6-c508-4364-9211-3c41f034d47d"">. ### With `ImageType.OTHER`; <img width=""330"" alt=""Renaming 'OTHER' image"" src=""https://github.com/user-attachments/assets/8014d5e8-9e11-481b-b69d-c74baa4fe309"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1659#issuecomment-2382998283
https://github.com/qupath/qupath/pull/1659#issuecomment-2382998283:12,Safety,avoid,avoids,12,"Last commit avoids showing all the extra color transforms if the `ImageType` is `FLUORESCENCE`. This makes the behaviour of RGB and non-RGB fluorescence images consistent *except* with the limitation that channel colors cannot be adjusted for RGB images: they remain fixed to red, green & blue. However, the same transforms are displayed in the Brightness/Contrast dialog and channel names can be changed. Hopefully this is an improvement on the situation in v0.5.x and before, where channel names were fixed and many (usually irrelevant) 'channels' were displayed in the dialog. Screenshots below show the color is unavailable, while the name can be set. If the transforms are desirable, but the images aren't brightfield, then the `ImageType` can be set to `OTHER`. ### With `ImageType.FLUORESCENCE`; <img width=""330"" alt=""Renaming 'FLUORESCENCE' image"" src=""https://github.com/user-attachments/assets/eda6e7c6-c508-4364-9211-3c41f034d47d"">. ### With `ImageType.OTHER`; <img width=""330"" alt=""Renaming 'OTHER' image"" src=""https://github.com/user-attachments/assets/8014d5e8-9e11-481b-b69d-c74baa4fe309"">",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1659#issuecomment-2382998283
https://github.com/qupath/qupath/pull/1669#issuecomment-2393449796:43,Security,access,accessibility,43,This works great! Should be a very helpful accessibility feature for colorblind folks :),MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1669#issuecomment-2393449796
https://github.com/qupath/qupath/pull/1671#issuecomment-2393474058:126,Deployability,Release,Release,126,"Works great on my Linux box, an Ubuntu 22.04 derivative with GNOME desktop environment:. ```; Description:	Pop!_OS 22.04 LTS; Release:	22.04; Codename:	jammy; ```. Would probably be worthwhile checking a KDE plasma version, will look into that quickly",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1671#issuecomment-2393474058
https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625:298,Deployability,update,updates,298,"Ah, that's a bit of a shame... but thanks for testing - there might be some other [platform preferences](https://openjfx.io/javadoc/23/javafx.graphics/javafx/application/Platform.Preferences.html) that help, although I'd be tempted to just leave is a bug that may magically get fixed by dependency updates. We still have the option to choose light or dark explicitly, so as long as that still works no one should be stuck.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625
https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625:287,Integrability,depend,dependency,287,"Ah, that's a bit of a shame... but thanks for testing - there might be some other [platform preferences](https://openjfx.io/javadoc/23/javafx.graphics/javafx/application/Platform.Preferences.html) that help, although I'd be tempted to just leave is a bug that may magically get fixed by dependency updates. We still have the option to choose light or dark explicitly, so as long as that still works no one should be stuck.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625
https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625:46,Testability,test,testing,46,"Ah, that's a bit of a shame... but thanks for testing - there might be some other [platform preferences](https://openjfx.io/javadoc/23/javafx.graphics/javafx/application/Platform.Preferences.html) that help, although I'd be tempted to just leave is a bug that may magically get fixed by dependency updates. We still have the option to choose light or dark explicitly, so as long as that still works no one should be stuck.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1671#issuecomment-2393621625
https://github.com/qupath/qupath/pull/1671#issuecomment-2393735211:15,Testability,test,tested,15,"In fairness, I tested on Plasma and it seems like `Platform.getPreferences().getColorScheme()` is indeed returning light when dark and dark when light, so there's not a whole lot we can do to handle that",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1671#issuecomment-2393735211
https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249:866,Energy Efficiency,adapt,adapting,866,"This is the macro shown above, included as an example:; ```java; /*; * ImageJ macro to apply an automated threshold to detect a single region.; * You will need to return the active Roi to see the results in QuPath.; */. // Define method (e.g. ""Triangle"", ""Otsu""...); method = ""Otsu"";. // Check if the image has a property specifying a dark background; // Override this by setting the value to true or false; if (Property.get(""qupath.image.background"")==""dark""); darkBackground = true;; else; darkBackground = false;. // Ensure 8-bit grayscale; resetMinAndMax();; run(""8-bit"");. // Create Roi from threshold; if (darkBackground); setAutoThreshold(method + "" dark"");; else; setAutoThreshold(method);; run(""Create Selection"");; ```; This effectively makes it possible to apply any of ImageJ's auto thresholding methods to any region of an image (or the entire image) - adapting for brightfield or fluorescence based on the image type. The resolution and channel can be specified from within QuPath's UI when the region is being sent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249
https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249:866,Modifiability,adapt,adapting,866,"This is the macro shown above, included as an example:; ```java; /*; * ImageJ macro to apply an automated threshold to detect a single region.; * You will need to return the active Roi to see the results in QuPath.; */. // Define method (e.g. ""Triangle"", ""Otsu""...); method = ""Otsu"";. // Check if the image has a property specifying a dark background; // Override this by setting the value to true or false; if (Property.get(""qupath.image.background"")==""dark""); darkBackground = true;; else; darkBackground = false;. // Ensure 8-bit grayscale; resetMinAndMax();; run(""8-bit"");. // Create Roi from threshold; if (darkBackground); setAutoThreshold(method + "" dark"");; else; setAutoThreshold(method);; run(""Create Selection"");; ```; This effectively makes it possible to apply any of ImageJ's auto thresholding methods to any region of an image (or the entire image) - adapting for brightfield or fluorescence based on the image type. The resolution and channel can be specified from within QuPath's UI when the region is being sent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249
https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249:119,Safety,detect,detect,119,"This is the macro shown above, included as an example:; ```java; /*; * ImageJ macro to apply an automated threshold to detect a single region.; * You will need to return the active Roi to see the results in QuPath.; */. // Define method (e.g. ""Triangle"", ""Otsu""...); method = ""Otsu"";. // Check if the image has a property specifying a dark background; // Override this by setting the value to true or false; if (Property.get(""qupath.image.background"")==""dark""); darkBackground = true;; else; darkBackground = false;. // Ensure 8-bit grayscale; resetMinAndMax();; run(""8-bit"");. // Create Roi from threshold; if (darkBackground); setAutoThreshold(method + "" dark"");; else; setAutoThreshold(method);; run(""Create Selection"");; ```; This effectively makes it possible to apply any of ImageJ's auto thresholding methods to any region of an image (or the entire image) - adapting for brightfield or fluorescence based on the image type. The resolution and channel can be specified from within QuPath's UI when the region is being sent.",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1682#issuecomment-2425148249
https://github.com/qupath/qupath/issues/1691#issuecomment-2448565070:103,Availability,down,download,103,You need to fill out the issue template for us to be able to diagnose the issue. You could also try to download a more recent version of qupath (eg v0.5.1) which may resolve your issue.,MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/issues/1691#issuecomment-2448565070
https://github.com/qupath/qupath/pull/1694#issuecomment-2459650284:75,Deployability,release,releases,75,"Tested on my fork and seems to work, but definitely one to watch in future releases. Will merge for now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1694#issuecomment-2459650284
https://github.com/qupath/qupath/pull/1694#issuecomment-2459650284:0,Testability,Test,Tested,0,"Tested on my fork and seems to work, but definitely one to watch in future releases. Will merge for now",MatchSource.ISSUE_COMMENT,qupath,qupath,v0.5.1,https://qupath.github.io,https://github.com/qupath/qupath/pull/1694#issuecomment-2459650284
