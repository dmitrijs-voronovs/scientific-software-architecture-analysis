quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Integrability,message,message,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,citing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/citing.html
Security,secur,secure,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Citing QuTiP; QuTiP is developed by several physicists in their spare time.; As with anyone in academics,; their life and death is determined entirely by citations and paper count. ; Therefore, if you find QuTiP useful, please consider citing this project as:. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP 2: A Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 184, 1234 (2013), DOI: 10.1016/j.cpc.2012.11.019. J. R. Johansson, P. D. Nation, and F. Nori: “QuTiP: An open-source Python framework for the dynamics of open quantum systems.”, Comp. Phys. Comm. 183, 1760–1772 (2012), DOI: 10.1016/j.cpc.2012.02.021. This will also help us secure future funding supporting the development of this software.; PDF versions of these papers may be found on the ArXiv preprint server; here and here.; If you do use QuTiP in a publication, please take a few minutes and let us know; by posting on the QuTiP message board.; We would love to hear how QuTiP is being used as a research tool. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,citing.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/citing.html
Availability,avail,available,"sing QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,cofc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/cofc.html
Deployability,patch,patches,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project",MatchSource.WIKI,cofc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/cofc.html
Energy Efficiency,adapt,adapted,"sing QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,cofc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/cofc.html
Modifiability,adapt,adapted,"sing QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,cofc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/cofc.html
Security,attack,attacks,"hon. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Code of conduct; As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities.; We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality.; Examples of unacceptable behavior by participants include:. The use of sexualized language or imagery; Personal attacks; Trolling or insulting/derogatory comments; Public or private harassment; Publishing other’s private information, such as physical or electronic addresses, without explicit permission; Other unethical or unprofessional conduct. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team.; This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community.; Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers.; This Code of Conduct is adapted from the Contributor Covenant, version",MatchSource.WIKI,cofc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/cofc.html
Availability,mainten,maintenance,"ping to add, many new features to the growing list of QuTiP functions:; Original Developers. Paul Nation; IBM Q; Library designer and main contributor. Robert Johansson; Tokyo, Japan; Library designer and main contributor. Project Governance; The governance process and model for the QuTiP Project can be found here. It contains a charter document.; Admin Team. Alex Pitchford; Aberystwyth University; Main focus: Quantum optimal control, solvers. Eric Giguère; Université de Sherbrooke; Main focus: Stochastic solvers, code optimization. Nathan Shammah; RIKEN; Main focus: Symmetrical models, education and outreach. Shahnawaz Ahmed; Chalmers; Main focus: Machine learning, Non-Markovian dynamics. Neill Lambert; RIKEN; Main focus: Non-Markovian dynamics, counting statistics. Boxi Li; Forschungszentrum Juelich; Main focus: Quantum control, Quantum device simulation. Jake Lishman; Imperial College London; Main focus: Core data model and linear algebra. Simon Cross; RIKEN; Main focus: Quantum control, machine learning, general maintenance. Asier Galicia; Forschungszentrum Juelich; Main focus: Core data model and backends. Paul Menczel; RIKEN; Main focus: Quantum control, non-Markovian solvers, MPI. Patrick Hopf; Technical University of Munich; Main focus: Quantum control. Board Members. Anton Frisk Kockum; Chalmers University of Technology. Daniel Burgarth; Macquarie University. Franco Nori; RIKEN / University of Michigan. Rob Johansson; Rakuten. Will Zeng; Unitary Fund. Core Contributors. Arne Grimsmo; Université de Sherbrooke. Chris Grenade; University of Sydney. Additional Developers. Denis Vasilyev (Leibniz); Kevin Fischer (Stanford); Anubhav Vardhan (New Dehli, India); Markus Baden (Zurich, Switzerland). Jonathan Zoller (Ulm University); Ben Criger (RWTH Aachen); Ben Bartlett (Stanford); Piotr Migdał (Warsaw, Poland). For a complete and up-to-date list of contributors, check out the Github pages (code, https://github.com/qutip/qutip-notebooks/graphs/contributors). © 2011 ",MatchSource.WIKI,devs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/devs.html
Performance,optimiz,optimization,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Contributors; The development of QuTiP is a community based effort with several developers contributing, or helping to add, many new features to the growing list of QuTiP functions:; Original Developers. Paul Nation; IBM Q; Library designer and main contributor. Robert Johansson; Tokyo, Japan; Library designer and main contributor. Project Governance; The governance process and model for the QuTiP Project can be found here. It contains a charter document.; Admin Team. Alex Pitchford; Aberystwyth University; Main focus: Quantum optimal control, solvers. Eric Giguère; Université de Sherbrooke; Main focus: Stochastic solvers, code optimization. Nathan Shammah; RIKEN; Main focus: Symmetrical models, education and outreach. Shahnawaz Ahmed; Chalmers; Main focus: Machine learning, Non-Markovian dynamics. Neill Lambert; RIKEN; Main focus: Non-Markovian dynamics, counting statistics. Boxi Li; Forschungszentrum Juelich; Main focus: Quantum control, Quantum device simulation. Jake Lishman; Imperial College London; Main focus: Core data model and linear algebra. Simon Cross; RIKEN; Main focus: Quantum control, machine learning, general maintenance. Asier Galicia; Forschungszentrum Juelich; Main focus: Core data model and backends. Paul Menczel; RIKEN; Main focus: Quantum control, non-Markovian solvers, MPI. Patrick Hopf; Technical University of Munich; Main focus: Quantum control. Board Members. Anton Frisk Kockum; Chalmers University of Technology. Daniel Burgarth; Macquarie University. Franco Nori; RIKEN / University of Michigan. Rob Johansson; Rakuten. Will Zeng; Unitary Fund. Core Contributors. Arne Grimsmo; Université de Sherbrooke. Chris Grenade; University of Sydney. Additional Developers. ",MatchSource.WIKI,devs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/devs.html
Usability,learn,learning,"b. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Contributors; The development of QuTiP is a community based effort with several developers contributing, or helping to add, many new features to the growing list of QuTiP functions:; Original Developers. Paul Nation; IBM Q; Library designer and main contributor. Robert Johansson; Tokyo, Japan; Library designer and main contributor. Project Governance; The governance process and model for the QuTiP Project can be found here. It contains a charter document.; Admin Team. Alex Pitchford; Aberystwyth University; Main focus: Quantum optimal control, solvers. Eric Giguère; Université de Sherbrooke; Main focus: Stochastic solvers, code optimization. Nathan Shammah; RIKEN; Main focus: Symmetrical models, education and outreach. Shahnawaz Ahmed; Chalmers; Main focus: Machine learning, Non-Markovian dynamics. Neill Lambert; RIKEN; Main focus: Non-Markovian dynamics, counting statistics. Boxi Li; Forschungszentrum Juelich; Main focus: Quantum control, Quantum device simulation. Jake Lishman; Imperial College London; Main focus: Core data model and linear algebra. Simon Cross; RIKEN; Main focus: Quantum control, machine learning, general maintenance. Asier Galicia; Forschungszentrum Juelich; Main focus: Core data model and backends. Paul Menczel; RIKEN; Main focus: Quantum control, non-Markovian solvers, MPI. Patrick Hopf; Technical University of Munich; Main focus: Quantum control. Board Members. Anton Frisk Kockum; Chalmers University of Technology. Daniel Burgarth; Macquarie University. Franco Nori; RIKEN / University of Michigan. Rob Johansson; Rakuten. Will Zeng; Unitary Fund. Core Contributors. Arne Grimsmo; Université de Sherbrooke. Chris Grenade; University of Sydney. Additional Developers. Denis Vasilyev (Leibniz); Kevin Fischer (Stanford); An",MatchSource.WIKI,devs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/devs.html
Availability,avail,available,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Users guide; Latest releases; Version 5.0.4. Read the Docs. PDF documentation. Version 4.7.6. Read the Docs. PDF documentation. Previous releases; Version 4.7.5 (archived). Online HTML documentation. PDF documentation. Version 4.6.0. Online HTML documentation. PDF documentation. Version 4.5.0. Online HTML documentation. PDF documentation. Version 4.4.0. Online HTML documentation. PDF documentation. Version 4.3.1. Online HTML documentation. PDF documentation. Version 4.2.0. Online HTML documentation. PDF documentation. Version 4.1.0. Online HTML documentation. PDF documentation. Version 4.0.2. Online HTML documentation. PDF documentation. Version 3.1.0. Online HTML documentation. PDF documentation. Version 3.0.1. Online HTML documentation. PDF documentation. Version 3.0.0. Online HTML documentation. PDF documentation. Version 2.2.0. PDF documentation. Development documentation; The documentation for the development version of QuTiP is available at the qutip-doc github repository. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,documentation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/documentation.html
Deployability,release,releases,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Users guide; Latest releases; Version 5.0.4. Read the Docs. PDF documentation. Version 4.7.6. Read the Docs. PDF documentation. Previous releases; Version 4.7.5 (archived). Online HTML documentation. PDF documentation. Version 4.6.0. Online HTML documentation. PDF documentation. Version 4.5.0. Online HTML documentation. PDF documentation. Version 4.4.0. Online HTML documentation. PDF documentation. Version 4.3.1. Online HTML documentation. PDF documentation. Version 4.2.0. Online HTML documentation. PDF documentation. Version 4.1.0. Online HTML documentation. PDF documentation. Version 4.0.2. Online HTML documentation. PDF documentation. Version 3.1.0. Online HTML documentation. PDF documentation. Version 3.0.1. Online HTML documentation. PDF documentation. Version 3.0.0. Online HTML documentation. PDF documentation. Version 2.2.0. PDF documentation. Development documentation; The documentation for the development version of QuTiP is available at the qutip-doc github repository. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,documentation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/documentation.html
Usability,guid,guide,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Users guide; Latest releases; Version 5.0.4. Read the Docs. PDF documentation. Version 4.7.6. Read the Docs. PDF documentation. Previous releases; Version 4.7.5 (archived). Online HTML documentation. PDF documentation. Version 4.6.0. Online HTML documentation. PDF documentation. Version 4.5.0. Online HTML documentation. PDF documentation. Version 4.4.0. Online HTML documentation. PDF documentation. Version 4.3.1. Online HTML documentation. PDF documentation. Version 4.2.0. Online HTML documentation. PDF documentation. Version 4.1.0. Online HTML documentation. PDF documentation. Version 4.0.2. Online HTML documentation. PDF documentation. Version 3.1.0. Online HTML documentation. PDF documentation. Version 3.0.1. Online HTML documentation. PDF documentation. Version 3.0.0. Online HTML documentation. PDF documentation. Version 2.2.0. PDF documentation. Development documentation; The documentation for the development version of QuTiP is available at the qutip-doc github repository. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,documentation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/documentation.html
Availability,down,download,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP has been developed over seven years by volunteers working in their spare time. If you find QuTiP useful, please consider taking a minute of your own time and citing it in your publications. Download; The recommended way to install QuTiP is with conda or pip, see the; documentation for details.; Latest releases; Verion 5.0.4 - 3 September 2024. v5.0.4.tar.gz; v5.0.4.zip. Version 4.7.6 - 5 April 2024. v4.7.6.tar.gz; v4.7.6.zip. Recent minor releases; Verion 5.0.3 - 28 June 2024. v5.0.3.tar.gz; v5.0.3.zip. Verion 5.0.2 - 17 May 2024. v5.0.2.tar.gz; v5.0.2.zip. Verion 5.0.1 - 3 April 2024. v5.0.1.tar.gz; v5.0.1.zip. Verion 5.0.0 - 28 March 2024. v5.0.0.tar.gz; v5.0.0.zip. Version 4.7.5 - 30 January 2024. v4.7.5.tar.gz; v4.7.5.zip. Version 4.7.4 - 18 January 2024. v4.7.4.tar.gz; v4.7.4.zip. Version 4.7.3 - 23 August 2023. v4.7.3.tar.gz; v4.7.3.zip. Version 4.7.2 - 29 June 2023. v4.7.2.tar.gz; v4.7.2.zip. Version 4.7.1 - 12 December 2022. v4.7.1.tar.gz; v4.7.1.zip. Version 4.7.0 - 13 April 2022. v4.7.0.tar.gz; v4.7.0.zip. Legacy releases; If you are interested in legacy releases of QuTiP, you can download all previous; versions from the GitHub by selecting the appropriate tag.; Installation; Instructions for installing QuTiP can be found in the documentation, or; in the INSTALL.txt file included in the QuTiP source folder.; Source Code; If you want to checkout the latest source code and documentation then head on; over to the QuTiP repositories at GitHub. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,download.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/download.html
Deployability,install,install,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP has been developed over seven years by volunteers working in their spare time. If you find QuTiP useful, please consider taking a minute of your own time and citing it in your publications. Download; The recommended way to install QuTiP is with conda or pip, see the; documentation for details.; Latest releases; Verion 5.0.4 - 3 September 2024. v5.0.4.tar.gz; v5.0.4.zip. Version 4.7.6 - 5 April 2024. v4.7.6.tar.gz; v4.7.6.zip. Recent minor releases; Verion 5.0.3 - 28 June 2024. v5.0.3.tar.gz; v5.0.3.zip. Verion 5.0.2 - 17 May 2024. v5.0.2.tar.gz; v5.0.2.zip. Verion 5.0.1 - 3 April 2024. v5.0.1.tar.gz; v5.0.1.zip. Verion 5.0.0 - 28 March 2024. v5.0.0.tar.gz; v5.0.0.zip. Version 4.7.5 - 30 January 2024. v4.7.5.tar.gz; v4.7.5.zip. Version 4.7.4 - 18 January 2024. v4.7.4.tar.gz; v4.7.4.zip. Version 4.7.3 - 23 August 2023. v4.7.3.tar.gz; v4.7.3.zip. Version 4.7.2 - 29 June 2023. v4.7.2.tar.gz; v4.7.2.zip. Version 4.7.1 - 12 December 2022. v4.7.1.tar.gz; v4.7.1.zip. Version 4.7.0 - 13 April 2022. v4.7.0.tar.gz; v4.7.0.zip. Legacy releases; If you are interested in legacy releases of QuTiP, you can download all previous; versions from the GitHub by selecting the appropriate tag.; Installation; Instructions for installing QuTiP can be found in the documentation, or; in the INSTALL.txt file included in the QuTiP source folder.; Source Code; If you want to checkout the latest source code and documentation then head on; over to the QuTiP repositories at GitHub. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,download.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/download.html
Availability,avail,available,"QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evol",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Energy Efficiency,efficient,efficiently,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Integrability,rout,routines,"0% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evolution solvers. Even better, these interpolating functions can be runtime compiled into C++, and support both real and complex data.; . From Bloch spheres to nonlinear colormaps for Wigner functions, QuTiP includes a host of built-in visualization routines that help bring your data to life. O",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Performance,perform,performing,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Testability,test,tested,"Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming language, and the performance of compiled code, all for free. What can be better than that?; . Can't express your time-dependence analytically, or need to construct a function from a data set? No problem. QuTiP allows for passing interpolating functions as time-dependent arguments to the evolution solvers. Even better, these interpolating functions can be runtime compiled into C++, and support both real and complex data.; . From Bloch spheres to nonlinear colormaps for Wigner functions, QuTiP includes a host of built-in visualization routines that help bring your data to life. Our plotting utilities have been used by Fortune 500 companies, government research labs, and countless research groups around the globe. If you don't look good, we don't look good. ; . QuTiP is thoroughly tested, both by its thousands of users, and by the large collection of built in test scripts. QuTiP includes over a thousand such tests, covering nearly all of the builtin functions. These tests are run over and over again during development to make sure that the results you get from QuTiP are in fact the correct answers. No other quantum simulation software is as well tested as QuTiP.; . No software should be a black box to the user, especially in science. QuTiP is not only completely open-source, but also includes hundreds of pages of documentation, a multitude of tutorial Jupyter notebooks, and a friendly community of users who kindly donate their time to help answer questions.; . © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Usability,learn,learn,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Features. QuTiP is the original quantum framework written in Python; the most widely ; used programming language in the quantum sciences. Python's straightforward syntax allows for constructing, manipulating, and evolving quantum objects using QuTiP with just a few lines of code. Easy to learn, and 100% open-source, QuTiP is the ideal toolbox for research or the classroom. Did you know that you can determine if an operator is Hermitian without performing the conjugate transpose? QuTiP does. In fact, it is just one of many custom algorithms that QuTiP uses to maximize performance. Focusing on sparse matrices, and the means by which to efficiently manipulate these data structures, allows QuTiP to tackle even the largest quantum mechanical calculations. ; . In addition to custom algorithms, QuTiP is capable of leveraging the multiprocessing power inside every modern computer. Taking advantage of the Python multiprocessing library, OPENMP, SSE3 processor extensions, and the Intel MKL, if available, allows for faster manipulation of quantum objects, and increased performance of evolution equations, without any work at all.; . QuTiP includes a variety of builtin solvers for dynamical simulations. In addition to the standard Lindblad and Monte Carlo Solvers, QuTiP includes routines for Bloch-Redfield evolution, periodic systems using the Floquet formalism, and stochastic solvers. Add to this, steady state analysis and non-Markovian techniques, and you have a wide variety of tools from which to explore your systems behavior. A wide range of time-dependent evolution simulations can be runtime compiled into C++ behind the scenes using Cython. Thus, you get the ease of use of the Python programming lang",MatchSource.WIKI,features.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/features.html
Availability,down,downloads,vel_atom — QuTiP 4.2 Documentation; qutip.tomography — QuTiP 4.2 Documentation; qutip.utilities — QuTiP 4.2 Documentation; qutip.visualization — QuTiP 4.2 Documentation; qutip.wigner — QuTiP 4.2 Documentation. Overview: module code — QuTiP 4.2 Documentation. Python Module Index — QuTiP 4.2 Documentation; Search — QuTiP 4.2 Documentation. /static; . /css; ; theme.css. /fonts; ; fontawesome-webfont-1.eot; fontawesome-webfont.eot; fontawesome-webfont.svg; fontawesome-webfont.ttf; fontawesome-webfont.woff; Inconsolata-Bold.ttf; Inconsolata-Regular.ttf; Lato-Bold.ttf; Lato-Regular.ttf; RobotoSlab-Bold.ttf; RobotoSlab-Regular.ttf. /js; ; modernizr.min.js; theme.js. doctools.js; favicon.ico; jquery.js; searchtools.js; underscore.js. /4.3; . /apidoc; ; API documentation — QuTiP 4.3 Documentation; Classes — QuTiP 4.3 Documentation; Functions — QuTiP 4.3 Documentation. Bibliography — QuTiP 4.3 Documentation; Change Log — QuTiP 4.3 Documentation; Developers — QuTiP 4.3 Documentation. /downloads; ; qutip_tree.pdf. Frontmatter — QuTiP 4.3 Documentation; Index — QuTiP 4.3 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 4.3 Documentation; Dynamics Simulation Results — QuTiP 4.3 Documentation; Floquet Formalism — QuTiP 4.3 Documentation; Lindblad Master Equation Solver — QuTiP 4.3 Documentation; Monte Carlo Solver — QuTiP 4.3 Documentation; Setting Options for the Dynamics Solvers — QuTiP 4.3 Documentation; Permutational Invariance — QuTiP 4.3 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 4.3 Documentation. /scripts; ; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; ex_steady.pdf; ex_steady.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 4.3 Documentation; Basic Operations on Quantum Objects — QuTiP 4.3 Documentation; Plotting on the Bloch Spher,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Energy Efficiency,schedul,scheduler,iP 4.6 Documentation; qutip.control.dynamics — QuTiP 4.6 Documentation; qutip.control.fidcomp — QuTiP 4.6 Documentation; qutip.control.optimizer — QuTiP 4.6 Documentation; qutip.control.optimresult — QuTiP 4.6 Documentation; qutip.control.propcomp — QuTiP 4.6 Documentation; qutip.control.pulsegen — QuTiP 4.6 Documentation; qutip.control.pulseoptim — QuTiP 4.6 Documentation; qutip.control.stats — QuTiP 4.6 Documentation; qutip.control.termcond — QuTiP 4.6 Documentation; qutip.control.tslotcomp — QuTiP 4.6 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.6 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.6 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.6 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.6 Documentation. /compiler; ; qutip.qip.compiler.cavityqedcompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.gatecompiler — QuTiP 4.6 Documentation; qutip.qip.compiler.instruction — QuTiP 4.6 Documentation; qutip.qip.compiler.scheduler — QuTiP 4.6 Documentation; qutip.qip.compiler.spinchaincompiler — QuTiP 4.6 Documentation. /device; ; qutip.qip.device.cavityqed — QuTiP 4.6 Documentation; qutip.qip.device.modelprocessor — QuTiP 4.6 Documentation; qutip.qip.device.optpulseprocessor — QuTiP 4.6 Documentation; qutip.qip.device.processor — QuTiP 4.6 Documentation; qutip.qip.device.spinchain — QuTiP 4.6 Documentation. /operations; ; qutip.qip.operations.gates — QuTiP 4.6 Documentation. qutip.qip.circuit — QuTiP 4.6 Documentation; qutip.qip.noise — QuTiP 4.6 Documentation; qutip.qip.pulse — QuTiP 4.6 Documentation; qutip.qip.qasm — QuTiP 4.6 Documentation; qutip.qip.qubits — QuTiP 4.6 Documentation. qutip.about — QuTiP 4.6 Documentation; qutip.bloch — QuTiP 4.6 Documentation; qutip.bloch_redfield — QuTiP 4.6 Documentation; qutip.continuous_variables — QuTiP 4.6 Documentation; qutip.correlation — QuTiP 4.6 Documentation; qutip.dimensions — QuTiP 4.6 Documentation; qutip.distributions — QuTiP 4.6 Documentation; qutip.entropy,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Integrability,depend,dependent,﻿. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. css; ; bootstrap.css; gh-fork-ribbon.css; site.css. QuTiP - Quantum Toolbox in Python. docs; . /3.0.0; . /apidoc; ; API documentation — QuTiP 3.0 Documentation; Classes — QuTiP 3.0 Documentation; Functions — QuTiP 3.0 Documentation. Bibliography — QuTiP 3.0 Documentation; Change Log — QuTiP 3.0 Documentation; Developers — QuTiP 3.0 Documentation; Frontmatter — QuTiP 3.0 Documentation; Index — QuTiP 3.0 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 3.0 Documentation; Dynamics Simulation Results — QuTiP 3.0 Documentation; Floquet Formalism — QuTiP 3.0 Documentation; Lindblad Master Equation Solver — QuTiP 3.0 Documentation; Monte Carlo Solver — QuTiP 3.0 Documentation; Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation; Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. /scripts; ; correlation_ex1.pdf; correlation_ex1.py; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; floquet_ex0.pdf; floquet_ex0.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 3.0 Documentation; Basic Operations on Quantum Objects — QuTiP 3.0 Documentation; Plotting on the Bloch Sphere — QuTiP 3.0 Documentation; Two-time correlation functions — QuTiP 3.0 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation; An Overview of the Eseries Class — QuTiP 3.0 Documentation; Guide Overview — QuTiP 3.0 Documentation; Running Problems in Parallel — QuTiP 3.0 Documentation; Generating Random Quantum States & Operators — QuTiP 3.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Performance,optimiz,optimizer,and Quantum System Dynamics — QuTiP 4.0 Documentation; An Overview of the Eseries Class — QuTiP 4.0 Documentation; Guide Overview — QuTiP 4.0 Documentation; Parallel computation — QuTiP 4.0 Documentation; Generating Random Quantum States & Operators — QuTiP 4.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 4.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 4.0 Documentation; Manipulating States and Operators — QuTiP 4.0 Documentation; Solving for Steady-State Solutions — QuTiP 4.0 Documentation; Using Tensor Products and Partial Traces — QuTiP 4.0 Documentation; Visualization of quantum states and processes — QuTiP 4.0 Documentation. /images; ; qutip_tree.pdf. QuTiP: Quantum Toolbox in Python (4.0) — QuTiP 4.0 Documentation; Installation — QuTiP 4.0 Documentation. /modules; . /qutip; . /control; ; qutip.control.dump — QuTiP 4.0 Documentation; qutip.control.dynamics — QuTiP 4.0 Documentation; qutip.control.fidcomp — QuTiP 4.0 Documentation; qutip.control.optimizer — QuTiP 4.0 Documentation; qutip.control.optimresult — QuTiP 4.0 Documentation; qutip.control.propcomp — QuTiP 4.0 Documentation; qutip.control.pulsegen — QuTiP 4.0 Documentation; qutip.control.pulseoptim — QuTiP 4.0 Documentation; qutip.control.stats — QuTiP 4.0 Documentation; qutip.control.termcond — QuTiP 4.0 Documentation; qutip.control.tslotcomp — QuTiP 4.0 Documentation. /nonmarkov; ; qutip.nonmarkov.heom — QuTiP 4.0 Documentation; qutip.nonmarkov.memorycascade — QuTiP 4.0 Documentation; qutip.nonmarkov.transfertensor — QuTiP 4.0 Documentation. /qip; . /algorithms; ; qutip.qip.algorithms.qft — QuTiP 4.0 Documentation. /models; ; qutip.qip.models.circuitprocessor — QuTiP 4.0 Documentation; qutip.qip.models.cqed — QuTiP 4.0 Documentation; qutip.qip.models.spinchain — QuTiP 4.0 Documentation. qutip.qip.circuit — QuTiP 4.0 Documentation; qutip.qip.gates — QuTiP 4.0 Documentation; qutip.qip.qubits — QuTiP 4.0 Documentation. qutip.about — QuTiP 4.0 Documentation; qutip.bloch — QuTiP 4.,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Testability,benchmark,benchmark,o-normal-italic.woff; lato-normal-italic.woff2; Roboto-Slab-Bold.woff; Roboto-Slab-Bold.woff2; Roboto-Slab-Regular.woff; Roboto-Slab-Regular.woff2. theme.css. /js; ; theme.js. doctools.js; documentation_options.js; favicon.ico; gallery.css; gallery-binder.css; gallery-dataframe.css; gallery-rendered-html.css; jquery.js; language_data.js; pygments.css; searchtools.js; site.css; underscore.js. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. downloads; . /2.2.0; ; QuTiP-2.2.0-DOC.pdf. /4.0.2; ; qutip-doc-4.0.2.pdf. /4.1.0; ; qutip-doc-4.1.pdf. /4.2.0; ; QuTiP_4.2.pdf. /4.3.1; ; qutip-doc-4.3.pdf. /4.4.0; ; qutip-doc-4.4.pdf. /4.5.0; ; qutip-doc-4.5.pdf. QuTiP - Quantum Toolbox in Python. images; ; favicon.ico. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. js; ; bootstrap.min.js; datamaps.world.min.js; jquery.js; map.js. news; ; Commercial_Prospects_for_Quantum_Computing_Dec_2016.pdf; llnl_advert.pdf. QuTiP - Quantum Toolbox in Python. qutip-benchmark; . /ops; ; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. QuTiP - Quantum Toolbox in Python. qutip-tutorials; ; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. qutip-virtual-lab; . /assets; ; favicon-42303b83.ico; index-107cdd9d.css; index-34b0aa26.js; KaTeX_AMS-Regular-0cdd387c.woff2; KaTeX_AMS-Regular-30da91e8.woff; KaTeX_AMS-Regular-68534840.ttf; KaTeX_Caligraphic-Bold-07d8e303.ttf; KaTeX_Caligraphic-Bold-1ae6bd74.woff; KaTeX_Caligraphic-Bold-de7701e4.woff2; KaTeX_Caligraphic-Regular-3398dd02.woff; KaTeX_Caligraphic-Regular-5d53e70a.woff2; KaTeX_Caligraphic-Regular-ed0b7437.ttf; KaTeX_Fraktur-Bold-74444efd.woff2; KaTeX_Fraktur-Bold-9163df9c.ttf; KaTeX_Fraktur-Bold-9be7ceb8.woff; KaTeX_Fraktur-Regular-1e6f9579.ttf; KaTeX_Frakt,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Usability,guid,guide,﻿. QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python; QuTiP - Quantum Toolbox in Python. css; ; bootstrap.css; gh-fork-ribbon.css; site.css. QuTiP - Quantum Toolbox in Python. docs; . /3.0.0; . /apidoc; ; API documentation — QuTiP 3.0 Documentation; Classes — QuTiP 3.0 Documentation; Functions — QuTiP 3.0 Documentation. Bibliography — QuTiP 3.0 Documentation; Change Log — QuTiP 3.0 Documentation; Developers — QuTiP 3.0 Documentation; Frontmatter — QuTiP 3.0 Documentation; Index — QuTiP 3.0 Documentation. /guide; . /dynamics; ; Bloch-Redfield master equation — QuTiP 3.0 Documentation; Dynamics Simulation Results — QuTiP 3.0 Documentation; Floquet Formalism — QuTiP 3.0 Documentation; Lindblad Master Equation Solver — QuTiP 3.0 Documentation; Monte Carlo Solver — QuTiP 3.0 Documentation; Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation; Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation; Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. /scripts; ; correlation_ex1.pdf; correlation_ex1.py; correlation_ex2.pdf; correlation_ex2.py; correlation_ex3.pdf; correlation_ex3.py; correlation_ex4.pdf; correlation_ex4.py; floquet_ex0.pdf; floquet_ex0.py; floquet_ex1.pdf; floquet_ex1.py; floquet_ex2.pdf; floquet_ex2.py; floquet_ex3.pdf; floquet_ex3.py; spectrum_ex1.pdf; spectrum_ex1.py. Users Guide — QuTiP 3.0 Documentation; Basic Operations on Quantum Objects — QuTiP 3.0 Documentation; Plotting on the Bloch Sphere — QuTiP 3.0 Documentation; Two-time correlation functions — QuTiP 3.0 Documentation; Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation; An Overview of the Eseries Class — QuTiP 3.0 Documentation; Guide Overview — QuTiP 3.0 Documentation; Running Problems in Parallel — QuTiP 3.0 Documentation; Generating Random Quantum States & Operators — QuTiP 3.0 Documentation; Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation; Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation,MatchSource.WIKI,index-wcopy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index-wcopy.html
Availability,avail,available,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index.html
Deployability,release,release,"ncluding those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been actively contributing QuTiP. QuTiP is currently supported by these organizations:. QuTiP is proud to be affiliated to:. The development of QuTiP was partially supported by the following organizations:. We also thank Google for their support through the Google Summer of Code program. . Latest releases. QuTiP 5.0.4:; ; September 03, 2024; install; docs; src; changelog. QuTiP 4.7.5:; ; April 5, 2024; install; docs; src; changelog. About QuTiP. GitHub ; Documentation ; Issue tracker ; Mailing list ; Wiki ; License ; Code of conduct . Related projects. SciPy ; NumPy ; Cython ; Matplotlib ; IPython ; SymPy . Affil",MatchSource.WIKI,index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index.html
Energy Efficiency,efficient,efficient,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index.html
Integrability,depend,depends,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index.html
Usability,user-friendly,user-friendly,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP is open-source software for simulating the dynamics of open quantum systems. The QuTiP library depends on the excellent Numpy, Scipy, and Cython numerical packages. In addition, graphical output is provided by Matplotlib. QuTiP aims to provide user-friendly and efficient numerical simulations of a wide variety of Hamiltonians, including those with arbitrary time-dependence, commonly found in a wide range of physics applications such as quantum optics, trapped ions, superconducting circuits, and quantum nanomechanical resonators. QuTiP is freely available for use and/or modification on all major platforms such as Linux, Mac OSX, and Windows*. Being free of any licensing fees, QuTiP is ideal for exploring quantum mechanics and dynamics in the classroom. *QuTiP is developed on Unix platforms only, and some features may not be available under Windows. From the classroom to the corporate office, QuTiP is used around the world to advance research in quantum optics, quantum information, quantum open systems, optomechanics, and many related fields. QuTiP is in use at nearly every single research university around the globe, government-funded research labs, and is relied upon by every major corporation focused on developing a quantum computer. QuTiP is already being used at a variety of institutions around the globe, and has been downloaded more than a million times since its initial release. Need; help in simulating a tricky problem? Our large community of users are gracious enough to take a moment of their time and help in tackling even the most esoteric of issues. Distribution of the 39,420 Unique Visitors in 2020. Supporting Organizations; Developers from Nori's lab and Blais' lab have been ",MatchSource.WIKI,index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/index.html
Availability,avail,available,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Job Announcements; At this time we have no positions available. If you are interested in contributing to QuTiP via schemes like GSOC, Unitary Fund, or otherwise please contact the admin team qutip-admin@googlegroups.com. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,jobs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/jobs.html
Availability,down,downloads,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP News. Mar 7, 2023; QuTiP 2022 Annual Report. QuTiP 2022 Annual Report. Feb 6, 2023; Google Summer of Code 2023 is coming!. NumFOCUS GSoC 2023; QuTiP Proposal Ideas; Application Period: 20 March - 4 April, 2023. December 12, 2022; QuTiP 4.7.1 Released. Release Notes; PyPI; Conda-forge. November 23, 2022; New QuTiP Tutorials and Benchmarks Pages Added to the Website. Benchmarks; Tutorials. November 16, 2022; QuTiP Reaches 1 Milion Downloads. Post; PyPI downloads; Conda Forge downloads. November 7, 2022; QuTiP highlighted in the 2022 Quantum Open Source Software Survey. Results from the Unitary Fund Survey. October 26, 2022; 2022 QuTiP Student Presentations (GSoC Projects). YouTube link. September 6, 2022; QuTiP Workshop at Quantum Africa Summer School in Kigali, Rwanda. Tutorials on QIP (Jupyter Book). July 1, 2022; QuTiP 2022 Google Summer of Code Projects Announced. Christian: QuTiP notebook CI testing and v5 update; Xavier: QuTiP benchmarks; Shreyas: qutip-qip backend for Qiskit. April 15, 2022; QuTiP 2022 Google Summer of Code Proposals Due!. NumFOCUS GSoC 2022; QuTiP Proposal Ideas; Application Period: 4 - 19 April, 2022. April 13, 2022; QuTiP 4.7 Released. Release Notes; PyPI; Conda-forge. April 11, 2022; QuTiP 2021 Annual Report. QuTiP 2021 Annual Report. June 7, 2021; 2021 Google Summer of Code Project Updates. Felipe's blog posts; Purva's blog posts; Asier's blog posts. March 18, 2021; Technical Staff Position for QuTiP Available at RIKEN. See QuTiP Jobs. March 15, 2021; QuTiP applies to Google Summer of Code 2021 under the NumFOCUS organization. NumFOCUS GSoC 2021; QuTiP Proposal Ideas; Application Period: March 29- April 13, 2021. June 22, 2020; 2020 Google Summer of Code Proje",MatchSource.WIKI,news.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/news.html
Deployability,update,update,"ist; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP News. Mar 7, 2023; QuTiP 2022 Annual Report. QuTiP 2022 Annual Report. Feb 6, 2023; Google Summer of Code 2023 is coming!. NumFOCUS GSoC 2023; QuTiP Proposal Ideas; Application Period: 20 March - 4 April, 2023. December 12, 2022; QuTiP 4.7.1 Released. Release Notes; PyPI; Conda-forge. November 23, 2022; New QuTiP Tutorials and Benchmarks Pages Added to the Website. Benchmarks; Tutorials. November 16, 2022; QuTiP Reaches 1 Milion Downloads. Post; PyPI downloads; Conda Forge downloads. November 7, 2022; QuTiP highlighted in the 2022 Quantum Open Source Software Survey. Results from the Unitary Fund Survey. October 26, 2022; 2022 QuTiP Student Presentations (GSoC Projects). YouTube link. September 6, 2022; QuTiP Workshop at Quantum Africa Summer School in Kigali, Rwanda. Tutorials on QIP (Jupyter Book). July 1, 2022; QuTiP 2022 Google Summer of Code Projects Announced. Christian: QuTiP notebook CI testing and v5 update; Xavier: QuTiP benchmarks; Shreyas: qutip-qip backend for Qiskit. April 15, 2022; QuTiP 2022 Google Summer of Code Proposals Due!. NumFOCUS GSoC 2022; QuTiP Proposal Ideas; Application Period: 4 - 19 April, 2022. April 13, 2022; QuTiP 4.7 Released. Release Notes; PyPI; Conda-forge. April 11, 2022; QuTiP 2021 Annual Report. QuTiP 2021 Annual Report. June 7, 2021; 2021 Google Summer of Code Project Updates. Felipe's blog posts; Purva's blog posts; Asier's blog posts. March 18, 2021; Technical Staff Position for QuTiP Available at RIKEN. See QuTiP Jobs. March 15, 2021; QuTiP applies to Google Summer of Code 2021 under the NumFOCUS organization. NumFOCUS GSoC 2021; QuTiP Proposal Ideas; Application Period: March 29- April 13, 2021. June 22, 2020; 2020 Google Summer of Code Project Updates. Jake's Blog posts; Sidhant's Blog posts; Asad's Blog posts. April 6, 2020; Unitary Fund supports QuTiP development through remote mentorships. Website; Blog post. March 16, 2020; Student applications open for G",MatchSource.WIKI,news.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/news.html
Testability,test,testing,"ist; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP News. Mar 7, 2023; QuTiP 2022 Annual Report. QuTiP 2022 Annual Report. Feb 6, 2023; Google Summer of Code 2023 is coming!. NumFOCUS GSoC 2023; QuTiP Proposal Ideas; Application Period: 20 March - 4 April, 2023. December 12, 2022; QuTiP 4.7.1 Released. Release Notes; PyPI; Conda-forge. November 23, 2022; New QuTiP Tutorials and Benchmarks Pages Added to the Website. Benchmarks; Tutorials. November 16, 2022; QuTiP Reaches 1 Milion Downloads. Post; PyPI downloads; Conda Forge downloads. November 7, 2022; QuTiP highlighted in the 2022 Quantum Open Source Software Survey. Results from the Unitary Fund Survey. October 26, 2022; 2022 QuTiP Student Presentations (GSoC Projects). YouTube link. September 6, 2022; QuTiP Workshop at Quantum Africa Summer School in Kigali, Rwanda. Tutorials on QIP (Jupyter Book). July 1, 2022; QuTiP 2022 Google Summer of Code Projects Announced. Christian: QuTiP notebook CI testing and v5 update; Xavier: QuTiP benchmarks; Shreyas: qutip-qip backend for Qiskit. April 15, 2022; QuTiP 2022 Google Summer of Code Proposals Due!. NumFOCUS GSoC 2022; QuTiP Proposal Ideas; Application Period: 4 - 19 April, 2022. April 13, 2022; QuTiP 4.7 Released. Release Notes; PyPI; Conda-forge. April 11, 2022; QuTiP 2021 Annual Report. QuTiP 2021 Annual Report. June 7, 2021; 2021 Google Summer of Code Project Updates. Felipe's blog posts; Purva's blog posts; Asier's blog posts. March 18, 2021; Technical Staff Position for QuTiP Available at RIKEN. See QuTiP Jobs. March 15, 2021; QuTiP applies to Google Summer of Code 2021 under the NumFOCUS organization. NumFOCUS GSoC 2021; QuTiP Proposal Ideas; Application Period: March 29- April 13, 2021. June 22, 2020; 2020 Google Summer of Code Project Updates. Jake's Blog posts; Sidhant's Blog posts; Asad's Blog posts. April 6, 2020; Unitary Fund supports QuTiP development through remote mentorships. Website; Blog post. March 16, 2020; Student applications open for G",MatchSource.WIKI,news.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/news.html
Deployability,install,installing,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-virtual-lab.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-virtual-lab.html
Integrability,interface,interface,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-virtual-lab.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-virtual-lab.html
Performance,optimiz,optimized,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-virtual-lab.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-virtual-lab.html
Usability,simpl,simple,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. QuTiP Virtual Lab. Exploring simple quantum systems with QuTiP can help build intuition for them,; but there are many cases where writing code and Jupyter notebooks can get; in the way:. When teaching, coding can be a big distraction. Quantum mechanics is complex ; enough without your students having to struggle with installing software,; messing up their notebooks or learning QuTiP at the same time. When doing research, coding can be a big detour. You just want to do a quick; check to remind yourself how a simple system works, not spend the afternoon; fiddling in a text editor. You have papers to write and grant reports to fill; in. Time is precious. When at a party or while pitching your cool ideas, you don’t want to take out; your laptop to show people how cool your ideas are. It breaks the flow. You; need to be able to show them on your tablet. For all of these use cases, there is QuTiP Virtual Lab – a tablet and web; optimized graphical interface for building and exploring simple quantum systems.; It runs entirely in your browser, so there’s no server and nothing to install.; Click the button below to get started!; Enter QuTiP Virtual Lab.; There’s a handy tutorial with videos included in the virtual lab itself and some pre-built systems; to get you started. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-virtual-lab.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-virtual-lab.html
Availability,error,error,"oherent oscillations inside a quantum manifold stabilized by dissipation"", ; arXiv:1705.02401. 350. Zhao et al., ""Two-photon driven Kerr resonator for quantum annealing with three-dimensional circuit QED"", ; arXiv:1712.03613. 349. Tezak et al., ""Low-dimensional manifolds for exact representation of open quantum systems"", ; Phys. Rev. A 96, 062113 (2017). 348. Lambert et al., ""Amplified and tunable transverse and longitudinal spin-photon coupling in hybrid circuit-QED"", ; arXiv:1712.02077. 347. Mirkin et al., ""In the quest of relations between non-Markovianity and quantum optimal control"", ; arXiv:1711.10551. 346. Gu et al., ""Topological edge states and pumping in a chain of coupled superconducting qubits"", ; arXiv:1711.06829. 345. Jiang et al., ""Quantum algorithms to simulate many-body physics of correlated fermions"", ; arXiv:1711.05395. 344. Brambilla et al., ""Heavy quarkonium suppression in a fireball"", ; arXiv:1711.04515. 343. Johnson et al., ""QVECTOR: an algorithm for device-tailored quantum error correction"", ; arXiv:1711.02249. 342. Li et al., ""Preparing entangled states between two NV centers via the damping of nanomechanical resonators"", ; Sci. Rep. 7, 14116 (2017). 341. Khan et al., ""Frequency combs in a lumped element Josephson junction circuit"", ; arXiv:1711.00772. 340. Trautmann et al., ""Trapped-ion quantum simulation of excitation transport: disordered, noisy, and long-range connected quantum networks"", ; arXiv:1710.09408. 339. Hu et al., ""Dark states and delocalization: competing effects of quantum coherence on the efficiency of light harvesting systems"", ; arXiv:1710.06792. 338. Potočnik et al., ""Studying Light-Harvesting Models with Superconducting Circuits"", ; arXiv:1710.07466. 337. Banchi et al., ""Driven Quantum Dynamics: Will It Blend?"", ; Phys. Rev. X 7, 041015 (2017). 336. Dhand et al., ""Quantum simulation via all-optically generated tensor network states"", ; arXiv:1710.06103. 335. Poonia et al., ""Quantum Biomimetic Modeling of Diamond NV- Center",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Deployability,upgrade,upgrade,"2017). 258. Gely et al., ""Convergence of the multimode quantum Rabi model of circuit quantum electrodynamics"", ; Phys. Rev. B 95, 245115 (2017). 257. Radtke et al., ""Photonic Quantum Operations via the Quantum Carburettor Effect"", ; arXiv:1701.04251. 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via posts",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Energy Efficiency,efficient,efficient,"ynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quantum data"", ; Quantum Sci. Technol. 2, 045001 (2017). 241. Zhong, ""Controllable and fast quantum-information transfer between distant nodes in two-dimensional networks"", ; Sci. Rep. 6, 8 (2016). 240. Guo et al., ""Giant acoustic atom: A single quantum system with a deterministic time delay"", ; Phys. Rev. A 95, 053821 (2017). 239. Vermersch et al., ""Quantum State Transfer via Noisy Photonic and Phononic Waveguides"", ; Phys. Rev. Lett. 118, 133601 (2017). 238. Gudmundsson et al., ""Time-dependent current into and through multilevel parallel quantum dots in a photon cavity"", ; Phys. Rev. B 95, 195307 (2017). 237. Braumüller et al., ""Analog quantum simulation of the Rabi model in the ultra-strong coupling regime"", ; Nat. Commun. 8, 779 (2017). 236. Lagoudakis et al., ""Ultrafast coherent manipulation of trions in site-controlled nanowire quantum dots"", ; Optica 3, 1430 (2016). 235. Roghani et al., ""Dissipative Preparation of Entangled Many-Body States with Rydberg Atoms"", ; arX",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Integrability,interface,interface,"točnik et al., ""Studying Light-Harvesting Models with Superconducting Circuits"", ; arXiv:1710.07466. 337. Banchi et al., ""Driven Quantum Dynamics: Will It Blend?"", ; Phys. Rev. X 7, 041015 (2017). 336. Dhand et al., ""Quantum simulation via all-optically generated tensor network states"", ; arXiv:1710.06103. 335. Poonia et al., ""Quantum Biomimetic Modeling of Diamond NV- Center Spin Dynamics"", ; arXiv:1709.07632. 334. Nimmrichter et al., ""Quantum and classical dynamics of a three-mode absorption refrigerator"", ; Quantum 1, 37 (2017). 333. Qin et al., ""Exponentially-Enhanced Light-Matter Interaction, Cooperativities, and Steady-State Entanglement Using Parametric Amplification"", ; arXiv:1709.09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Diss",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Modifiability,coupling,coupling,"; arXiv:1712.09762. 359. Dahlberg et al., ""SimulaQron - A simulator for developing quantum internet software"", ; arXiv:1712.08032. 358. Abdel-Wahab et al., ""Dynamic evolution of double Λ five-level atom interacting with one-mode electromagnetic cavity field"", ; Pramana - J. Phys. 89, 87 (2017). 357. Dai et al., ""Quantum simulation of the general semi-classical Rabi model in regimes of arbitrarily strong driving"", ; Appl. Phys. Lett. 111, 242601 (2017). 356. Zhou et al., ""Simulating the Lipkin-Meshkov-Glick model in a hybrid quantum system"", ; arXiv:1712.06234. 355. Otterbach et al., ""Unsupervised Machine Learning on a Hybrid Quantum Computer"", ; arXiv:1712.05771. 354. Wang et al., ""Parallel quantum operations with chiral spin states in a superconducting circuit"", ; arXiv:1712.05261. 353. Tugen et al., ""A Comparative Study of Coupled High-Q Cavity-Quantum Dot System Regarding Dipole Induced Transparency"", ; arXiv:1712.01944. 352. Chen et al., ""Tuning coupling between superconducting resonators with collective qubits"", ; arXiv:1712.04357. 351. Touzard et al., ""Coherent oscillations inside a quantum manifold stabilized by dissipation"", ; arXiv:1705.02401. 350. Zhao et al., ""Two-photon driven Kerr resonator for quantum annealing with three-dimensional circuit QED"", ; arXiv:1712.03613. 349. Tezak et al., ""Low-dimensional manifolds for exact representation of open quantum systems"", ; Phys. Rev. A 96, 062113 (2017). 348. Lambert et al., ""Amplified and tunable transverse and longitudinal spin-photon coupling in hybrid circuit-QED"", ; arXiv:1712.02077. 347. Mirkin et al., ""In the quest of relations between non-Markovianity and quantum optimal control"", ; arXiv:1711.10551. 346. Gu et al., ""Topological edge states and pumping in a chain of coupled superconducting qubits"", ; arXiv:1711.06829. 345. Jiang et al., ""Quantum algorithms to simulate many-body physics of correlated fermions"", ; arXiv:1711.05395. 344. Brambilla et al., ""Heavy quarkonium suppression in a fireball"", ; arX",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Performance,scalab,scalable,".09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Dissipative phase transition in the open quantum Rabi model"", ; Phys. Rev. A 97, 013825 (2018). 322. Higgins et al., ""Coherent Control of a Single Trapped Rydberg Ion"", ; Phys. Rev. Lett. 119, 220501 (2017). 321. Schlipf et al., ""A molecular quantum spin network controlled by a single qubit"", ; Sci. Adv. 3, 1701116 (2017). 320. Hardal et al., ""Quantum heat engine with coupled superconducting resonators"", ; Phys. Rev. E 96, 062120 (2017). 319. Katabarwa et al., ""Quantum Projective Simulation with Hamiltonian Evolution: A study in reinforcement learning"", ; arXiv:1708.00123. 318. Kienzler et al., ""Quantum Harmonic Oscillator State Control in a Squeezed Fock Basis"", ; Phys. Rev. Lett. 119, 0336",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Safety,detect,detection,"ional-order switched systems and its digital implementation"", ; International Journal of Electronics and Communications (2017). 297. Yoshihara et al., ""Characteristic spectra of circuit quantum electrodynamics systems from the ultrastrong- to the deep-strong-coupling regime"", ; Phys. Rev. A 95, 053824 (2017). 296. Endo et al., ""Dynamics of an ultra-strongly-coupled system interacting with a driven nonlinear resonator"", ; arXiv:1705.08688. 295. Venkatesh et al., ""Cooperative Effects in Closely Packed Quantum Emitters with Collective Dephasing"", ; Phys. Rev. Lett. 120, 033602 (2018). 294. Snijders et al., ""A fiber coupled cavity QED source of identical single photons"", ; arXiv:1705.05876. 293. Zanker et al., ""Analyzing the spectral density of a perturbed analog quantum simulator using Keldysh formalism"", ; arXiv:1705.02325. 292. Csurgay et al., ""Toward engineering design of quantum circuits"", ; Int. J. Circ. Theor. Appl. (2017). 291. Megyeri et al., ""Why material slow light does not improve cavity-enhanced atom detection"", ; J. Mod. Phys. (2017). 290. Huembeli et al., ""Towards a heralded eigenstate-preserving measurement of multi-qubit parity in circuit QED"", ; Phys. Rev. A 96, 012313 (2017). 289. Shammah et al., ""Superradiance with local phase-breaking effects"", ; Phys. Rev. A 96, 023863 (2017). 288. Arenz et al., ""The roles of drift and control field constraints upon quantum control speed limits"", ; New J. Phys. 19, 103015 (2017). 287. Leroux et al., ""Simple variational ground state and pure-cat-state generation in the quantum Rabi model"", ; Phys. Rev. A 96, 043834 (2017). 286. Laflamme et al., ""Continuous measurement of an atomic current"", ; Phys. Rev. A 95, 043843 (2017). 285. de Assis et al., ""Negative response with an optical cavity and traveling wave fields"", ; Phys. Rev. A 96, 013821 (2017). 284. Gough, ""The Tyranny of Qubits - Quantum Technology's Scalability Bottleneck"", ; arXiv:1703.05342. 283. Hamsen et al., ""Two-Photon Blockade in an Atom-Driven Cavity QED",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Security,access,access," 256. Lagoudakis et al., ""Observation of Mollow Triplets with Tunable Interactions in Double Lambda Systems of Individual Hole Spins"", ; Phys. Rev. Lett. 118, 013602 (2017). 255. Pucci et al., ""Quantum effects in the cooperative scattering of light by atomic clouds"", ; Phys. Rev. A 95, 053625 (2017). 254. Gessner et al., ""Resolution-enhanced entanglement detection"", ; Phys. Rev. A 95, 032326 (2017). 253. Nigg et al., ""Superconducting Grid-Bus Surface Code Architecture for Hole-Spin Qubits"", ; Phys. Rev. Lett. 118, 147701 (2017). 252. Lüer et al., ""Lévy Defects in Matrix-Immobilized J Aggregates: Tracing Intra-and Intersegmental Exciton Relaxation"", ; J. Phys. Chem. Lett. 8, 547 (2017). 251. Dive et al., ""In situ upgrade of quantum simulators to universal computers"", ; arXiv:1701.01723. 250. Barnes et al., ""Fast microwave-driven three-qubit gates for cavity-coupled superconducting qubits"", ; Phys. Rev. B 96, 024504 (2017). 249. Hu, ""Spin-based single-photon transistor, dynamic random access memory, diodes, and routers in semiconductors"", ; Phys. Rev. B 94, 245307 (2016). 248. Leung et al., ""Speedup for quantum optimal control from automatic differentiation based on graphics processing units"", ; Phys. Rev. A 95, 042318 (2017). 247. Bruhat et al., ""Strong coupling between an electron in a quantum dot circuit and a photon in a cavity"", ; arXiv:1612.05214. 246. Zanoci et al., ""Entanglement and thermalization in open fermion systems"", ; arXiv:1612.04840. 245. Volokitin et al., ""Computation of the asymptotic states of modulated open quantum systems with a numerically exact realization of the quantum trajectory method"", ; Phys. Rev. E 96, 053313 (2017). 244. Montenegro et al., ""Macroscopic nonclassical-state preparation via postselection"", ; Phys. Rev. A 96, 053851 (2017). 243. Cirio et al., ""Amplified Optomechanical Transduction of Virtual Radiation Pressure"", ; Phys. Rev. Lett. 119, 053601 (2017). 242. Romero et al., ""Quantum autoencoders for efficient compression of quan",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Testability,benchmark,benchmarking," QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Papers Using QuTiP; Found QuTiP useful for your own work? Please consider helping out by donating an example notebook highlighting how QuTiP was used in your publication. Paper; Journal; Notebook. 371. Fischer et al., ""Scattering into one-dimensional waveguides from a coherently-driven quantum-optical system"", ; Quantum 2, 69 (2018).; Notebook. 370. Fischer et al., ""Particle emission from open quantum systems"", ; arXiv:1803.04648; Notebook. 369. Sonar et al., ""Squeezing Enhances Quantum Synchronization"", ; arXiv:1801.10383. 368. Bergfield et al., ""Signatures of Plexitonic States in Molecular Electroluminescence"", ; Sci. Rep. 8, 2314 (2018). 367. Benedetti et al., ""A generative modeling approach for benchmarking and training shallow quantum circuits"", ; arXiv:1801.07686. 366. Botzem et al., ""Tuning methods for semiconductor spin--qubits"", ; arXiv:1801.03755. 365. Schneider et al., ""Local Sensing with an AC Stark Spectrum Analyzer"", ; arXiv:1801.05144. 364. Seah et al., ""Work production of quantum rotor engines"", ; arXiv:1801.02820. 363. Susa et al., ""Exponential Speedup of Quantum Annealing by Inhomogeneous Driving of the Transverse Field"", ; arXiv:1801.02005. 362. Hanschke et al., ""Quantum dot single photon sources with ultra-low multi-photon probability"", ; arXiv:1801.01672; Notebook. 361. Vermersch et al., ""Unitary n-designs via random quenches in atomic Hubbard and Spin models: Application to the measurement of Renyi entropies"", ; arXiv:1801.00999. 360. Krastanov et al., ""Optimized Entanglement Purification"", ; arXiv:1712.09762. 359. Dahlberg et al., ""SimulaQron - A simulator for developing quantum internet software"", ; arXiv:1712.08032. 358. Abdel-Wahab et al., ""Dynamic evolution of double",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Usability,feedback,feedback,".09555. 332. Ishibashi et al., ""Oscillation collapse in coupled quantum van der Pol oscillators"", ; Phys. Rev. E 96, 052210 (2017). 331. Elbin et al., ""Rényi Entropies from Random Quenches in Atomic Hubbard and Spin Models"", ; arXiv:1709.05060. 330. Li et al., ""Quantum microwave-optical interface with nitrogen-vacancy centers in diamond"", ; Phys. Rev. A 96, 032342 (2017). 329. Diguna et al., ""The coupling of single-photon exciton–biexciton quantum dot and cavity"", ; J. Nonlinear Optic. Phys. Mat. 1750029, (2017). 328. Lee et al., ""Effective formalism for open-quantum-system dynamics: Time-coarse-graining approach"", ; Phys. Rev. A 97, 012102 (2018). 327. de Moraes Neto et al., ""Steady many-body entanglements in dissipative systems"", ; Phys. Rev. A 96, 062313 (2017). 326. Zhang et al., ""Efficient numerical solution of excitation number conserving quantum systems"", ; AIP Advances 7, 085225 (2017). 325. Heuck et al., ""Temporally and frequency multiplexed single photon source using quantum feedback control for scalable photonic quantum technologies"", ; arXiv:1708.08875. 324. Kurian et al., ""Oxidative species-induced excitonic transport in tubulin aromatic networks: Potential implications for neurodegenerative disease"", ; J. Photochem. Photobiol. B: Biology (2017). 323. Hwang et al., ""Dissipative phase transition in the open quantum Rabi model"", ; Phys. Rev. A 97, 013825 (2018). 322. Higgins et al., ""Coherent Control of a Single Trapped Rydberg Ion"", ; Phys. Rev. Lett. 119, 220501 (2017). 321. Schlipf et al., ""A molecular quantum spin network controlled by a single qubit"", ; Sci. Adv. 3, 1701116 (2017). 320. Hardal et al., ""Quantum heat engine with coupled superconducting resonators"", ; Phys. Rev. E 96, 062120 (2017). 319. Katabarwa et al., ""Quantum Projective Simulation with Hamiltonian Evolution: A study in reinforcement learning"", ; arXiv:1708.00123. 318. Kienzler et al., ""Quantum Harmonic Oscillator State Control in a Squeezed Fock Basis"", ; Phys. Rev. Lett. 119, 0336",MatchSource.WIKI,users.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/users.html
Energy Efficiency,charge,charge,"1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - Simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Integrability,depend,dependent,Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Time-dependent Master Equation: Landau-Zener transitions; Time-dependent Master Equation: Landau-Zener-Stuckelberg inteferometry; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady stat,MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Modifiability,coupling,coupling,"me coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; Spin squeezing with noise ; Boundary time crystals ; Multiple spin ensembles ; Von Neumann entropy and purity . Hierarchical Equations of Motion. HEOM 1a: Spin-Bath model (introduction); HEOM 1b: Spin-Bath model (very strong coupling); HEOM 1c: Spin-Bath model (Underdamped Case); HEOM 1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - Simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectorie",MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Safety,detect,detection,Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Time-dependent Master Equation: Landau-Zener transitions; Time-dependent Master Equation: Landau-Zener-Stuckelberg inteferometry; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady stat,MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Testability,benchmark,benchmarking,and introduce specific functionality in QuTiP. Python Introduction. Introduction to Python; Introduction to NumPy Arrays; Plotting in Python Using Matplotlib; Lecture 0 - Introduction to QuTiP. For a more in depth discussion see: Lectures on scientific computing with Python.; Visualization. Bloch Sphere animation; Bloch Sphere with colorbar; Energy-level diagrams; Pseudo-probability functions; Quantum Process Tomography; Qubism visualizations; Visualization demos; Wigner functions. Quantum information processing; This section requires an additional package qutip-qip.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Time-dependent Master Equation: Landau-Zener transitions; Time-dependent Master Equation: Landau-Zener-Stuckelberg inteferometry; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection ,MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Usability,guid,guide,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Tutorials for QuTiP Version 4. This page contains our collection of Jupyter (formerly IPython) notebooks; for introducing and demonstrating features of QuTiP.; Going through these notebooks should be a good way to get familiarized with the software.; If you are new to scientific computing with Python, you might also find it; useful to have a look at these IPython notebook; Lectures on scientific computing with Python. This are the tutorials for QuTiP Version 4. You can find the tutorials for QuTiP Version 5 here. ; A guide for transitioning from version 4 to version 5 can be found here. ; The following are the contents of this page:. Example notebooks. Python Introduction; Visualization; Quantum information processing. Quantum circuits and algoritms; Pulse-level circuit simulation. Time evolution; Optimal control; Tomography; Permutational invariant Lindblad dynamics; Hierarchical Equations of Motion; Miscellaneous tutorials. Quantum mechanics lectures with QuTiP; Contributing. Example notebooks. These notebooks demonstrate and introduce specific functionality in QuTiP. Python Introduction. Introduction to Python; Introduction to NumPy Arrays; Plotting in Python Using Matplotlib; Lecture 0 - Introduction to QuTiP. For a more in depth discussion see: Lectures on scientific computing with Python.; Visualization. Bloch Sphere animation; Bloch Sphere with colorbar; Energy-level diagrams; Pseudo-probability functions; Quantum Process Tomography; Qubism visualizations; Visualization demos; Wigner functions. Quantum information processing; This section requires an additional package qutip-qip.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotat",MatchSource.WIKI,qutip-tutorials/index-v4.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index-v4.html
Energy Efficiency,charge,charge,"pectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference; qutip-jax JAX backend for qutip. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 - Quantum Monte-Carlo Trajectories; Lecture 7 - Two-qubit iSWAP gate and process tomography; Lecture 8 - Adiabatic sweep; Lecture 9 - Squeezed states of a quantum harmonic oscillator; Lecture 10 - Cavity-QED in the dispersive regime; Lecture 11 - Superconducting Josephson charge qubits; Lecture 12 - Decay into a squeezed vacuum field; Lecture 13 - Resonance flourescence; Lecture 14 - Kerr nonlinearities; Lecture 15 - Nonclassically driven atoms (cascaded quantum systems); Lecture 16 - Gallery of Wigner functions. Contributing; If you would like to contribute a notebook or report a bug, you may open; an issue or pull request in the; qutip-tutorials; GitHub repository. A few of the notebooks are still maintained in the repository; qutip-notebooks and; a complete archive of older versions of the tutorials is maintained there. © 2011 to 2024 inclusive, QuTiP developers and contributors. . ",MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Integrability,depend,dependent,p.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Non-Markovian Monte Carlo Solver: Two Physical Examples; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; ,MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Modifiability,coupling,coupling,"me coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; Spin squeezing with noise ; Boundary time crystals ; Multiple spin ensembles ; Von Neumann entropy and purity . Hierarchical Equations of Motion. HEOM 1a: Spin-Bath model (introduction); HEOM 1b: Spin-Bath model (very strong coupling); HEOM 1c: Spin-Bath model (Underdamped Case); HEOM 1d: Spin-Bath model, fitting of spectrum and correlation functions; HEOM 1e: Spin-Bath model (pure dephasing); HEOM 2: Dynamics in Fenna-Mathews-Olsen complex (FMO); HEOM 3: Quantum Heat Transport; HEOM 4: Dynamical decoupling of a non-Markovian environment; HEOM 5a: Fermionic single impurity model; HEOM 5b: Discrete boson coupled to an impurity and fermionic leads; Hierarchical Equation of Motion Examples. Miscellaneous tutorials. Lecture: Single-photon Interference; qutip-jax JAX backend for qutip. Quantum mechanics lectures with QuTiP; These lecture-style notebooks focus on particular quantum mechanics; topics and analyze them numerically using QuTiP (some more detailed than others). Lecture 0 - Introduction to QuTiP; Lecture 1 - Vacuum Rabi oscillations in the Jaynes-Cummings model; Lecture 2A - simulation of a two-qubit gate using a resonator as coupler; Lecture 2B - Single-Atom-Lasing; Lecture 3A - The Dicke model; Lecture 3B - Jaynes-Cummings-like model in the ultrastrong coupling regime; Lecture 4 - Correlation functions; Lecture 5 - Evolution and quantum statistics of a quantum parameter amplifier; Lecture 6 ",MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Safety,detect,detection,p.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Non-Markovian Monte Carlo Solver: Two Physical Examples; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coherent; Steady-State: Optomechanical System in the Single-Photon Strong-Coupling Regime; Steady-State: Homodyned Jaynes-Cummings emission; Steady-State: Time-dependent (periodic) quantum system. Optimal control. Overview ; Hadamard ; QFT ; Lindbladian ; Symplectic ; QFT (CRAB) ; State to state (CRAB) ; CNOT ; iSWAP ; Single-qubit rotation ; Toffoli gate . Tomography. Density matrix estimation with iterative maximum likelihood estimation . Permutational invariant Lindblad dynamics. Overview ; Superradiant light emission ; Steady state superradiance ; Open Dicke model ; ,MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Testability,benchmark,benchmarking,cific functionality in QuTiP. Python Introduction. Introduction to Python; Introduction to NumPy Arrays; Plotting in Python Using Matplotlib; Lecture 0 - Introduction to QuTiP. For a more in depth discussion see: Lectures on scientific computing with Python.; Visualization. Animation demos; Bloch Sphere animation; Bloch Sphere with colorbar; Energy-level diagrams; Pseudo-probability functions; Quantum Process Tomography; Qubism visualizations; Visualization demos; Wigner functions. Quantum information processing; This section requires an additional package qutip-qip.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and single-qubit rotations; Imports and Exports QASM circuit; QuTiP example: Quantum Gates and their usage; Quantum Teleportation Circuit. Pulse-level circuit simulation. Compiling and simulating a 10-qubit Quantum Fourier Transform (QFT) algorithm; Custimize the pulse-level simulation; Examples for OptPulseProcessor; Scheduler for quantum gates and instructions; Simulating randomized benchmarking; Simulating the Deutsch–Jozsa algorithm at the pulse level; measuring the relaxation time with the idling gate. Time evolution. QobjEvo: time-dependent quantum objects; Schrödinger Equation Solver: Larmor precession; Master Equation Solver: Single-Qubit Dynamics; Master Equation Solver: Vacuum Rabi oscillations; Master Equation Solver: Dynamics of a Spin Chain; Monte Carlo Solver: Birth and Death of Photons in a Cavity; Bloch-Redfield Solver: Two Level System; Bloch-Redfield Solver: Time dependent operators; Bloch-Redfield Solver: Dissipative Atom-Cavity system; Bloch-Redfield Solver: Phonon-assisted initialization; Floquet Solvers; Floquet Formalism; Non-Markovian Monte Carlo Solver: Two Physical Examples; Stochastic Solver: Heterodyne Detection; Stochastic Solver: Mixing stochastic and deterministic equations; Stochastic Solver: Photo-current detection in a JC model; Stochastic vs. Monte-Carlo Solver: Cat states become coher,MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Usability,guid,guide,"﻿. QuTiP - Quantum Toolbox in Python. Fork me on GitHub. QuTiP; Quantum Toolbox in Python. QuTiP. News; Releases. Documentation. Users Guide; Tutorials; Benchmarks; QuTiP Virtual Lab; Features; Citing. Community. Mailing List; Github; Papers Using QuTiP; Job Announcements. Devs. Tutorials for QuTiP Version 5. This page contains our collection of Jupyter (formerly IPython) notebooks; for introducing and demonstrating features of QuTiP.; Going through these notebooks should be a good way to get familiarized with the software.; If you are new to scientific computing with Python, you might also find it; useful to have a look at these IPython notebook; Lectures on scientific computing with Python. This are the tutorials for QuTiP Version 5. You can find the tutorials for QuTiP Version 4 here. ; A guide for transitioning from version 4 to version 5 can be found here. ; The following are the contents of this page:. Example notebooks. Python Introduction; Visualization; Quantum information processing. Quantum circuits and algoritms; Pulse-level circuit simulation. Time evolution; Optimal control; Tomography; Permutational invariant Lindblad dynamics; Hierarchical Equations of Motion; Miscellaneous tutorials. Quantum mechanics lectures with QuTiP; Contributing. Example notebooks. These notebooks demonstrate and introduce specific functionality in QuTiP. Python Introduction. Introduction to Python; Introduction to NumPy Arrays; Plotting in Python Using Matplotlib; Lecture 0 - Introduction to QuTiP. For a more in depth discussion see: Lectures on scientific computing with Python.; Visualization. Animation demos; Bloch Sphere animation; Bloch Sphere with colorbar; Energy-level diagrams; Pseudo-probability functions; Quantum Process Tomography; Qubism visualizations; Visualization demos; Wigner functions. Quantum information processing; This section requires an additional package qutip-qip.; Quantum circuits and algorithms. Decomposition of the Toffoli gate in terms of CNOT and s",MatchSource.WIKI,qutip-tutorials/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/qutip-tutorials/index.html
Deployability,install,installation,". Bibliography — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bibliography. « Developers. Bibliography¶. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA.77.032322. [Gri98]; Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). do",MatchSource.WIKI,docs/3.0.0/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/biblio.html
Availability,avail,available,"spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squ",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Deployability,install,installation,". Change Log — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Change Log; Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Versio",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Energy Efficiency,power,power,"w; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which n",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Integrability,depend,dependent," (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a precalculated numpy array that specifies the values of the; Qobj-coefficients for each time step.; New functions for working with different superoperator representations,; including Kraus and Chi representation.; New functions for visualizing quantum states using Qubism and Schimdt plots:; plot_qubism and plot_schmidt.; Dynamics solver now support taking argument e_ops (expectation value; operators) in dictionary form.; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been re",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Modifiability,variab,variable,"eData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gate",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Performance,concurren,concurrence,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Imp",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Safety,avoid,avoiding,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose func",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Testability,test,tests,"lback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to ",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Usability,simpl,simplified," for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner co",MatchSource.WIKI,docs/3.0.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/changelog.html
Deployability,install,installation,". Developers — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Developers; Lead Developers; Contributors. « Change Log. Bibliography ». Developers¶. Lead Developers¶; Robert Johansson (RIKEN); Paul Nation (Korea University). Contributors¶. Note; Anyone is welcome to contribute to QuTiP. If you are interested in helping, please let us know!. alexbrc (github user) - Code contributor; Amit Jamadagni - Bug fix; Anders Lund (Technical University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav Vardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documenta",MatchSource.WIKI,docs/3.0.0/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/contributors.html
Availability,avail,available,"rrelation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.0. status:Released. copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Jap",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Deployability,install,installation,". Frontmatter — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, ",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Energy Efficiency,efficient,efficiently," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, provid",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Ba",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Modifiability,coupling,coupling,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optic",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Performance,perform,performed,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Testability,test,tested,"ed ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See C",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Usability,guid,guide,"m Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.0. status:Released. copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.",MatchSource.WIKI,docs/3.0.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/frontmatter.html
Deployability,install,installation,". Index — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Index. A; | B; | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gat",MatchSource.WIKI,docs/3.0.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/genindex.html
Performance,concurren,concurrence,loch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). csign() (in module qutip.qip.gates). D. dag() (Qobj method). destroy() (in module qutip.operators). diag() (Qobj method). dispersive_gate_correction() (DispersivecQED method). DispersivecQED (class in qutip.qip.models.cqed).,MatchSource.WIKI,docs/3.0.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/genindex.html
Usability,clear,clear, | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_vari,MatchSource.WIKI,docs/3.0.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/genindex.html
Deployability,install,installation,". QuTiP: Quantum Toolbox in Python (3.0.0) — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.0.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.0.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windo",MatchSource.WIKI,docs/3.0.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/index.html
Integrability,depend,dependencies,"ns; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.0.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.0.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floque",MatchSource.WIKI,docs/3.0.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/index.html
Performance,load,loading,"amiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Utilitiy Functions. Change Log; Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); ",MatchSource.WIKI,docs/3.0.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/index.html
Availability,avail,available,"tran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Deployability,install,installation,". Installation — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming ",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Integrability,depend,dependencies,"jects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carl",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Modifiability,variab,variable,"eshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Verifying the Installation¶; QuTiP includes a collection of built-in test scripts to verify that an installation was successful. To run the suite of tests scripts you must have the nose testing library. After installing QuTiP, leave the installation directory, run Python (or iPython), and call:; >>> import qutip.testing as qt; >>> qt.run(). If successful, these tests indicate that all of the QuTiP functions are working properly. If any errors occur, please check that your have installed all of the required modules. See the next section on how to check the installed versions of the QuTiP dependencies. If these tests still fail, t",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Performance,perform,performance,"cientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then ",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Testability,test,tested,"1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present,",MatchSource.WIKI,docs/3.0.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/installation.html
Deployability,install,installation,". Python Module Index — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.fortran.mcsolve_f90.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.operators.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.sesolve.    ; qutip.states.    ; quti",MatchSource.WIKI,docs/3.0.0/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/py-modindex.html
Deployability,install,installation,". Search — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Search. Please activate JavaScript to enable the search; functionality.; . From here you can search these documents. Enter your search; words into the box below and click ""search"". Note that the search; function will automatically search for all of the words. Pages; containing fewer words won't appear in the result list.; . Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/search.html
Deployability,install,installation,". Bibliography — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bibliography. « Developers. Bibliography¶. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA.77.032322. [Gri98]; Grifoni, P. Hänggi,",MatchSource.WIKI,docs/3.0.1/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/biblio.html
Availability,failure,failure,".0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occured when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsing; the version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API for working with; distribution functions.; New format for defining time-dependent Hamiltonians and collapse operators,; using a pr",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Deployability,install,installation,". Change Log — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Change Log; Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); N",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Energy Efficiency,power,power,"w; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which n",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Integrability,depend,dependent,"e . Change Log; Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occured when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsing; the version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochastic with stochastic master equation and stochastic; Schrödinger equation solvers.; Expanded steady state solvers. The function steady has been deprecated in; favor of steadystate. The steadystate solver no longer use umfpack by; default. New pre-processing methods for reordering and balancing the linear; equation system used in direct solution of the steady state.; New module qutip.qip with utilities for quantum information processing,; including pre-defined quantum gates along with functions for expanding; arbitrary 1, 2, and 3 qubit gates to N qubit registers, circuit; representations, library of quantum algorithms, and basic physical models for; some common QIP architectures.; New module qutip.distributions with unified API fo",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Modifiability,variab,variable,"eData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to the command line if ntraj=1. Version 2.1.0 (October 05, 2012):¶. New Features¶. New method for generating Wigner functions based on Laguerre polynomials.; coherent(), coherent_dm(), and thermal_dm() can now be expressed using analytic values.; Unittests now use nose and can be run after installation.; Added iswap and sqrt-iswap gate",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Performance,concurren,concurrence,".; Public plotting functions from the qutip.visualization module are now; prefixed with plot_ (e.g., plot_fock_distribution). The; plot_wigner and plot_wigner_fock_distribution now supports 3D views; in addition to contour views.; New API and new functions for working with spin operators and states,; including for example spin_Jx, spin_Jy, spin_Jz and; spin_state, spin_coherent.; The expect function now supports a list of operators, in addition to the; previously supported list of states.; Simplified creation of qubit states using ket function.; The module qutip.cyQ has been renamed to qutip.cy and the sparse; matrix-vector functions spmv and spmv1d has been combined into one; function spmv. New functions for operating directly on the underlaying; sparse CSR data have been added (e.g., spmv_csr). Performance; improvements. New and improved Cython functions for calculating expectation; values for state vectors, density matrices in matrix and vector form.; The concurrence function now supports both pure and mixed states. Added; function for calculating the entangling power of a two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Imp",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Safety,avoid,avoiding,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose func",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Testability,test,tests,"lback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner colormap for highlighting negative values.; More graph styles to the visualization module. Bug Fixes:¶. Function based time-dependent Hamiltonians now keep the correct phase.; mcsolve no longer prints to ",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Usability,simpl,simplified," for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master eqautions with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructued.; QuTiP is now using continous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose function.; Continuos variable functions for calculating correlation and covariance; matrices, the Wigner covariance matrix and the logarithmic negativity for; for multimode fields in Fock basis.; The master-equation solver (mesolve) now accepts pre-constructed Liouvillian; terms, which makes it possible to solve master equations that are not on; the standard Lindblad form.; Optional Fortran Monte Carlo solver (mcsolve_f90) by Arne Grimsmo.; A module of tools for using QuTiP in IPython notebooks.; Increased performance of the steady state solver.; New Wigner co",MatchSource.WIKI,docs/3.0.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/changelog.html
Deployability,install,installation,". Developers — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Developers; Lead Developers; Contributors. « Change Log. Bibliography ». Developers¶. Lead Developers¶; Robert Johansson (RIKEN); Paul Nation (Korea University). Contributors¶. Note; Anyone is welcome to contribute to QuTiP. If you are interested in helping, please let us know!. alexbrc (github user) - Code contributor; Amit Jamadagni - Bug fix; Anders Lund (Technical University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav V",MatchSource.WIKI,docs/3.0.1/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/contributors.html
Availability,avail,available,"n the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.0. status:Released. copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Jap",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Deployability,install,installation,". Frontmatter — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johan",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Energy Efficiency,efficient,efficiently," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, provid",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Ba",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Modifiability,coupling,coupling,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optic",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Performance,perform,performed,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Testability,test,tested,"ed ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a small number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions by providing the following advantages:. QuTiP relies on completely open-source software. You are free to modify and use it as you wish with no licensing fees.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See C",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Usability,guid,guide,"State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.0. status:Released. copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.",MatchSource.WIKI,docs/3.0.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/frontmatter.html
Deployability,install,installation,". Index — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Index. A; | B; | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() ",MatchSource.WIKI,docs/3.0.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/genindex.html
Performance,concurren,concurrence,loch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). csign() (in module qutip.qip.gates). D. dag() (Qobj method). destroy() (in module qutip.operators). diag() (Qobj method). dispersive_gate_correction() (DispersivecQED method). DispersivecQED (class in qutip.qip.models.cqed).,MatchSource.WIKI,docs/3.0.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/genindex.html
Usability,clear,clear, | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_vari,MatchSource.WIKI,docs/3.0.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/genindex.html
Deployability,install,installation,". QuTiP: Quantum Toolbox in Python (3.0.1) — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.0.1); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.0.1)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via Sci",MatchSource.WIKI,docs/3.0.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/index.html
Integrability,depend,dependencies,"re; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.0.1); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.0.1)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Red",MatchSource.WIKI,docs/3.0.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/index.html
Performance,load,loading,"amiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Utilitiy Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug ",MatchSource.WIKI,docs/3.0.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/index.html
Availability,avail,available," class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Deployability,install,installation,". Installation — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guid",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Integrability,depend,dependencies,"Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; C",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Modifiability,variab,variable,"eshoot problems on Windows, but the following installation steps have been reported to work:. Install the Python(X,Y) distribution (tested with version 2.7.3.1). Other Python distributions, such as Enthought Python Distribution or Anaconda CE have also been reported to work. When installing Python(x,y), explicitly select to include the Cython package in the installation. This package is not selected by default. Add the following content to the file C:/Python27/Lib/distutils/distutils.cfg (or create the file if it does not already exists):; [build]; compiler = mingw32. [build_ext]; compiler = mingw32. The directory where the distutils.cfg file should be placed might be different if you have installed the Python environment in a different location than in the example above. Obtain the QuTiP source code and installed it following the instructions given above. Note; In some cases, to get the dynamic compilation of Cython code to work, it; might be necessary to edit the PATH variable and make sure that; C:\MinGW32-xy\bin appears either first in the PATH list, or possibly; right after C:\Python27\Lib\site-packages\PyQt4. This is to make sure; that the right version of the MinGW compiler is used if more than one; is installed (not uncommon under Windows, since many packages are; distributed and installed with their own version of all dependencies). Optional Installation Options¶. UMFPACK Linear Solver¶; As of SciPy 0.14+, the umfpack linear solver routines for solving large-scale sparse linear systems have been replaced due to licensing restrictions. The default method for all sparse linear problems is now the SuperLU library. However, scipy still includes the ability to call the umfpack library via the scikits.umfpack module. In our experience, the umfpack solver is 2-5x faster than the SuperLU routines, which is a very noticeable performance increase when used for solving steady state solutions. We have an updated scikits.umfpack module available at http://github.com/non",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Performance,perform,performance,"es are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are only tested on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; sudo pip install qutip. However, when installing QuTiP this way the Fortran-based Monte Carlo solver is not included.; More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then ",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Testability,test,tested,"27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.6+); Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.13+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has a substantial performance benefit when compared with the Python-based solver. In order to install this package you must have a Fortra",MatchSource.WIKI,docs/3.0.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/installation.html
Deployability,install,installation,". Python Module Index — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.fortran.mcsolve_f90.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.operators.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.ran",MatchSource.WIKI,docs/3.0.1/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/py-modindex.html
Deployability,install,installation,". Search — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Search. Please activate JavaScript to enable the search; functionality.; . From here you can search these documents. Enter your search; words into the box below and click ""search"". Note that the search; function will automatically search for all of the words. Pages; containing fewer words won't appear in the result list.; . Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/search.html
Deployability,install,installation,"﻿. Bibliography — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bibliography. « Developers. Bibliography¶. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA",MatchSource.WIKI,docs/3.1.0/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/biblio.html
Availability,avail,available,"New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True);",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Deployability,install,installation,"﻿. Change Log — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Change Log; Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fix",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Energy Efficiency,power,power,"ntract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version2int function that cause a failure when parsing; the version number of the Cython package. Version 3.0.0 (July 17, 2014):¶. New Features¶. New module qutip.stochasti",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Integrability,depend,dependent,"n 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in co",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Modifiability,enhance,enhanced,":; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Performance,perform,performance,"r counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-dependent problem (list string format) with multiple terms in coefficient to an operator. Version 3.0.1 (Aug 5, 2014):¶. Bug Fixes¶. Fix bug in create(), which returned a Qobj with CSC data instead of CSR.; Fix several bugs in mcsolve: Incorrect storing of collapse times and collapse; operator records. Incorrect averaging of expectation values for different; trajectories when using only 1 CPU.; Fix bug in parsing of time-dependent Hamiltonian/collapse operator arguments; that occurred when the args argument is not a dictionary.; Fix bug in internal _version",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Safety,avoid,avoiding,"two-qubit gate.; Added function for generating (generalized) Lindblad dissipator; superoperators.; New functions for generating Bell states, and singlet and triplet states.; QuTiP no longer contains the demos GUI. The examples are now available on the; QuTiP web site. The qutip.gui module has been renamed to qutip.ui and; does no longer contain graphical UI elements. New text-based and HTML-based; progressbar classes.; Support for harmonic oscillator operators/states in a Fock state basis that; does not start from zero (e.g., in the range [M,N+1]). Support for; eliminating and extracting states from Qobj instances (e.g., removing one; state from a two-qubit system to obtain a three-level system).; Support for time-dependent Hamiltonian and Liouvillian callback functions that; depend on the instantaneous state, which for example can be used for solving; master equations with mean field terms. Improvements¶. Restructured and optimized implementation of Qobj, which now has; significantly lower memory footprint due to avoiding excessive copying of; internal matrix data.; The classes OdeData, Odeoptions, Odeconfig are now called; Result, Options, and Config, respectively, and are available in; the module qutip.solver.; The squeez function has been renamed to squeeze.; Better support for sparse matrices when calculating propagators using the; propagator function.; Improved Bloch sphere.; Restructured and improved the module qutip.sparse, which now only; operates directly on sparse matrices (not on Qobj instances).; Improved and simplified implement of the tensor function.; Improved performance, major code cleanup (including namespace changes),; and numerous bug fixes.; Benchmark scripts improved and restructured.; QuTiP is now using continuous integration tests (TravisCI). Version 2.2.0 (March 01, 2013):¶. New Features¶. Added Support for Windows; New Bloch3d class for plotting 3D Bloch spheres using Mayavi.; Bloch sphere vectors now look like arrows.; Partial transpose fu",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Testability,log,logging,"ew Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady sta",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Usability,progress bar,progress bars," (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). « Functions. Developers ». Change Log¶. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NAMESPACE CHANGE: QuTiP no longer exports symbols from NumPy and matplotlib, so those modules must now be explicitly imported when required.; New module for counting statistics.; Stochastic solvers now run trajectories in parallel.; New superoperator and tensor manipulation functions; (super_tensor, composite, tensor_contract).; New logging module for debugging (qutip.logging).; New user-available API for parallelization (parallel_map).; New enhanced (optional) text-based progressbar (qutip.ui.EnhancedTextProgressBar); Faster Python based monte carlo solver (mcsolve).; Support for progress bars in propagator function.; Time-dependent Cython code now calls complex cmath functions.; Random numbers seeds can now be reused for successive calls to mcsolve.; The Bloch-Redfield master equation solver now supports optional Lindblad type collapse operators.; Improved handling of ODE integration errors in mesolve.; Improved correlation function module (for example, improved support for time-dependent problems).; Improved parallelization of mcsolve (can now be interrupted easily, support for IPython.parallel, etc.); Many performance improvements, and much internal code restructuring. Bug Fixes¶. Cython build files for time-dependent string format now removed automatically.; Fixed incorrect solution time from inverse-power method steady state solver.; mcsolve now supports Options(store_states=True); Fixed bug in hadamard gate function.; Fixed compatibility issues with NumPy 1.9.0.; Progressbar in mcsolve can now be suppressed.; Fixed bug in gate_expand_3toN.; Fixed bug for time-depende",MatchSource.WIKI,docs/3.1.0/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/changelog.html
Deployability,install,installation,"﻿. Developers — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Developers; Lead Developers; Contributors. « Change Log. Bibliography ». Developers¶. Lead Developers¶; Robert Johansson (RIKEN); Paul Nation (Korea University). Contributors¶. Note; Anyone is welcome to contribute to QuTiP. If you are interested in helping, please let us know!. alexbrc (github user) - Code contributor; Alexander Pitchford (Aberystwyth University) - Code contributor; Amit Jamadagni - Bug fix; Anders Lund (Technical University of Denmark) - Bug hunting for the Monte",MatchSource.WIKI,docs/3.1.0/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/contributors.html
Availability,avail,available,"ization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.1.0. status:Released (January 1, 2015). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially ",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Deployability,install,installation,"﻿. Frontmatter — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Energy Efficiency,efficient,efficiently," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting l",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Integrability,depend,dependence,"mponents, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Ba",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Modifiability,coupling,coupling,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optic",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Performance,perform,performed,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Testability,test,tested,"onducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy and Scipy libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See C",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Usability,guid,guide,"ew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. « QuTiP: Quantum T... Installation ». Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Address:Department of Physics, Korea University,; Seongbuk-gu Seoul, 136-713 South Korea. Author:J.R. Johansson. Address:iTHES Research Group, RIKEN,; Wako-shi Saitama, 351-0198 Japan. version:3.1.0. status:Released (January 1, 2015). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http:/",MatchSource.WIKI,docs/3.1.0/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/frontmatter.html
Deployability,install,installation,"﻿. Index — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Index. A; | B; | C; | D; | E; | F; | G; | H; | I; | J; | K; | L; | M; | N; | O; | P; | Q; | R; | S; | T; | U; | V; | W. A. about() (in module qutip). add_1q_gate() (QubitCircuit method). add_annotation() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit ",MatchSource.WIKI,docs/3.1.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html
Performance,concurren,concurrence, module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_pulse_gen() (in module qutip.control.pulsegen). create_pulse_optimizer() (in module qutip.control.pulseoptim). cs,MatchSource.WIKI,docs/3.1.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html
Usability,clear,clear,n() (Bloch method). add_circuit() (QubitCircuit method). add_gate() (QubitCircuit method). add_points() (Bloch method). (Bloch3d method). add_states() (Bloch method). (Bloch3d method). add_vectors() (Bloch method). (Bloch3d method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. checkherm() (Qobj method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). concurrence() (in module qutip.entropy). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_fi,MatchSource.WIKI,docs/3.1.0/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/genindex.html
Deployability,install,installation,"﻿. QuTiP: Quantum Toolbox in Python (3.1.0) — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.1.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.1.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.",MatchSource.WIKI,docs/3.1.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/index.html
Integrability,depend,dependencies,"um states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . QuTiP: Quantum Toolbox in Python (3.1.0); Indices and tables. Frontmatter ». QuTiP: Quantum Toolbox in Python (3.1.0)¶. Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results;",MatchSource.WIKI,docs/3.1.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/index.html
Performance,load,loading,"ns; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Optimal control; Utilitiy Functions. Change Log; Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1",MatchSource.WIKI,docs/3.1.0/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/index.html
Availability,avail,available,"7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository. Installing from source¶; Installing QuTiP from source requires that all the dependencies are satisfied. The installation of these dependencies is different on each platform, and detailed instructions for Linux (Ubuntu), Mac OS X and Windows are given below.; Regardless of platform, to install QuTiP from the source code run:; sudo python setup.py install. To also include the optional Fortran Monte Carlo solver, run:; sudo python setup.py install --with-f90mc. On Windows, omit sudo from the commands given above. Installation on Ubuntu Linux¶. Using QuTiP’s PPA¶; The easiest way ",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Deployability,install,installation,"﻿. Installation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version I",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Integrability,depend,dependencies,"oducts and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cy",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Modifiability,config,configuration," can be installed using:; sudo apt-get install texlive-latex-extra # recommended for plotting; sudo apt-get install mayavi2 # optional, for Bloch3d only; sudo apt-get install libblas-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install liblapack-dev # optional, for Fortran Monte Carlo solver; sudo apt-get install gfortran # optional, for Fortran Monte Carlo solver. Installation on Mac OS X (10.8+)¶. Setup Using Homebrew¶; The latest version of QuTiP can be quickly installed on OS X using Homebrew and the automated installation shell scripts. Python 2.7 installation script; Python 3.4 installation script. Having downloaded the script corresponding to the version of Python you want to use, the installation script can be run from the terminal using (replacing X with 2 or 3); sh install_qutip_pyX.sh. The script will then install Homebrew and the required QuTiP dependencies before installing QuTiP itself and running the built in test suite. Any errors in the homebrew configuration will be displayed at the end. Using Python 2.7 or 3.4, the python commend-line and IPython interpreter can be run by calling python and ipython or python3 and ipython3, respectively.; If you have installed other packages in the /usr/local/ directory, or have changed the permissions of any of its sub-directories, then this script may fail to install all the necessary tools automatically. Setup Using Macports¶; If you have not done so already, install the Apple Xcode developer tools from the Apple App Store. After installation, open Xcode and go to: Preferences -> Downloads, and install the ‘Command Line Tools’.; On the Mac OS, you can install the required libraries via MacPorts. After installation, the necessary “ports” for QuTiP may be installed via (Replace ‘34’ with ‘27’ if you want Python 2.7); sudo port install py34-scipy; sudo port install py34-matplotlib +latex; sudo port install py34-cython; sudo port install py34-ipython +notebook+parallel; sudo port install py34-pip. Now",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Performance,perform,performance,"re currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms. Platform-independent installation¶; Often the easiest way is to install QuTiP is to use the Python package manager pip.; pip install qutip. Or, optionally, to also include the Fortran-based Monte Carlo solver:; pip install qutip --install-option=--with-f90mc. More detailed platform-dependent installation alternatives are given below. Get the source code¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Testability,test,tested,".1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Using QuTiP’s PPA; Manual installation of dependencies. Installation on Mac OS X (10.8+); Setup Using Homebrew; Setup Using Macports; Setup via SciPy Superpack; Anaconda CE Distribution. Installation on Windows; Optional Installation Options; UMFPACK Linear Solver; Optimized BLAS Libraries. Verifying the Installation; Checking Version Information using the About Function. « Frontmatter. Users Guide ». Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.3+ is highly recommended. Numpy; 1.7+; Not tested on lower versions. Scipy; 0.14+; Lower versions have missing features. Matplotlib; 1.2.0+; Some plotting does not work on lower versions. Cython; 0.15+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Fortran; Compiler; Fortran 90; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Optional. Needed for using the Bloch3d class. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. LaTeX; TexLive 2009+; Optional. Needed if using LaTeX in figures. nose; 1.1.2+; Optional. For running tests. scikits.umfpack; 5.2.0+; Optional. Faster (~2-5x) steady state calculations. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a",MatchSource.WIKI,docs/3.1.0/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/installation.html
Deployability,install,installation,"﻿. Python Module Index — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.grape.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.fortran.mcsolve_f90.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.operators.    ; qutip.parall",MatchSource.WIKI,docs/3.1.0/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/py-modindex.html
Deployability,install,installation,"﻿. Search — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Search. Please activate JavaScript to enable the search; functionality.; . From here you can search these documents. Enter your search; words into the box below and click ""search"". Note that the search; function will automatically search for all of the words. Pages; containing fewer words won't appear in the result list.; . Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/search.html
Deployability,update,updated,"; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Bibliography. Bibliography¶. [BCSZ08]; Bruzda, V. Cappellini, H.-J. Sommers, K. Życzkowski, Random Quantum Operations, Phys. Lett. A 373, 320-324 (2009). doi:10.1016/j.physleta.2008.11.043. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Mez07]; Mezzadri, How to generate random matrices from the classical compact groups, Notices of the AMS 54 592-604 (2007). arXiv:math-ph/0609050. [Mis12]. Miszczak, Generating and using truly random quantum states in Mathematica, Computer Physics Communications 183 1, 118-124 (2012). doi:10.1016/j.cpc.2011.08.002. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA.77.032322. [Gri98]; Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). doi:10.1016/S0370-1573(98)00022-2. [Cre03]. Creffield, Location of crossings in the Floquet spectrum of a driven two-level system, Phys. Rev. B 67, 165301 (2003). doi:10.1103/PhysRevB.67.165301. [Gar03]Gardineer and Zoller, Quantum Noise (Springer, 2004). [Bre02]H.-P. Breuer and F. Petruccione, The Theory of Open Quantum Systems (Oxford, 2002). [Coh92]; Cohen-Tannoudji, J. Dupont-Roc, G. Grynberg, Atom-Photon Interactions: Basic Processes and Applications, (Wiley, 1992). [WBC11]C. Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/biblio.html
Availability,error,error,"o; set_phase_option function now property phase_option. propcomp properties; grad_exact (now read only). propcomp functions; compute_propagator now _compute_propagator; compute_diff_prop now _compute_diff_prop; compute_prop_grad now _compute_prop_grad. tslotcomp functions; get_timeslot_for_fidelity_calc now _get_timeslot_for_fidelity_calc. Miscellaneous. QuTiP Travis CI tests now use the Anaconda distribution.; The about box and ipynb version_table now display addition system information.; Updated Cython cleanup to remove depreciation warning in sysconfig.; Updated ipynb_parallel to look for ipyparallel module in V4 of the notebooks. Bug Fixes¶. Fixes for countstat and psuedo-inverse functions; Fixed Qobj division tests on 32-bit systems.; Removed extra call to Python in time-dependent Cython code.; Fixed issue with repeated Bloch sphere saving.; Fixed T_0 triplet state not normalized properly. (Fixed by Eric Hontz); Simplified compiler flags (support for ARM systems).; Fixed a decoding error in qload.; Fixed issue using complex.h math and np.kind_t variables.; Corrected output states mismatch for ntraj=1 in the mcf90 solver.; Qobj data is now copied by default to avoid a bug in multiplication. (Fixed by Richard Brierley); Fixed bug overwriting hardware_info in __init__. (Fixed by Johannes Feist); Restored ability to explicity set Q.isherm, Q.type, and Q.superrep.; Fixed integer depreciation warnings from NumPy.; Qobj * (dense vec) would result in a recursive loop.; Fixed args=None -> args={} in correlation functions to be compatible with mesolve.; Fixed depreciation warnings in mcsolve.; Fixed neagtive only real parts in rand_ket.; Fixed a complicated list-cast-map-list antipattern in super operator reps. (Fixed by Stefan Krastanov); Fixed incorrect isherm for sigmam spin operator.; Fixed the dims when using final_state_output in mesolve and sesolve. Version 3.1.0 (January 1, 2015):¶. New Features¶. MAJOR FEATURE: New module for quantum control (qutip.control).; NA",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Version 4.1.0 (in dev); Improvements. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Neve",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Energy Efficiency,power,power,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Integrability,depend,dependent,":; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build ze",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Modifiability,enhance,enhancements,"0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Performance,perform,performance,"0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Safety,avoid,avoid,"vements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Testability,test,tests,"ures; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (in dev)¶. Improvements¶; Core libraries. erf supported function in td strings. QIP. Gate object can be used to instantiate another identical gate. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.0.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/changelog.html
Deployability,update,updated,"University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav Vardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documentation; Arne Grimsmo (University of Auckland) - Bug hunter, Code contributor; Ben Criger (Waterloo IQC) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:Alexander Pitchford. Author:Chris Grenade. Author:Arne Grimsmo. Author:P.D. Nation. Author:J.R. Johansson. version:4.0. status:Released (XX YY, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Deployability,release,release,"thon programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Energy Efficiency,efficient,efficiently," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting l",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Integrability,depend,dependence,"ted by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpag",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Modifiability,coupling,coupling,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optic",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Performance,perform,performed,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Testability,test,tested,"ting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ar",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:Alexander Pitchford. Author:Chris Grenade. Author:Arne Grimsmo. Author:P.D. Nation. Author:J.R. Johansson. version:4.0. status:Released (XX YY, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on",MatchSource.WIKI,docs/4.0.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/frontmatter.html
Deployability,integrat,integrator,"ttribute). HEOMSolver (class in qutip.nonmarkov.heom). hilbert_dist() (in module qutip.metrics). hinton() (in module qutip.visualization). homogeneous (StochasticSolverOptions attribute). HSolverDL (class in qutip.nonmarkov.heom). I. identity() (in module qutip.operators). init_coeffs() (PulseGenCrab method). init_comp() (FidCompTraceDiff method). (FidCompUnitary method). (FidelityComputer method). init_freqs() (PulseGenCrabFourier method). init_normalization() (FidCompUnitary method). init_optim() (Optimizer method). (OptimizerCrab method). (OptimizerLBFGSB method). init_pulse() (PulseGen method). (PulseGenCrab method). (PulseGenCrabFourier method). (PulseGenLinear method). (PulseGenPeriodic method). init_timeslots() (Dynamics method). initial (Dynamics attribute). initial_amps (OptimResult attribute). initial_ctrl_offset (Dynamics attribute). initial_ctrl_scaling (Dynamics attribute). initial_fid_err (OptimResult attribute). initialize_controls() (Dynamics method). integrator (MemoryCascade attribute). isbra (Qobj attribute). iscp (Qobj attribute). iscptp (Qobj attribute). isherm (Qobj attribute). ishp (Qobj attribute). isket (Qobj attribute). isoper (Qobj attribute). isoperbra (Qobj attribute). isoperket (Qobj attribute). issuper (Qobj attribute). istp (Qobj attribute). iswap() (in module qutip.qip.gates). iter_num (OptimIterSummary attribute). iter_step_callback_func() (Optimizer method). iter_summary (OptimDump attribute). (Optimizer attribute). J. jmat() (in module qutip.operators). K. ket() (in module qutip.states). ket2dm() (in module qutip.states). L. L1 (MemoryCascade attribute). L2 (MemoryCascade attribute). lbound (PulseGen attribute). learningtimes (TTMSolverOptions attribute). level (Dump attribute), [1]. lindblad_dissipator() (in module qutip.superoperator). LinearSpinChain (class in qutip.qip.models.spinchain). linspace_with() (in module qutip.utilities). liouvillian() (in module qutip.superoperator). load_circuit() (CircuitProcessor method). log_lev",MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Energy Efficiency,charge,charge,odule qutip.metrics). average_states (Options attribute). axes (Bloch attribute). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bnd_cut_approx (HSolverDL attribute). boltzmann (HEOMSolver attribute). bounds (Optimizer attribute). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops (StochasticSolverOptions attribute). c_ops_markov (MemoryCascade attribute). cache_dyn_gen_eigenvectors_adj (Dynamics attribute). cache_phased_dyn_gen (Dynamics attribute). cache_prop_grad (Dynamics attribute). calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.en,MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Integrability,integrat,integrator,"ttribute). HEOMSolver (class in qutip.nonmarkov.heom). hilbert_dist() (in module qutip.metrics). hinton() (in module qutip.visualization). homogeneous (StochasticSolverOptions attribute). HSolverDL (class in qutip.nonmarkov.heom). I. identity() (in module qutip.operators). init_coeffs() (PulseGenCrab method). init_comp() (FidCompTraceDiff method). (FidCompUnitary method). (FidelityComputer method). init_freqs() (PulseGenCrabFourier method). init_normalization() (FidCompUnitary method). init_optim() (Optimizer method). (OptimizerCrab method). (OptimizerLBFGSB method). init_pulse() (PulseGen method). (PulseGenCrab method). (PulseGenCrabFourier method). (PulseGenLinear method). (PulseGenPeriodic method). init_timeslots() (Dynamics method). initial (Dynamics attribute). initial_amps (OptimResult attribute). initial_ctrl_offset (Dynamics attribute). initial_ctrl_scaling (Dynamics attribute). initial_fid_err (OptimResult attribute). initialize_controls() (Dynamics method). integrator (MemoryCascade attribute). isbra (Qobj attribute). iscp (Qobj attribute). iscptp (Qobj attribute). isherm (Qobj attribute). ishp (Qobj attribute). isket (Qobj attribute). isoper (Qobj attribute). isoperbra (Qobj attribute). isoperket (Qobj attribute). issuper (Qobj attribute). istp (Qobj attribute). iswap() (in module qutip.qip.gates). iter_num (OptimIterSummary attribute). iter_step_callback_func() (Optimizer method). iter_summary (OptimDump attribute). (Optimizer attribute). J. jmat() (in module qutip.operators). K. ket() (in module qutip.states). ket2dm() (in module qutip.states). L. L1 (MemoryCascade attribute). L2 (MemoryCascade attribute). lbound (PulseGen attribute). learningtimes (TTMSolverOptions attribute). level (Dump attribute), [1]. lindblad_dissipator() (in module qutip.superoperator). LinearSpinChain (class in qutip.qip.models.spinchain). linspace_with() (in module qutip.utilities). liouvillian() (in module qutip.superoperator). load_circuit() (CircuitProcessor method). log_lev",MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Modifiability,config,config,"). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in ",MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Performance,concurren,concurrence,"od). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method), [1]. coup_op (HEOMSolver attribute). coup_strength (HEOMSolver attribute). covariance_matrix() (in module qutip.continuous_variables). cphase() (i",MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Usability,clear,clear,"n qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bnd_cut_approx (HSolverDL attribute). boltzmann (HEOMSolver attribute). bounds (Optimizer attribute). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops (StochasticSolverOptions attribute). c_ops_markov (MemoryCascade attribute). cache_dyn_gen_eigenvectors_adj (Dynamics attribute). cache_phased_dyn_gen (Dynamics attribute). cache_prop_grad (Dynamics attribute). calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (Bloch3d method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeffs (PulseGenCrab attribute). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). col_times (Result attribute). col_which (Result attribute). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). config (Optimizer attribute). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method), [1]. controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). co",MatchSource.WIKI,docs/4.0.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/genindex.html
Deployability,release,released,"n; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (in dev); Improvements. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/index.html
Integrability,depend,dependent,"eneral Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Verifying the Installation; Checking Version Information using the About Function; Installation on MS Windows. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distri",MatchSource.WIKI,docs/4.0.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (in dev); Improvements. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Versi",MatchSource.WIKI,docs/4.0.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/index.html
Availability,avail,available,"cludes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶; The default Anaconda environment has all the Python packages needed for running QuTiP.; You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.; You may wish to this for many reasons:. It is a good idea generally; You are using MS Windows and want to use Python 3; You are using Miniconda because you do not have the disk space for full Anaconda. To create a Conda env for QuTiP called qutip:-; (note the python=3 can be ommited if you want the default Python version, if you want to use Python 3 with MS Windows, then it must be python=3.4); recommended:; conda create -n qutip python=3 mkl numpy scipy cython matplotlib nose multiprocess jupyter notebook spyder. minimum (recommended):; c",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Deployability,install,installing," Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Verifying the Installation; Checking Version Information using the About Function; Installation on MS Windows. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recom",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Modifiability,config,configuration,"nctionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶; The default Anaconda environment has all the Python packages needed for running QuTiP.; You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.; You may wish to this for many reasons:. It is a good idea generally; You are using MS Windows and want to use Python 3; You are using",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Performance,perform,performance,"equired:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda insta",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Testability,test,tested,". . Installation — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Verifying the Installation; Checking Version Information using the About Function; Installation on MS Windows. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.4+ is highly recommended. Numpy; 1.8+; Not tested on lower versions. Scipy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. GCC; Compiler; 4.2+; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. gfortran; 4.2+; Needed for compiling the optional Fortran-based; Monte Carlo solver. BLAS; library; 1.2+; Optional, Linux & Mac only.; Needed for installing Fortran Monte Carlo solver. Mayavi; 4.1+; Needed for using the Bloch3d class. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. As of version 2.2, QuTiP includes an optional Fortran-based Monte Carlo solver that has some performance benefit over the Python-based solver when simulating small systems. In order to install this package you must have a Fortran compiler (for example gfortran) and BLAS development libraries. At present, these packages are tested only on the Linux and OS X platforms.; We would not recom",MatchSource.WIKI,docs/4.0.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ». Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.0 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.0; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs ». Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 11, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.0.2/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.0.2/search.html
Deployability,update,updated,"; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Bibliography. Bibliography¶. [BCSZ08]; Bruzda, V. Cappellini, H.-J. Sommers, K. Życzkowski, Random Quantum Operations, Phys. Lett. A 373, 320-324 (2009). doi:10.1016/j.physleta.2008.11.043. [Hav03]Havel, T. Robust procedures for converting among Lindblad, Kraus and matrix representations of quantum dynamical semigroups. Journal of Mathematical Physics 44 2, 534 (2003). doi:10.1063/1.1518555. [Wat13]Watrous, J. Theory of Quantum Information, lecture notes. [Mez07]; Mezzadri, How to generate random matrices from the classical compact groups, Notices of the AMS 54 592-604 (2007). arXiv:math-ph/0609050. [Mis12]. Miszczak, Generating and using truly random quantum states in Mathematica, Computer Physics Communications 183 1, 118-124 (2012). doi:10.1016/j.cpc.2011.08.002. [Moh08]; Mohseni, A. T. Rezakhani, D. A. Lidar, Quantum-process tomography: Resource analysis of different strategies, Phys. Rev. A 77, 032322 (2008). doi:10.1103/PhysRevA.77.032322. [Gri98]; Grifoni, P. Hänggi, Driven quantum tunneling, Physics Reports 304, 299 (1998). doi:10.1016/S0370-1573(98)00022-2. [Cre03]. Creffield, Location of crossings in the Floquet spectrum of a driven two-level system, Phys. Rev. B 67, 165301 (2003). doi:10.1103/PhysRevB.67.165301. [Gar03]Gardineer and Zoller, Quantum Noise (Springer, 2004). [Bre02]H.-P. Breuer and F. Petruccione, The Theory of Open Quantum Systems (Oxford, 2002). [Coh92]; Cohen-Tannoudji, J. Dupont-Roc, G. Grynberg, Atom-Photon Interactions: Basic Processes and Applications, (Wiley, 1992). [WBC11]C. Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/biblio.html
Availability,robust,robust,"rsion 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x fast",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 201",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Energy Efficiency,power,power,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Integrability,depend,dependent," 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve code",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Modifiability,enhance,enhancements,"URE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Performance,perform,performance,"URE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Safety,avoid,avoid,"Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than ",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Testability,test,tests," QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threashold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.1/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/changelog.html
Deployability,update,updated,"University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav Vardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documentation; Arne Grimsmo (University of Auckland) - Bug hunter, Code contributor; Ben Criger (Waterloo IQC) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.1. status:Released (March 10, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Deployability,release,release,"thon programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Energy Efficiency,efficient,efficiently," quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting l",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Integrability,depend,dependence,"ted by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpag",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Modifiability,coupling,coupling,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optic",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Performance,perform,performed,"ys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, ",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Testability,test,tested,"ting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is a fully open-source implementation of a framework written in the Python programming language designed for simulating the open quantum dynamics for systems such as those listed above. This framework distinguishes itself from the other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ar",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.1. status:Released (March 10, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; The development of QuTiP has been partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed",MatchSource.WIKI,docs/4.1/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/frontmatter.html
Deployability,update,update,ntract() (in module qutip.tensor). TerminationConditions (class in qutip.control.termcond). thermal_dm() (in module qutip.states). three_level_basis() (in module qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). Z. zero_ket() (in module qutip.state,MatchSource.WIKI,docs/4.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/genindex.html
Energy Efficiency,charge,charge,s method). add_states() (Bloch method). add_timing() (Stats method). add_vectors() (Bloch method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module,MatchSource.WIKI,docs/4.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/genindex.html
Modifiability,config,configure,s). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,docs/4.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/genindex.html
Performance,concurren,concurrence,e). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,docs/4.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/genindex.html
Usability,clear,clear,imizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in modu,MatchSource.WIKI,docs/4.1/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/genindex.html
Deployability,release,released,"loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/index.html
Integrability,depend,dependent,"tform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distri",MatchSource.WIKI,docs/4.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015)",MatchSource.WIKI,docs/4.1/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/index.html
Availability,avail,available,"; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Deployability,install,installation,"ox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; ",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Modifiability,config,configuration,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment.",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Performance,load,load,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Security,access,access,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Testability,test,tested,". . Installation — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platforms. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; ",MatchSource.WIKI,docs/4.1/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.1 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.1; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Search. Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Mar 28, 2017. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.1/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.1/search.html
Deployability,update,updated,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/biblio.html
Performance,optimiz,optimization,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/biblio.html
Security,access,access,"lculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/biblio.html
Availability,error,error,"n now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Ver",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Version 4.3.0 (); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 ()¶. Improvements¶. Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and ",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Energy Efficiency,power,power,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Integrability,depend,dependent,"mprovements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 ()¶. Improvements¶. Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputi",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Modifiability,enhance,enhancements,"TURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method ",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Performance,optimiz,optimization,"; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 ()¶. Improvements¶. Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions. Bug Fixes¶. Fixed bug in trace-norm for non-Hermitian operators. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Safety,safe,safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Testability,test,tests,"sue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.2/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/changelog.html
Deployability,update,updated,"University of Denmark) - Bug hunting for the Monte-Carlo solver; Andre Carvalho - Bug hunter; André Xuereb (University of Hannover) - Bug hunter; Anubhav Vardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documentation; Arne Grimsmo (University of Auckland) - Bug hunter, Code contributor; Ben Criger (Waterloo IQC) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.2. status:Released (July 28, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of int",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Deployability,release,release,"Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webp",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Modifiability,coupling,coupling,"J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Performance,perform,performed,"ori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.2. status:Released (July 28, 2017). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. Earlier development of QuTiP was partially supported by the Japanese Society for the Promotion of Science Foreign Postdoctoral Fellowship Program under grants P11202 (PDN) and P11501 (JRJ). Additional funding comes from RIKEN, Kakenhi grant Nos. 2301202 (PDN), 2302501 (JRJ), and Korea University. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of int",MatchSource.WIKI,docs/4.2/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/frontmatter.html
Deployability,update,update,ntract() (in module qutip.tensor). TerminationConditions (class in qutip.control.termcond). thermal_dm() (in module qutip.states). three_level_basis() (in module qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). Z. zero_ket() (in module qutip.state,MatchSource.WIKI,docs/4.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/genindex.html
Energy Efficiency,charge,charge,t method). add_states() (Bloch method). add_timing() (Stats method). add_vectors() (Bloch method). adjacent_gates() (CircuitProcessor method). (QubitCircuit method). (SpinChain method). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module,MatchSource.WIKI,docs/4.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/genindex.html
Modifiability,config,configure,s). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,docs/4.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/genindex.html
Performance,concurren,concurrence,e). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,docs/4.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/genindex.html
Usability,clear,clear,imizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. calculate() (Stats method). charge() (in module qutip.operators). check_herm() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in modu,MatchSource.WIKI,docs/4.2/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/genindex.html
Deployability,release,released,"ects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.3.0 (); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/index.html
Integrability,depend,dependent,"tform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distri",MatchSource.WIKI,docs/4.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utilitiy Functions. Change Log; Version 4.3.0 (); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 ",MatchSource.WIKI,docs/4.2/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/index.html
Availability,avail,available,"ling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Deployability,install,installation,"ox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. ",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Modifiability,config,configuration,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Performance,load,load,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Security,access,access,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Testability,test,tested,". . Installation — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,docs/4.2/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.2 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.2; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Search. Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo.; Last updated on Jan 17, 2018. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.2/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.2/search.html
Deployability,update,updated,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/biblio.html
Performance,optimiz,optimization,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/biblio.html
Security,access,access,"alculus for; open quantum systems. arXiv:1111.6950. [dAless08]; d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). [Kha05]; Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. [Byrd95]. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. [Flo12]. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. [Lloyd14]; Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. [Doria11]; Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. [Caneva11]; Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. [Rach15]; Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. [DYNAMO]; Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/biblio.html
Availability,error,error,"s, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling wit",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Energy Efficiency,power,power,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Integrability,depend,dependent,"n 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Modifiability,config,configuration,"ures; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEATURE: Added the Permutational Invariant Quantum Solver (PIQS) module (by Nathan Shammah and Shahnawaz Ahmed) which allows the simluation of large TLSs ensembles including collective and local Lindblad dissipation. Applications range from superradiance to spin squeezing.; MAJOR FEATURE: Added a photon scattering module (by Ben Bartlett) which can be used to study scattering in arbitrary driven systems coupled to some configuration of output waveguides.; Cubic_Spline functions as time-dependent arguments for the collapse operators in mesolve are now allowed.; Added a faster version of bloch_redfield_tensor, using components from the time-dependent version. About 3x+ faster for secular tensors, and 10x+ faster for non-secular tensors.; Computing Q.overlap() [inner product] is now ~30x faster.; Added projector method to Qobj class.; Added fast projector method, Q.proj().; Computing matrix elements, Q.matrix_element is now ~10x faster.; Computing expectation values for ket vectors using expect is now ~10x faster.; Q.tr() is now faster for small Hilbert space dimensions.; Unitary operator evolution added to sesolve; Use OPENMP for tidyup if installed. Bug Fixes¶. Fixed bug that stopped simdiag working for python 3.; Fixed semidefinite cvxpy Variable and Parameter.; Fixed iterative lu solve atol keyword issue.; Fixed unitary op evolution rhs matrix",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Performance,optimiz,optimization,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Safety,safe,safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Testability,test,tests,"sue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.3/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/changelog.html
Deployability,update,updated,"ardhan (IIT, Kanpur) - Bug hunter, Code contributor, Documentation; Arne Grimsmo (University of Auckland) - Bug hunter, Code contributor; Ben Criger (Waterloo IQC) - Code contributor; Ben Bartlett (Stanford) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Nathan Shammah (RIKEN) - Code contributor; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; Shahnawaz Ahmed (RIKEN, BITS Pilani) - Code contributor, Bug hunter; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.3. status:Released (July 18, 2018). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretic",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Deployability,release,release," Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webp",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Modifiability,coupling,coupling,"hor:J.R. Johansson. Author:Chris Grenade. version:4.3. status:Released (July 18, 2018). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Performance,perform,performed,"ting This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author:P.D. Nation. Author:Alexander Pitchford. Author:Arne Grimsmo. Author:J.R. Johansson. Author:Chris Grenade. version:4.3. status:Released (July 18, 2018). copyright:This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretic",MatchSource.WIKI,docs/4.3/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/frontmatter.html
Deployability,update,update,ntract() (in module qutip.tensor). TerminationConditions (class in qutip.control.termcond). thermal_dm() (in module qutip.states). three_level_basis() (in module qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). Z. zero_ket() (in module qutip.state,MatchSource.WIKI,docs/4.3/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/genindex.html
Energy Efficiency,charge,charge,). (QubitCircuit method). (SpinChain method). am() (in module qutip.piqs). ap() (in module qutip.piqs). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary,MatchSource.WIKI,docs/4.3/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/genindex.html
Modifiability,config,configure,ry() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,docs/4.3/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/genindex.html
Performance,concurren,concurrence,check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,docs/4.3/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/genindex.html
Usability,clear,clear,r method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). corre,MatchSource.WIKI,docs/4.3/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/genindex.html
Deployability,release,released,"enerating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/index.html
Integrability,depend,dependent,"dent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-proba",MatchSource.WIKI,docs/4.3/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); I",MatchSource.WIKI,docs/4.3/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/index.html
Availability,avail,available,"ling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Deployability,install,installation,"ox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. ",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Modifiability,config,configuration,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Performance,load,load,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html; and the latest source code is available in our Github repository. http://github.com/qutip; In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Security,access,access,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Testability,test,tested,". . Installation — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when ",MatchSource.WIKI,docs/4.3/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.3 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.3; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Search. Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo; Last updated on Feb 26, 2019. . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.3/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.3/search.html
Deployability,update,updated,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/biblio.html
Performance,optimiz,optimization,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/biblio.html
Security,access,access,"tems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/biblio.html
Availability,avail,available,"ersion 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bu",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Version 4.4.0 (July 03, 2019); Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant coll",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Energy Efficiency,efficient,efficiently,"y 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by B",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Integrability,depend,dependant,"ersion 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bu",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Modifiability,variab,variable,":. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.4.0 (July 03, 2019)¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients. The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by Boxi Li).; Added the quantum Hellinger distance to qutip.metrics (by Wojciech Rzadkowski).; Implemented possibility of choosing a random seed (by Marek marekyggdrasil).; Added a code of conduct to Github. Bug Fixes¶. Fixed bug that made QuTiP incompatible with SciPy 1.3.; quite.cite() is improved.; Added matplotlib as optional dependency and updated numpy and scipy requirements.; Fixed matrix generating coherent spin states in qutip.piqs to include complex coefficients. Version 4.3.0 (July 14, 2018)¶. Improvements¶. MAJOR FEAT",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Performance,optimiz,optimization,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Safety,safe,safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Testability,test,tests,"sue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under Windows. Version 4.0.2 (January 5, 2017)¶. Bug Fixes¶. td files no longer left behind by correlation tests; Various fast sparse fixes. Version 4.0.0 (December 22, 2016)¶. Improvements¶; Core libraries. MAJOR FEATURE: Fast sparse: New subclass of csr_matrix added that overrides commonly used methods to avoid certain checks that incurr execution cost. All Qobj.data now fast_csr_matrix; HEOM performance enhancements; spmv now faster; mcsolve codegen further optimised. Control modules. Time dependent drift (through list of pwc dynamics generators); memory optimisation options provided for control.dynamics. Bug Fixes¶. recompilation of pyx files on first import removed; tau array in control.pulseoptim funcs now works. Version 3.2.0 (Never officially released)¶. New Features¶; Core libraries. MAJOR FEATURE: Non-Markovian solvers: Hierarchy (Added by Neill Lambert), Memory-Cascade, and Transfer-Tensor methods.; MAJOR FEATURE: Default steady state solver now up to 100x faster using the Intel Pardiso library under the Anaconda and Intel Python distributions.; The default Wigner function",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.4/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/changelog.html
Deployability,update,updated,"or; Ben Criger (Waterloo IQC) - Code contributor; Ben Bartlett (Stanford) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Eric Giguere (Sherbrooke University) - Code contributor; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Nathan Shammah (RIKEN) - Code contributor; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Nithin Ramu Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; Shahnawaz Ahmed (RIKEN, BITS Pilani) - Code contributor, Bug hunter; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; J.R. Johansson. Author; Chris Grenade. Author; P.D. Nation. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefo",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Deployability,release,release,"lating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webp",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Modifiability,coupling,coupling,"; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Performance,perform,performed,"ting This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; J.R. Johansson. Author; Chris Grenade. Author; P.D. Nation. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.4. status; Released (July 18, 2018). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefo",MatchSource.WIKI,docs/4.4/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/frontmatter.html
Deployability,update,update,ntract() (in module qutip.tensor). TerminationConditions (class in qutip.control.termcond). thermal_dm() (in module qutip.states). three_level_basis() (in module qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). writeout() (DynamicsDump method). (EvoCompDumpItem method). (OptimDump method). Z. zero_ket() (in module qutip.state,MatchSource.WIKI,docs/4.4/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/genindex.html
Energy Efficiency,charge,charge,). (QubitCircuit method). (SpinChain method). am() (in module qutip.piqs). ap() (in module qutip.piqs). apply_method_params() (Optimizer method). apply_params() (Dynamics method). (FidelityComputer method). (Optimizer method). (PropagatorComputer method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary,MatchSource.WIKI,docs/4.4/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/genindex.html
Modifiability,config,configure,ry() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump method). create_new_stats() (HEOMSolver m,MatchSource.WIKI,docs/4.4/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/genindex.html
Performance,concurren,concurrence,check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Dump,MatchSource.WIKI,docs/4.4/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/genindex.html
Usability,clear,clear,r method). (PulseGen method). (TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). CircuitProcessor (class in qutip.qip.models). CircularSpinChain (class in qutip.qip.models.spinchain). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coefficient_matrix() (Dicke method). (Pim method). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). corre,MatchSource.WIKI,docs/4.4/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/genindex.html
Deployability,release,released,"ven eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.4.0 (July 03, 2019); Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme",MatchSource.WIKI,docs/4.4/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/index.html
Integrability,depend,dependent,"da environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Monte Carlo Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis p",MatchSource.WIKI,docs/4.4/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.4.0 (July 03, 2019); Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 201",MatchSource.WIKI,docs/4.4/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/index.html
Availability,avail,available,"ling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Deployability,install,installation,"ox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. ",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when usin",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Modifiability,config,configuration,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Performance,load,load,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Security,access,access,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Testability,test,tested,". . Installation — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. nose; 1.1.2+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when usin",MatchSource.WIKI,docs/4.4/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.4 Documentation. QuTiP: Quantum Toolbox in Python. . 4.4; . Frontmatter; Installation; Users Guide; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Search. Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Jul 02, 2019.; . Built with Sphinx using a theme provided by Read the Docs. ",MatchSource.WIKI,docs/4.4/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.4/search.html
Deployability,update,updated,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/biblio.html
Performance,optimiz,optimization,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/biblio.html
Security,access,access,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Kha05. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbruggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005). doi:10.1016/j.jmr.2004.11.004. Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/biblio.html
Availability,error,error," (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot states (by Alex Pitchford).; Fixed bug in steadystate solver by removing separate arguments for MKL and Scipy (by Tarun Raheja).; Fixed Bloch.add_ponts by setting edgecolor = None in plot_points (by Nathan Shammah).; Fixed error checking for null matrix in essolve solver affecting also ode2es (by Peter Kirton).; Removed unnecessary shebangs in .pyx and .pxd files (by Samesh Lakhotia).; Fixed sesolve and import of os in codegen (by Alex Pitchford).; Updated plot_fock_distribution by removing the offset value 0.4 in the plot (by Rajiv-B). Version 4.4.1 (Au",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Deployability,release,released,". . Change Log — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperato",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Energy Efficiency,efficient,efficiently," (by Boxi Li).; Generalize expand_oper for arbitrary dimensions, and new method for cyclic permutations of given target cubits (by Boxi Li). Bug Fixes¶. Fixed the pickling but that made solver unable to run in parallel on Windows (Thank lrunze for reporting); Removed warning when mesolve fall back on sesolve (by Michael Goerz).; Fixed dimension check and confusing documentation in random ket (by Yariv Yanay).; Fixed Qobj isherm not working after using Qobj.permute (Thank llorz1207 for reporting).; Correlation functions call now properly handle multiple time dependant functions (Thank taw181 for reporting).; Removed mutable default values in mesolve/sesolve (by Michael Goerz).; Fixed simdiag bug (Thank Croydon-Brixton for reporting).; Better support of constant QobjEvo (by Boxi Li).; Fixed potential cyclic import in the control module (by Alexander Pitchford). Version 4.4.0 (July 03, 2019)¶. Improvements¶. MAJOR FEATURE: Added methods and techniques to the stochastic solvers (by Eric Giguère) which allows to use a much broader set of solvers and much more efficiently.; MAJOR FEATURE: Optimization of the montecarlo solver (by Eric Giguère). Computation are faster in many cases. Collapse information available to time dependant information.; Added the QObjEvo class and methods (by Eric Giguère), which is used behind the scenes by the dynamical solvers, making the code more efficient and tidier. More built-in function available to string coefficients.; The coefficients can be made from interpolated array with variable timesteps and can obtain state information more easily. Time-dependant collapse operator can have multiple terms.; New wigner_transform and plot_wigner_sphere function. (by Nithin Ramu).; ptrace is faster and work on bigger systems, from 15 Qbits to 30 Qbits.; QIP module: added the possibility for user-defined gates, added the possibility to remove or add gates in any point of an already built circuit, added the molmer_sorensen gate, and fixed some bugs (by ",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Integrability,message,message," Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propagator (by Nathan Shammah).; Fixed dimensional incongruence in propagator (by Nathan Shammah); Fixed bug by rewriting clebsch function based on long integer fraction (by Eric Giguère).; Fixed bugs in QobjEvo’s args depending on state and added solver tests using them (by Eric Giguère).; Fixed bug in sesolve calculation of average states when summing the timeslot s",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Modifiability,refactor,refactored,"cs »; Change Log. Change Log¶. Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nathan Shammah).; Added improvements to Qobj introducing the inv method and making the partial trace, ptrace, faster, keeping both sparse and dense methods (by Eric Giguère).; Allowed general callable objects to define a time-dependent Hamiltonian (by Eric Giguère).; Added feature so that QobjEvo no longer requires Cython for string coefficients (by Eric Giguère).; Updated authors list on Github and added my binder link (by Nathan Shammah). Bug Fixes¶. Fixed PolyDataMapper construction for Bloch3d (by Sam Griffiths).; Fixed error checking for null matrix in essolve (by Nathan Shammah).; Fixed name collision for parallel propag",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Performance,optimiz,optimization,"unitary op evolution rhs matrix in ssesolve.; Fixed interpolating function to return zero outside range.; Fixed dnorm complex casting bug.; Fixed control.io path checking issue.; Fixed ENR fock dimension.; Fixed hard coded options in propagator ‘batch’ mode; Fixed bug in trace-norm for non-Hermitian operators.; Fixed bug related to args not being passed to coherence_function_g2; Fixed MKL error checking dict key error. Version 4.2.0 (July 28, 2017)¶. Improvements¶. MAJOR FEATURE: Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse m",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Safety,safe,safety,"Initial implementation of time-dependent Bloch-Redfield Solver.; Qobj tidyup is now an order of magnitude faster.; Time-dependent codegen now generates output NumPy arrays faster.; Improved calculation for analytic coefficients in coherent states (Sebastian Kramer).; Input array to correlation FFT method now checked for validity.; Function-based time-dependent mesolve and sesolve routines now faster.; Codegen now makes sure that division is done in C, as opposed to Python.; Can now set different controls for a each timeslot in quantum optimization. This allows time-varying controls to be used in pulse optimisation. Bug Fixes¶. rcsolve importing old Odeoptions Class rather than Options.; Non-int issue in spin Q and Wigner functions.; Qobj’s should tidyup before determining isherm.; Fixed time-dependent RHS function loading on Win.; Fixed several issues with compiling with Cython 0.26.; Liouvillian superoperators were hard setting isherm=True by default.; Fixed an issue with the solver safety checks when inputing a list. with Python functions as time-dependence. Fixed non-int issue in Wigner_cmap.; MKL solver error handling not working properly. Version 4.1.0 (March 10, 2017)¶. Improvements¶; Core libraries. MAJOR FEATURE: QuTiP now works for Python 3.5+ on Windows using Visual Studio 2015.; MAJOR FEATURE: Cython and other low level code switched to C++ for MS Windows compatibility.; MAJOR FEATURE: Can now use interpolating cubic splines as time-dependent coefficients.; MAJOR FEATURE: Sparse matrix - vector multiplication now parallel using OPENMP.; Automatic tuning of OPENMP threading threshold.; Partial trace function is now up to 100x+ faster.; Hermitian verification now up to 100x+ faster.; Internal Qobj objects now created up to 60x faster.; Inplace conversion from COO -> CSR sparse formats (e.g. Memory efficiency improvement.); Faster reverse Cuthill-Mckee and sparse one and inf norms. Bug Fixes¶. Cleanup of temp. Cython files now more robust and working under W",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Testability,test,testing,"ersion 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Change Log. Change Log¶. Version 4.5.0 (January 31, 2020)¶. Improvements¶. MAJOR FEATURE: Added qip.noise, a module with pulse level description of quantum circuits allowing to model various types of noise and devices (by Boxi Li).; MAJOR FEATURE: Added qip.lattice, a module for the study of lattice dynamics in 1D (by Saumya Biswas).; Migrated testing from Nose to PyTest (by Tarun Raheja).; Optimized testing for PyTest and removed duplicated test runners (by Jake Lishman).; Deprecated importing qip functions to the qutip namespace (by Boxi Li).; Added the possibility to define non-square superoperators relevant for quantum circuits (by Arne Grimsmo and Josh Combes).; Implicit tensor product for qeye, qzero and basis (by Jake Lishman).; QObjEvo no longer requires Cython for string coefficient (by Eric Giguère).; Added marked tests for faster tests in testing.run() and made faster OpenMP benchmarking in CI (by Eric Giguère).; Added entropy and purity for Dicke density matrices, refactored into more general dicke_trace (by Nathan Shammah).; Added option for specifying resolution in Bloch.save function (by Tarun Raheja).; Added information related to the value of hbar in wigner and continuous_variables (by Nicolas Quesada).; Updated requirements for scipy 1.4 (by Eric Giguère).; Added previous lead developers to the qutip.about() message (by Nath",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Usability,simpl,simplified,"ns.; The default Wigner function now uses a Clenshaw summation algorithm to evaluate a polynomial series that is applicable for any number of exciations (previous limitation was ~50 quanta), and is ~3x faster than before. (Added by Denis Vasilyev); Can now define a given eigen spectrum for random Hermitian and density operators.; The Qobj expm method now uses the equivilent SciPy routine, and performs a much faster exp operation if the matrix is diagonal.; One can now build zero operators using the qzero function. Control modules. MAJOR FEATURE: CRAB algorithm added; This is an alternative to the GRAPE algorithm, which allows for analytical control functions, which means that experimental constraints can more easily be added into optimisation.; See tutorial notebook for full information. Improvements¶; Core libraries. Two-time correlation functions can now be calculated for fully time-dependent Hamiltonians and collapse operators. (Added by Kevin Fischer); The code for the inverse-power method for the steady state solver has been simplified.; Bloch-Redfield tensor creation is now up to an order of magnitude faster. (Added by Johannes Feist); Q.transform now works properly for arrays directly from sp_eigs (or eig).; Q.groundstate now checks for degeneracy.; Added sinm and cosm methods to the Qobj class.; Added charge and tunneling operators.; Time-dependent Cython code is now easier to read and debug. Control modules. The internal state / quantum operator data type can now be either Qobj or ndarray; Previous only ndarray was possible. This now opens up possibility of using Qobj methods in fidelity calculations; The attributes and functions that return these operators are now preceded by an underscore, to indicate that the data type could change depending on the configuration options.; In most cases these functions were for internal processing only anyway, and should have been ‘private’.; Accessors to the properties that could be useful outside of the library have been",MatchSource.WIKI,docs/4.5/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/changelog.html
Deployability,update,updated,"; Ben Criger (Waterloo IQC) - Code contributor; Ben Bartlett (Stanford) - Code contributor; Bredan Abolins (Berkeley) - Bug hunter; Chris Granade - Code contributor; Claudia Degrandi (Yale University) - Documentation; Dawid Crivelli - Bug hunter; Denis Vasilyev (St. Petersburg State University) - Code contributor; Dong Zhou (Yale University) - Bug hunter; Eric Giguere (Sherbrooke University) - Code contributor; Florian Ong (Institute for Quantum Computation) - Bug hunter; Frank Schima - Macports packaging; Henri Nielsen (Technical University of Denmark) - Bug hunter; Hwajung Kang (Systems Biology Institute, Tokyo) - Suggestions for improving Bloch class; James Clemens (Miami University - Ohio) - Bug hunter; Johannes Feist - Code contributor; Jonas Hörsch - Code contributor; Jonas Neergaard-Nielsen (Technical University of Denmark) - Code contributor, Windows support; JP Hadden (University of Bristol) - Code contributor, improved Bloch sphere visualization; Kevin Fischer (Stanford) - Code contributor; Laurence Stant - Documentation; Markus Baden (Centre for Quantum Technologies, Singapore) - Code contributor, Documentation; Myung-Joong Hwang (Pohang University of Science and Technology) - Bug hunter; Nathan Shammah (RIKEN) - Code contributor; Neill Lambert (RIKEN) - Code contributor, Windows support; Nikolas Tezak (Stanford) - Code contributor; Nithin Ramu Code contributor; Per Nielsen (Technical University of Denmark) - Bug hunter, Code contributor; Piotr Migdał (ICFO) - Code contributor; Reinier Heeres (Yale University) - Code contributor; Robert Jördens (NIST) - Linux packaging; Simon Whalen - Code contributor; Shahnawaz Ahmed (RIKEN, BITS Pilani) - Code contributor, Bug hunter; W.M. Witzel - Bug hunter. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/contributors.html
Availability,avail,available,". . Frontmatter — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.5. status; Released (January 30, 2020). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore in",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Deployability,release,release,"ting the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webpage. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions are noted. See Contributors for a list of people who have helped in one way or another. If you are interested, please drop us a line at the QuTiP discussion group webp",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Modifiability,coupling,coupling,"eill Lambert. Author; Eric Giguere. version; 4.5. status; Released (January 30, 2020). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Performance,perform,performed,"ting This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. Contributing to QuTiP¶; We welcome anyone who is interested in helping us make QuTiP the best package for simulating quantum systems. Anyone who contributes will be duly recognized. Even small contributions ",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Usability,guid,guide,". . Frontmatter — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. version; 4.5. status; Released (January 30, 2020). copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be download from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organization:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore in",MatchSource.WIKI,docs/4.5/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/frontmatter.html
Deployability,update,update,ule qutip.three_level_atom). three_level_ops() (in module qutip.three_level_atom). tidyup() (eseries method). (Qobj method). TimeslotComputer (class in qutip.control.tslotcomp). tlist() (Pulse property). to_chi() (in module qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). transform() (Qobj method). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). UserNoise (class in qutip.qip.noise). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1d method). writeout() (DynamicsDump method). (EvoCom,MatchSource.WIKI,docs/4.5/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/genindex.html
Energy Efficiency,charge,charge,(TimeslotComputer method). average_gate_fidelity() (in module qutip.metrics). B. basis() (in module qutip.states). (Lattice1d method). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module quti,MatchSource.WIKI,docs/4.5/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/genindex.html
Modifiability,config,configure, cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in module qutip.operators). create_dump_dir() (Du,MatchSource.WIKI,docs/4.5/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/genindex.html
Performance,concurren,concurrence,). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.gates). create() (in modu,MatchSource.WIKI,docs/4.5/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/genindex.html
Usability,clear,clear,dule qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). composite() (in module qutip.tensor). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceD,MatchSource.WIKI,docs/4.5/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/genindex.html
Deployability,release,released,"umentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Lattice; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015):; New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014):; Bug Fixes. Version 3.0.0 (July 17, 2014):; New Features; Improvements. Version 2.2.0 (March 01, 2013):; New Features; Bug Fixes:. Version 2.1.0 (October 05, 2012):; New Features; Bug Fixes:. Version 2.0.0 (June 01, 2012):; New Features. Version 1.1.4 (May 28, 2012):; Bug Fixes:. Version 1.1.3 (November 21, 2011):; New Functions:; Bug Fixes:. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme",MatchSource.WIKI,docs/4.5/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/index.html
Integrability,depend,dependent,"g your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability",MatchSource.WIKI,docs/4.5/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/index.html
Performance,load,loading,"ate solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Introduction; Quantum Circuit; Processor for QIP simulation; Noise Simulation; Workflow of the Processor. Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and Operators; Functions acting on states and operators; Dynamics and Time-Evolution; Lattice; Visualization; Quantum Information Processing; Non-Markovian Solvers; Optimal control; Utility Functions. Change Log; Version 4.5.0 (January 31, ",MatchSource.WIKI,docs/4.5/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/index.html
Availability,avail,available,"ling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may however wish to install QuTiP in a Conda environment (env) other than the default Anaconda environment. You may wish to install Miniconda instead if you need to be economical with disk space. However, if you are not familiar with conda environments and only plan to use if for QuTiP, then you should probably work with a default Anaconda / Miniconda environment.; To create a Conda env for QuTiP called qutip-env:; conda create -n qutip-env python=3. Note the python=3 can be ommited if you want the default Python ",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Deployability,install,installation,"ox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. ",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Integrability,depend,depends,". . Installation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work b",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Modifiability,config,configuration,"Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; If you aleady have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. Otherwise refer to building-conda-environment; If you are using MS Windows, then you will probably want to refer to installation-on-MS-Windows. Building your Conda environment¶. Important; There are no working conda-forge packages for Python 2.7 on Windows. On Windows you should create a Python 3.5+ environment. The default Anaconda environment has all the Python packages needed for running QuTiP. You may how",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Performance,load,load,"ow. Installing from Source¶; Official releases of QuTiP are available from the download section on the project’s web pages. http://www.qutip.org/download.html. and the latest source code is available in our Github repository. http://github.com/qutip. In general we recommend users to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the ",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Security,access,access,"s to use the latest stable release of QuTiP, but if you are interested in helping us out with development or wish to submit bug fixes, then use the latest development version from the Github repository.; Installing QuTiP from source requires that all the dependencies are satisfied. To install QuTiP from the source code run:; python setup.py install. To install OPENMP support, if available, run:; python setup.py install --with-openmp. If you are wishing to contribute to the QuTiP project, then you will want to create your own fork of qutip, clone this to a local folder, and ‘install’ it into your Python env using:; python setup.py develop --with-openmp. import qutip in this Python env will then load the code from your local fork, enabling you to test changes interactively.; The sudo pre-command is typically not needed when installing into Anaconda type environments, as Anaconda is usually installed in the users home directory. sudo will be needed (on Linux and OSX) for installing into Python environments where the user does not have write access. Installation on MS Windows¶. Important; Installation on Windows has changed substantially as of QuTiP 4.1. The only supported installation configuration is using the Conda environment with Python 3.5+ and Visual Studio 2015. We are recommending and supporting installation of QuTiP into a Conda environment. Other scientific Python implementations such as Python-xy may also work, but are not supported.; As of QuTiP 4.1, recommended installation on Windows requires Python 3.5+, as well as Visual Studio 2015. With this configuration, one can install QuTiP using any of the above mentioned receipes. Visual Studio 2015 is not required for the install of the conda-forge package, but it is required at runtime for the string format time-dependence solvers. When installing Visual Studio 2015 be sure to select options for the C++ compiler.; The ‘Community’ edition of Visual Studio 2015 is free to download use, however it does require ap",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Testability,test,tested,". . Installation — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; General Requirements; Platform-independent Installation; Building your Conda environment; Adding the conda-forge channel. Installing via pip; Installing from Source; Installation on MS Windows; Windows and Python 2.7. Verifying the Installation; Checking Version Information using the About Function. Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Installation. Installation¶. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python; programming language. The following packages are currently required:. Package; Version; Details. Python; 2.7+; Version 3.5+ is highly recommended. NumPy; 1.8+; Not tested on lower versions. SciPy; 0.15+; Lower versions have missing features. Matplotlib; 1.2.1+; Some plotting does not work on lower versions. Cython; 0.21+; Needed for compiling some time-dependent; Hamiltonians. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files. Python; Headers; 2.7+; Linux only. Needed for compiling Cython files. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. LaTeX; TexLive 2009+; Needed if using LaTeX in matplotlib figures. pytest; 5.3+; For running the test suite. We would not recommend installation into the system Python on Linux platforms, as it is likely that the required libraries will be difficult to update to sufficiently recent versions. The system Python on Linux is used for system things, changing its configuration could lead to highly undesirable results. We are recommending and supporting Anaconda / Miniconda Python environments for QuTiP on all platformsx [It is also possible to install the Intel Python Distribution via the conda installer in Anaconda]. Platform-independent Installation¶; QuTiP is designed to work b",MatchSource.WIKI,docs/4.5/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/installation.html
Deployability,update,updated,". . Python Module Index — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.dimensions.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.lattice.    ; qutip.mcsolve.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.device.    ; qutip.qip.gates.    ; qutip.qip.qubits.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.semidefinite.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.topology.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/py-modindex.html
Deployability,update,updated,". . Search — QuTiP 4.5 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.5; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Bibliography. QuTiP: Quantum Toolbox in Python. Docs »; Search. Please activate JavaScript to enable the search; functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, and E. Giguere; ; Last updated on Feb 01, 2020.; . Built with Sphinx using a theme provided by Read the Docs. . ",MatchSource.WIKI,docs/4.5/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.5/search.html
Deployability,update,updated,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/biblio.html
Performance,optimiz,optimization,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/biblio.html
Security,access,access,". Wood, J. Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/biblio.html
Availability,fault,faults,"(October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Deployability,release,released," Bug Fixes; Documentation Improvements; Developer Changes. Version 4.6.2 (June 2, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.1 (May 4, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.0 (April 11, 2021); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.3 (February 19, 2021); Improvements. Version 4.5.2 (July 14, 2020); Improvements; Bug Fixes; Developer Changes. Version 4.5.1 (May 15, 2020); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_tr",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Energy Efficiency,power,power,"s removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and th",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Integrability,depend,dependabot," (#1715 by Asier Galicia); Fixed a typo in the chi_to_choi documentation. Previously the documentation mixed up chi and choi. (#1731 by Pontus Wikståhl); Improved the documentation for the stochastic equation solvers. Added links to notebooks with examples, API doumentation and external references. (#1743 by Leonardo Assis); Fixed a typo in qutip.settings in the settings guide. (#1786 by Mahdi Aslani); Made numerous small improvements to the text of the QuTiP basics guide. (#1768 by Anna Naden); Made a small phrasing improvement to the README. (#1790 by Rita Abani). Developer Changes¶. Improved test coverage of states and operators functions. (#1578 by Eric Giguère); Fixed test_interpolate mcsolve use (#1645 by Eric Giguère); Ensured figure plots are explicitly closed during tests so that the test suite passes when run headless under Xvfb. (#1648 by Simon Cross); Bumped the version of pillow used to build documentation from 8.2.0 to 9.0.0. (#1654, #1760 by dependabot); Bumped the version of babel used to build documentation from 2.9.0 to 2.9.1. (#1695 by dependabot); Bumped the version of numpy used to build documentation from 1.19.5 to 1.21.0. (#1767 by dependabot); Bumped the version of ipython used to build documentation from 7.22.0 to 7.31.1. (#1780 by dependabot); Rename qutip.bib to CITATION.bib to enable GitHub’s citation support. (#1662 by Ashish Panigrahi); Added tests for simdiags. (#1681 by Eric Giguère); Added support for specifying the numpy version in the CI test matrix. (#1696 by Simon Cross); Fixed the skipping of the dnorm metric tests if cvxpy is not installed. Previously all metrics tests were skipped by accident. (#1704 by Florian Hopfmueller); Added bug report, feature request and other options to the GitHub issue reporting template. (#1728 by Aryaman Kolhe); Updated the build process to support building on Python 3.10 by removing the build requirement for numpy < 1.20 and replacing it with a requirement on oldest-supported-numpy. (#1747 by Simo",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Modifiability,config,configuration," have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed errors in the calculation of the Husimi spin_q_function and spin_wigner functions and added tests for them. (#1632 by Mark Johnson); Fixed setting of OpenMP compilation flag on Linux. Previously when compiling the OpenMP functions were compiled without parallelization. (#1693 by Eric Giguère); Fixed tracking the state of the Bloch sphere figure and axes to prevent exceptions during rendering. (#1619 by Simon Cross); Fixed compatibility with numpy configuration in numpy’s 1.22.0 release. (#1752 by Matthew Treinish); Added dims checks for e_ops passed to solvers to prevent hanging the calling process when e_ops of the wrong dimensions were passed. (#1778 by Eric Giguère); Added a check in Qobj constructor that the respective members of data.shape cannot be larger than what the corresponding dims could contain to prevent a segmentation fault caused by inconsistencies between dims and shapes. (#1783, #1785, #1784 by Lajos Palanki & Eric Giguère). Documentation Improvements¶. Added docs for the num_cbits parameter of the QubitCircuit class. (#1652 by Jon Crall); Fixed the parameters in the call to fsesolve in the Floquet guide. (#1675 by Simon Cross); Fixed the description of random number usage in the Monte Carlo solver guide. (#1677 by Ian Thorvaldson); Fixed the rendering of equation numbers in the documentation (they now appear on the right as expected, not above the equation). (#1678 by Simon Cross); Updated the i",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Performance,perform,performance,"sion 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Safety,sanity check,sanity checks,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Testability,test,testing," Toolbox in Python. »; Change Log. Change Log¶. Version 4.6.3 (February ?, 2022)¶; This minor release adds support for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad init",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Usability,simpl,simple," for numpy 1.22 and Python 3.10 and removes some blockers for running QuTiP on the Apple M1.; The performance of the enr_destroy, state_number_enumerate and hadamard_transform functions was drastically improved (up to 70x or 200x faster in some common cases), and support for the drift Hamiltonian was added to the qutip.qip Processor.; The qutip.hardware_info module was removed as part of adding support for the Apple M1. We hope the removal of this little-used module does not adversely affect many users – it was largely unrelated to QuTiP’s core functionality and its presence was a continual source of blockers to importing qutip on new or changed platforms.; A new check on the dimensions of Qobj’s were added to prevent segmentation faults when invalid shape and dimension combinations were passed to Cython code.; In addition, there were many small bugfixes, documentation improvements, and improvements to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states ",MatchSource.WIKI,docs/4.6/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/changelog.html
Deployability,update,updated,"Alex Pitchford; Nathan Shammah; Shahnawaz Ahmed; Neill Lambert; Eric Giguère; Boxi Li; Jake Lishman; Simon Cross. Past Lead Developers¶. Robert Johansson (RIKEN); Paul Nation (Korea University); Chris Granade; Arne Grimsmo. Contributors¶. Note; Anyone is welcome to contribute to QuTiP.; If you are interested in helping, please let us know!. Abhisek Upadhyaya; Adriaan; Alexander Pitchford; Alexios-xi; Amit; Anubhav Vardhan; Arie van Deursen; Arne Grimsmo; Arne Hamann; Asier Galicia Martinez; Ben Bartlett; Ben Criger; Ben Jones; Bo Yang; Boxi Li; Canoming; Christoph Gohlke; Christopher Granade; Craig Gidney; Denis Vasilyev; Dominic Meiser; Drew Parsons; Eric Giguère; Eric Hontz; Felipe Bivort Haiek; Florestan Ziem; Gilbert Shih; Harry Adams; Ivan Carvalho; Jake Lishman; Jevon Longdell; Johannes Feist; Jonas Hoersch; Jonas Neergaard-Nielsen; Jonathan A. Gross; Julian Iacoponi; Kevin Fischer; Laurence Stant; Louis Tessler; Lucas Verney; Marco David; Marek; Markus Baden; Martín Sande; Mateo Laguna; Matthew O’Brien; Michael Goerz; Michael V. DePalatis; Moritz Oberhauser; Nathan Shammah; Neill Lambert; Nicolas Quesada; Nikolas Tezak; Nithin Ramu; Paul Nation; Peter Kirton; Philipp Schindler; Piotr Migdal; Rajiv-B; Ray Ganardi; Reinier Heeres; Richard Brierley; Robert Johansson; Sam Griffiths; Samesh Lakhotia; Sebastian Krämer; Shahnawaz Ahmed; Sidhant Saraogi; Simon Cross; Simon Humpohl; Simon Whalen; Stefan Krastanov; Tarun Raheja; Thomas Walker; Viacheslav Ostroukh; Vlad Negnevitsky; Wojciech Rzadkowski; Xiaodong Qi; Xiaoliang Wu; Yariv Yanay; YouWei Zhao; alex; eliegenois; essence-of-waqf; fhenneke; gecrooks; jakobjakobson13; maij; sbisw002; yuri@FreeBSD; Élie Gouzien. Next ; Previous. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/contributors.html
Availability,avail,available,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Deployability,release,release,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum informat",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Modifiability,coupling,coupling,"iguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Performance,perform,performed,"g This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a comput",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Usability,guid,guide,". Frontmatter — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.6.3. copyright; This documentation is licensed under the Creative Commons Attribution 3.0 Unported License. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from http://arxiv.org/abs/1211.6518 or http://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement perfo",MatchSource.WIKI,docs/4.6/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/frontmatter.html
Deployability,update,update,). (DispersiveCavityQED method). (LinearSpinChain method). (ModelProcessor method). (SpinChain method). to_chi() (in module qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_list() (QobjEvo method). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.operations.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). U. unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
Energy Efficiency,charge,charge,e qutip.metrics). B. basis() (in module qutip.states). (Lattice1d method). bell_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module quti,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
Modifiability,config,configure, (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
Performance,concurren,concurrence, property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
Usability,clear,clear,brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method,MatchSource.WIKI,docs/4.6/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/genindex.html
Deployability,release,released," Bug Fixes; Documentation Improvements; Developer Changes. Version 4.6.2 (June 2, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.1 (May 4, 2021); Improvements; Bug Fixes; Developer Changes. Version 4.6.0 (April 11, 2021); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.3 (February 19, 2021); Improvements. Version 4.5.2 (July 14, 2020); Improvements; Bug Fixes; Developer Changes. Version 4.5.1 (May 15, 2020); Improvements; Bug Fixes; Deprecations; Developer Changes. Version 4.5.0 (January 31, 2020); Improvements; Bug Fixes. Version 4.4.1 (August 29, 2019); Improvements; Bug Fixes. Version 4.4.0 (July 03, 2019); Improvements; Bug Fixes. Version 4.3.0 (July 14, 2018); Improvements; Bug Fixes. Version 4.2.0 (July 28, 2017); Improvements; Bug Fixes. Version 4.1.0 (March 10, 2017); Improvements; Bug Fixes. Version 4.0.2 (January 5, 2017); Bug Fixes. Version 4.0.0 (December 22, 2016); Improvements; Bug Fixes. Version 3.2.0 (Never officially released); New Features; Improvements; Bug Fixes. Version 3.1.0 (January 1, 2015); New Features; Bug Fixes. Version 3.0.1 (Aug 5, 2014); Bug Fixes. Version 3.0.0 (July 17, 2014); New Features; Improvements. Version 2.2.0 (March 01, 2013); New Features; Bug Fixes. Version 2.1.0 (October 05, 2012); New Features; Bug Fixes. Version 2.0.0 (June 01, 2012); New Features. Version 1.1.4 (May 28, 2012); Bug Fixes. Version 1.1.3 (November 21, 2011); New Functions; Bug Fixes. Version 1.1.2 (October 27, 2011); Bug Fixes. Version 1.1.1 (October 25, 2011); New Functions; Bug Fixes. Version 1.1.0 (October 04, 2011); New Functions; Bug Fixes. Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; QuTiP major release roadmap. Ideas for future QuTiP ",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
Integrability,depend,dependent,"lling with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and p",MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
Performance,load,loading, Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.6/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/index.html
Availability,avail,available,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Deployability,install,install,"﻿. Installation — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfai",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Integrability,depend,dependencies,"ion. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test sui",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Modifiability,enhance,enhanced,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Performance,load,load,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Safety,detect,detect,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Testability,test,test,"s this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while ",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Usability,guid,guides,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.6/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/installation.html
Deployability,update,updated,". Python Module Index — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.dimensions.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.lattice.    ; qutip.matplotlib_utilities.    ; qutip.mcsolve.    ; qutip.measurement.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.operations.gates.    ; qutip.qip.qasm.    ; qutip.qip.qubits.    ; qutip.qobj.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.semidefinite.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.topology.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/py-modindex.html
Deployability,update,updated,". Search — QuTiP 4.6 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.6; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography. QuTiP: Quantum Toolbox in Python. »; Search. Please activate JavaScript to enable the search functionality.; . © Copyright 2011 and later, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, A.L. Grimsmo, N. Shammah, S. Ahmed, N. Lambert, B. Li, J. Lishman, S. Cross, and E. Giguère.; ; Last updated on Feb 08, 2022.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.6/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.6/search.html
Deployability,update,updated,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
Performance,optimiz,optimization," Biamonte, D. G. Cory, Tensor networks and graphical calculus for; open quantum systems. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
Security,access,access,"ms. arXiv:1111.6950. dAless08. d’Alessandro, Introduction to Quantum Control and Dynamics, (Chapman & Hall/CRC, 2008). Byrd95. Byrd, P. Lu, J. Nocedal, and C. Zhu, A Limited Memory Algorithm for Bound Constrained Optimization, SIAM J. Sci. Comput. 16, 1190 (1995). doi:10.1137/0916069. Flo12. Floether, P. de Fouquieres, and S. G. Schirmer, Robust quantum gates for open systems via optimal control: Markovian versus non-Markovian dynamics, New J. Phys. 14, 073023 (2012). doi:10.1088/1367-2630/14/7/073023. Lloyd14. Lloyd and S. Montangero, Information theoretical analysis of quantum optimal control, Phys. Rev. Lett. 113, 010502 (2014). doi:10.1103/PhysRevLett.113.010502. Doria11. Doria, T. Calarco & S. Montangero, Optimal Control Technique for Many-Body Quantum Dynamics, Phys. Rev. Lett. 106, 190501 (2011). doi:10.1103/PhysRevLett.106.190501. Caneva11. Caneva, T. Calarco, & S. Montangero, Chopped random-basis quantum optimization, Phys. Rev. A 84, 022326 (2011). doi:10.1103/PhysRevA.84.022326. Rach15. Rach, M. M. Müller, T. Calarco, and S. Montangero, Dressing the chopped-random-basis optimization: A bandwidth-limited access to the trap-free landscape, Phys. Rev. A. 92, 062343 (2015). doi:10.1103/PhysRevA.92.062343. DYNAMO. Machnes, U. Sander, S. J. Glaser, P. De Fouquieres, A. Gruslys, S. Schirmer, and T. Schulte-Herbrueggen, Comparing, Optimising and Benchmarking Quantum Control Algorithms in a Unifying Programming Framework, Phys. Rev. A. 84, 022305 (2010). arXiv:1011.4874. Wis09; Wiseman, H. M. & Milburn, G. J. Quantum Measurement and Control, (Cambridge University Press, 2009). NKanej; N Khaneja et. al. Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005). doi:10.1016/j.jmr.2004.11.004. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/biblio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/biblio.html
Availability,error,error,"icensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Deployability,release,released,"022). Improvements; Bug Fixes; Documentation Improvements; Developer Changes; Version 4.6.2 (June 2, 2021). Improvements; Bug Fixes; Developer Changes; Version 4.6.1 (May 4, 2021). Improvements; Bug Fixes; Developer Changes; Version 4.6.0 (April 11, 2021). Improvements; Bug Fixes; Deprecations; Developer Changes; Version 4.5.3 (February 19, 2021). Improvements; Version 4.5.2 (July 14, 2020). Improvements; Bug Fixes; Developer Changes; Version 4.5.1 (May 15, 2020). Improvements; Bug Fixes; Deprecations; Developer Changes; Version 4.5.0 (January 31, 2020). Improvements; Bug Fixes; Version 4.4.1 (August 29, 2019). Improvements; Bug Fixes; Version 4.4.0 (July 03, 2019). Improvements; Bug Fixes; Version 4.3.0 (July 14, 2018). Improvements; Bug Fixes; Version 4.2.0 (July 28, 2017). Improvements; Bug Fixes; Version 4.1.0 (March 10, 2017). Improvements; Bug Fixes; Version 4.0.2 (January 5, 2017). Bug Fixes; Version 4.0.0 (December 22, 2016). Improvements; Bug Fixes; Version 3.2.0 (Never officially released). New Features; Improvements; Bug Fixes; Version 3.1.0 (January 1, 2015). New Features; Bug Fixes; Version 3.0.1 (Aug 5, 2014). Bug Fixes; Version 3.0.0 (July 17, 2014). New Features; Improvements; Version 2.2.0 (March 01, 2013). New Features; Bug Fixes; Version 2.1.0 (October 05, 2012). New Features; Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Energy Efficiency,adapt,adaptive,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Integrability,integrat,integration,"gvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to buil",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Modifiability,adapt,adaptive,".X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in heterodyne smesolver and passing through of sc_ops to photocurrent solver. (#2081 by Bogdan Reznychenko and Simon Cross); Update calls to SciPy eigvalsh and eigsh to pass the range of eigenvalues to return using subset_by_index=. (#2081 by Simon Cross); Fixed bug where some matrices were wrongly found to be hermitian. (#2082 by AGaliciaMartinez). Miscellaneous¶. Fixed typo in stochastic.py (#2049, by eltociear); ptrace always return density matrix (#2185, issue by udevd); mesolve can support mixed callable and Qobj for e_ops (#2184 issue by balopat). Version 4.7.1 (December 11, 2022)¶; This is a bugfix release for QuTiP 4.7.X. In addition to the minor fixes; listed below, the release adds builds for Python 3.11 and support for; packaging 22.0. Features¶. Improve qutip import times by setting logger names explicitly. (#1980). Bug Fixes¶. Change floquet_master_equation_rates(…) to use an adaptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave a",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Performance,load,loaded,"daptive number of time steps scaled by the number of sidebands, kmax. (#1961); Change fidelity(A, B) to use the reduced fidelity formula for pure states which is more numerically efficient and accurate. (#1964); Change brmesolve to raise an exception when ode integration is not successful. (#1965); Backport fix for IPython helper Bloch._repr_svg_ from dev.major. Previously the print_figure function returned bytes, but since ipython/ipython#5452 (in 2014) it returns a Unicode string. This fix updates QuTiP’s helper to match. (#1970); Fix correlation for case where only the collapse operators are time dependent. (#1979); Fix the hinton visualization method to plot the matrix instead of its transpose. (#2011); Fix the hinton visualization method to take into account all the matrix coefficients to set the squares scale, instead of only the diagonal coefficients. (#2012); Fix parsing of package versions in setup.py to support packaging 22.0. (#2037); Add back .qu suffix to objects saved with qsave and loaded with qload. The suffix was accidentally removed in QuTiP 4.7.0. (#2038); Add a default max_step to processors. (#2040). Documentation¶. Add towncrier for managing the changelog. (#1927); Update the version of numpy used to build documentation to 1.22.0. (#1940); Clarify returned objects from bloch_redfield_tensor(). (#1950); Update Floquet Markov solver docs. (#1958); Update the roadmap and ideas to show completed work as of August 2022. (#1967). Miscellaneous¶. Return TypeError instead of Exception for type error in sesolve argument. (#1924); Add towncrier draft build of changelog to CI tests. (#1946); Add Python 3.11 to builds. (#2041); Simplify version parsing by using packaging.version.Version. (#2043); Update builds to use cibuildwheel 2.11, and to build with manylinux2014 on Python 3.8 and 3.9, since numpy and SciPy no longer support manylinux2010 on those versions of Python. (#2047). Version 4.7.0 (April 13, 2022)¶; This release sees the addition of two new so",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Safety,sanity check,sanity checks,"ents to our building and testing processes. Improvements¶. The enr_destroy function was made ~200x faster in many simple cases. (#1593 by Johannes Feist); The state_number_enumerate function was made significantly faster. (#1594 by Johannes Feist); Added the missing drift Hamiltonian to the method run_analytically of Processor. (#1603 Boxi Li); The hadamard_transform was made much faster, e.g., ~70x faster for N=10. (#1688 by Asier Galicia); Added support for computing the power of a scalar-like Qobj. (#1692 by Asier Galicia); Removed the hardware_info module. This module wasn’t used inside QuTiP and regularly broke when new operating systems were released, and in particular prevented importing QuTiP on the Apple M1. (#1754, #1758 by Eric Giguère). Bug Fixes¶. Fixed support for calculating the propagator of a density matrix with collapse operators. QuTiP 4.6.2 introduced extra sanity checks on the dimensions of inputs to mesolve (Fix mesolve segfault with bad initial state #1459), but the propagator function’s calls to mesolve violated these checks by supplying initial states with the dimensions incorrectly set. propagator now calls mesolve with the correct dimensions set on the initial state. (#1588 by Simon Cross); Fixed support for calculating the propagator for a superoperator without collapse operators. This functionality was not tested by the test suite and appears to have broken sometime during 2019. Tests have now been added and the code breakages fixed. (#1588 by Simon Cross); Fixed the ignoring of the random number seed passed to rand_dm in the case where pure was set to true. (#1600 Pontus Wikståhl); Fixed qutip.control.optimize_pulse support for sparse eigenvector decomposition with the Qobj oper_dtype (the Qobj oper_dtype is the default for large systems). (#1621 by Simon Cross); Removed qutip.control.optimize_pulse support for scipy.sparse.csr_matrix and generic ndarray-like matrices. Support for these was non-functional. (#1621 by Simon Cross); Fixed ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Testability,test,tests,"Bug Fixes; Version 2.0.0 (June 01, 2012). New Features; Version 1.1.4 (May 28, 2012). Bug Fixes; Version 1.1.3 (November 21, 2011). New Functions; Bug Fixes; Version 1.1.2 (October 27, 2011). Bug Fixes; Version 1.1.1 (October 25, 2011). New Functions; Bug Fixes; Version 1.1.0 (October 04, 2011). New Functions; Bug Fixes; Version 1.0.0 (July 29, 2011). Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Change Log. Change Log¶. QuTiP 4.7.5 (2024-01-29)¶; Patch release for QuTiP 4.7. It adds support for SciPy 1.12. Bug Fixes¶. Remove use of scipy.<numpy-func> in parallel.py, incompatible with scipy==1.12 (#2305 by Evan McKinney). QuTiP 4.7.4 (2024-01-15)¶. Bug Fixes¶. Adapt to deprecation from matplotlib 3.8 (#2243, reported by Bogdan Reznychenko); Fix name of temp files for removal after use. (#2251, reported by Qile Su); Avoid integer overflow in Qobj creation. (#2252, reported by KianHwee-Lim); Ignore DeprecationWarning from pyximport (#2287); Add partial support and tests for python 3.12. (#2294). Miscellaneous¶. Rework choi_to_kraus, making it rely on an eigenstates solver that can choose eigh if the Choi matrix is Hermitian, as it is more numerically stable. (#2276, by Bogdan Reznychenko); Rework kraus_to_choi, making it faster (#2283, by Bogdan Reznychenko and Rafael Haenel). QuTiP 4.7.3 (2023-08-22)¶. Bug Fixes¶. Non-oper qobj + scalar raise an error. (#2208 reported by vikramkashyap); Fixed issue where extract_states did not preserve hermiticity.; Fixed issue where rand_herm did not set the private attribute _isherm to True. (#2214 by AGaliciaMartinez); ssesolve average states to density matrices (#2216 reported by BenjaminDAnjou). Miscellaneous¶. Exclude cython 3.0.0 from requirement (#2204); Run in no cython mode with cython >=3.0.0 (#2207). QuTiP 4.7.2 (2023-06-28)¶; This is a bugfix release for QuTiP 4.7.X. It adds support for; numpy 1.25 and scipy 1.11. Bug Fixes¶. Fix setting of sso.m_ops in ",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Usability,simpl,simple,"Live. (#1580 by Jake Lishman); The signatures of rand_ket and rand_ket_haar were changed to allow N (the size of the random ket) to be determined automatically when dims are specified. (#1509 by Purva Thakre). Bug Fixes¶. Fix circuit index used when plotting circuits with non-reversed states. (#1847 by Christian Staufenbiel); Changed implementation of qutip.orbital to use scipy.special.spy_harm to remove bugs in angle interpretation. (#1844 by Christian Staufenbiel); Fixed QobjEvo.tidyup to use settings.auto_tidyup_atol when removing small elements in sparse matrices. (#1832 by Eric Giguère); Ensured that tidyup’s default tolerance is read from settings at each call. (#1830 by Eric Giguère); Fixed scipy.sparse deprecation warnings raised by qutip.fast_csr_matrix. (#1827 by Simon Cross); Fixed rendering of vectors on the Bloch sphere when using matplotlib 3.5 and above. (#1818 by Simon Cross); Fixed the displaying of Lattice1d instances and their unit cells. Previously calling them raised exceptions in simple cases. (#1819, #1697 and #1702 by Simon Cross and Saumya Biswas); Fixed the displaying of the title for hinton and matrix_histogram plots when a title is given. Previously the supplied title was not displayed. (#1707 by Vladimir Vargas-Calderón); Removed an incorrect check on the initial state dimensions in the QubitCircuit constructor. This allows, for example, the construction of qutrit circuits. (#1807 by Boxi Li); Fixed the checking of method and offset parameters in coherent and coherent_dm. (#1469 and #1741 by Joseph Fox-Rabinovitz and Simon Cross); Removed the Hamiltonian saved in the sesolve solver results. (#1689 by Eric Giguère); Fixed a bug in rand_herm with pos_def=True and density>0.5 where the diagonal was incorrectly filled. (#1562 by Eric Giguère). Documentation Improvements¶. Added contributors image to the documentation. (#1828 by Leonard Assis); Fixed the Theory of Quantum Information bibliography link. (#1840 by Anto Luketina); Fixed minor gra",MatchSource.WIKI,docs/4.7/changelog.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/changelog.html
Deployability,update,updated,"ght and Licensing. QuTiP: Quantum Toolbox in Python. »; Developers. Developers¶. Lead Developers¶. Alex Pitchford; Nathan Shammah; Shahnawaz Ahmed; Neill Lambert; Eric Giguère; Boxi Li; Jake Lishman; Simon Cross. Past Lead Developers¶. Robert Johansson (RIKEN); Paul Nation (Korea University); Chris Granade; Arne Grimsmo. Contributors¶. Note; Anyone is welcome to contribute to QuTiP.; If you are interested in helping, please let us know!. Abhisek Upadhyaya; Adriaan; Alexander Pitchford; Alexios-xi; Amit; Anubhav Vardhan; Arie van Deursen; Arne Grimsmo; Arne Hamann; Asier Galicia Martinez; Ben Bartlett; Ben Criger; Ben Jones; Bo Yang; Boxi Li; Canoming; Christoph Gohlke; Christopher Granade; Craig Gidney; Denis Vasilyev; Dominic Meiser; Drew Parsons; Eric Giguère; Eric Hontz; Felipe Bivort Haiek; Florestan Ziem; Gilbert Shih; Harry Adams; Ivan Carvalho; Jake Lishman; Jevon Longdell; Johannes Feist; Jonas Hoersch; Jonas Neergaard-Nielsen; Jonathan A. Gross; Julian Iacoponi; Kevin Fischer; Laurence Stant; Louis Tessler; Lucas Verney; Marco David; Marek Narozniak; Markus Baden; Martín Sande; Mateo Laguna; Matthew O’Brien; Michael Goerz; Michael V. DePalatis; Moritz Oberhauser; Nathan Shammah; Neill Lambert; Nicolas Quesada; Nikolas Tezak; Nithin Ramu; Paul Nation; Peter Kirton; Philipp Schindler; Piotr Migdal; Rajiv-B; Ray Ganardi; Reinier Heeres; Richard Brierley; Robert Johansson; Sam Griffiths; Samesh Lakhotia; Sebastian Krämer; Shahnawaz Ahmed; Sidhant Saraogi; Simon Cross; Simon Humpohl; Simon Whalen; Stefan Krastanov; Tarun Raheja; Thomas Walker; Viacheslav Ostroukh; Vlad Negnevitsky; Wojciech Rzadkowski; Xiaodong Qi; Xiaoliang Wu; Yariv Yanay; YouWei Zhao; alex; eliegenois; essence-of-waqf; fhenneke; gecrooks; jakobjakobson13; maij; sbisw002; yuri@FreeBSD; Élie Gouzien. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/contributors.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/contributors.html
Availability,avail,available,". Copyright and Licensing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. QuTiP: Quantum Toolbox in Python. »; Copyright and Licensing. Copyright and Licensing¶; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text¶; The canonical form of this license is available at https://creativecommons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived fro",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Deployability,release,release,"IAL,; INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES.; Termination. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License.; Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Energy Efficiency,adapt,adaptation,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Integrability,synchroniz,synchronization,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Modifiability,adapt,adaptation,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Performance,perform,performance,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Safety,avoid,avoidance,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Security,access,access," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Testability,assert,assert,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Usability,clear,clearly,"eans to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing s",MatchSource.WIKI,docs/4.7/copyright-1.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright-1.html
Availability,avail,available,". Copyright and Licensing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. QuTiP: Quantum Toolbox in Python. »; Copyright and Licensing. Copyright and Licensing¶; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; Unless specifically indicated otherwise, all code samples, the source code of QuTiP, and its reproductions in this documentation, are licensed under the terms of the 3-clause BSD license, reproduced below. License Terms for Documentation Text¶; The canonical form of this license is available at https://creativecommons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived fro",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Deployability,release,release,"IAL,; INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS; LICENSE OR THE USE OF THE WORK, EVEN IF LICENSOR HAS BEEN ADVISED OF THE; POSSIBILITY OF SUCH DAMAGES.; Termination. This License and the rights granted hereunder will terminate automatically; upon any breach by You of the terms of this License. Individuals or; entities who have received Adaptations or Collections from You under this; License, however, will not have their licenses terminated provided such; individuals or entities remain in full compliance with those licenses.; Sections 1, 2, 5, 6, 7, and 8 will survive any termination of this; License.; Subject to the above terms and conditions, the license granted here is; perpetual (for the duration of the applicable copyright in the Work).; Notwithstanding the above, Licensor reserves the right to release the Work; under different license terms or to stop distributing the Work at any; time; provided, however that any such election will not serve to withdraw; this License (or any other license that has been, or is required to be,; granted under the terms of this License), and this License will continue; in full force and effect unless terminated as stated above. Miscellaneous. Each time You Distribute or Publicly Perform the Work or a Collection,; the Licensor offers to the recipient a license to the Work on the same; terms and conditions as the license granted to You under this License.; Each time You Distribute or Publicly Perform an Adaptation, Licensor; offers to the recipient a license to the original Work on the same terms; and conditions as the license granted to You under this License.; If any provision of this License is invalid or unenforceable under; applicable law, it shall not affect the validity or enforceability of the; remainder of the terms of this License, and without further action by the; parties to this agreement, such provision shall be reformed to the; minimum extent necessary to make such provision valid and",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Energy Efficiency,adapt,adaptation,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Integrability,synchroniz,synchronization,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Modifiability,adapt,adaptation,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Performance,perform,performance,"mons.org/licenses/by/3.0/, which should be considered the binding version of this license.; It is reproduced here for convenience.; THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CREATIVE COMMONS; PUBLIC LICENSE (“CCPL” OR “LICENSE”). THE WORK IS PROTECTED BY COPYRIGHT AND/OR; OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS; LICENSE OR COPYRIGHT LAW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and indepen",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Safety,avoid,avoidance,"AW IS PROHIBITED.; BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HERE, YOU ACCEPT AND AGREE TO BE; BOUND BY THE TERMS OF THIS LICENSE. TO THE EXTENT THIS LICENSE MAY BE CONSIDERED; TO BE A CONTRACT, THE LICENSOR GRANTS YOU THE RIGHTS CONTAINED HERE IN; CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. Definitions. “Adaptation” means a work based upon the Work, or upon the Work and other; pre-existing works, such as a translation, adaptation, derivative work,; arrangement of music or other alterations of a literary or artistic work,; or phonogram or performance and includes cinematographic adaptations or; any other form in which the Work may be recast, transformed, or adapted; including in any form recognizably derived from the original, except that; a work that constitutes a Collection will not be considered an Adaptation; for the purpose of this License. For the avoidance of doubt, where the; Work is a musical work, performance or phonogram, the synchronization of; the Work in timed-relation with a moving image (“synching”) will be; considered an Adaptation for the purpose of this License.; “Collection” means a collection of literary or artistic works, such as; encyclopedias and anthologies, or performances, phonograms or broadcasts,; or other works or subject matter other than works listed in Section 1(f); below, which, by reason of the selection and arrangement of their; contents, constitute intellectual creations, in which the Work is; included in its entirety in unmodified form along with one or more other; contributions, each constituting separate and independent works in; themselves, which together are assembled into a collective whole. A work; that constitutes a Collection will not be considered an Adaptation (as; defined above) for the purposes of this License.; “Distribute” means to make available to the public the original and; copies of the Work or Adaptation, as appropriate, through sale or other; transfer of ownership.; “Licensor” means th",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Security,access,access," a work of applied art; an illustration, map, plan, sketch or; three-dimensional work relative to geography, topography, architecture or; science; a performance; a broadcast; a phonogram; a compilation of data; to the extent it is protected as a copyrightable work; or a work; performed by a variety or circus performer to the extent it is not; otherwise considered a literary or artistic work.; “You” means an individual or entity exercising rights under this License; who has not previously violated the terms of this License with respect to; the Work, or who has received express permission from the Licensor to; exercise rights under this License despite a previous violation.; “Publicly Perform” means to perform public recitations of the Work and to; communicate to the public those public recitations, by any means or; process, including by wire or wireless means or public digital; performances; to make available to the public Works in such a way that; members of the public may access these Works from a place and at a place; individually chosen by them; to perform the Work to the public by any; means or process and the communication to the public of the performances; of the Work, including by public digital performance; to broadcast and; rebroadcast the Work by any means including signs, sounds or images.; “Reproduce” means to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, ",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Testability,assert,assert,"uch URI does not refer to the copyright notice or; licensing information for the Work; and (iv) , consistent with Section; 3(b), in the case of an Adaptation, a credit identifying the use of the; Work in the Adaptation (e.g., “French translation of the Work by Original; Author,” or “Screenplay based on original Work by Original Author”). The; credit required by this Section 4 (b) may be implemented in any; reasonable manner; provided, however, that in the case of a Adaptation or; Collection, at a minimum such credit will appear, if a credit for all; contributing authors of the Adaptation or Collection appears, then as; part of these credits and in a manner at least as prominent as the; credits for the other contributing authors. For the avoidance of doubt,; You may only use the credit required by this Section for the purpose of; attribution in the manner set out above and, by exercising Your rights; under this License, You may not implicitly or explicitly assert or imply; any connection with, sponsorship or endorsement by the Original Author,; Licensor and/or Attribution Parties, as appropriate, of You or Your use; of the Work, without the separate, express prior written permission of; the Original Author, Licensor and/or Attribution Parties.; Except as otherwise agreed in writing by the Licensor or as may be; otherwise permitted by applicable law, if You Reproduce, Distribute or; Publicly Perform the Work either by itself or as part of any Adaptations; or Collections, You must not distort, mutilate, modify or take other; derogatory action in relation to the Work which would be prejudicial to; the Original Author’s honor or reputation. Licensor agrees that in those; jurisdictions (e.g. Japan), in which any exercise of the right granted in; Section 3(b) of this License (the right to make Adaptations) would be; deemed to be a distortion, mutilation, modification or other derogatory; action prejudicial to the Original Author’s honor and reputation, the; Licensor will w",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Usability,clear,clearly,"eans to make copies of the Work by any means including; without limitation by sound or visual recordings and the right of; fixation and reproducing fixations of the Work, including storage of a; protected performance or phonogram in digital form or other electronic; medium. Fair Dealing Rights. Nothing in this License is intended to reduce, limit, or; restrict any uses free from copyright or rights arising from limitations or; exceptions that are provided for in connection with the copyright protection; under copyright law or other applicable laws.; License Grant. Subject to the terms and conditions of this License, Licensor; hereby grants You a worldwide, royalty-free, non-exclusive, perpetual (for; the duration of the applicable copyright) license to exercise the rights in; the Work as stated below:. to Reproduce the Work, to incorporate the Work into one or more; Collections, and to Reproduce the Work as incorporated in the; Collections;; to create and Reproduce Adaptations provided that any such Adaptation,; including any translation in any medium, takes reasonable steps to; clearly label, demarcate or otherwise identify that changes were made to; the original Work. For example, a translation could be marked “The; original work was translated from English to Spanish,” or a modification; could indicate “The original work has been modified.”;; to Distribute and Publicly Perform the Work including as incorporated in; Collections; and,; to Distribute and Publicly Perform Adaptations. For the avoidance of doubt:. Non-waivable Compulsory License Schemes. In those jurisdictions in; which the right to collect royalties through any statutory or; compulsory licensing scheme cannot be waived, the Licensor reserves; the exclusive right to collect such royalties for any exercise by You; of the rights granted under this License;; Waivable Compulsory License Schemes. In those jurisdictions in which; the right to collect royalties through any statutory or compulsory; licensing s",MatchSource.WIKI,docs/4.7/copyright.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/copyright.html
Availability,avail,available,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Deployability,release,release,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Energy Efficiency,efficient,efficiently,"ystem encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to re",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Integrability,depend,dependence,"tor and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a computer algebra package for quantum mechanics and photonic quantum networks. Libraries Using QuTiP¶; Several libraries rely on QuTiP for quantum physics or quantum informat",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Modifiability,coupling,coupling,"nd the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as qua",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Performance,perform,performed,"This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quantum system. For although much care is taken experimentally to eliminate the unwanted influence of external interactions, there remains, if ever so slight, a coupling between the system of interest and the external world. In addition, any measurement performed on the system necessarily involves coupling to the measuring device, therefore introducing an additional source of external influence. Consequently, developing the necessary tools, both theoretical and numerical, to account for the interactions between a system and its environment is an essential step in understanding the dynamics of practical quantum systems.; In general, for all but the most basic of Hamiltonians, an analytical description of the system dynamics is not possible, and one must resort to numerical simulations of the equations of motion. In absence of a quantum computer, these simulations must be carried out using classical computing techniques, where the exponentially increasing dimensionality of the underlying Hilbert space severely limits the size of system that can be efficiently simulated. However, in many fields such as quantum optics, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin co",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Testability,test,tested,"cs, trapped ions, superconducting circuit devices, and most recently nanomechanical systems, it is possible to design systems using a small number of effective oscillator and spin components, excited by a limited number of quanta, that are amenable to classical simulation in a truncated Hilbert space.; The Quantum Toolbox in Python, or QuTiP, is an open-source framework written in the Python programming language, designed for simulating the open quantum dynamics of systems such as those listed above. This framework distinguishes itself from other available software solutions in providing the following advantages:. QuTiP relies entirely on open-source software. You are free to modify and use it as you wish with no licensing fees or limitations.; QuTiP is based on the Python scripting language, providing easy to read, fast code generation without the need to compile after modification.; The numerics underlying QuTiP are time-tested algorithms that run at C-code speeds, thanks to the Numpy, Scipy, and Cython libraries, and are based on many of the same algorithms used in propriety software.; QuTiP allows for solving the dynamics of Hamiltonians with (almost) arbitrary time-dependence, including collapse operators.; Time-dependent problems can be automatically compiled into C++-code at run-time for increased performance.; Takes advantage of the multiple processing cores found in essentially all modern computers.; QuTiP was designed from the start to require a minimal learning curve for those users who have experience using the popular quantum optics toolbox by Sze M. Tan.; Includes the ability to create high-quality plots, and animations, using the excellent Matplotlib package. For detailed information about new features of each release of QuTiP, see the Change Log. QuTiP Plugins¶; Several libraries depend on QuTiP heavily making QuTiP a super-library. Matsubara; Matsubara is a plugin to study the ultrastrong coupling regime with structured baths. QNET; QNET is a comput",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Usability,guid,guide,"﻿. Frontmatter — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; QuTiP Plugins; Libraries Using QuTiP; Contributing to QuTiP. Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Frontmatter. Frontmatter¶. About This Documentation¶; This document contains a user guide and automatically generated API documentation for QuTiP. A PDF version of this text is available at the documentation page.; For more information see the QuTiP project web page. Author; J.R. Johansson. Author; P.D. Nation. Author; Alexander Pitchford. Author; Arne Grimsmo. Author; Chris Grenade. Author; Nathan Shammah. Author; Shahnawaz Ahmed. Author; Neill Lambert. Author; Eric Giguere. Author; Boxi Li. Author; Jake Lishman. Author; Simon Cross. release; 4.7.5. copyright; The text of this documentation is licensed under the Creative Commons Attribution 3.0 Unported License.; All contained code samples, and the source code of QuTiP, are licensed under the 3-clause BSD licence.; Full details of the copyright notices can be found on the Copyright and Licensing page of this documentation. Citing This Project¶; If you find this project useful, then please cite:. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP 2: A Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 184, 1234 (2013).or. J. R. Johansson, P.D. Nation, and F. Nori, “QuTiP: An open-source Python framework for the dynamics of open quantum systems”, Comp. Phys. Comm. 183, 1760 (2012).which may also be downloaded from https://arxiv.org/abs/1211.6518 or https://arxiv.org/abs/1110.0573, respectively. Funding¶; QuTiP is developed under the auspice of the non-profit organizations:. QuTiP was partially supported by. About QuTiP¶; Every quantum system encountered in the real world is an open quan",MatchSource.WIKI,docs/4.7/frontmatter.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/frontmatter.html
Deployability,update,update,ule qutip.superop_reps). to_choi() (in module qutip.superop_reps). to_kraus() (in module qutip.superop_reps). to_list() (QobjEvo method). to_stinespring() (in module qutip.superop_reps). to_super() (in module qutip.superop_reps). toffoli() (in module qutip.qip.operations.gates). tr() (Qobj method). tracedist() (in module qutip.metrics). trans() (Qobj method). (QobjEvo method). transform() (Qobj method). triplet_states() (in module qutip.states). trunc_neg() (Qobj method). TSlotCompUpdateAll (class in qutip.control.tslotcomp). ttmsolve() (in module qutip.nonmarkov.transfertensor). TTMSolverOptions (class in qutip.nonmarkov.transfertensor). tunneling() (in module qutip.operators). TwoModeQuadratureCorrelation (class in qutip.distributions). types (BathExponent attribute). U. UnderDampedBath (class in qutip.nonmarkov.heom). unflatten() (in module qutip.dimensions). unit() (Qobj method). unitarity() (in module qutip.metrics). unitarity_check() (Dynamics method). update() (HarmonicOscillatorProbabilityFunction method). (HarmonicOscillatorWaveFunction method). (TwoModeQuadratureCorrelation method). update_ctrl_amps() (Dynamics method). update_fid_err_log() (OptimDump method). update_grad_log() (OptimDump method). update_grad_norm_log() (OptimDump method). update_psi() (TwoModeQuadratureCorrelation method). update_rho() (TwoModeQuadratureCorrelation method). V. value() (eseries method). variance() (in module qutip.expect). vector_mutation (Bloch attribute). vector_style (Bloch attribute). vector_to_operator() (in module qutip.superoperator). vector_width (Bloch attribute). version_table() (in module qutip.ipynbtools). visualize() (Distribution method). W. w_state() (in module qutip.states). weighted_bipartite_matching() (in module qutip.graph). wigner() (in module qutip.wigner). wigner_cmap() (in module qutip.matplotlib_utilities). wigner_covariance_matrix() (in module qutip.continuous_variables). WignerDistribution (class in qutip.distributions). winding_number() (Lattice1,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
Energy Efficiency,charge,charge,_state() (in module qutip.states). berkeley() (in module qutip.qip.operations.gates). berry_curvature() (in module qutip.topology). Bloch (class in qutip.bloch). Bloch3d (class in qutip.bloch3d). bloch_redfield_solve() (in module qutip.bloch_redfield). bloch_redfield_tensor() (in module qutip.bloch_redfield). bloch_wave_functions() (Lattice1d method). block_matrix() (in module qutip.piqs). BosonicBath (class in qutip.nonmarkov.heom). bra() (in module qutip.states). breadth_first_search() (in module qutip.graph). brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (Bloch3d method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
Modifiability,config,configure,erty). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase() (in module qutip.qip.operations.gates). c,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
Performance,concurren,concurrence,y). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). compile() (CavityQEDCompiler method). (GateCompiler method). (QobjEvo method). (SpinChainCompiler method). complex_phase_cmap() (in module qutip.matplotlib_utilities). composite() (in module qutip.tensor). compress() (QobjEvo method). compute_evolution() (Dynamics method). compute_fid_err_grad() (FidCompTraceDiff method). (FidCompTraceDiffApprox method). compute_fid_grad() (FidCompUnitary method). concurrence() (in module qutip.entropy). configure() (HEOMSolver method). (HSolverDL method). conj() (Qobj method). (QobjEvo method). ControlAmpNoise (class in qutip.qip.noise). controlled_gate() (in module qutip.qip.operations.gates). convert_unit() (in module qutip.utilities). copy() (Qobj method). (QobjEvo method). correlation() (in module qutip.correlation). correlation_2op_1t() (in module qutip.correlation). correlation_2op_2t() (in module qutip.correlation). correlation_3op_1t() (in module qutip.correlation). correlation_3op_2t() (in module qutip.correlation). correlation_4op_1t() (in module qutip.correlation). correlation_4op_2t() (in module qutip.correlation). correlation_matrix() (in module qutip.continuous_variables). correlation_matrix_field() (in module qutip.continuous_variables). correlation_matrix_quadrature() (in module qutip.continuous_variables). correlation_ss() (in module qutip.correlation). cosm() (Qobj method). covariance_matrix() (in module qutip.continuous_variables). cphase(),MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
Usability,clear,clear,brmesolve() (in module qutip.bloch_redfield). build_preconditioner() (in module qutip.steadystate). bulk_Hamiltonians() (Lattice1d method). bures_angle() (in module qutip.metrics). bures_dist() (in module qutip.metrics). C. c_ops() (Dicke method). calculate() (Stats method). calculate_j_m() (Pim method). calculate_k() (Pim method). CavityQEDCompiler (class in qutip.qip.compiler). cell_periodic_parts() (Lattice1d method). cell_structures() (in module qutip.lattice). charge() (in module qutip.operators). check_herm() (Qobj method). check_isunitary() (Qobj method). check_unitarity() (DynamicsUnitary method). chi_to_choi() (in module qutip.superop_reps). choi_to_chi() (in module qutip.superop_reps). choi_to_kraus() (in module qutip.superop_reps). choi_to_super() (in module qutip.superop_reps). circuit_to_qasm_str() (in module qutip.qip.qasm). CircuitResult (class in qutip.qip.circuit). CircuitSimulator (class in qutip.qip.circuit). CircularSpinChain (class in qutip.qip.device). clear() (Bloch method). (Bloch3d method). (FidCompUnitary method). (FidelityComputer method). (Stats method). clebsch() (in module qutip.utilities). cnot() (in module qutip.qip.operations.gates). coeff() (Pulse property). coefficient_matrix() (Dicke method). (Pim method). coeffs() (CircularSpinChain property). (DispersiveCavityQED property). (LinearSpinChain property). (ModelProcessor property). (OptPulseProcessor property). (Processor property). (SpinChain property). coherence_function_g1() (in module qutip.correlation). coherence_function_g2() (in module qutip.correlation). coherent() (in module qutip.states). coherent_dm() (in module qutip.states). collapse_dims_oper() (in module qutip.dimensions). collapse_dims_super() (in module qutip.dimensions). collapse_uncoupled() (in module qutip.piqs). combine() (BosonicBath class method). combine_dyn_gen() (Dynamics method). commutation_rules() (Scheduler method). commutator() (in module qutip.operators). compare_amps() (TSlotCompUpdateAll method). co,MatchSource.WIKI,docs/4.7/genindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/genindex.html
Deployability,release,release,"r Changes; Improvements; Bug Fixes; Documentation Improvements; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Improvements; Bug Fixes; Developer Changes; Improvements; Bug Fixes; Deprecations; Developer Changes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Improvements; Bug Fixes; Bug Fixes; Improvements; Bug Fixes; New Features; Improvements; Bug Fixes; New Features; Bug Fixes; Bug Fixes; New Features; Improvements; New Features; Bug Fixes; New Features; Bug Fixes; New Features; Bug Fixes; New Functions; Bug Fixes; Bug Fixes; New Functions; Bug Fixes; New Functions; Bug Fixes. Developers; Lead Developers; Past Lead Developers; Contributors. Development Documentation; Contributing to QuTiP Development; Quick Start; Core Library: qutip/qutip; Documentation: qutip/qutip (doc directory). QuTiP Development Roadmap; Preamble; Library package structure; Development Projects; Completed Development Projects; QuTiP major release roadmap. Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Directives. Release and Distribution; Preamble; Setting Up The Release Branch; Build Release Distribution and Deploy; Getting the Built Documentation; Making a Release on GitHub; Website; Conda Forge. Bibliography; Copyright and Licensing; License Terms for Documentation Text; License Terms for Source Code of QuTiP and Code Samples. Indices and tables¶. Index; Module Index; Search Page. Next . © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
Integrability,depend,dependent,"a; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis pro",MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
Performance,load,loading,nic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; Quantum Information Processing. API documentation; Classes; Qobj; QobjEvo; eseries; Bloch sphere; Distributions; Cubic Spline; Non-Markovian Solvers; Solver Options and Results; Permutational Invariance; One-Dimensional Lattice; Distribution functions; Quantum information processing; Optimal control. Functions; Manipulation and Creation of States and ,MatchSource.WIKI,docs/4.7/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/index.html
Availability,avail,available,"nal packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manually, but it is recommended to keep defaults as the highest priority. New conda environments¶; The default Anaconda environment has all the Python packages needed for running QuTiP installed already, so you will only need to add the conda-forge channel and then install the package.; If you have only installed Miniconda, or you want a completely clean virtual environment to install QuTiP in, the conda package manager provides a convenient way ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Deployability,install,install,"﻿. Installation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence.",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Integrability,depend,dependencies,"ox in Python; . ; . 4.7; . Frontmatter; Installation; Quick Start; General Requirements; Installing with conda; Adding the conda-forge channel; New conda environments. Installing from Source; PEP 517 Source Builds; Direct Setuptools Source Builds. Installation on Windows; Verifying the Installation; Checking Version Information. Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Installation. Installation¶. Quick Start¶; From QuTiP version 4.6 onwards, you should be able to get a working version of QuTiP with the standard; pip install qutip. It is not recommended to install any packages directly into the system Python environment; consider using pip or conda virtual environments to keep your operating system space clean, and to have more control over Python and other package versions.; You do not need to worry about the details on the rest of this page unless this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test sui",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Modifiability,enhance,enhanced,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Performance,load,load,"ilds¶; This is the method to have the greatest amount of control over the installation, but it the most error-prone and not recommended unless you know what you are doing.; You first need to have all the runtime dependencies installed.; The most up-to-date requirements will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a pe",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Safety,detect,detect,"29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while using conda, but uniformly using conda will make complete dependency management easier.; If you already have your conda environment set up, and have the conda-forge channel available, then you can install QuTiP using:; conda install qutip. This will install the minimum set of dependences, but none of the optional packages. Adding the conda-forge channel¶; To install QuTiP from conda, you will need to add the conda-forge channel.; The following command adds this channel with lowest priority, so conda will still try and install all other packages normally:; conda config --append channels conda-forge. If you want to change the order of your channels later, you can edit your .condarc (user home folder) file manual",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Testability,test,test,"s this command did not work, but do also read the next section for the list of optional dependencies.; The rest of this page covers installation directly from conda, installation from source, and additional considerations when working on Windows. General Requirements¶; QuTiP depends on several open-source libraries for scientific computing in the Python programming language.; The following packages are currently required:. Package; Version; Details. Python; 3.6+. NumPy; 1.16+. SciPy; 1.0+; Lower versions may have missing features. In addition, there are several optional packages that provide additional functionality:. Package; Version; Details. matplotlib; 1.2.1+; Needed for all visualisation tasks. cython; 0.29.20+; Needed for compiling some time-dependent; Hamiltonians. cvxpy; 1.0+; Needed to calculate diamond norms. C++; Compiler; GCC 4.7+,; MS VS 2015; Needed for compiling Cython files, made when; using string-format time-dependence. pytest,; pytest-rerunfailures; 5.3+; For running the test suite. LaTeX; TeXLive 2009+; Needed if using LaTeX in matplotlib figures, or for; nice circuit drawings in IPython. In addition, there are several additional packages that are not dependencies, but may give you a better programming experience.; IPython provides an improved text-based Python interpreter that is far more full-featured that the default interpreter, and runs in a terminal.; If you prefer a more graphical set-up, Jupyter provides a notebook-style interface to mix code and mathematical notes together.; Alternatively, Spyder is a free integrated development environment for Python, with several nice features for debugging code.; QuTiP will detect if it is being used within one of these richer environments, and various outputs will have enhanced formatting. Installing with conda¶; QuTiP is designed to work best when using the Anaconda or Intel Python distributions that support the conda package management system.; It is still possible to use pip to install QuTiP while ",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Usability,guid,guides,"ts will be listed in pyproject.toml file, in the build-system.requires key.; As of the 4.6.0 release, the build requirements can be installed with; pip install setuptools wheel packaging 'cython>=0.29.20' 'numpy>=1.16.6,<1.20' 'scipy>=1.0'. or similar with conda if you prefer.; You will also need to have a functional C++ compiler installed on your system.; This is likely already done for you if you are on Linux or macOS, but see the section on Windows installations if that is your operating system.; To install QuTiP from the source code run:; python setup.py install. To install OpenMP support, if available, run:; python setup.py install --with-openmp. This will attempt to load up OpenMP libraries during the compilation process, which depends on you having suitable C++ compiler and library support.; If you are on Linux this is probably already done, but the compiler macOS ships with does not have OpenMP support.; You will likely need to refer to external operating-system-specific guides for more detail here, as it may be very non-trivial to correctly configure.; If you wish to contribute to the QuTiP project, then you will want to create your own fork of the QuTiP git repository, clone this to a local folder, and install it into your Python environment using:; python setup.py develop. When you do import qutip in this environment, you will then load the code from your local fork, enabling you to edit the Python files and have the changes immediately available when you restart your Python interpreter, without needing to rebuild the package.; Note that if you change any Cython files, you will need to rerun the build command.; You should not need to use sudo (or other superuser privileges) to install into a personal virtual environment; if it feels like you need it, there is a good chance that you are installing into the system Python environment instead. Installation on Windows¶; As with other operating systems, the easiest method is to use pip install qutip, or use the",MatchSource.WIKI,docs/4.7/installation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/installation.html
Deployability,update,updated,". Python Module Index — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Python Module Index. Python Module Index. q.  . q. qutip.    ; qutip.bloch_redfield.    ; qutip.continuous_variables.    ; qutip.control.pulsegen.    ; qutip.control.pulseoptim.    ; qutip.correlation.    ; qutip.dimensions.    ; qutip.entropy.    ; qutip.essolve.    ; qutip.expect.    ; qutip.fileio.    ; qutip.floquet.    ; qutip.graph.    ; qutip.ipynbtools.    ; qutip.krylovsolve.    ; qutip.lattice.    ; qutip.matplotlib_utilities.    ; qutip.mcsolve.    ; qutip.measurement.    ; qutip.mesolve.    ; qutip.metrics.    ; qutip.nonmarkov.transfertensor.    ; qutip.operators.    ; qutip.orbital.    ; qutip.parallel.    ; qutip.partial_transpose.    ; qutip.piqs.    ; qutip.propagator.    ; qutip.qip.algorithms.qft.    ; qutip.qip.operations.gates.    ; qutip.qip.qasm.    ; qutip.qip.qubits.    ; qutip.qobj.    ; qutip.random_objects.    ; qutip.rhs_generate.    ; qutip.scattering.    ; qutip.semidefinite.    ; qutip.sesolve.    ; qutip.states.    ; qutip.steadystate.    ; qutip.stochastic.    ; qutip.superop_reps.    ; qutip.superoperator.    ; qutip.tensor.    ; qutip.three_level_atom.    ; qutip.tomography.    ; qutip.topology.    ; qutip.utilities.    ; qutip.visualization.    ; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/py-modindex.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/py-modindex.html
Deployability,update,updated,". Search — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Search. Please activate JavaScript to enable the search functionality.; . © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/search.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/search.html
Deployability,install,installation,". API documentation — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Ten",MatchSource.WIKI,docs/3.0.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/apidoc.html
Integrability,depend,dependent,"Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/apidoc.html
Availability,toler,tolerance,"a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Deployability,install,installation,". Classes — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. « API documentatio... Functions ». Classes¶. Qobj¶. class Qobj(inpt=None, dims=, [[][]]shape=, []type=None, isherm=None, fast=False, superrep=None)¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-number), as well as a collection of common; operator/state operati",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Energy Efficiency,reduce,reduced,"ess_bar; qutip.ui.BaseProgressBar; Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=, []xlabels=[])¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : mat",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Integrability,depend,dependent,"of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectiv",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Modifiability,variab,variable,"tcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: List :. Specific qubits for applying gates. arg_value: Float :. Argument value(phi). arg_label: String :. Label for gate representation. add_circuit(qc, start=0)¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc: QubitCircuit :. The circuit block to be added to the main circuit. start: Integer :. The qubit on which the first gate is applied. add_gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Adds a gate with specified parameters to the circuit. Parameters:name: String :. Gate name. targets: List :. Gate targets. controls: List :. Gate controls. arg_value: Float :. Argument value(phi). arg_label: String :. Label f",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Performance,perform,performing,"; str; Representation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. ",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Usability,simpl,simple,"ha; float {0.1}; Sets transparency of Bloch sphere frame. frame_color; str {‘gray’}; Color of sphere wireframe. frame_width; int {1}; Width of wireframe. point_color; list {[“b”,”r”,”g”,”#CC6600”]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (‘b’). point_marker; list {[“o”,”s”,”d”,”^”]}; List of point marker shapes to cycle through. point_size; list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alpha; float {0.2}; Transparency of Bloch sphere itself. sphere_color; str {‘#FFDDDD’}; Color of Bloch sphere. figsize; list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_color; list {[“g”,”#CC6600”,”b”,”r”]}; List of vector colors to cycle through. vector_width; int {5}; Width of displayed vectors. vector_style; str {‘-|>’, ‘simple’, ‘fancy’, ‘’}; Vector arrowhead style (from matplotlib’s arrow style). vector_mutation; int {20}; Width of vectors arrowhead. view; list {[-60,30]}; Azimuthal and Elevation viewing angles. xlabel; list {[“$x$”,”“]}; List of strings corresponding to +x and -x axes labels, respectively. xlpos; list {[1.1,-1.1]}; Positions of +x and -x labels respectively. ylabel; list {[“$y$”,”“]}; List of strings corresponding to +y and -y axes labels, respectively. ylpos; list {[1.2,-1.2]}; Positions of +y and -y labels respectively. zlabel; list {[r’$left|0right>$’,r’$left|1right>$’]}; List of strings corresponding to +z and -z axes labels, respectively. zlpos; list {[1.2,-1.2]}; Positions of +z and -z labels respectively. Methods. add_annotation(state_or_vector, text, **kwargs)¶; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters:state_or_vector : Qobj/array/list/tuple. Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/unicode. Annot",MatchSource.WIKI,docs/3.0.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/classes.html
Availability,error,error," Returns:oper : qutip.qobj.Qobj. Squeezing operator. phase(N, phi0=0)¶; Single-mode Pegg-Barnett phase operator. Parameters:N : int. Number of basis states in Hilbert space. phi0 : float. Reference phase. Returns:oper : qobj. Phase operator with respect to reference phase. Notes; The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Deployability,install,installation,". Functions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Sch",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Energy Efficiency,power,power,". List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Integrability,depend,dependent,"ettings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. « Classes. Change Log ». Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Modifiability,config,configuration,"eters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix repr",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Performance,concurren,concurrence," : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual i",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Safety,avoid,avoids," \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj :. Superoperator formed from input quantum object. lindblad_dissipator(a, b=None, data_only=False)¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters:a : qobj. Left part of collapse operator. b : qobj (optiona",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Security,access,access,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options: ‘pairs’ - typical coordinates, ‘pairs_skewed’ - for; ferromagnetic/antriferromagnetic plots, ‘before_after’ - related to; Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles. Option; ‘grid_iteration’ sets the same number of particles as for; grid_iteration. Option ‘all’ makes label for all particles. Typically; it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Testability,log,logarithm,"ho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Para",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Usability,simpl,simply,"<qutip.solver.Options instance at 0x2ac685b5cd88>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix. calc_entropy : boolean. If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns:results : Result. Object storing all results from simulation. Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or ",MatchSource.WIKI,docs/3.0.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/apidoc/functions.html
Availability,avail,available," Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Deployability,install,installation,". Basic Operations on Quantum Objects — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Integrability,message,message,"f a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Modifiability,variab,variables,"ction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank `Qobj` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Performance,load,load," and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Security,access,accessed,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Testability,log,logic,"ns on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> q * x; TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Exponential; Q.expm(); Matrix exponential of operator. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matrix Element; Q.matrix_element(bra,ket); Matrix element <bra|Q|ket>. Norm; Q.norm(); Returns L2 norm for states,; trace norm for operators. Partial Trace; Q.ptrace(sel); Partial trace returning components; selected using ‘sel’ parameter. Permute; Q.permu",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Usability,clear,clear," objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 2.]; [ 3.]; [ 4.]; [ 5.]]. In [5]: x = array([[1, 2, 3, 4, 5]]). In [6]: Qobj(x); Out[6]: ; Quantum object: dims = [[1], [5]], shape = [1, 5], type = bra; Qobj data =; [[ 1. 2. 3. 4. 5.]]. In [7]: r = np.random.rand(4, 4). In [8]: Qobj(r); Out[8]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0.2809971 0.97255146 0.71730328 0.00521497]; [ 0.21618564 0.59474207 0.0897929 0.67690883]; [ 0.64495791 0.98742768 0.2892686 0.29891427]; [ 0.19186651 0.4029137 0.22928811 0.10506436]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m) / fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alph",MatchSource.WIKI,docs/3.0.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-basics.html
Availability,down,down," [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [40]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [41]: zp=zeros(20). In [42]: pnts=[xp,yp,zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz=zeros(20). In [46]: yz=[sin(th) for th in linspace(0,pi,20)]. In [47]: zz=[cos(th) for th in linspace(0,pi,20)]. In [48]: b.add_points([xz,yz,zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Deployability,install,installation,". Plotting on the Bloch Sphere — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Modifiability,evolve,evolve,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly sim",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Performance,load,load,"Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multipl",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Security,access,accessed," ‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the ",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Usability,simpl,simply,"ctly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/3.0.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-bloch.html
Availability,avail,available,"= {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\end{split}\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is show in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a ",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
Deployability,install,installation,"﻿. Two-time correlation functions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is t",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
Energy Efficiency,power,power,"orrelation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
Modifiability,evolve,evolved,"um States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
Performance,perform,performs,"leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to mak",MatchSource.WIKI,docs/3.0.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-correlation.html
Deployability,install,installation,". Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-d",MatchSource.WIKI,docs/3.0.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html
Integrability,depend,dependent," Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-dynamics.html
Deployability,install,installation,". An Overview of the Eseries Class — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that t",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
Integrability,depend,dependent,"; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an in",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
Modifiability,parameteriz,parameterized,"TiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
Performance,perform,performed,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
Usability,simpl,simply,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [6]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [7]: es2; Out[7]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we c",MatchSource.WIKI,docs/3.0.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-eseries.html
Availability,avail,available,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
Deployability,install,installation,"﻿. Guide Overview — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
Security,access,accessible,"em Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
Usability,guid,guide," and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, ",MatchSource.WIKI,docs/3.0.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-overview.html
Availability,avail,available,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
Deployability,install,installation,". Running Problems in Parallel — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in par",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
Energy Efficiency,power,powerful,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
Modifiability,variab,variables," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
Performance,perform,performing,"tes & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). I",MatchSource.WIKI,docs/3.0.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-parfor.html
Deployability,install,installation,". Generating Random Quantum States & Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a si",MatchSource.WIKI,docs/3.0.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-random.html
Testability,test,testing,"ion and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [2]: rand_ket(5); Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.62994785+0.1389789j ]; [-0.43288801+0.01284981j]; [-0.22400352-0.20321684j]; [-0.47922421-0.22806793j]; [-0.11912553-0.09464168j]]. or; In [3]: rand_herm(5); Out[3]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.58420310+0.j -0.43073690+0.2344248j 0.00000000+0.j; -0.27393962+0.12764388j -0.48896580+0.09691766j]; [-0.43",MatchSource.WIKI,docs/3.0.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-random.html
Deployability,install,installation,". Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated v",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
Performance,load,loading,"ide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
Usability,simpl,simple,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345018. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, ",MatchSource.WIKI,docs/3.0.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-saving.html
Availability,toler,tolerance,".0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
Deployability,install,installation,". Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
Performance,load,loaded,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
Safety,detect,detect,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
Usability,simpl,simple," Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup ",MatchSource.WIKI,docs/3.0.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-settings.html
Availability,down,down,"[[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; Out[53]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [54]: spin2 = basis(2, 1). In [55]: spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [56]: sigmaz() * spin2; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathr",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Deployability,install,installation,"﻿. Manipulating States and Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations o",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Energy Efficiency,energy,energy,"delity(x, x); Out[39]: 1.000000024796918. In [40]: tracedist(y, y); Out[40]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [41]: tracedist(y, x); Out[41]: 0.9771565834831235. In [42]: sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.97715657031452496. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.7782890495537043. In [44]: tracedist(x, z); Out[44]: 0.8559028328862588. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Integrability,depend,dependence,"]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [8]: c = create(5). In [9]: c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [10]: c * c * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [11]: c ** 2 * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [12]: c * a * vac; Out[12]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [13]: c * a * (c * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [14]: c * a * (c**2 * vac); Out[14]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [15]: c * a * (c**2 ",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Modifiability,extend,extended,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [105]: J = to_choi(S). In [106]: J; Out[106]: ; Quantum object",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Performance,perform,performing,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Security,expose,exposed,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by ",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Usability,guid,guide,"Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0",MatchSource.WIKI,docs/3.0.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-states.html
Availability,down,downside,"Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These featu",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Deployability,install,installation,". Solving for Steady-State Solutions — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathcal{L}\rho_{ss}=0.\]; Although the requirement for time-indepen",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Energy Efficiency,power,power,"olving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.s",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Integrability,rout,routine,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Modifiability,coupling,coupling,"he incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); axhline(y=fexpt, color='r', lw=1.5); ylim([0, 10]); xlabel('Time', fontsize=14); ylabel('Number of excitations', fontsize=14); legend(('Monte-Carlo', 'Master Equation', 'Steady State')); title('Deca",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Performance,perform,perform,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Usability,simpl,simple,"ving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathcal{L}\rho_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES me",MatchSource.WIKI,docs/3.0.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-steady.html
Availability,down,down,"rmed by taking the tensor product of the two single-qubit ground state vectors:; In [2]: tensor(basis(2, 0), basis(2, 0)); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: t",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
Deployability,install,installation,". Using Tensor Products and Partial Traces — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace. « Manipulating Sta... Time Evolution a... ». Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
Energy Efficiency,energy,energy,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; ",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
Modifiability,extend,extended,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
Usability,simpl,simple,"its:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tens",MatchSource.WIKI,docs/3.0.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-tensor.html
Availability,error,errors,"ds[k]]; ....: for k in range(len(lbls_list))])); ....: . In [72]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [73]: ax.view_init(azim=-55, elev=45). In [74]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [75]: rho_ss = steadystate(H, [sqrt(0.1) * a, sqrt(0.4) * b.dag()]). In [76]: fig, ax = hinton(rho_ss) #, xlabels=xlabels, ylabels=xlabels). In [77]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
Deployability,install,installation,". Visualization of quantum states and processes — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected opera",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
Integrability,depend,dependent,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
Performance,perform,perform,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
Security,access,access,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/3.0.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide-visualization.html
Deployability,install,installation,". Users Guide — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
Integrability,depend,dependent,"rsion 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
Performance,load,loading," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 17, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/guide.html
Availability,down,downside,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,". Bloch-Redfield master equation — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example d",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Energy Efficiency,energy,energy,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Integrability,depend,depends,") are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Modifiability,coupling,coupling,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Usability,clear,clear,".3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,". Dynamics Simulation Results — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Result class has been renamed to Result, but fo",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
Performance,load,loaded,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
Security,access,access,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
Usability,simpl,simplified,"ch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Result class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating wh",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-data.html
Deployability,install,installation,"﻿. Floquet Formalism — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independen",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
Energy Efficiency,efficient,efficiently,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
Integrability,depend,dependent,"tting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
Modifiability,coupling,coupling,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-floquet.html
Deployability,install,installation,". Lindblad Master Equation Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. « Dynamics Simulat... Monte Carlo Solv... ». Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\)",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
Energy Efficiency,efficient,efficient,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
Modifiability,evolve,evolves,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code:; >>> H = 2 * pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = linspace(0.0, 10.0, 20.0); >>> result = mesolve(H, psi0, times, [], [sigmaz()]); >>> result; Result object with mesolve data.; ---------------------------------; expect = True; num_expect = 1, num_collapse = 0; >>> result.expect[0]; array([ 1.00000000+0.j, 0.78914229+0.j, 0.24548596+0.j, -0.40169696+0.j,; -0.87947669+0.j, -0.98636356+0.j",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
Performance,perform,perform,"ndblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
Security,access,accessible,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-master.html
Availability,error,errors," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Deployability,install,installation,". Monte Carlo Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of qu",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Energy Efficiency,monitor,monitored,"(July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Integrability,depend,dependent,"(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Modifiability,config,configuration,"ectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Performance,perform,performed,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); # run Monte Carlo solver; data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); plot(times, data.expect[0], times, data.expect[1]); title('Monte Carlo time evolution'); xlabel('Time'); ylabel('Expectation values'); legend((""cavity photon number"", ""atom excitation probability"")); show(). The advantage of the Monte Carlo method over the master equ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Usability,simpl,simply,"r state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-monte.html
Availability,toler,tolerance," Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Performance (QuT... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; >>> options = Options(). the properties and default values of this class can be view via the print function:; >>> print(options); Options properties:; ----------------------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 8; rhs_filename: None; rhs_reuse: False; gui: True; mc_avg: True. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html
Deployability,install,installation,". Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Performance (QuT... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; >>> options = Options(). the properties and default values of this class can be view via the print function:; >>> print(options); Options properties:; ---------------------",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html
Integrability,depend,dependent,"p: 0; tidy: True; num_cpus: 8; rhs_filename: None; rhs_reuse: False; gui: True; mc_avg: True. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; >>> options = Options(); >>> options.num_cpus = 3; >>> options.gui = False; >>> options.atol = 1e-10. or one can use an inline method,; >>> options = Options(num_cpus=3, gui=False, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; >>> print options; Options properties:; ----------------------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tid",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html
Modifiability,variab,variable,"m step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; >>> options = Options(); >>> options.num_cpus = 3; >>> options.gui = False; >>> options.atol = 1e-10. or one can use an inline method,; >>> options = Options(num_cpus=3, gui=False, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; >>> print options; Options properties:; ----------------------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 3; rhs_filename: None; rhs_reuse: False; gui: False; mc_avg: True. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args,; >>> options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args,; >>> options=options). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-options.html
Deployability,install,installation,". Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html
Performance,perform,performance,"tial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hy",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html
Testability,test,test,"ng on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hyperthreading are marginal at best. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Jul 16, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-performance.html
Deployability,install,installation,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed th",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Energy Efficiency,efficient,efficient,"t time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat le",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Integrability,depend,dependent,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.0. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed th",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Modifiability,variab,variable,"Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.0 (July X, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in gener",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Safety,avoid,avoid,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Testability,log,log," with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as th",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Usability,simpl,simply,"eye(3)). # Define collapse operators; c_ops = []; # Cavity decay rate; kappa = 1.5; c_ops.append(sqrt(kappa) * a). # Atomic decay rate; gamma = 6 # decay rate; # Use Rb branching ratio of 5/9 e->u, 4/9 e->g; c_ops.append(sqrt(5*gamma/9) * sigma_ue); c_ops.append(sqrt(4*gamma/9) * sigma_ge). # Define time vector; t = linspace(-15, 15, 100). # Define initial state; psi0 = tensor(basis(N, 0), ustate). # Define states onto which to project; state_GG = tensor(basis(N, 1), ground); sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). # Set up the time varying Hamiltonian; g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do:; def H1_coeff(t, args):; return 9 * exp(-(t / 5.) ** 2). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve):; H = [H0,[H1,H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; >>> output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate:; from qutip import *; kappa = 0.5; def col_coeff(t, arg",MatchSource.WIKI,docs/3.0.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.0/guide/dynamics/dynamics-time.html
Deployability,install,installation,". API documentation — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator ",MatchSource.WIKI,docs/3.0.1/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/apidoc.html
Integrability,depend,dependent,"and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/apidoc.html
Availability,toler,tolerance,"a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array :. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of ",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Deployability,install,installation,". Classes — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Classes; Qobj; eseries; Bloch sphere; Solver Options and Results; Distribution functions; Quantum information processing. « API documentatio... Functions ». Classes¶. Qobj¶. class Qobj(inpt=None, dims=, [[][]]shape=, []type=None, isherm=None, fast=False, superrep=None)¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,-,* between Qobj; instances (and / by a C-numb",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Energy Efficiency,reduce,reduced,"ess_bar; qutip.ui.BaseProgressBar; Optional progress bar class instance. Distribution functions¶. class Distribution(data=None, xvecs=, []xlabels=[])¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal(dim=0)¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,; ax : mat",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Integrability,depend,dependent,"of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. .. note:: :. Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectiv",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Modifiability,variab,variable,"tcomes given a two-mode wavefunction. update_rho(rho)¶; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix. class HarmonicOscillatorWaveFunction(psi=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(psi)¶; Calculate the wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)¶; Methods. update(rho)¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Methods. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String :. Gate name. start: Integer :. Starting location of qubits. end: Integer :. Last qubit for the gate. qubits: List :. Specific qubits for applying gates. arg_value: Float :. Argument value(phi). arg_label: String :. Label for gate representation. add_circuit(qc, start=0)¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc: QubitCircuit :. The circuit block to be added to the main circuit. start: Integer :. The qubit on which the first gate is applied. add_gate(name, targets=None, controls=None, arg_value=None, arg_label=None)¶; Adds a gate with specified parameters to the circuit. Parameters:name: String :. Gate name. targets: List :. Gate targets. controls: List :. Gate controls. arg_value: Float :. Argument value(phi). arg_label: String :. Label f",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Performance,perform,performing,"; str; Representation used if type is ‘super’. One of ‘super’; (Liouville form) or ‘choi’ (Choi matrix with tr = dimension). Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum; object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing; partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool :. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array :. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. ",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Usability,simpl,simple,"ha; float {0.1}; Sets transparency of Bloch sphere frame. frame_color; str {‘gray’}; Color of sphere wireframe. frame_width; int {1}; Width of wireframe. point_color; list {[“b”,”r”,”g”,”#CC6600”]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue (‘b’). point_marker; list {[“o”,”s”,”d”,”^”]}; List of point marker shapes to cycle through. point_size; list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!. sphere_alpha; float {0.2}; Transparency of Bloch sphere itself. sphere_color; str {‘#FFDDDD’}; Color of Bloch sphere. figsize; list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football. vector_color; list {[“g”,”#CC6600”,”b”,”r”]}; List of vector colors to cycle through. vector_width; int {5}; Width of displayed vectors. vector_style; str {‘-|>’, ‘simple’, ‘fancy’, ‘’}; Vector arrowhead style (from matplotlib’s arrow style). vector_mutation; int {20}; Width of vectors arrowhead. view; list {[-60,30]}; Azimuthal and Elevation viewing angles. xlabel; list {[“$x$”,”“]}; List of strings corresponding to +x and -x axes labels, respectively. xlpos; list {[1.1,-1.1]}; Positions of +x and -x labels respectively. ylabel; list {[“$y$”,”“]}; List of strings corresponding to +y and -y axes labels, respectively. ylpos; list {[1.2,-1.2]}; Positions of +y and -y labels respectively. zlabel; list {[r’$left|0right>$’,r’$left|1right>$’]}; List of strings corresponding to +z and -z axes labels, respectively. zlpos; list {[1.2,-1.2]}; Positions of +z and -z labels respectively. Methods. add_annotation(state_or_vector, text, **kwargs)¶; Add a text or LaTeX annotation to Bloch sphere,; parametrized by a qubit state or a vector. Parameters:state_or_vector : Qobj/array/list/tuple. Position for the annotaion.; Qobj of a qubit or a vector of 3 elements. text : str/unicode. Annot",MatchSource.WIKI,docs/3.0.1/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/classes.html
Availability,error,error," Returns:oper : qutip.qobj.Qobj. Squeezing operator. phase(N, phi0=0)¶; Single-mode Pegg-Barnett phase operator. Parameters:N : int. Number of basis states in Hilbert space. phi0 : float. Reference phase. Returns:oper : qobj. Phase operator with respect to reference phase. Notes; The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Deployability,install,installation,". Functions — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Flo",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Energy Efficiency,power,power,". List of system operators that couple to bath degrees of freedom. e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. args : dictionary. Dictionary of parameters for time-dependent Hamiltonians and collapse; operators. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which contains either; a list of expectation values, for operators given in e_ops, or a list; of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, use_secular=True)¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: :class:`qutip.qobj`, list of :class:`qutip.qobj` :. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=, []options=None)¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: :class:`qutip.solver` :. An instance of the class qutip.solver, which",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Integrability,depend,dependent,"sses; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; IPython Notebook Tools; Miscellaneous. « Classes. Change Log ». Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. Notes; A subtle incompatibility ",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Modifiability,config,configuration,"eters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix repr",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Performance,concurren,concurrence," : float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual i",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Safety,avoid,avoids," \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=, []data_only=False)¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj :. Superoperator formed from input quantum object. lindblad_dissipator(a, b=None, data_only=False)¶; Lindblad dissipator (generalized) for a single pair of collapse operators; (a, b), or for a single collapse operator (a) when b is not specified:. \[\mathcal{D}[a,b]\rho = a \rho b^\dagger -; \frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]. Parameters:a : qobj. Left part of collapse operator. b : qobj (optiona",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Security,access,access,"tplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Testability,log,logarithm,"ho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: :class:`qutip.qobj` :. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)¶; Von-Neumann entropy of density matrix. Para",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Usability,simpl,simply,"<qutip.solver.Options instance at 0x2b11f5a5cd40>, sparse_dms=True, serial=False, ptrace_sel=, []calc_entropy=False)¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. list or array of collapse operators. e_ops : array_like. list or array of operators for calculating expectation values. options : Options. Instance of solver options. sparse_dms : boolean. If averaged density matrices are returned, they will be stored as; sparse (Compressed Row Format) matrices during computation if; sparse_dms = True (default), and dense matrices otherwise. Dense; matrices might be preferable for smaller systems. serial : boolean. If True (default is False) the solver will not make use of the; multiprocessing module, and simply run in serial. ptrace_sel: list :. This optional argument specifies a list of components to keep when; returning a partially traced density matrix. This can be convenient for; large systems where memory becomes a problem, but you are only; interested in parts of the density matrix. calc_entropy : boolean. If ptrace_sel is specified, calc_entropy=True will have the solver; return the averaged entropy over trajectories in results.entropy. This; can be interpreted as a measure of entanglement. See Phys. Rev. Lett.; 93, 120408 (2004), Phys. Rev. A 86, 022310 (2012). Returns:results : Result. Object storing all results from simulation. Exponential Series¶. essolve(H, rho0, tlist, c_op_list, e_ops)¶; Evolution of a state vector or density matrix (rho0) for a given; Hamiltonian (H) and set of collapse operators (c_op_list), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (tlist), or ",MatchSource.WIKI,docs/3.0.1/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/apidoc/functions.html
Availability,avail,available,"m States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Deployability,install,installation,". Basic Operations on Quantum Objects — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, w",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Integrability,message,message,"f a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Modifiability,variab,variables,"ction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank `Qobj` object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Performance,load,load,"s in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Important; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Security,access,accessed,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Testability,log,logic,"ns on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; >>> q * x; TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Exponential; Q.expm(); Matrix exponential of operator. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matrix Element; Q.matrix_element(bra,ket); Matrix element <bra|Q|ket>. Norm; Q.norm(); Returns L2 norm for states,; trace norm for operators. Partial Trace; Q.ptrace(sel); Partial trace returning components; selected using ‘sel’ parameter. Permute; Q.permu",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Usability,clear,clear,"ects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([1,2,3,4,5]); Out[4]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 2.]; [ 3.]; [ 4.]; [ 5.]]. In [5]: x = array([[1, 2, 3, 4, 5]]). In [6]: Qobj(x); Out[6]: ; Quantum object: dims = [[1], [5]], shape = [1, 5], type = bra; Qobj data =; [[ 1. 2. 3. 4. 5.]]. In [7]: r = np.random.rand(4, 4). In [8]: Qobj(r); Out[8]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0.53687843 0.03179873 0.29785873 0.04462891]; [ 0.67900829 0.37491091 0.13618856 0.62680971]; [ 0.41240537 0.50347257 0.26573402 0.2244419 ]; [ 0.35279373 0.56183588 0.91221813 0.33800095]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m) / fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alph",MatchSource.WIKI,docs/3.0.1/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-basics.html
Availability,down,down," [37]: b.show(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp=[cos(th) for th in linspace(0,2*pi,20)]. In [40]: yp=[sin(th) for th in linspace(0,2*pi,20)]. In [41]: zp=zeros(20). In [42]: pnts=[xp,yp,zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz=zeros(20). In [46]: yz=[sin(th) for th in linspace(0,pi,20)]. In [47]: zz=[cos(th) for th in linspace(0,pi,20)]. In [48]: b.add_points([xz,yz,zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Deployability,install,installation,". Plotting on the Bloch Sphere — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often conv",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Modifiability,evolve,evolve,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b=Bloch(); b.vector_color = ['r']; b.view=[-40,30]; for i in xrange(len(sx)):; b.clear(); b.add_vectors([sin(theta),0,cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is fairly sim",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Performance,load,load,"Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multipl",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Security,access,accessed," ‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b=Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the ",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Usability,simpl,simply,"ctly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [3]: b=Bloch(). which will load an instance of the qutip.Bloch class, or using:; In [4]: b3d=Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [5]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/3.0.1/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-bloch.html
Availability,avail,available,"= {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\end{split}\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is show in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a ",MatchSource.WIKI,docs/3.0.1/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html
Deployability,install,installation,"﻿. Two-time correlation functions — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)",MatchSource.WIKI,docs/3.0.1/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html
Energy Efficiency,power,power,"orrelation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a",MatchSource.WIKI,docs/3.0.1/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html
Modifiability,evolve,evolved,"g Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,docs/3.0.1/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html
Performance,perform,performs,"leaky cavity with three different relaxation rates.; from qutip import *; from scipy import *. times = linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_ss(H, times, [sqrt(0.5) * a], x, x); corr2 = correlation_ss(H, times, [sqrt(1.0) * a], x, x); corr3 = correlation_ss(H, times, [sqrt(2.0) * a], x, x). from pylab import *; plot(times, real(corr1), times, real(corr2), times, real(corr3)); xlabel(r'Time $t$'); ylabel(r'Correlation $\left<x(t)x(0)\right>$'); show(). (Source code, png, hires.png, pdf). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; from qutip import *; import pylab as plt; from scipy import *; from scipy import *; N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * pi # cavity and atom frequency; g = 0.1 * 2 * pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [sqrt(kappa * (1 + n_th)) * a, sqrt(kappa * n_th) * a.dag(), sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to mak",MatchSource.WIKI,docs/3.0.1/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-correlation.html
Deployability,install,installation,". Time Evolution and Quantum System Dynamics — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-R",MatchSource.WIKI,docs/3.0.1/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-dynamics.html
Integrability,depend,dependent," and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-dynamics.html
Deployability,install,installation,". An Overview of the Eseries Class — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by i",MatchSource.WIKI,docs/3.0.1/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html
Integrability,depend,dependent,"bjects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an in",MatchSource.WIKI,docs/3.0.1/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html
Modifiability,parameteriz,parameterized,"; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/3.0.1/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html
Performance,perform,performed,"0.5+0j). In [15]: es3_expect.value([0.0, pi/2]); Out[15]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [16]: psi0 = basis(2,1). In [17]: H = sigmaz(). In [18]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [19]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [20]: es; Out[20]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,docs/3.0.1/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html
Usability,simpl,simply,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [3]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [4]: omega=1.0. In [5]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [6]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [7]: es2; Out[7]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we c",MatchSource.WIKI,docs/3.0.1/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-eseries.html
Availability,avail,available,"-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html
Deployability,install,installation,"﻿. Guide Overview — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located ",MatchSource.WIKI,docs/3.0.1/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html
Security,access,accessible,"-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html
Usability,guid,guide,"oducts and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples, which can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at after of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, ",MatchSource.WIKI,docs/3.0.1/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-overview.html
Availability,avail,available,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html
Deployability,install,installation,". Running Problems in Parallel — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we c",MatchSource.WIKI,docs/3.0.1/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html
Energy Efficiency,power,powerful,"ns with multiple input arguments and even keyword arguments:; In [16]: def sum_diff(x , y, z=0): return x + y, x - y, z. In [17]: parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5); Out[17]: [array([5, 7, 9]), array([-3, -3, -3]), array([5, 5, 5])]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance.; Parfor is also useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-Based parfor¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parfor. The advantage of this parfor implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Parallel picloud Computations¶. Note; New in QuTiP 3. New to QuTiP version 3 is the option to run computations in parallel on the cloud computing platform provided by PiCloud. You must have their software installed on your machine, and an active account, for this function to work. Note that, at present, the picloud software is only available for Python version 2.7. Using the picloud function is very similar to using parfor, however the picloud function does not accept any keyword arguments:; >>> from qutip.picloud import *; >>> def add(x, y): return x + y; >>> picloud(add, [10, 20, 30], [5, 6, 7]); [15, 26, 37]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html
Modifiability,variab,variables," (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). In [13]: print(a); [0 1 2 3 4]. In [14]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/3.0.1/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html
Performance,perform,performing,"rnal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. « Visualization of... Saving QuTiP Obj... ». Running Problems in Parallel¶. QuTiP’s Built-in Parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parfor (parallel-for-loop) function.; To use the parfor function we need to define a function of one or more variables, and the range over which these variable are to be iterated. For example:; In [2]: def func1(x): return x, x**2, x**3. In [3]: [a,b,c] = parfor(func1, range(10)). In [4]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [5]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [6]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. One can also use a single output variable as:; In [7]: x = parfor(func1, range(10)). In [8]: print(x[0]); [0 1 2 3 4 5 6 7 8 9]. In [9]: print(x[1]); [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(x[2]); [ 0 1 8 27 64 125 216 343 512 729]. The qutip.parfor function is not limited to just numbers, but also works for a variety of outputs:; In [11]: def func2(x): return x, Qobj(x), 'a' * x. In [12]: [a, b, c] = parfor(func2, range(5)). I",MatchSource.WIKI,docs/3.0.1/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-parfor.html
Deployability,install,installation,". Generating Random Quantum States & Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for d",MatchSource.WIKI,docs/3.0.1/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-random.html
Testability,test,testing,"; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [2]: rand_ket(5); Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.39285336+0.27024047j]; [-0.51803588+0.10328369j]; [-0.58850701-0.16960316j]; [-0.20872011+0.08251858j]; [-0.23355115+0.11654335j]]. or; In [3]: rand_herm(5); Out[3]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.78906375+0.j -0.49042711+0.01532022j -0.20366873+0.17308185j; -0.33542127-0.1744431j 0.00000000+0.j ]; [-0.4",MatchSource.WIKI,docs/3.0.1/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-random.html
Deployability,install,installation,". Saving QuTiP Objects and Data Sets — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be expo",MatchSource.WIKI,docs/3.0.1/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html
Performance,load,loading,"ations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Running Problems... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,docs/3.0.1/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html
Usability,simpl,simple,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [2]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [3]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [4]: qsave(rho_ss, 'steadystate'). In [5]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [6]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [7]: a = destroy(10). In [8]: expect(a.dag() * a, rho_ss_loaded); Out[8]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [9]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, ",MatchSource.WIKI,docs/3.0.1/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-saving.html
Availability,toler,tolerance,".0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are describ",MatchSource.WIKI,docs/3.0.1/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html
Deployability,install,installation,". Modifying Internal QuTiP Settings — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity ",MatchSource.WIKI,docs/3.0.1/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html
Performance,load,loaded,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html
Safety,detect,detect,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html
Usability,simpl,simple," Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. qutip_graphics; Use matplotlib; True / False. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup ",MatchSource.WIKI,docs/3.0.1/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-settings.html
Availability,down,down,"[[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [52]: sigmaz(); Out[52]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [53]: sigmaz() * spin; Out[53]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [54]: spin2 = basis(2, 1). In [55]: spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [56]: sigmaz() * spin2; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\mathrm{up}\right>\) state of a two-level spin system while spin2 gives the \(\left|\mathrm{down}\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\mathrm{up}\right>\) state:; In [57]: sigmaz() * spin; Out[57]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\mathrm{down}\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\mathr",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Deployability,install,installation,"﻿. Manipulating States and Operators — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Energy Efficiency,energy,energy,"delity(x, x); Out[39]: 1.000000024796918. In [40]: tracedist(y, y); Out[40]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [41]: tracedist(y, x); Out[41]: 0.9771565834831235. In [42]: sqrt(1 - fidelity(y, x) ** 2); Out[42]: 0.97715657031452496. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [43]: 1 - fidelity(x, z) ** 2; Out[43]: 0.7782890495537043. In [44]: tracedist(x, z); Out[44]: 0.8559028328862588. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [45]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [46]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [47]: vac; Out[47]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [48]: c = create(2). In [49]: c * vac; Out[49]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Integrability,depend,dependence,"]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [8]: c = create(5). In [9]: c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [10]: c * c * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [11]: c ** 2 * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [12]: c * a * vac; Out[12]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [13]: c * a * (c * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [14]: c * a * (c**2 * vac); Out[14]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [15]: c * a * (c**2 ",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Modifiability,extend,extended,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [105]: J = to_choi(S). In [106]: J; Out[106]: ; Quantum object",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Performance,perform,performing,"perators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [6]: a * vac; Out[6]: ; Q",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Security,expose,exposed,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [94]: X = sigmax(). In [95]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [96]: S2 = to_super(X). In [97]: (S - S2).norm(); Out[97]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [98]: S; Out[98]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [99]: S.iscp, S.istp, S.iscptp; Out[99]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [100]: H = 10 * sigmaz(). In [101]: c1 = destroy(2). In [102]: L = liouvillian(H, [c1]). In [103]: L; Out[103]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [104]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by ",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Usability,guid,guide,"quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [2]: vac = basis(5, 0). In [3]: print(vac); Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [4]: a = destroy(5). In [5]: print(a); Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0",MatchSource.WIKI,docs/3.0.1/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-states.html
Availability,down,downside,"Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for symmetric (or Hermitian), positive-definite matrices. Since the Liouvillian has none of these properties, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to be good. QuTiP makes use of an incomplete LU preconditioner is invoked automatically when using the iterative 'GMRES' and 'LGMRES' solvers that uses a combination of symmetric and antisymmetric matrix permutations that attempts to improve the preconditioning process. These featu",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Deployability,install,installation,". Solving for Steady-State Solutions — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathc",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Energy Efficiency,power,power,"olving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.s",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Integrability,rout,routine,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'GMRES' and 'LGMRES' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make thee iterative methods faster than the other solution methods. The problem with precon",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Modifiability,coupling,coupling,"he incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; from qutip import *; from pylab import *; from scipy import *. # Define paramters; N = 20 # number of basis states to consider; a = destroy(N); H = a.dag() * a; psi0 = basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = expect(a.dag() * a, final_state). tlist = linspace(0, 50, 100); # monte-carlo; mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); axhline(y=fexpt, color='r', lw=1.5); ylim([0, 10]); xlabel('Time', fontsize=14); ylabel('Number of excitations', fontsize=14); legend(('Monte-Carlo', 'Master Equation', 'Steady State')); title('Deca",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Performance,perform,perform,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; True, False; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Usability,simpl,simple,"ving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{\partial\rho_{ss}}{\partial t}=\mathcal{L}\rho_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\rho_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find.; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES me",MatchSource.WIKI,docs/3.0.1/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-steady.html
Availability,down,down,"rmed by taking the tensor product of the two single-qubit ground state vectors:; In [2]: tensor(basis(2, 0), basis(2, 0)); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: t",MatchSource.WIKI,docs/3.0.1/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-tensor.html
Deployability,install,installation,". Using Tensor Products and Partial Traces — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace. « Manipulating Sta... Time Evolution a... ». Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space",MatchSource.WIKI,docs/3.0.1/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-tensor.html
Energy Efficiency,energy,energy,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [10]: H; Out[10]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; ",MatchSource.WIKI,docs/3.0.1/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-tensor.html
Modifiability,extend,extended,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [3]: tensor([basis(2, 0), basis(2, 0)]); Out[3]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [4]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[4]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,docs/3.0.1/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-tensor.html
Usability,simpl,simple,"its:; In [5]: tensor(sigmax(), sigmax()); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [6]: tensor(sigmaz(), identity(2)); Out[6]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [7]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [8]: H; Out[8]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [9]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tens",MatchSource.WIKI,docs/3.0.1/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-tensor.html
Availability,error,errors,"ds[k]]; ....: for k in range(len(lbls_list))])); ....: . In [72]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [73]: ax.view_init(azim=-55, elev=45). In [74]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [75]: rho_ss = steadystate(H, [sqrt(0.1) * a, sqrt(0.4) * b.dag()]). In [76]: fig, ax = hinton(rho_ss) #, xlabels=xlabels, ylabels=xlabels). In [77]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,docs/3.0.1/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html
Deployability,install,installation,". Visualization of quantum states and processes — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind mi",MatchSource.WIKI,docs/3.0.1/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html
Integrability,depend,dependent,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [78]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [79]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [80]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [81]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [82]: chi = qpt(U_rho, op_basis). In [83]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [84]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html
Performance,perform,perform,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Running Problems... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/3.0.1/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html
Security,access,access,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/3.0.1/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide-visualization.html
Deployability,install,installation,". Users Guide — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolut",MatchSource.WIKI,docs/3.0.1/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html
Integrability,depend,dependent,"rsion 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel ",MatchSource.WIKI,docs/3.0.1/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html
Performance,load,loading," Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Performance (QuTiP vs. qotoolbox); Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Running Problems in Parallel; QuTiP’s Built-in Parallel for-loop; IPython-Based parfor; Parallel picloud Computations. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/guide.html
Availability,down,downside,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,". Bloch-Redfield master equation — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operato",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Energy Efficiency,energy,energy,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Integrability,depend,depends,") are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Modifiability,coupling,coupling,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Usability,clear,clear,".3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,". Dynamics Simulation Results — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. I",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html
Performance,load,loaded,">> show(). Data for expectation values extracted from the result Result object. State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; >>> qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a ”.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Data for expectation values from the stored_result object loaded from the result object stored with qutip.fileio.qsave. Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html
Security,access,access,"o methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html
Usability,simpl,simplified,"ntum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Result class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating wh",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-data.html
Deployability,install,installation,"﻿. Floquet Formalism — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hami",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html
Energy Efficiency,efficient,efficiently,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html
Integrability,depend,dependent,"alization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Performance (QuT... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html
Modifiability,coupling,coupling,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-floquet.html
Deployability,install,installation,". Lindblad Master Equation Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. « Dynamics Simulat... Monte Carlo Solv... ». Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html
Energy Efficiency,efficient,efficient,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html
Modifiability,evolve,evolves,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code:; >>> H = 2 * pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = linspace(0.0, 10.0, 20.0); >>> result = mesolve(H, psi0, times, [], [sigmaz()]); >>> result; Result object with mesolve data.; ---------------------------------; expect = True; num_expect = 1, num_collapse = 0; >>> result.expect[0]; array([ 1.00000000+0.j, 0.78914229+0.j, 0.24548596+0.j, -0.40169696+0.j,; -0.87947669+0.j, -0.98636356+0.j",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html
Performance,perform,perform,"ndblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html
Security,access,accessible,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-master.html
Availability,error,errors," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Deployability,install,installation,". Monte Carlo Solver — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the envi",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Energy Efficiency,monitor,monitored,"July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Integrability,depend,dependent,"(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)). # run again, reusing data; options = Options(rhs_reuse=True); data2 = mcsolve(H, psi1, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; options=options). # plot both results; plot(times, data1.expect[0], times, data1.expect[1], lw=2); plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); title('Monte Carlo time evolution'); xlabel('Time', fontsize=14); ylabel('Expectation values', fontsize=14); legend((""cavity photon number"", ""atom excitation probability"")); show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has markedly enhanced performance for smaller systems. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstation:; data1 = mcsolve_f90(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations that must be kept in mind. First, this",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Modifiability,config,configuration,"ectation values for 1 trajectory; expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories; expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories; expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; >>> options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a). # first run; data1 = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). # change initial state; psi1 = tensor(fock(2, 0), coherent(10",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Performance,perform,performed,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{n}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve:; from qutip import *; from pylab import *. times = linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2 * pi * a.dag() * a + 2 * pi * sm.dag() * sm + \; 2 * pi * 0.25 * (sm * a.dag() + sm.dag() * a); # run Monte Carlo solver; data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); plot(times, data.expect[0], times, data.expect[1]); title('Monte Carlo time evolution'); xlabel('Time'); ylabel('Expectation values'); legend((""cavity photon number"", ""atom excitation probability"")); show(). The advantage of the Monte Carlo method over the master equ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Usability,simpl,simply,"r state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; >>> data = mcsolve(H, psi0, times, [sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm],; >>> ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; >>> ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-monte.html
Availability,toler,tolerance," Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Performance (QuT... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; >>> options = Options(). the properties and default values of this class can be view via the print function:; >>> print(options); Options properties:; ----------------------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 8; rhs_filename: None; rhs_reuse: False; gui: True; mc_avg: True. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-options.html
Deployability,install,installation,". Setting Options for the Dynamics Solvers — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Performance (QuT... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; >>> options = Options(). the properties and default values of this class can be view via the print function:; ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-options.html
Integrability,depend,dependent,"p: 0; tidy: True; num_cpus: 8; rhs_filename: None; rhs_reuse: False; gui: True; mc_avg: True. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; >>> options = Options(); >>> options.num_cpus = 3; >>> options.gui = False; >>> options.atol = 1e-10. or one can use an inline method,; >>> options = Options(num_cpus=3, gui=False, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; >>> print options; Options properties:; ----------------------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tid",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-options.html
Modifiability,variab,variable,"m step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; >>> options = Options(); >>> options.num_cpus = 3; >>> options.gui = False; >>> options.atol = 1e-10. or one can use an inline method,; >>> options = Options(num_cpus=3, gui=False, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; >>> print options; Options properties:; ----------------------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 3; rhs_filename: None; rhs_reuse: False; gui: False; mc_avg: True. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args,; >>> options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args,; >>> options=options). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-options.html
Deployability,install,installation,". Performance (QuTiP vs. qotoolbox) — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox coun",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html
Performance,perform,performance," Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hy",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html
Testability,test,test,"zation of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Performance (QuTiP vs. qotoolbox). « Floquet Formalis... Setting Options ... ». Performance (QuTiP vs. qotoolbox)¶; Here we compare the performance of the master equation and Monte Carlo solvers to their quantum optics toolbox counterparts.; In this example, we calculate the time evolution of the density matrix for a coupled oscillator system using the qutip.mesolve function, and compare it to the quantum optics toolbox (qotoolbox). Here, we see that the QuTiP solver out performs its qotoolbox counterpart by a substantial margin as the system size increases. To test the Monte Carlo solvers, here we simulate a trilinear Hamiltonian over a range of Hilbert space sizes. Since QuTiP uses multiprocessing, we can measure the performance gain when using several CPU’s. In contrast, the qotoolbox is limited to a single processor only. In the legend, we show the speed-up factor in the parenthesis, which should ideally be equal to the number of processors. Finally, we have included the results using hyperthreading, written here as 4+(x) where x is the number of hyperthreads, found in some newer Intel processors. We see however that the performance benefits from hyperthreading are marginal at best. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Aug 05, 2014.; Created using Sphinx 1.2.2. ",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-performance.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-performance.html
Deployability,install,installation,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Energy Efficiency,efficient,efficient,"t time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat le",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Integrability,depend,dependent,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.0 Documentation. QuTiP; 3.0.1. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.6+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Modifiability,variab,variable,"Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Running Problems in Parallel; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Function Based Hamiltonian; A Quick Comparison of Simulation Times; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in gener",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Safety,avoid,avoid,"table of simulation times for the single-photon example using the different time-dependent formats and both the master equation and Monte Carlo solver. Format; Master Equation; Monte Carlo. Python Function; 2.1 sec; 27 sec. Cython String; 1.4 sec; 9 sec. Hamiltonian Function; 1.0 sec; 238 sec. For the current example, the table indicates that the Hamiltonian function method is in fact the fastest when using the master equation solver. This is because the simulation is quite small. In contrast, the Hamiltonian function is over 26x slower than the compiled string version when using the Monte Carlo solver. In this case, the 500 trajectories needed in the simulation highlights the inefficient nature of the Python function calls. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do:; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). In this case, the second call to qutip.mcsolve takes 3 seconds less than the first. Of course our parameters are different, but this also shows how much time one can save by not reorganizing the data, and in the case of the string format, not recompiling the code. If you need to call the solvers many times for different parameters, this savings will obviously start to add",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Testability,log,log," with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. If you can write you time-dependent coefficients using any of the following functions, or combinations thereof (including constants) then you may use this method:; 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil',; 'copysign', 'cos', 'cosh', 'degrees', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10', 'log1p',; 'modf', 'pow', 'radians', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'. Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as th",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Usability,simpl,simply,"eye(3)). # Define collapse operators; c_ops = []; # Cavity decay rate; kappa = 1.5; c_ops.append(sqrt(kappa) * a). # Atomic decay rate; gamma = 6 # decay rate; # Use Rb branching ratio of 5/9 e->u, 4/9 e->g; c_ops.append(sqrt(5*gamma/9) * sigma_ue); c_ops.append(sqrt(4*gamma/9) * sigma_ge). # Define time vector; t = linspace(-15, 15, 100). # Define initial state; psi0 = tensor(basis(N, 0), ustate). # Define states onto which to project; state_GG = tensor(basis(N, 1), ground); sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). # Set up the time varying Hamiltonian; g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do:; def H1_coeff(t, args):; return 9 * exp(-(t / 5.) ** 2). In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve):; H = [H0,[H1,H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; >>> output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate:; from qutip import *; kappa = 0.5; def col_coeff(t, arg",MatchSource.WIKI,docs/3.0.1/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.0.1/guide/dynamics/dynamics-time.html
Deployability,install,installation,"﻿. API documentation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Lev",MatchSource.WIKI,docs/3.1.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/apidoc.html
Integrability,depend,dependent," Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . API documentation. « Modifying Intern... Classes ». API documentation¶; This chapter contains automatically generated API documentation, including a; complete list of QuTiP’s public classes and functions. Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Optimal control; Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/apidoc/apidoc.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/apidoc.html
Availability,toler,tolerance,"rms a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0=machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals: array. Array of eigenvalues for operator. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenstates and eigenenergies.; Eigenstates and eigenenergies are defined for operators and; superoperators only. Parameters:sparse : bool. Use sparse Eigensolver. sort : str. Sort eigenvalues (and vectors) ‘low’ to high, or ‘high’ to low. eigvals : int. Number of requested eigenvalues. Default is all eigenvalues. tol : float. Tolerance used by sparse Eigensolver (0 = machine precision).; The sparse solver may not converge if the tolerance is set too low. maxiter : int. Maximum number of iterations performed by sparse solver (if used). Returns:eigvals : array. Array of eigenvalues for operator. eigvecs : array. Array of qu",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Deployability,install,installation,"﻿. Classes — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Classes; Qobj; eseries; Bloch sphere. Solver Options and Results; Distribution functions. Quantum information processing. Optimal control. « API documentatio... Classes¶. Qobj¶. class Qobj(inpt=None, dims=[[], []], shape=[], type=None, isherm=None, fast=False, superrep=None)¶; A class for representing quantum objects, such as quantum operators; and states.; The Qobj class is the QuTiP representation of quantum operators and state; vectors. This class also implements math operations +,",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Energy Efficiency,reduce,reduced,"istribution(data=None, xvecs=[], xlabels=[])[source]¶; A class for representation spatial distribution functions.; The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far).; It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters:data : array_like. Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs. xvecs : list. List of arrays that spans the space for each coordinate. xlabels : list. List of labels for each coordinate. Methods. marginal. project. visualize. visualize_1d. visualize_2d_colormap. visualize_2d_surface. marginal(dim=0)[source]¶; Calculate the marginal distribution function along the dimension; dim. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; marginal distribution. Returns:d : Distributions. A new instances of Distribution that describes the marginal; distribution. project(dim=0)[source]¶; Calculate the projection (max value) distribution function along the; dimension dim. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters:dim : int. The dimension (coordinate index) along which to obtain the; projected distribution. Returns:d : Distributions. A new instances of Distribution that describes the projection. visualize(fig=None, ax=None, figsize=(8, 6), colorbar=True, cmap=None, style='colormap', show_xlabel=True, show_ylabel=True)[source]¶; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution.; Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualiz",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Integrability,depend,dependent," Array of eigenvalues for operator. eigvecs : array. Array of quantum operators representing the oprator eigenkets.; Order of eigenkets is determined by order of eigenvalues. Notes; The sparse eigensolver is much slower than the dense version.; Use sparse only if memory requirements demand it. eliminate_states(states_inds, normalize=False)¶; Creates a new quantum object with states in state_inds eliminated. Parameters:states_inds : list of integer. The states that should be removed. normalize : True / False. Weather or not the new Qobj instance should be normalized (default; is False). For Qobjs that represents density matrices or state; vectors normalized should probably be set to True, but for Qobjs; that represents operators in for example an Hamiltonian, normalize; should be False. Returns:q : qutip.Qobj. A new instance of qutip.Qobj that contains only the states; corresponding to indices that are not in state_inds. Note; Experimental. static evaluate(qobj_list, t, args)¶; Evaluate a time-dependent quantum object in list format. For; example,. qobj_list = [H0, [H1, func_t]]; is evaluated to. Qobj(t) = H0 + H1 * func_t(t, args); and. qobj_list = [H0, [H1, ‘sin(w * t)’]]; is evaluated to. Qobj(t) = H0 + H1 * sin(args[‘w’] * t). Parameters:qobj_list : list. A nested list of Qobj instances and corresponding time-dependent; coefficients. t : float. The time for which to evaluate the time-dependent Qobj instance. args : dictionary. A dictionary with parameter values required to evaluate the; time-dependent Qobj intance. Returns:output : Qobj. A Qobj instance that represents the value of qobj_list at time t. expm(method=None)¶; Matrix exponential of quantum operator.; Input operator must be square. Parameters:method : str {‘dense’, ‘sparse’, ‘scipy-dense’, ‘scipy-sparse’}. Use set method to use to calculate the matrix exponentiation. The; available choices includes ‘dense’ and ‘sparse’ for using QuTiP’s; implementation of expm using dense and sparse matrices,; respectiv",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Modifiability,variab,variable,"e wavefunction for the given state of an harmonic; oscillator. class HarmonicOscillatorProbabilityFunction(rho=None, omega=1.0, extent=[-5, 5], steps=250)[source]¶; Methods. marginal. project. update. visualize. visualize_1d. visualize_2d_colormap. visualize_2d_surface. update(rho)[source]¶; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix). Quantum information processing¶. class Gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Representation of a quantum gate, with its required parametrs, and target; and control qubits. class QubitCircuit(N, reverse_states=True)[source]¶; Representation of a quantum program/algorithm, maintaining a sequence; of gates.; Attributes. png. svg. Methods. add_1q_gate. add_circuit. add_gate. adjacent_gates. latex_code. propagators. qasm. remove_gate. resolve_gates. reverse_circuit. add_1q_gate(name, start=0, end=None, qubits=None, arg_value=None, arg_label=None)[source]¶; Adds a single qubit gate with specified parameters on a variable; number of qubits in the circuit. By default, it applies the given gate; to all the qubits in the register. Parameters:name: String. Gate name. start: Integer. Starting location of qubits. end: Integer. Last qubit for the gate. qubits: List. Specific qubits for applying gates. arg_value: Float. Argument value(phi). arg_label: String. Label for gate representation. add_circuit(qc, start=0)[source]¶; Adds a block of a qubit circuit to the main circuit.; Globalphase gates are not added. Parameters:qc: QubitCircuit. The circuit block to be added to the main circuit. start: Integer. The qubit on which the first gate is applied. add_gate(name, targets=None, controls=None, arg_value=None, arg_label=None)[source]¶; Adds a gate with specified parameters to the circuit. Parameters:name: String. Gate name. targets: List. Gate targets. controls: List. Gate controls. arg_value: Float. Argument value(phi). arg_label: String. Label for gat",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Performance,perform,performing," operator in column vector form. isoperbra; (bool) Indicates if the quantum object represents an operator in row vector form. Methods. conj(); Conjugate of quantum object. dag(); Adjoint (dagger) of quantum object. eigenenergies(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies (eigenvalues) of a quantum object. eigenstates(sparse=False, sort=’low’, eigvals=0, tol=0, maxiter=100000); Returns eigenenergies and eigenstates of quantum object. expm(); Matrix exponential of quantum object. full(); Returns dense array of quantum object data attribute. groundstate(sparse=False,tol=0,maxiter=100000); Returns eigenvalue and eigenket for the groundstate of a quantum object. matrix_element(bra, ket); Returns the matrix element of operator between bra and ket vectors. norm(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns norm of a ket or an operator. permute(order); Returns composite qobj with indices reordered. ptrace(sel); Returns quantum object for selected dimensions after performing partial trace. sqrtm(); Matrix square root of quantum object. tidyup(atol=1e-12); Removes small elements from quantum object. tr(); Trace of quantum object. trans(); Transpose of quantum object. transform(inpt, inverse=False); Performs a basis transformation defined by inpt matrix. unit(norm=’tr’, sparse=False, tol=0, maxiter=100000); Returns normalized quantum object. checkherm()¶; Check if the quantum object is hermitian. Returns:isherm: bool. Returns the new value of isherm property. conj()¶; Conjugate operator of quantum object. dag()¶; Adjoint operator of quantum object. diag()¶; Diagonal elements of quantum object. Returns:diags: array. Returns array of real values if operators is Hermitian,; otherwise complex values are returned. eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)¶; Eigenenergies of a quantum object.; Eigenenergies (eigenvalues) are defined for operators or superoperators; only. Parameters:sparse : bool. Use ",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Testability,log,logger,"in a cQED system by adding; single qubit gates to get the correct output matrix. Parameters:qc: Qobj. The circular spin chain circuit to be resolved. rwa: Boolean. Specify if RWA is used or not. Returns:qc: QubitCircuit. Returns QubitCircuit of resolved gates for the qubit circuit in the; desired basis. Optimal control¶. class GRAPEResult(u=None, H_t=None, U_f=None)[source]¶; Class for representing the result of a GRAPE simulation.; Attributes. u; (array) GRAPE control pulse matrix. H_t; (time-dependent Hamiltonian) The time-dependent Hamiltonian that realize the GRAPE pulse sequence. U_f; (Qobj) The final unitary transformation that is realized by the evolution of the system with the GRAPE generated pulse sequences. class Dynamics(optimconfig)[source]¶; This is a base class only. See subclass descriptions and choose an; appropriate one for the application.; Note that initialize_controls must be called before any of the methods; can be used.; Attributes. log_level; (integer) level of messaging output from the logger. Options are attributes of qutip.logging, in decreasing levels of messaging, are: DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL Anything WARN or above is effectively ‘quiet’ execution, assuming everything runs as expected. The default NOTSET implies that the level will be taken from the QuTiP settings file, which by default is WARN Note value should be set using set_log_level. stats; (Stats) Attributes of which give performance stats for the optimisation set to None to reduce overhead of calculating stats. Note it is (usually) shared with the Optimizer object. tslot_computer; (TimeslotComputer (subclass instance)) Used to manage when the timeslot dynamics generators, propagators, gradients etc are updated. prop_computer; (PropagatorComputer (subclass instance)) Used to compute the propagators and their gradients. fid_computer; (FidelityComputer (subclass instance)) Used to computer the fidelity error and the fidelity error gradient. nu",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Usability,simpl,simple,"at {0.1}) Sets transparency of Bloch sphere frame. frame_color; (str {‘gray’}) Color of sphere wireframe. frame_width; (int {1}) Width of wireframe. point_color; (list {[“b”,”r”,”g”,”#CC6600”]}) List of colors for Bloch sphere point markers to cycle through. i.e. By default, points 0 and 4 will both be blue (‘b’). point_marker; (list {[“o”,”s”,”d”,”^”]}) List of point marker shapes to cycle through. point_size; (list {[25,32,35,45]}) List of point marker sizes. Note, not all point markers look the same size when plotted!. sphere_alpha; (float {0.2}) Transparency of Bloch sphere itself. sphere_color; (str {‘#FFDDDD’}) Color of Bloch sphere. figsize; (list {[7,7]}) Figure size of Bloch sphere plot. Best to have both numbers the same; otherwise you will have a Bloch sphere that looks like a football. vector_color; (list {[“g”,”#CC6600”,”b”,”r”]}) List of vector colors to cycle through. vector_width; (int {5}) Width of displayed vectors. vector_style; (str {‘-|>’, ‘simple’, ‘fancy’, ‘’}) Vector arrowhead style (from matplotlib’s arrow style). vector_mutation; (int {20}) Width of vectors arrowhead. view; (list {[-60,30]}) Azimuthal and Elevation viewing angles. xlabel; (list {[“$x$”,”“]}) List of strings corresponding to +x and -x axes labels, respectively. xlpos; (list {[1.1,-1.1]}) Positions of +x and -x labels respectively. ylabel; (list {[“$y$”,”“]}) List of strings corresponding to +y and -y axes labels, respectively. ylpos; (list {[1.2,-1.2]}) Positions of +y and -y labels respectively. zlabel; (list {[r’$left|0right>$’,r’$left|1right>$’]}) List of strings corresponding to +z and -z axes labels, respectively. zlpos; (list {[1.2,-1.2]}) Positions of +z and -z labels respectively. Methods. add_annotation. add_points. add_states. add_vectors. clear. make_sphere. plot_annotations. plot_axes. plot_axes_labels. plot_back. plot_front. plot_points. plot_vectors. render. save. set_label_convention. show. add_annotation(state_or_vector, text, **kwargs)[source]¶; Add a text or",MatchSource.WIKI,docs/3.1.0/apidoc/classes.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/classes.html
Availability,error,error,"ite quantum; system. excitations : integer. The maximum number of excitations that are to be included in the; state space. state : list of integers. The state in the number basis representation. Returns:op : Qobj. A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by dims and; exciations. Random Operators and States¶; This module is a collection of random state and operator generators.; The sparsity of the ouput Qobj’s is controlled by varing the; density parameter. rand_dm(N, density=0.75, pure=False, dims=None)[source]¶; Creates a random NxN density matrix. Parameters:N : int. Shape of output density matrix. density : float. Density between [0,1] of output density matrix. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN density matrix quantum operator. Notes; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that \(Tr(\rho)=1\). rand_herm(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse Hermitian quantum object.; Uses \(H=X+X^{+}\) where \(X\) is; a randomly generated quantum operator with a given density. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Hermitian operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Hermitian quantum operator. rand_ket(N, density=1, dims=None)[source]¶; Creates a random Nx1 sparse ket vector. Parameters:N : int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse unitary q",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Deployability,install,installation,"﻿. Functions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Ser",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Energy Efficiency,power,power,"h to evaluate expectation values. c_ops : list of qutip.qobj. List of system collapse operators. args : dictionary. Placeholder for future implementation, kept for API consistency. options : qutip.solver.Options. Options for the solver. Returns:result: qutip.solver.Result. An instance of the class qutip.solver.Result, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by tlist. bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True)[source]¶; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system’s coupling; to its environment. Note; This tensor generation requires a time-independent Hamiltonian. Parameters:H : qutip.qobj. System Hamiltonian. a_ops : list of qutip.qobj. List of system operators that couple to the environment. spectra_cb : list of callback functions. List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of qutip.qobj. List of system collapse operators. use_secular : bool. Flag (True of False) that indicates if the secular approximation should; be used. Returns:R, kets: qutip.Qobj, list of qutip.Qobj. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None)[source]¶; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; bloch_redfield_tensor. Parameters:R : qutip.qobj. Bloch-Redfield tensor. ekets : array of qutip.qobj. Array of kets that make up a basis tranformation for the eigenbasis. rho0 : qutip.qobj. Initial density matrix. tlist : list / array. List of times for \(t\). e_ops : list of qutip.qobj / callback function. List of operators for which to evaluate expectation values. options : qutip.Qdeoptions. Options for the ODE solver. Returns:output: qutip.solver. An i",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Integrability,depend,dependent,"on 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Functions; Manipulation and Creation of States and Operators; Quantum States; Quantum Operators; Random Operators and States; Three-Level Atoms; References; Notes. Superoperators and Liouvillians; Superoperator Representations. Functions acting on states and operators; Tensor; Expectation Values; Partial Transpose; Entropy Functions; Density Matrix Metrics; Continous Variables. Dynamics and Time-Evolution; Schrödinger Equation; Master Equation; Monte Carlo Evolution; Exponential Series; Bloch-Redfield Master Equation; Floquet States and Floquet-Markov Master Equation; Stochastic Schrödinger Equation and Master Equation; Correlation Functions; Steady-state Solvers; Propagators; Time-dependent problems. Visualization; Pseudoprobability Functions; Graphs and Visualization; Quantum Process Tomography. Quantum Information Processing; Gates; Qubits; Algorithms. Optimal control; Utilitiy Functions; Graph Theory Routines; Utility Functions; File I/O Functions; Parallelization; IPython Notebook Tools; Miscellaneous. Change Log ». Functions¶. Manipulation and Creation of States and Operators¶. Quantum States¶. basis(N, n=0, offset=0)[source]¶; Generates the vector representation of a Fock state. Parameters:N : int. Number of Fock states in Hilbert space. n : int. Integer corresponding to desired number state, defaults; to 0 if omitted. offset : int (default 0). The lowest number state that is included in the finite number state; representation of the state. Returns:state : qobj. Qobj representing the requested number state |n>. N",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Modifiability,config,configuration,": int. Number of rows for output quantum operator. density : float. Density between [0,1] of output ket state. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns:oper : qobj. Nx1 ket state quantum operator. rand_unitary(N, density=0.75, dims=None)[source]¶; Creates a random NxN sparse unitary quantum object.; Uses \(\exp(-iH)\) where H is a randomly generated; Hermitian operator. Parameters:N : int. Shape of output quantum operator. density : float. Density between [0,1] of output Unitary operator. dims : list. Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns:oper : qobj. NxN Unitary quantum operator. Three-Level Atoms¶; This module provides functions that are useful for simulating the; three level atom with QuTiP. A three level atom (qutrit) has three states,; which are linked by dipole transitions so that 1 <-> 2 <-> 3.; Depending on there relative energies they are in the ladder, lambda or; vee configuration. The structure of the relevant operators is the same; for any of the three configurations:; Ladder: Lambda: Vee:; |two> |three>; -------|three> ------- -------; | / \ |one> /; | / \ ------- /; | / \ \ /; -------|two> / \ \ /; | / \ \ /; | / \ \ /; | / -------- \ /; -------|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Performance,concurren,concurrence,": float. Variance of operator ‘oper’ for given state. Partial Transpose¶. partial_transpose(rho, mask, method='dense')[source]¶; Return the partial transpose of a Qobj instance rho,; where mask is an array/list with length that equals; the number of components of rho (that is, the length of; rho.dims[0]), and the values in mask indicates whether; or not the corresponding subsystem is to be transposed.; The elements in mask can be boolean or integers 0 or 1,; where True/1 indicates that the corresponding subsystem; should be tranposed. Parameters:rho : qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[sourc",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Safety,avoid,avoids,"-----|one> ------- |three> -------; |one> |two>. References¶; The naming of qutip operators follows the convention in [R1] . [R1]Shore, B. W., “The Theory of Coherent Atomic Excitation”,; Wiley, 1990. Notes¶; Contributed by Markus Baden, Oct. 07, 2011. three_level_basis()[source]¶; Basis states for a three level atom. Returns:states : array. array of three level atom basis vectors. three_level_ops()[source]¶; Operators for a three level system (qutrit). Returns:ops : array. array of three level operators. Superoperators and Liouvillians¶. operator_to_vector(op)[source]¶; Create a vector representation of a quantum operator given; the matrix representation. vector_to_operator(op)[source]¶; Create a matrix representation given a quantum operator in; vector form. liouvillian(H, c_ops=[], data_only=False, chi=None)[source]¶; Assembles the Liouvillian superoperator from a Hamiltonian; and a list of collapse operators. Like liouvillian, but with an; experimental implementation which avoids creating extra Qobj instances,; which can be advantageous for large systems. Parameters:H : qobj. System Hamiltonian. c_ops : array_like. A list or array of collapse operators. Returns:L : qobj. Liouvillian superoperator. spost(A)[source]¶; Superoperator formed from post-multiplication by operator A. Parameters:A : qobj. Quantum operator for post multiplication. Returns:super : qobj. Superoperator formed from input qauntum object. spre(A)[source]¶; Superoperator formed from pre-multiplication by operator A. Parameters:A : qobj. Quantum operator for pre-multiplication. Returns:super :qobj. Superoperator formed from input quantum object. sprepost(A, B)[source]¶; Superoperator formed from pre-multiplication by operator A and post-; multiplication of operator B. Parameters:A : Qobj. Quantum operator for pre-multiplication. B : Qobj. Quantum operator for post-multiplication. Returns:super : Qobj. Superoperator formed from input quantum objects. lindblad_dissipator(a, b=None, data_only=False)[",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Security,access,access," figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis context in which the plot will be drawn. figsize : (width, height). The size of the matplotlib figure (in inches) if it is to be created; (that is, if no ‘fig’ and ‘ax’ arguments are passed). Returns:fig, ax : tuple. A tuple of the matplotlib figure and axes instances used to produce; the figure. plot_qubism(ket, theme='light', how='pairs', grid_iteration=1, legend_iteration=0, fig=None, ax=None, figsize=(6, 6))[source]¶; Qubism plot for pure states of many qudits.; Works best for spin chains, especially with even number of particles; of the same dimension.; Allows to see entanglement between first 2*k particles and the rest. More information:; J. Rodriguez-Laguna, P. Migdal,; M. Ibanez Berganza, M. Lewenstein, G. Sierra,; “Qubism: self-similar visualization of many-body wavefunctions”,; New J. Phys. 14 053028 (2012), arXiv:1112.3560,; http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access). Parameters:ket : Qobj. Pure state for plotting. theme : ‘light’ (default) or ‘dark’. Set coloring theme for mapping complex values into colors.; See: complex_array_to_rgb. how : ‘pairs’ (default), ‘pairs_skewed’ or ‘before_after’. Type of Qubism plotting.; Options:. ‘pairs’ - typical coordinates,; ‘pairs_skewed’ - for ferromagnetic/antriferromagnetic plots,; ‘before_after’ - related to Schmidt plot (see also: plot_schmidt). grid_iteration : int (default 1). Helper lines to be drawn on plot.; Show tiles for 2*grid_iteration particles vs all others. legend_iteration : int (default 0) or ‘grid_iteration’ or ‘all’. Show labels for first 2*legend_iteration particles.; Option ‘grid_iteration’ sets the same number of particles. as for grid_iteration. Option ‘all’ makes label for all particles.; Typically it should be 0, 1, 2 or perhaps 3. fig : a matplotlib figure instance. The figure canvas on which the plot will be drawn. ax : a matplotlib axis instance. The axis contex",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Testability,log,logarithm,"qutip.qobj. A density matrix. mask : list / array. A mask that selects which subsystems should be transposed. method : str. choice of method, dense or sparse. The default method; is dense. The sparse implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns:rho_pr: qutip.qobj. A density matrix with the selected subsystems transposed. Entropy Functions¶. concurrence(rho)[source]¶; Calculate the concurrence entanglement measure for a two-qubit state. Parameters:state : qobj. Ket, bra, or density matrix for a two-qubit state. Returns:concur : float. Concurrence. References. [R2]http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). entropy_conditional(rho, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the conditional entropy \(S(A|B)=S(A,B)-S(B)\); of a slected density matrix component. Parameters:rho : qobj. Density matrix of composite object. selB : int/list. Selected components for density matrix B. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_cond : float. Value of conditional entropy. entropy_linear(rho)[source]¶; Linear entropy of a density matrix. Parameters:rho : qobj. sensity matrix or ket/bra vector. Returns:entropy : float. Linear entropy of rho. Examples; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. entropy_mutual(rho, selA, selB, base=2.718281828459045, sparse=False)[source]¶; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters:rho : qobj. Density matrix for composite quantum systems. selA : int/list. int or list of first selected density matrix components. selB : int/list. int or list of second selected density matrix components. base : {e,2}. Base of logarithm. sparse : {False,True}. Use sparse eigensolver. Returns:ent_mut : float. Mutual information between selected components. entropy_vn(rho, base=2.718281828459045, sparse=False)[source]¶; Von-Neumann entropy",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Usability,progress bar,progress bar,"):; return exp(-args['a']*t). H = [H0, [H1, H1_coeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write:; H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters:H : qutip.Qobj. System Hamiltonian. psi0 : qutip.Qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectories to run. c_ops : array_like. single collapse operator or list or array of collapse; operators. e_ops : array_like. single operator or list or array of operators for calculating; expectation values. args : dict. Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options. Instance of ODE solver options. progress_bar: BaseProgressBar. Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function. A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary. Optional keyword arguments to the map_func function. Returns:results : qutip.solver.Result. Object storing all results from the simulation. Note; It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds). mcsolve_f90(H, psi0, tlist, c_ops, e_ops, ntraj=None, options=<qutip.solver.Options instance at 0x1048d6b48>, sparse_dms=True, serial=False, ptrace_sel=[], calc_entropy=False)[source]¶; Monte-Carlo wave function solver with fortran 90 backend.; Usage is identical to qutip.mcsolve, for problems without explicit; time-dependence, and with some optional input:. Parameters:H : qobj. System Hamiltonian. psi0 : qobj. Initial state vector. tlist : array_like. Times at which results are recorded. ntraj : int. Number of trajectori",MatchSource.WIKI,docs/3.1.0/apidoc/functions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/apidoc/functions.html
Availability,avail,available,"Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix r",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Deployability,install,installation,"﻿. Basic Operations on Quantum Objects — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of ",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Integrability,message,message,"f a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4x4 sparse matrix of type '<type 'numpy.complex128'>'; 	with 3 stored elements in Compressed Sparse Row format>. The data attribute returns a message stating that the data is a sparse matrix. All Qobj instances store their data as a sparse matrix to save memory. To access the underlying dense matrix one needs to use the qutip.Qobj.full function as described below. Qobj Math¶; The rules for mathematical operations on Qobj instances are similar to standard matrix arithmetic:; In [20]: q = destroy(4). In [21]: x = sigmax(). In [22]: q + 5; Out[22]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 5. 1. 0. 0. ]; [ 0. 5. 1.41421356 0. ]; [ 0. 0. 5. 1.73205081]; [ 0. 0. 0. 5. ]]. In [23]: x * x; Out[23]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Modifiability,variab,variables,"duction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vectors. The quantum object class, qutip.Qobj, accomplishes this using matrix representation.; To begin, let us create a blank Qobj:; In [3]: Qobj(); Out[3]: ; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]. where we see the blank Qobj object with dimensions, shape, and data. Here the data corresponds to a 1x1-dimensional matrix consisting of a single zero entry. Hint; By convention, Class objects in Python such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([[1],[2],[3],[4],[5]]); Out[4]: ; Quantum obje",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Performance,load,load,"cts and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Basic Operations on Quantum Objects; First things first; The quantum object class; Introduction; States and operators; Qobj attributes; Qobj Math. Functions operating on Qobj class. « Guide Overview. Manipulating Sta... ». Basic Operations on Quantum Objects¶. First things first¶. Warning; Do not run QuTiP from the installation directory. To load the qutip modules, we must first call the import statement:; In [1]: from qutip import *. that will load all of the user available functions. Often, we also need to import the Numpy and Matplotlib libraries with:; In [2]: import numpy as np. Note that, in the rest of the documentation, functions are written using qutip.module.function() notation which links to the corresponding function in the QuTiP API: Functions. However, in calling import *, we have already loaded all of the QuTiP modules. Therefore, we will only need the function name and not the complete path when calling the function from the interpreter prompt or a Python script. The quantum object class¶. Introduction¶; The key difference between classical and quantum mechanics lies in the use of operators instead of numbers as variables. Moreover, we need to specify state vectors and their properties. Therefore, in computing the dynamics of quantum systems we need a data structure that is capable of encapsulating the properties of a quantum operator and ket/bra vect",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Security,access,accessed,"m object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.77880170+0.j ]; [ 0.38939142-0.38939142j]; [ 0.00000000-0.27545895j]; [-0.07898617-0.07898617j]; [-0.04314271+0.j ]]. In [11]: destroy(4); Out[11]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. ]; [ 0. 0. 1.41421356 0. ]; [ 0. 0. 0. 1.73205081]; [ 0. 0. 0. 0. ]]. In [12]: sigmaz(); Out[12]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [13]: jmat(5/2.0,'+'); Out[13]: ; Quantum object: dims = [[6], [6]], shape = [6, 6], type = oper, isherm = False; Qobj data =; [[ 0. 2.23606798 0. 0. 0. 0. ]; [ 0. 0. 2.82842712 0. 0. 0. ]; [ 0. 0. 0. 3. 0. 0. ]; [ 0. 0. 0. 0. 2.82842712 0. ]; [ 0. 0. 0. 0. 0. 2.23606798]; [ 0. 0. 0. 0. 0. 0. ]]. Qobj attributes¶; We have seen that a quantum object has several internal attributes, such as data, dims, and shape. These can be accessed in the following way:; In [14]: q = destroy(4). In [15]: q.dims; Out[15]: [[4], [4]]. In [16]: q.shape; Out[16]: [4, 4]. In general, the attributes (properties) of a Qobj object (or any Python class) can be retrieved using the Q.attribute notation. In addition to the attributes shown with the print function, the Qobj class also has the following:. Property; Attribute; Description. Data; Q.data; Matrix representing state or operator. Dimensions; Q.dims; List keeping track of shapes for; individual components of a; multipartite system (for tensor; products and partial traces). Shape; Q.shape; Dimensions of underlying data matrix. is Hermitian?; Q.isherm; Is the operator Hermitian or not?. Type; Q.type; Is object of type ‘ket, ‘bra’,; ‘oper’, or ‘super’?. The Qobj Class viewed as a container for the properties need to characterize a quantum operator or state vector. For the destruction operator above:; In [17]: q.type; Out[17]: 'oper'. In [18]: q.isherm; Out[18]: False. In [19]: q.data; Out[19]: ; <4",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Testability,log,logic,".]; [ 0. 1.]]. In [24]: q ** 3; Out[24]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0. 0. 0. 2.44948974]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]; [ 0. 0. 0. 0. ]]. In [25]: x / np.sqrt(2); Out[25]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.70710678]; [ 0.70710678 0. ]]. Of course, like matrices, multiplying two objects of incompatible shape throws an error:; In [26]: q * x; ---------------------------------------------------------------------------; TypeError Traceback (most recent call last); <ipython-input-26-c5138e004127> in <module>(); ----> 1 q * x. /opt/local/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/site-packages/qutip/qobj.py in __mul__(self, other); 433 ; 434 else:; --> 435 raise TypeError(""Incompatible Qobj shapes""); 436 ; 437 elif isinstance(other, (list, np.ndarray)):. TypeError: Incompatible Qobj shapes. In addition, the logic operators is equal == and is not equal != are also supported. Functions operating on Qobj class¶; Like attributes, the quantum object class has defined functions (methods) that operate on Qobj class instances. For a general quantum object Q:. Function; Command; Description. Check Hermicity; Q.check_herm(); Check if quantum object is Hermitian. Conjugate; Q.conj(); Conjugate of quantum object. Dagger (adjoint); Q.dag(); Returns adjoint (dagger) of object. Diagonal; Q.diag(); Returns the diagonal elements. Eigenenergies; Q.eigenenergies(); Eigenenergies (values) of operator. Eigenstates; Q.eigenstates(); Returns eigenvalues and eigenvectors. Eliminate States; Q.eliminate_states(inds); Returns quantum object with states in; list inds removed. Exponential; Q.expm(); Matrix exponential of operator. Extract States; Q.extract_states(inds); Qobj with states listed in inds only. Full; Q.full(); Returns full (not sparse) array of; Q’s data. Groundstate; Q.groundstate(); Eigenval & eigket of Qobj groundstate. Matri",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Usability,clear,clear,"hon such as Qobj() differ from functions in the use of a beginning capital letter. We can create a Qobj with a user defined data set by passing a list or array of data into the Qobj:; In [4]: Qobj([[1],[2],[3],[4],[5]]); Out[4]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 2.]; [ 3.]; [ 4.]; [ 5.]]. In [5]: x = np.array([[1, 2, 3, 4, 5]]). In [6]: Qobj(x); Out[6]: ; Quantum object: dims = [[1], [5]], shape = [1, 5], type = bra; Qobj data =; [[ 1. 2. 3. 4. 5.]]. In [7]: r = np.random.rand(4, 4). In [8]: Qobj(r); Out[8]: ; Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False; Qobj data =; [[ 0.13271688 0.96498406 0.6217972 0.05120659]; [ 0.95073525 0.4422577 0.93436513 0.39684026]; [ 0.14249098 0.57866168 0.75444556 0.95474959]; [ 0.43023463 0.67188093 0.42813227 0.53413365]]. Notice how both the dims and shape change according to the input data. Although dims and shape appear to have the same function, the difference will become quite clear in the section on tensor products and partial traces. Note; If you are running QuTiP from a python script you must use the print function to view the Qobj attributes. States and operators¶; Manually specifying the data for each quantum object is inefficient. Even more so when most objects correspond to commonly used types such as the ladder operators of a harmonic oscillator, the Pauli spin operators for a two-level system, or state vectors such as Fock states. Therefore, QuTiP includes predefined objects for a variety of states:. States; Command (# means optional); Inputs. Fock state ket vector; basis(N,#m)/fock(N,#m); N = number of levels in Hilbert space,; m = level containing excitation; (0 if no m given). Fock density matrix; (outer product of basis); fock_dm(N,#p); same as basis(N,m) / fock(N,m). Coherent state; coherent(N,alpha); alpha = complex number (eigenvalue); for requested coherent state. Coherent density matrix; (outer product); coherent_dm(N,alpha)",MatchSource.WIKI,docs/3.1.0/guide/guide-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-basics.html
Availability,down,down,"or and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; In [39]: xp = [np.cos(th) for th in np.linspace(0, 2*pi, 20)]. In [40]: yp = [sin(th) for th in np.linspace(0, 2*pi, 20)]. In [41]: zp = np.zeros(20). In [42]: pnts = [xp, yp, zp]. In [43]: b.add_points(pnts,'m') # <-- add a 'm' string to signify 'multi' colored points. In [44]: b.show(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; In [45]: xz = np.zeros(20). In [46]: yz = [np.sin(th) for th in np.linspace(0, pi ,20)]. In [47]: zz = [np.cos(th) for th in np.linspace(0, pi, 20)]. In [48]: b.add_points([xz, yz, zz]) # no 'm'. In [49]: b.show(). Again, the same plot can be generated using the qutip.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The Bloch class uses Matplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In t",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Deployability,install,installation,"﻿. Plotting on the Bloch Sphere — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Modifiability,evolve,evolve,"e() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; from qutip import *; from scipy import *; def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = sigmax(); sy = sigmay(); sz = sigmaz(); sm = sigmam(); H = w * (cos(theta) * sz + sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(sqrt(rate) * sz). # evolve and calculate expectation values; output = mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]) ; return output.expect[0], output.expect[1], output.expect[2]; ; ## calculate the dynamics; w = 1.0 * 2 * pi # qubit angular frequency; theta = 0.2 * pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a* basis(2,0) + (1-a)*basis(2,1))/(sqrt(a**2 + (1-a)**2)); tlist = linspace(0,4,250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; b = Bloch(); b.vector_color = ['r']; b.view = [-40,30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta),0,np.cos(theta)]); b.add_points([sx[:i+1],sy[:i+1],sz[:i+1]]); b.save(dirc='temp') #saving images to temp directory in current working directory. Generating an animation using ffmpeg (for example) is f",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Performance,load,load,"och3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay; Generating Images for Animation; Directly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple ",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Security,access,accessed,"‘gray’. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.point_mode; Type of point markers to draw; sphere. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; ‘#808080’. b.size; Sets size of figure window; [500,500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; [‘r’, ‘g’, ‘b’, ‘y’]. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45,65 ]. b.xlabel; Labels for x-axis; [‘|x>’, ‘’] +x and -x. b.xlpos; Position of x-axis labels; [1.07,-1.07]. b.ylabel; Labels for y-axis; [‘$y$’,’‘] +y and -y. b.ylpos; Position of y-axis labels; [1.07,-1.07]. b.zlabel; Labels for z-axis; [‘|0>’, ‘|1>’] +z and -z. b.zlpos; Position of z-axis labels; [1.07,-1.07]. These properties can also be accessed via the print command:; In [50]: b = Bloch(). In [51]: print(b); Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,... The Bloch sphere will automatically number the",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Usability,simpl,simply,"ctly Generating an Animation. « Two-time correla... Visualization of... ». Plotting on the Bloch Sphere¶. Important; Updated in QuTiP version 3.0. Introduction¶; When studying the dynamics of a two-level system, it is often convent to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; In [1]: b = Bloch(). which will load an instance of the qutip.Bloch class, or using:; >>> b3d = Bloch3d(). that loads the qutip.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; In [2]: b.show(). or. In addition to the show() command, the Bloch class has the following functions:. Name; Input Parameters (#=optional); Description. add_points(pnts,#meth); pnts list/array of (x,y,z) points,; meth=’m’ (default meth=’s’) will; plot a collection of points as; multi-colored data points.; Adds a single or set of data points; to be plotted on the sphere. add_states(state,#kind); state Qobj or list/array of Qobj’s; representing state or density matrix; of a two-level system,; kind (optional) string specifying; if state should be plotted as point; (‘point’) or vector (default).; Input multiple states as a list or array. add_vectors(vec); vec list/array of (x,y,z) points; giving direction and length of; state vectors.; adds single or multiple vectors to plot. clear();  ; Removes all data from Bloch sphere.; Keeps customized figure properties. save(#format,#dirc); format format (default=’png’) of; output file, dirc",MatchSource.WIKI,docs/3.1.0/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-bloch.html
Availability,avail,available,"= {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\end{split}\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is show in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation or; qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_ss or; qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_4op_1t; \(\left<A(0)B(\tau)C(\tau)D(0)\right>\). qutip.correlation.correlation_4op_2t; \(\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function sovlers return a ",MatchSource.WIKI,docs/3.1.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html
Deployability,install,installation,"﻿. Two-time correlation functions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\",MatchSource.WIKI,docs/3.1.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html
Energy Efficiency,power,power,"three different relaxation rates.; In [1]: times = np.linspace(0,10.0,200). In [2]: a = destroy(10). In [3]: x = a.dag() + a. In [4]: H = a.dag() * a. In [5]: corr1 = correlation_ss(H, times, [np.sqrt(0.5) * a], x, x). In [6]: corr2 = correlation_ss(H, times, [np.sqrt(1.0) * a], x, x). In [7]: corr3 = correlation_ss(H, times, [np.sqrt(2.0) * a], x, x). In [8]: figure(); Out[8]: <matplotlib.figure.Figure at 0x10b2196d0>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x10b4a3490>,; <matplotlib.lines.Line2D at 0x10b4a33d0>,; <matplotlib.lines.Line2D at 0x10b4fddd0>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x10df0d310>. In [11]: xlabel(r'Time $t$'); Out[11]: <matplotlib.text.Text at 0x10d29b1d0>. In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destro",MatchSource.WIKI,docs/3.1.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html
Modifiability,evolve,evolved,"umentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. « An Overview of t... Plotting on the ... ». Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\begin{split}\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\end{split}\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the intial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm s",MatchSource.WIKI,docs/3.1.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html
Performance,perform,performs,"ib.figure.Figure at 0x10b2196d0>. In [9]: plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); Out[9]: ; [<matplotlib.lines.Line2D at 0x10b4a3490>,; <matplotlib.lines.Line2D at 0x10b4a33d0>,; <matplotlib.lines.Line2D at 0x10b4fddd0>]. In [10]: legend(['0.5','1.0','2.0']); Out[10]: <matplotlib.legend.Legend at 0x10df0d310>. In [11]: xlabel(r'Time $t$'); Out[11]: <matplotlib.text.Text at 0x10d29b1d0>. In [12]: ylabel(r'Correlation $\left<x(t)x(0)\right>$'); Out[12]: <matplotlib.text.Text at 0x10d263f90>. In [13]: show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[\begin{split}S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\end{split}\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using the qutip.essolve.essolve solver and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from qutip import *; import pylab as plt. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = tensor(destroy(N), qeye(2)); sm = tensor(qeye(N), destroy(2)); H = wc * a.dag() * a + wa * sm.dag() * sm + g * (a.dag() * sm + a * sm.dag()). # collapse operators; n_th = 0.25; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag(), np.sqrt(gamma) * sm]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure ",MatchSource.WIKI,docs/3.1.0/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-correlation.html
Deployability,install,installation,"﻿. Time Evolution and Quantum System Dynamics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; B",MatchSource.WIKI,docs/3.1.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html
Integrability,depend,dependent,"tates and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Time Evolution and Quantum System Dynamics. « Using Tensor Pro... Dynamics Simulat... ». Time Evolution and Quantum System Dynamics¶. Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Setting Options for the Dynamics Solvers. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-dynamics.html
Deployability,install,installation,"﻿. An Overview of the Eseries Class — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An ",MatchSource.WIKI,docs/3.1.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html
Integrability,depend,dependent,"s and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an in",MatchSource.WIKI,docs/3.1.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html
Modifiability,parameteriz,parameterized,"Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. « Solving for Stea... Two-time correla... ». An Overview of the Eseries Class¶. Exponential-series representation of time-dependent quantum objects¶; The eseries object in QuTiP is a representation of an exponential-series expansion of time-dependent quantum objects (a concept borrowed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax",MatchSource.WIKI,docs/3.1.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html
Performance,perform,performed,"0.5+0j). In [13]: es3_expect.value([0.0, pi/2]); Out[13]: array([ -1.00000000e+00, -6.12323400e-17]). Note the expectation value of the qutip.eseries object, expect(rho, es3), itself is an qutip.eseries, but with amplitude coefficients that are C-numbers instead of quantum operators. To evaluate the C-number qutip.eseries at the times times we use esval(es3_expect, times), or, equivalently, es3_expect.value(times). Applications of exponential series¶; The exponential series formalism can be useful for the time-evolution of quantum systems. One approach to calculating the time evolution of a quantum system is to diagonalize its Hamiltonian (or Liouvillian, for dissipative systems) and to express the propagator (e.g., \(\exp(-iHt) \rho \exp(iHt)\)) as an exponential series.; The QuTiP function qutip.essolve.ode2es and qutip.essolve use this method to evolve quantum systems in time. The exponential series approach is particularly suitable for cases when the same system is to be evolved for many different initial states, since the diagonalization only needs to be performed once (as opposed to e.g. the ode solver that would need to be ran independently for each initial state).; As an example, consider a spin-1/2 with a Hamiltonian pointing in the \(\sigma_z\) direction, and that is subject to noise causing relaxation. For a spin originally is in the up state, we can create an qutip.eseries object describing its dynamics by using the qutip.es2ode function:; In [14]: psi0 = basis(2,1). In [15]: H = sigmaz(). In [16]: L = liouvillian(H, [sqrt(1.0) * destroy(2)]). In [17]: es = ode2es(L, psi0). The qutip.essolve.ode2es function diagonalizes the Liouvillian \(L\) and creates an exponential series with the correct eigenfrequencies and amplitudes for the initial state \(\psi_0\) (psi0).; We can examine the resulting qutip.eseries object by printing a text representation:; In [18]: es; Out[18]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = (-1+0j",MatchSource.WIKI,docs/3.1.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html
Usability,simpl,simply,"owed from the quantum optics toolbox).; An exponential series is parameterized by its amplitude coefficients \(c_i\) and rates \(r_i\), so that the series takes the form \(E(t) = \sum_i c_i e^{r_it}\). The coefficients are typically quantum objects (type Qobj: states, operators, etc.), so that the value of the eseries also is a quantum object, and the rates can be either real or complex numbers (describing decay rates and oscillation frequencies, respectively). Note that all amplitude coefficients in an exponential series must be of the same dimensions and composition.; In QuTiP, an exponential series object is constructed by creating an instance of the class qutip.eseries:; In [1]: es1 = eseries(sigmax(), 1j). where the first argument is the amplitude coefficient (here, the sigma-X operator), and the second argument is the rate. The eseries in this example represents the time-dependent operator \(\sigma_x e^{i t}\).; To add more terms to an qutip.eseries object we simply add objects using the + operator:; In [2]: omega=1.0. In [3]: es2 = (eseries(0.5 * sigmax(), 1j * omega) +; ...: eseries(0.5 * sigmax(), -1j * omega)); ...: . The qutip.eseries in this example represents the operator \(0.5 \sigma_x e^{i\omega t} + 0.5 \sigma_x e^{-i\omega t}\), which is the exponential series representation of \(\sigma_x \cos(\omega t)\). Alternatively, we can also specify a list of amplitudes and rates when the qutip.eseries is created:; In [4]: es2 = eseries([0.5 * sigmax(), 0.5 * sigmax()], [1j * omega, -1j * omega]). We can inspect the structure of an qutip.eseries object by printing it to the standard output console:; In [5]: es2; Out[5]: ; ESERIES object: 2 terms; Hilbert space dimensions: [[2], [2]]; Exponent #0 = -1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]; Exponent #1 = 1j; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 0. 0.5]; [ 0.5 0. ]]. and we c",MatchSource.WIKI,docs/3.1.0/guide/guide-eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-eseries.html
Availability,avail,available,"iew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html
Deployability,install,installation,"﻿. Guide Overview — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API docume",MatchSource.WIKI,docs/3.1.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html
Security,access,accessible,"iew of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html
Usability,guid,guide," Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Guide Overview; Organization. « Users Guide. Basic Operations... ». Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project web page http://qutip.org/tutorials.html, this guide should provide a more or less complete overview. In addition, the API documentation for each function is located at the end of this guide. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the QuTiP tree-diagram of user accessible functions and classes. QuTiP tree-diagram of user accessible functions and classes. Back to top. © Copyright 2011 and later, ",MatchSource.WIKI,docs/3.1.0/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-overview.html
Deployability,install,installation,"﻿. Parallel computation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedu",MatchSource.WIKI,docs/3.1.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html
Energy Efficiency,power,powerful,"e. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; In [23]: import time. In [24]: def func(x): time.sleep(1). In [25]: result = parallel_map(func, range(50), progress_bar=True); 10.0%. Run time: 2.01s. Est. time left: 00:00:00:18; 20.0%. Run time: 3.01s. Est. time left: 00:00:00:12; 30.0%. Run time: 4.02s. Est. time left: 00:00:00:09; 40.0%. Run time: 5.02s. Est. time left: 00:00:00:07; 50.0%. Run time: 7.02s. Est. time left: 00:00:00:07; 60.0%. Run time: 8.02s. Est. time left: 00:00:00:05; 70.0%. Run time: 9.02s. Est. time left: 00:00:00:03; 80.0%. Run time: 10.02s. Est. time left: 00:00:00:02; 90.0%. Run time: 12.02s. Est. time left: 00:00:00:01; 100.0%. Run time: 13.02s. Est. time left: 00:00:00:00; Total run time: 13.07s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶. Note; New in QuTiP 3. When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPythons powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html
Modifiability,variab,variables," Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = p",MatchSource.WIKI,docs/3.1.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html
Performance,perform,performing,"ng Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. « Visualization of... Saving QuTiP Obj... ». Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qut",MatchSource.WIKI,docs/3.1.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html
Safety,avoid,avoid," use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; In [1]: def func1(x): return x, x**2, x**3. In [2]: a, b, c = parfor(func1, range(10)). In [3]: print(a); [0 1 2 3 4 5 6 7 8 9]. In [4]: print(b); [ 0 1 4 9 16 25 36 49 64 81]. In [5]: print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; In [6]: result = parallel_map(func1, range(10)). In [7]: result_array = np.array(result). In [8]: print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. In [9]: print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. In [10]: print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; In [11]: result = parfor(func1, range(5)). In [12]: print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. In [13]: result = parallel_map(func1, range(5)). In [14]: print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; In [15]: def func2(x): return x, Qobj(x), 'a' * x. In [16]: a, b, c = parfor(func2, range(5)). In [17]: print(a); [0 1 2 3 4]. In [18]: print(b); [ Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 0.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 1.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = True; Qobj data =; [[ 2.]]; Quantum object: dims = [[1], [1]], shape = [1, 1], type = oper, isherm = Tr",MatchSource.WIKI,docs/3.1.0/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-parfor.html
Deployability,install,installation,"﻿. Generating Random Quantum States & Operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API document",MatchSource.WIKI,docs/3.1.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-random.html
Testability,test,testing," Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Generating Random Quantum States & Operators; Composite random objects. « Saving QuTiP Obj... Modifying Intern... ». Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state generators for simulations, theorem evaluation, and code testing:. Function; Description. rand_ket; Random ket-vector. rand_dm; Random density matrix. rand_herm; Random Hermitian matrix. rand_unitary; Random Unitary matrix. See the API documentation: Random Operators and States for details.; In all cases, these functions can be called with a single parameter \(N\) that indicates a \(NxN\) matrix (rand_dm, rand_herm, rand_unitary), or a \(Nx1\) vector (rand_ket), should be generated. For example:; In [1]: rand_ket(5); Out[1]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[-0.37899439-0.03246954j]; [-0.09389192-0.30281261j]; [-0.41147565-0.20947105j]; [-0.41769426-0.02916778j]; [-0.54640563+0.26024817j]]. or; In [2]: rand_herm(5); Out[2]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = True; Qobj data =; [[-0.29514824+0.j 0.00000000+0.j -0.27781445-0.15337652j; -0.35652395-0.05592461j 0.00000000+0.j ]; [ 0.00000000+",MatchSource.WIKI,docs/3.1.0/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-random.html
Deployability,install,installation,"﻿. Saving QuTiP Objects and Data Sets — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical",MatchSource.WIKI,docs/3.1.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html
Performance,load,loading," Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. « Parallel computa... Generating Rando... ». Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.filei",MatchSource.WIKI,docs/3.1.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html
Usability,simpl,simple,"back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator:; In [1]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, sqrt(0.25) * a.dag()]. In [2]: rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; In [3]: qsave(rho_ss, 'steadystate'). In [4]: ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations:; In [5]: rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = [10, 10], type = oper, isHerm = True. In [6]: a = destroy(10). In [7]: expect(a.dag() * a, rho_ss_loaded); Out[7]: 0.9902248289345064. The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve:; In [8]: a = destroy(10); H = a.dag() * a ; c_ops = [sqrt(0.5) * a, ",MatchSource.WIKI,docs/3.1.0/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-saving.html
Availability,toler,tolerance,"2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this f",MatchSource.WIKI,docs/3.1.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html
Deployability,install,installation,"﻿. Modifying Internal QuTiP Settings — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; qu",MatchSource.WIKI,docs/3.1.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html
Performance,load,loaded,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html
Safety,detect,detect,"by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup absolute tolerance; auto_tidyup_atol=1e-12; # number of cpus; num_cpus=4; # debug; debug=False. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html
Usability,simpl,simple," Changing Settings; Persistent Settings. « Generating Rando... API documentatio... ». Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.setings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for the file .qutiprc in the user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample .qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; # QuTiP Graphics; qutip_graphics=""YES""; # use auto tidyup; auto_tidyup=True; # detect hermiticity; auto_herm=True; # use auto tidyup ",MatchSource.WIKI,docs/3.1.0/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-settings.html
Availability,down,downarrow," = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; In [51]: sigmaz(); Out[51]: ; Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. In [52]: sigmaz() * spin; Out[52]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [53]: spin2 = basis(2, 1). In [54]: spin2; Out[54]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. In [55]: sigmaz() * spin2; Out[55]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; In [56]: sigmaz() * spin; Out[56]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Deployability,install,installation,"﻿. Manipulating States and Operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we w",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Energy Efficiency,energy,energy,"ty(x, x); Out[38]: 1.0000000208397526. In [39]: tracedist(y, y); Out[39]: 0.0. We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\).; In [40]: tracedist(y, x); Out[40]: 0.9771565895267291. In [41]: np.sqrt(1 - fidelity(y, x) ** 2); Out[41]: 0.97715657013508528. For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; In [42]: 1 - fidelity(x, z) ** 2; Out[42]: 0.7782890497791632. In [43]: tracedist(x, z); Out[43]: 0.8559028328862591. Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; In [44]: spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; In [45]: vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; In [46]: vac; Out[46]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]]. In [47]: c = create(2). In [48]: c * vac; Out[48]: ; Quantum object: dims = [[2], [1]], shape = [2, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Integrability,depend,dependence,".]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; In [7]: c = create(5). In [8]: c * vac; Out[8]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; In [9]: c * c * vac; Out[9]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; In [10]: c ** 2 * vac; Out[10]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 1.41421356]; [ 0. ]; [ 0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; In [11]: c * a * vac; Out[11]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. or on the \(\left| 1\right>\) state:; In [12]: c * a * (c * vac); Out[12]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0.]; [ 1.]; [ 0.]; [ 0.]; [ 0.]]. or the \(\left| 2\right>\) state:; In [13]: c * a * (c**2 * vac); Out[13]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 0. ]; [ 0. ]; [ 2.82842712]; [ 0. ]; [ 0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; In [14]: c * a * (c**2 ",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Modifiability,extend,extended,"atrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by using the to_super,; to_kraus and to_choi functions. The superrep; attribute keeps track of what reprsentation is a Qobj is currently using.; In [104]: J = to_choi(S). In [105]: J; Out[105]: ; Quantum object:",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Performance,perform,performing," Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ]; [ 0. 0. 0. 0. 2. ]; [ 0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; In [5]: a * vac; Out[5",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Security,expose,exposed,"2], [2]], [1]], shape = [4, 1], type = operator-ket; Qobj data =; [[ 0.]; [ 2.]; [ 1.]; [ 3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called supermatrices.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; In [93]: X = sigmax(). In [94]: S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; In [95]: S2 = to_super(X). In [96]: (S - S2).norm(); Out[96]: 0.0. Quantum objects representing superoperators are denoted by type='super':; In [97]: S; Out[97]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; In [98]: S.iscp, S.istp, S.iscptp; Out[98]: (True, True, True). In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamilonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; In [99]: H = 10 * sigmaz(). In [100]: c1 = destroy(2). In [101]: L = liouvillian(H, [c1]). In [102]: L; Out[102]: ; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = [4, 4], type = super, isherm = False; Qobj data =; [[ 0.0 +0.j 0.0 +0.j 0.0 +0.j 1.0 +0.j]; [ 0.0 +0.j -0.5+20.j 0.0 +0.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j -0.5-20.j 0.0 +0.j]; [ 0.0 +0.j 0.0 +0.j 0.0 +0.j -1.0 +0.j]]. In [103]: S = (12 * L).expm(). Once a superoperator has been obtained, it can be converted between the; supermatrix, Kraus and Choi formalisms by u",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Usability,guid,guide,"es; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. « Basic Operations... Using Tensor Pro... ». Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; In [1]: vac = basis(5, 0). In [2]: vac; Out[2]: ; Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; In [3]: a = destroy(5). In [4]: a; Out[4]: ; Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isherm = False; Qobj data =; [[ 0. 1. 0. 0. 0. ]; [ 0. 0. 1.41421356 0. 0. ]; [ 0. 0. 0. 1.73205081 0. ",MatchSource.WIKI,docs/3.1.0/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-states.html
Availability,down,downside,"ill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Deployability,install,installation,"﻿. Solving for Steady-State Solutions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend towar",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Energy Efficiency,power,power,"irect or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State Solutions for Arbitrary Systems¶. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Iteratively solve for the steady-state solution using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Iteratively solve for the steady-state solution using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the SVD of the Liouvillian represented by a dense matrix. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, an arbitrary Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian for the system. Using the S",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Integrability,rout,routine,"; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. Additional parameters may be used by calling the steady-state solver as:; >>> rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on the bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the oth",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Modifiability,coupling,coupling,"conditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; In [1]: N = 20 # number of basis states to consider. In [2]: a = destroy(N). In [3]: H = a.dag() * a. In [4]: psi0 = basis(N, 10) # initial state. In [5]: kappa = 0.1 # coupling to oscillator. In [6]: c_op_list = []. In [7]: n_th_a = 2 # temperature with average of 2 excitations. In [8]: rate = kappa * (1 + n_th_a). In [9]: c_op_list.append(sqrt(rate) * a) # decay operators. In [10]: rate = kappa * n_th_a. In [11]: c_op_list.append(sqrt(rate) * a.dag()) # excitation operators. In [12]: final_state = steadystate(H, c_op_list). In [13]: fexpt = expect(a.dag() * a, final_state). In [14]: tlist = linspace(0, 50, 100). In [15]: mcdata = mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); 10.0%. Run time: 0.41s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.82s. Est. time left: 00:00:00:03; 30.0%. Run time: 1.17s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.61s. Est. time left: 00:00:00:02; 50.0%. Run time: 2.01s. Est. time left: 00:00:00:02; 60.0%. Run time: 2.35s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.65s. Est. time left: 00:00:00:01; 80.0%. Run time: 3.01s. Est. time left: 00:00:00:00; 90.0%. Run time: 3.43s. Est. time left: 00:00:00:00; ",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Performance,perform,perform,"se, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_umfpack; False, True; Use the umfpack solver rather than the default superLU. on SciPy 0.14+, this option requires installing the scikits.umfpack extension. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Usability,simpl,simple,"ary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. « Setting Options ... An Overview of t... ». Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State Solutions for Arbitrary Systems¶. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument.; Available Steady-State Methods:. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the eigenvector corresponding to the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Iteratively solve for the steady-state solution using the inverse-power method. GMRES; ‘iterative-gmres’; Iteratively solve for the steady-state solution using the GMRES method and optional preconditioner. LGMRES; ‘iterativ",MatchSource.WIKI,docs/3.1.0/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-steady.html
Availability,down,down,"rmed by taking the tensor product of the two single-qubit ground state vectors:; In [1]: tensor(basis(2, 0), basis(2, 0)); Out[1]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: t",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Deployability,install,installation,"﻿. Using Tensor Products and Partial Traces — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. « Manipulating Sta... Time Evolution a... ». Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qub",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Energy Efficiency,energy,energy,". 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tensor(identity(2), sigmax(), sigmax())); ...: . In [9]: H; Out[9]: ; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isherm = True; Qobj data =; [[",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Integrability,contract,contracting,"[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; Out[30]: [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; Out[33]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; In [34]: tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; Out[34]: [[[2], [2]], [[3], [3]]]. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Modifiability,extend,extended,"2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. or equivalently using the list format:; In [2]: tensor([basis(2, 0), basis(2, 0)]); Out[2]: ; Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket; Qobj data =; [[ 1.]; [ 0.]; [ 0.]; [ 0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; In [3]: tensor((basis(2, 0) + basis(2, 1)).unit(),; ...: (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0)); ...: ; Out[3]: ; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]; [ 0.5]; [ 0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Performance,perform,performs," represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.to_super:; In [27]: A = qeye([2]). In [28]: B = qeye([3]). In [29]: to_super(tensor(A, B)).dims; Out[29]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. In [30]: tensor(to_super(A), to_super(B)).dims; Out[30]: [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; In [31]: super_tensor(to_super(A), to_super(B)).dims; Out[31]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.composite function automatically switches between; qutip.tensor and qutip.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; In [32]: composite(A, B).dims; Out[32]: [[2, 3], [2, 3]]. In [33]: composite(to_super(A), to_super(B)).dims; Out[33]: [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_co",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Usability,simpl,simple,"its:; In [4]: tensor(sigmax(), sigmax()); Out[4]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 0. 0. 0. 1.]; [ 0. 0. 1. 0.]; [ 0. 1. 0. 0.]; [ 1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act only on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; In [5]: tensor(sigmaz(), identity(2)); Out[5]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both qubit has equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; In [6]: H = tensor(sigmaz(), identity(2)) + tensor(identity(2),; ...: sigmaz()) + 0.05 * tensor(sigmax(), sigmax()); ...: . In [7]: H; Out[7]: ; Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; In [8]: H = (tensor(sigmaz(), identity(2), identity(2)) +; ...: tensor(identity(2), sigmaz(), identity(2)) +; ...: tensor(identity(2), identity(2), sigmaz()) +; ...: 0.5 * tensor(sigmax(), sigmax(), identity(2)) +; ...: 0.25 * tens",MatchSource.WIKI,docs/3.1.0/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-tensor.html
Availability,error,errors,"]; ....: for k in range(len(lbls_list))])); ....: . In [71]: fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). In [72]: ax.view_init(azim=-55, elev=45). In [73]: plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; In [74]: rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). In [75]: fig, ax = hinton(rho_ss) # xlabels=xlabels, ylabels=xlabels). In [76]: plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the ma",MatchSource.WIKI,docs/3.1.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html
Deployability,install,installation,"﻿. Visualization of quantum states and processes — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Parallel computa... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first meth",MatchSource.WIKI,docs/3.1.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html
Integrability,depend,dependent,"(M\) with a size that is the square of the size of the superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.gates.iswap generates the unitary transformation for the state kets:; In [77]: U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; In [78]: U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; In [79]: op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2. In [80]: op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; In [81]: chi = qpt(U_rho, op_basis). In [82]: fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). In [83]: plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html
Performance,perform,perform,"(October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Custom Color Maps. Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. « Plotting on the ... Parallel computa... ». Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/3.1.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html
Security,access,access,"interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/3.1.0/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide-visualization.html
Deployability,install,installation,"﻿. Users Guide — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite ",MatchSource.WIKI,docs/3.1.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide.html
Integrability,depend,dependent,"er 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Users Guide. « Installation. Guide Overview ». Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPytho",MatchSource.WIKI,docs/3.1.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide.html
Performance,load,loading,"; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Bloch-Redfield master equation; Solving Problems with Time-dependent Hamiltonians; Floquet Formalism; Setting Options for the Dynamics Solvers. Solving for Steady-State Solutions; Introduction; Steady State Solutions for Arbitrary Systems; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. An Overview of the Eseries Class; Exponential-series representation of time-dependent quantum objects; Applications of exponential series. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/guide.html
Availability,avail,available,"ons on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . All modules for which code is available; qutip; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dynamics; qutip.control.grape; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.correlation; qutip.distributions; qutip.entropy; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.fortran.mcsolve_f90; qutip.graph; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.operators; qutip.parallel; qutip.partial_transpose; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.gates; qutip.qip.models; qutip.qip.models.cqed; qutip.qip.models.spinchain; qutip.qip.qubits; qutip.random_objects; qutip.sesolve; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.utilities; qutip.visualization; qutip.wigner. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created usin",MatchSource.WIKI,docs/3.1.0/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/index.html
Deployability,install,installation,"﻿. Overview: module code — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . All modules for which code is available; qutip; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dynamics; qutip.control.grape; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.correlation; qutip.distributions; qutip.entropy; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.fortran.mcsolve_f90; qutip.graph; qutip.ipynbtools; qutip.mcsolve; qutip.mesolve; qutip.metrics; qutip.operators; qutip.parallel; qutip",MatchSource.WIKI,docs/3.1.0/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/index.html
Availability,error,errors,"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import division, print_function, absolute_import; import os; # Fix the multiprocessing issue with NumPy compiled against OPENBLAS; if 'OPENBLAS_MAIN_FREE' not in os.environ:; os.environ['OPENBLAS_MAIN_FREE'] = '1'; # automatically set number of threads used by MKL and openblas to 1; # prevents errors when running things in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__v",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Deployability,install,installation,"﻿. qutip — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2. Redistribu",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Integrability,depend,dependencies,"ssing issue with NumPy compiled against OPENBLAS; if 'OPENBLAS_MAIN_FREE' not in os.environ:; os.environ['OPENBLAS_MAIN_FREE'] = '1'; # automatically set number of threads used by MKL and openblas to 1; # prevents errors when running things in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlin",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Modifiability,config,configuration,"ile__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # -----------------------------------------------------------------------------; # setup the cython environment; #; _cython_requirement = ""0.15.0""; try:; import Cython; if _version2int(Cython.__version__) < _version2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number ",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Performance,load,loading,"ion2int(_cython_requirement):; print(""QuTiP warning: old version of cython detected "" +; (""(%s), requiring %s."" %; (Cython.__version__, _cython_requirement))). import pyximport; os.environ['CFLAGS'] = '-O3 -w -ffast-math -march=native -mfpmath=sse'; pyximport.install(setup_args={'include_dirs': [numpy.get_include()]}). except Exception as e:; print(""QuTiP warning: Cython setup failed: "" + str(e)); else:; del Cython, pyximport. # -----------------------------------------------------------------------------; # Load user configuration if present: override defaults.; #; try:; if os.name == ""nt"":; qutip_rc_file = os.path.join(; os.getenv('APPDATA'), 'qutip', ""qutiprc""; ); else:; qutip_rc_file = os.path.join(; # This should possibly be changed to ~/.config/qutiprc,; # to follow XDG specs. Also, OS X uses a different naming; # convention as well.; os.environ['HOME'], "".qutiprc""; ); qutip.settings.load_rc_file(qutip_rc_file). except Exception as e:; try:; qutip.settings._logger.warning(""Error loading RC file."", exc_info=1); except:; pass. # -----------------------------------------------------------------------------; # cpu/process configuration; #; import multiprocessing. # Check if environ flag for qutip processes is set; if 'QUTIP_NUM_PROCESSES' in os.environ:; qutip.settings.num_cpus = int(os.environ['QUTIP_NUM_PROCESSES']); else:; os.environ['QUTIP_NUM_PROCESSES'] = str(qutip.settings.num_cpus). if qutip.settings.num_cpus == 0:; # if num_cpu is 0 set it to the available number of cores; from qutip.hardware_info import hardware_info; info = hardware_info(); if 'cpus' in info:; qutip.settings.num_cpus = info['cpus']; else:; qutip.settings.num_cpus = multiprocessing.cpu_count(). # -----------------------------------------------------------------------------; # Load configuration from environment variables: override defaults and; # configuration file.; #. # check for fortran mcsolver files; try:; from qutip.fortran import mcsolve_f90; except:; qutip.settings.fortran = False",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Safety,detect,detected,"hings in parallel. Should be set; # by user directly in a script or notebook if >1 is needed.; # Must be set BEFORE importing NumPy; if 'MKL_NUM_THREADS' not in os.environ:; os.environ['MKL_NUM_THREADS'] = '1'. if 'OPENBLAS_NUM_THREADS' not in os.environ:; os.environ['OPENBLAS_NUM_THREADS'] = '1'. import sys; import warnings. import qutip.settings; import qutip.version; from qutip.version import version as __version__; from qutip.utilities import _version2int. # -----------------------------------------------------------------------------; # Check if we're in IPython.; try:; __IPYTHON__; qutip.settings.ipython = True; except:; qutip.settings.ipython = False. # -----------------------------------------------------------------------------; # Check for minimum requirements of dependencies, give the user a warning; # if the requirements aren't fulfilled; #. numpy_requirement = ""1.6.0""; try:; import numpy; if _version2int(numpy.__version__) < _version2int(numpy_requirement):; print(""QuTiP warning: old version of numpy detected "" +; (""(%s), requiring %s."" %; (numpy.__version__, numpy_requirement))); except:; warnings.warn(""numpy not found.""). scipy_requirement = ""0.11.0""; try:; import scipy; if _version2int(scipy.__version__) < _version2int(scipy_requirement):; print(""QuTiP warning: old version of scipy detected "" +; (""(%s), requiring %s."" %; (scipy.__version__, scipy_requirement))); except:; warnings.warn(""scipy not found.""). # -----------------------------------------------------------------------------; # check to see if running from install directory for released versions.; #; top_path = os.path.dirname(os.path.dirname(__file__)); try:; setup_file = open(top_path + '/setup.py', 'r'); except:; pass; else:; if ('QuTiP' in setup_file.readlines()[1][3:]) and qutip.version.release:; print(""You are in the installation directory. "" +; ""Change directories before running QuTiP.""); setup_file.close(). del top_path. # --------------------------------------------------------------",MatchSource.WIKI,docs/3.1.0/modules/qutip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip.html
Availability,down,downside,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,"﻿. Bloch-Redfield master equation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Energy Efficiency,energy,energy,"field master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Integrability,depend,depends,") are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho(s)\) is replaced by \(\rho(t)\) in Eq. (1). The result is the Redfield equation. (2)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Modifiability,coupling,coupling,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Usability,clear,clear,".3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP. « Monte Carlo Solv... Solving Problems... ». Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-bloch-redfield.html
Deployability,install,installation,"﻿. Dynamics Simulation Results — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-data.html
Security,access,access,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results. To ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-data.html
Usability,simpl,simplified," Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. « Time Evolution a... Lindblad Master ... ». Dynamics Simulation Results¶. Important; In QuTiP 2, the results from all of the dynamics solvers are returned as Odedata objects. This unified and significantly simplified postprocessing of simulation results from different solvers, compared to QuTiP 1. However, this change also results in the loss of backward compatibility with QuTiP version 1.x. In QuTiP 3, the Odedata class has been renamed to Result, but for backwards compatibility an alias between Result and Odedata is provided. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating w",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-data.html
Deployability,install,installation,"﻿. Floquet Formalism — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html
Energy Efficiency,efficient,efficiently,"n 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html
Integrability,depend,dependent,"s and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet formalism in QuTiP; Pre-computing the Floquet modes for one period. Floquet theory for dissipative evolution; The Floquet-Markov master equation in QuTiP. « Solving Problems... Setting Options ... ». Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html
Modifiability,coupling,coupling,"pendent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; >>> gamma1 = 0.1; >>> def noise_spectrum(omega):; >>> return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; from qutip import *; from scipy import *. delta = 0.0 * 2*pi; eps0 = 1.0 * 2*pi; A = 0.25 * 2*pi; omega = 1.0 * 2*pi; T = (2*pi)/omega; tlist = linspace(0.0, 20 * T, 101); psi0 = basis(2,0). H",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-floquet.html
Deployability,install,installation,"﻿. Lindblad Master Equation Solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. « Dynamics Simulat... Monte Carlo Solv... ». Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html
Energy Efficiency,efficient,efficient,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html
Modifiability,evolve,evolves,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; In [1]: H = 2 * np.pi * 0.1 * sigmax(). In [2]: psi0 = basis(2, 0). In [3]: times = np.linspace(0.0, 10.0, 20.0). In [4]: result = mesolve(H, psi0, times, [], [sigmaz()]). The brackets in the fourth argument is an empty list of collapse operators, since we consider unitary evolution in this example. See the next section for examples on how dissipation is included by defining a list of collapse operators.; ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html
Performance,perform,perform,"ndblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html
Security,access,accessible,"nd the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[\begin{split}i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\end{split}\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.mesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver. Alternatively, we can use the function qutip.essolve, which uses the exponential-series technique to calculate the time evolution of a system. The qutip.mesolve and qutip.essolve functions take the same arguments and it is therefore easy switch between the two solvers.; ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-master.html
Availability,error,errors," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.57s. Est. time left: 00:00:00:23; 20.0%. Run time: 4.90s. Est. time left: 00:00:00:19; 30.0%. Run time: 7.20s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.68s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.98s. Est. time left: 00:00:00:11; 60.0%. Run time: 14.43s. Est. time left: 00:00:00:09; 70.0%. Run time: 16.91s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.25s. Est. time left: 00:00:00:04; 90.0%. Run time: 21.87s. Est. time left: 00:00:00:02; 100.0%. Run time: 24.21s. Est. time left: 00:00:00:00; Total run time: 24.27s. where we have add",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Deployability,install,installation,"﻿. Monte Carlo Solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realizatio",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Energy Efficiency,monitor,monitored,"July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Monte Carlo Solver; Introduction; Monte Carlo in QuTiP; Changing the Number of Trajectories; Reusing Hamiltonian Data; Fortran Based Monte Carlo Solver. « Lindblad Master ... Bloch-Redfield m... ». Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)\[\begin{split}\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\end{split}\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2).",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Integrability,depend,dependent,"29]: <matplotlib.figure.Figure at 0x107d48210>. In [30]: plot(times, data1.expect[0], times, data1.expect[1], lw=2); Out[30]: ; [<matplotlib.lines.Line2D at 0x10ab737d0>,; <matplotlib.lines.Line2D at 0x10ab73a50>]. In [31]: plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); Out[31]: ; [<matplotlib.lines.Line2D at 0x1096d45d0>,; <matplotlib.lines.Line2D at 0x1096d47d0>]. In [32]: title('Monte Carlo time evolution'); Out[32]: <matplotlib.text.Text at 0x107db4790>. In [33]: xlabel('Time', fontsize=14); Out[33]: <matplotlib.text.Text at 0x1078fcd10>. In [34]: ylabel('Expectation values', fontsize=14); Out[34]: <matplotlib.text.Text at 0x107df7150>. In [35]: legend((""cavity photon number"", ""atom excitation probability"")); Out[35]: <matplotlib.legend.Legend at 0x107a31b90>. In [36]: show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Fortran Based Monte Carlo Solver¶. Note; In order to use the Fortran Monte Carlo solver, you must have the blas development libraries, and installed QuTiP using the flag: --with-f90mc. In performing time-independent Monte Carlo simulations with QuTiP, systems with small Hilbert spaces suffer from poor performance as the ODE solver must exit the ODE solver at each time step and check for the state vector norm. To correct this, QuTiP now includes an optional Fortran based Monte Carlo solver that has enhanced performance for systems with small Hilbert space dimensionality. Using the Fortran based solver is extremely simple; one just needs to replace mcsolve with mcsolve_f90. For example, from our previous demonstration; In [37]: data1 = mcsolve_f90(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). In using the Fortran solver, there are a few limitations tha",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Modifiability,config,configuration,"sing:; In [17]: expt10 = data.expect[1] # <- expectation values avg. over 10 trajectories. In [18]: expt100 = data.expect[2] # <- expectation values avg. over 100 trajectories. In [19]: expt1000 = data.expect[3] # <- expectation values avg. over 1000 trajectories. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; In [20]: options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; In [21]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [22]: a = tensor(qeye(2), destroy(10)). In [23]: sm = tensor(destroy(2), qeye(10)). In [24]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + \; ....: 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); ....: . In [25]: data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.20s. Est. time left: 00:00:00:10; 20.0%. Run time: 2.49s",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Performance,perform,performed,"e system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)\[\sum_{i=1}^{n} P_{i}(\tau) \ge r\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; In [1]: times = np.linspace(0.0, 10.0, 200). In [2]: psi0 = tensor(fock(2, 0), fock(10, 5)). In [3]: a = tensor(qeye(2), destroy(10)). In [4]: sm = tensor(destroy(2), qeye(10)). In [5]: H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a). In [6]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); 10.0%. Run time: 1.27s. Est. time left: 00:00:00:11; 20.0%. Run time: 2.44s. Est. time left: 00:00:00:09; 30.0%. Run time: 3.64s. Est. time left: 00:00:00:08; 40.0%. Run time: 4.82s. Est. time left: 00:00:00:07; 50.0%. Run time: 5.98s. Est. time left: 00:00:00:05; 60.0%. Run ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Usability,simpl,simply,"r state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; In [14]: data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000); 10.0%. Run time: 2.57s. Est. time left: 00:00:00:23; 20.0%. Run time: 4.90s. Est. time left: 00:00:00:19; 30.0%. Run time: 7.20s. Est. time left: 00:00:00:16; 40.0%. Run time: 9.68s. Est. time left: 00:00:00:14; 50.0%. Run time: 11.98s. Est. time left: 00:00:00:11; 60.0%. Run time: 14.43s. Est. time left: 00:00:00:09; 70.0%. Run time: 16.91s. Est. time left: 00:00:00:07; 80.0%. Run time: 19.25s. Est. time left: 00:00:00:04; 90.0%. Run time: 21.87s. Est. time left: 00:00:00:02; 100.0%. Run time: 24.21s. Est. time left: 00:00:00:00; Total run time: 24.27s. where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-monte.html
Availability,toler,tolerance,olvers. « Floquet Formalis... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this class can be view via the print function:; In [2]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average ,MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html
Deployability,install,installation,"﻿. Setting Options for the Dynamics Solvers — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Setting Options for the Dynamics Solvers. « Floquet Formalis... Solving for Stea... ». Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; In [1]: options = Options(). the properties and default values of this",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html
Integrability,depend,dependent,"pect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html
Modifiability,variab,variable,"cally by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.num_cpus; installed num; of processors; Integer number of cpu’s used by mcsolve. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repeatative tasks. options.gui; True (if GUI); Use the mcsolve progessbar. Defaults to False on Windows. options.mc_avg; True; Average over trajectories for expectation values from mcsolve. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; or one can use an inline method,; Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; In [3]: print(options); Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 0; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-options.html
Availability,avail,available,"ned functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign',; 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10',; 'log1p', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh', 'trunc'], ; dtype='|S9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. However, this method is somewhat less efficient then the previously mentioned methods, and does not allow for time-dependent collapse operators. However, in contrast to options #1 and #2, this method can be used in implementing time-dependent Hamiltonians that cannot be expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent ",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Deployability,install,installation,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Energy Efficiency,efficient,efficient,"t time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed in the Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; ar",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Integrability,depend,dependent,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Modifiability,variab,variable,"erators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; Using the args variable. String Format Method; Reusing Time-Dependent Hamiltonian Data; Running String-Based Time-Dependent Problems using Parfor. « Bloch-Redfield m... Floquet Formalis... ». Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution, we assumed that the systems under consideration were described by time-independent Hamiltonians. However, many systems have explicit time dependence in either the Hamiltonian, or the collapse operators describing coupling to the environment, and sometimes both components might depend on time. The two main evolution solvers in QuTiP, qutip.mesolve and qutip.mcsolve, discussed in Lindblad Master Equation Solver and Monte Carlo Solver respectively, are capable of handling time-dependent Hamiltonians and collapse terms. There are, in general, three different ways to implement time-dependent problems in QuT",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Safety,avoid,avoid," = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; In [45]: output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; In [46]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [47]: args = {'A': 9, 'sig': 5}. In [48]: output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables e, j or pi will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; In [49]: H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]. In [50]: args = {'A': 9, 'sig': 5}. In [51]: output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); 10.0%. Run time: 0.36s. Est. time left: 00:00:00:03; 20.0%. Run time: 0.64s. Est. time left: 00:00:00:02; 30.0%. Run time: 0.93s. Est. time left: 00:00:00:02; 40.0%. Run time: 1.21s. Est. time left: 00:00:00:01; 50.0%. Run time: 1.48s. Est. time left: 00:00:00:01; 60.0%. Run time: 1.76s. Est. time left: 00:00:00:01; 70.0%. Run time: 2.00s. Est. time left: 00:00:00:00; 80.0%. Run time: 2.23s. Est. time left: 00:00:00:00; 90.0%. Run time: 2.46s. Est. time left: 00:00:00:00; 100.0%. Ru",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Testability,log,log,"and executed.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Give the multiple choices of input style, the first question that arrises is which option to choose? In short, the function based method (option #1) is the most general, allowing for essentially arbitrary coefficients expressed via user defined functions. However, by automatically compiling your system into C code, the second option (string based) tends to be more efficient and will run faster. Of course, for small system sizes and evolution times, the difference will be minor. Although this method does not support all time-dependent coefficients that one can think of, it does support essentially all problems that one would typically encounter. Time-dependent coefficients using any of the following functions, or combinations thereof (including constants) can be compiled directly into C-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atan2', 'atanh', 'conj',; 'cos', 'cosh','exp', 'imag', 'log', 'pow', 'proj, 'real', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh'. If you require mathematical functions other than those listed above, than it is possible to call any of the functions in the numpy math library using the prefix np. before the function name in the string, i.e 'np.sin(t)'. The available functions can be found using; In [1]: import numpy as np. In [2]: np.array(dir(np.math)[6:]); Out[2]: ; array(['asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign',; 'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1',; 'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',; 'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10',; 'log1p', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh', 'sqrt',; 'tan', 'tanh', 'trunc'], ; dtype='|S9'). Finally option #3, expressing the Hamiltonian as a Python function, is the original method for time dependence in QuTiP 1.x. H",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Usability,simpl,simply,"avity decay rate. In [13]: c_ops.append(np.sqrt(kappa) * a). In [14]: gamma = 6 # Atomic decay rate. In [15]: c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u. In [16]: c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. In [17]: t = np.linspace(-15, 15, 100) # Define time vector. In [18]: psi0 = tensor(basis(N, 0), ustate) # Define initial state. In [19]: state_GG = tensor(basis(N, 1), ground) # Define states onto which to project. In [20]: sigma_GG = state_GG * state_GG.dag(). In [21]: state_UU = tensor(basis(N, 0), ustate). In [22]: sigma_UU = state_UU * state_UU.dag(). In [23]: g = 5 # coupling strength. In [24]: H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term. In [25]: H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; In [26]: def H1_coeff(t, args):; ....: return 9 * np.exp(-(t / 5.) ** 2); ....: . In this case, the return value dependents only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); In [27]: H = [H0,[H1,H1_coeff]]. In [28]: output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; In [29]: output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]); 10.0%. Run time: 0.56s. Est. time left: 00:00:00:05; 20.0%. Run time: 1.08s. Est. time left: 00:00:00:04; 30.0%. Run time: 1.64s. Est. time left: 00:00:00:03; 40.0%. Run time: 2.31s. Est. time left: 00:00:00:03; 50.0%. Run time: 2.90s. Est. time left: 00:00:00:02; 60.0%. Run time: 3.49s. Est. time left: 00:00:00:02;",MatchSource.WIKI,docs/3.1.0/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/guide/dynamics/dynamics-time.html
Deployability,install,installation,"﻿. qutip.bloch — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch.html
Usability,simpl,simple,"s transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_width : int {1}; Width of wireframe.; point_color : list {[""b"",""r"",""g"",""#CC6600""]}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('b').; point_marker : list {[""o"",""s"",""d"",""^""]}; List of point marker shapes to cycle through.; point_size : list {[25,32,35,45]}; List of point marker sizes. Note, not all point markers look; the same size when plotted!; sphere_alpha : float {0.2}; Transparency of Bloch sphere itself.; sphere_color : str {'#FFDDDD'}; Color of Bloch sphere.; figsize : list {[7,7]}; Figure size of Bloch sphere plot. Best to have both numbers the same;; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {[""g"",""#CC6600"",""b"",""r""]}; List of vector colors to cycle through.; vector_width : int {5}; Width of displayed vectors.; vector_style : str {'-|>', 'simple', 'fancy', ''}; Vector arrowhead style (from matplotlib's arrow style).; vector_mutation : int {20}; Width of vectors arrowhead.; view : list {[-60,30]}; Azimuthal and Elevation viewing angles.; xlabel : list {[""$x$"",""""]}; List of strings corresponding to +x and -x axes labels, respectively.; xlpos : list {[1.1,-1.1]}; Positions of +x and -x labels respectively.; ylabel : list {[""$y$"",""""]}; List of strings corresponding to +y and -y axes labels, respectively.; ylpos : list {[1.2,-1.2]}; Positions of +y and -y labels respectively.; zlabel : list {[r'$\\left|0\\right>$',r'$\\left|1\\right>$']}; List of strings corresponding to +z and -z axes labels, respectively.; zlpos : list {[1.2,-1.2]}; Positions of +z and -z labels respectively. """"""; def __init__(self, fig=None, axes=None, view=None, figsize=None,; background=False):. # Figure and axes; self.fig = fig; self.axes = axes; # Background axes, default = False; self.background = background; # The size of the figure in inches, default = [5,5].; self.figsiz",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch.html
Deployability,install,installation,"﻿. qutip.bloch3d — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch3d; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch3d.html
Usability,clear,clear,"""\n""; s += ""frame_radius: "" + str(self.frame_radius) + ""\n""; s += ""point_color: "" + str(self.point_color) + ""\n""; s += ""point_mode: "" + str(self.point_mode) + ""\n""; s += ""point_size: "" + str(self.point_size) + ""\n""; s += ""sphere_alpha: "" + str(self.sphere_alpha) + ""\n""; s += ""sphere_color: "" + str(self.sphere_color) + ""\n""; s += ""size: "" + str(self.size) + ""\n""; s += ""vector_alpha: "" + str(self.vector_alpha) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_head_height: "" + str(self.vector_head_height) + ""\n""; s += ""vector_head_radius: "" + str(self.vector_head_radius) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. [docs] def clear(self):; """"""Resets the Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []. [docs] def add_points(self, points, meth='s'):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array/list; Collection of data points. meth : str {'s','m'}; Type of points to plot, use 'm' for multicolored. """"""; if not isinstance(points[0], (list, np.ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = np.array(points); if meth == 's':; if len(points[0]) == 1:; pnts = np.array(; [[points[0][0]], [points[1][0]], [points[2][0]]]); pnts = np.append(pnts, points, axis=1); else:; pnts = points; self.points.append(pnts); self.point_style.append('s'); else:; self.points.append(points); self.point_style.append('m'). [docs] def add_states(self, state, kind='vector'):; """"""Add a state vector Qobj to Bloch sphere. Parameters; ----------; state : qobj; Input state vector. kind : str {'vector','point'}; Type of object to plot. """"""; if isinstance(stat",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch3d.html
Deployability,install,installation,"﻿. qutip.bloch_redfield — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.bloch_redfield; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following d",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html
Energy Efficiency,power,power," are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for calculting the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj) or not a.isherm:; raise TypeError(""Operators in a_ops must be Hermitian Qobj.""). # default spectrum; if not spectra_cb:; spectra_cb = [lambda w: 1.0 for _ in a_ops]. # use the eigenbasis; evals, ekets = H.eigenstates(). N = len(evals); K = len(a_ops); A = np.zeros((K, N, N), dtype=complex) # TODO: use sparse here; W = np.zeros((N, N)). # pre-calculate matrix elements; for n in range(N):; for m in range(N):; W[m, n] = np.real(evals",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html
Integrability,integrat,integrate,"n permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['brmesolve', 'bloch_redfield_solve', 'bloch_redfield_tensor']. import numpy as np; import scipy.integrate. from qutip.qobj import Qobj, isket; from qutip.superoperator import spre, spost, vec2mat, mat2vec, vec2mat_index; from qutip.expect import expect; from qutip.solver import Options; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.solver import Result; from qutip.superoperator import liouvillian. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops, e_ops=[], spectra_cb=[], c_ops=None,; args={}, options=Options()):; """"""; Solve the dynamics for a system using the Bloch-Redfield master equation. .. note::. This solver does not currently support time-dependent Hamiltonians. Parameters; ----------. H : :class:`qutip.Qobj`; System Hamiltonian. rho0 / psi0: :class:`qutip.Qobj`; Initial density matrix or state vector (ket). tlist : *list* / *array*; List of times for :math:`t`. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to bath degrees ",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html
Modifiability,coupling,coupling,"rder,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); for t_idx, _ in enumerate(tlist):. if not r.successful():; break. rho_eb.data = vec2mat(r.y). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). return result_list. # -----------------------------------------------------------------------------; # Functions for calculting the Bloch-Redfield tensor for a time-independent; # system.; #; [docs]def bloch_redfield_tensor(H, a_ops, spectra_cb, c_ops=None, use_secular=True):; """"""; Calculate the Bloch-Redfield tensor for a system given a set of operators; and corresponding spectral functions that describes the system's coupling; to its environment. .. note::. This tensor generation requires a time-independent Hamiltonian. Parameters; ----------. H : :class:`qutip.qobj`; System Hamiltonian. a_ops : list of :class:`qutip.qobj`; List of system operators that couple to the environment. spectra_cb : list of callback functions; List of callback functions that evaluate the noise power spectrum; at a given frequency. c_ops : list of :class:`qutip.qobj`; List of system collapse operators. use_secular : bool; Flag (True of False) that indicates if the secular approximation should; be used. Returns; -------. R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`. R is the Bloch-Redfield tensor and kets is a list eigenstates of the; Hamiltonian. """""". # Sanity checks for input parameters; if not isinstance(H, Qobj):; raise TypeError(""H must be an instance of Qobj""). for a in a_ops:; if not isinstance(a, Qobj)",MatchSource.WIKI,docs/3.1.0/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/bloch_redfield.html
Deployability,install,installation,"﻿. qutip.continuous_variables — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.continuous_variables; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the",MatchSource.WIKI,docs/3.1.0/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/continuous_variables.html
Modifiability,variab,variable,"re without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; """"""; Given a basis set of operators :math:`\\{a\\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \\langle a_m a_n \\rangle. Parameters; ----------. basis : list of :class:`qutip.qobj.Qobj`; List of operators that defines the basis for the correlation matrix. rho : :class:`qutip.qobj.Qobj`; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------. corr_mat: *array*; A 2-dimensional *array* of correlation values or operators. """""". if rho is None:; # return array of opera",MatchSource.WIKI,docs/3.1.0/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/continuous_variables.html
Testability,log,logarithmic,"`qutip.qobj.Qobj`; Field operator for mode 1. a2 : :class:`qutip.qobj.Qobj`; Field operator for mode 2. R : *array*; The quadrature correlation matrix. rho : :class:`qutip.qobj.Qobj`; Density matrix for which to calculate the covariance matrix. Returns; -------. cov_mat: *array*; A 2-dimensional *array* of covariance values. """"""; if R is not None:. if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=object); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=object). elif a1 is not None and a2 is not None:. if rho is not None:; x1 = (a1 + a1.dag()) / np.sqrt(2); p1 = -1j * (a1 - a1.dag()) / np.sqrt(2); x2 = (a2 + a2.dag()) / np.sqrt(2); p2 = -1j * (a2 - a2.dag()) / np.sqrt(2); return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""). else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V):; """"""; Calculate the logarithmic negativity given the symmetrized covariance; matrix, see :func:`qutip.continous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. Returns; -------. N: *float*, the logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """""". A = V[0:2, 0:2]; B = V[2:4, 2:4]; C = V[0:2, 2:4]. sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu). return logneg. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/continuous_variables.html
Availability,error,errors,"j`; Initial state density matrix :math:`\\rho(t_0)` or state vector; :math:`\\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. reverse : bool; If `True`, calculate :math:`\left<A(t)B(t+\\tau)\\right>` instead of; :math:`\left<A(t+\\tau)B(t)\\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : :class:`qutip.solver.Options`; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec: *array*; An *array* of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\\tau)B(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian. state0 : :class:`qutip.qobj.Qobj`; Initial state density matrix :mat",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Deployability,install,installation,"﻿. qutip.correlation — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.correlation; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Energy Efficiency,power,power,"ics (uses steady state rho0). Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian. wlist : *list* / *array*; list of frequencies for :math:`\\omega`. c_ops : list of :class:`qutip.qobj`; list of collapse operators. a_op : :class:`qutip.qobj`; operator A. b_op : :class:`qutip.qobj`; operator B. solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse). use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------. spectrum: *array*; An *array* with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(taulist, y):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------. tlist : *list* / *array*; list/array of times :math:`t` which the correlation function is given. y : *list* / *array*; list/array of correlations corresponding to time delays :math:`t`. Returns; -------. w, S : *tuple*; Returns an array of angular frequencies 'w' and the corresponding; one-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]). N = len(taulist); dt = taulist[1] - taulist[0]. F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # select only indices for elements that corresponds; # to positive frequencies; indices = np.where(f > 0.0). return 2 * np.pi * f[indices], 2 * dt * np.real(F[indices]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Integrability,depend,dependent,"events divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec: *array*; An *array* of correlation values for the times specified by `taulist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args=None,; options=Options(ntraj=[20, 100])):; """"""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\\tau)C(t)\\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math: `\\tau<0`. Parameters; ----------. H : :class:`qutip.qobj.Qobj`; system Hamiltonian, or a callback function for time-dependent; Hamiltonians. rho0 : :class:`qutip.qobj.Qobj`; Initial state density matrix :math:`\\rho_0` or state vector; :math:`\\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : *list* / *array*; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. :math:`t \rightarrow \infty`; here tlist is; automatically set, ignoring user input. taulist : *list* / *array*; list of times for :math:`\\tau`. taulist must be positive and contain; the element `0`. c_ops : list of :class:`qutip.qobj.Qobj`; list of collapse operators. (does not accept time dependence). a_op : :class:`qutip.qobj.Qobj`; operator A. b_op : :class:`qutip.qobj.Qobj`; operator B. c_op : :class:`qutip.qobj.Qobj`; operator C. solver : str; choice of solver (`me` for master-equation, `mc` fo",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Modifiability,evolve,evolve,"itive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); H_shifted, _args = _transform_H_t_shift(H, args). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Performance,load,loaded,"0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; if not isinstance(H, Qobj):; _args[""_t0""] = tlist[t_idx]. for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H_shifted, chi_0/chi_0.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H_shifted, chi/chi.norm(), taulist, c_ops, [b_op],; args=_args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat[t_idx, :] += \; 1/(4*options.ntraj[0]) * (c_tau[0] - c_tau[2] -; 1j*c_tau[1] + 1j*c_tau[3]); if t_idx == 1:; options.rhs_reuse = True. return corr_mat. # pseudo-inverse solvers. def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; """"""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\\tau)B(0)\\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full();",MatchSource.WIKI,docs/3.1.0/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/correlation.html
Deployability,install,installation,"﻿. qutip.distributions — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.distributions; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following dis",MatchSource.WIKI,docs/3.1.0/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/distributions.html
Energy Efficiency,reduce,reduced,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,docs/3.1.0/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/distributions.html
Integrability,depend,depending,"cs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, style=""colormap"",; show_xlabel=True, show_ylabel=True):; """"""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""; n = len(self.xvecs); if n == 2:; if style == ""colormap"":; return self.visualize_2d_colormap(fig=fig, ax=ax,; figsize=figsize,; colorbar=colorbar,; cmap=cmap,; show_xlabel=show_xlabel,; show_ylabel=show_ylabel); else:; return self.visualize_2d_surface(fig=fi",MatchSource.WIKI,docs/3.1.0/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/distributions.html
Deployability,install,installation,"﻿. qutip.entropy — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.entropy; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html
Energy Efficiency,power,power," of a slected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html
Performance,concurren,concurrence,"d; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e."");",MatchSource.WIKI,docs/3.1.0/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html
Safety,avoid,avoid,"rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] http://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""to",MatchSource.WIKI,docs/3.1.0/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html
Testability,log,log," THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual',; 'concurrence', 'entropy_conditional', 'entangling_power']. from numpy import e, real, sort, sqrt; from scipy import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.qip.gates import swap. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of ",MatchSource.WIKI,docs/3.1.0/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/entropy.html
Deployability,install,installation,"﻿. qutip.essolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.essolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/essolve.html
Integrability,depend,depending,"RS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``",MatchSource.WIKI,docs/3.1.0/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/essolve.html
Deployability,install,installation,"﻿. qutip.expect — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.expect; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/expect.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/expect.html
Deployability,install,installation,"﻿. qutip.fileio — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.fileio; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html
Performance,load,loaded,"ns""); M += 1. #; # read data and store in a matrix; #; f.seek(0). if numtype == ""complex"":; data = np.zeros((M, N), dtype=""complex""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = complex(item); n += 1; m += 1. else:; data = np.zeros((M, N), dtype=""float""); m = n = 0; for line in f:; # skip comment lines; if line[0] == '#' or line[0] == '%':; continue; n = 0; for item in line.rstrip().split(sep):; data[m, n] = float(item); n += 1; m += 1. f.close(). return data. [docs]def qsave(data, name='qutip_data'):; """"""; Saves given data to file named 'filename.qu' in current directory. Parameters; ----------; data : instance/array_like; Input Python object to be stored.; filename : str; Name of output data file. """"""; # open the file for writing; fileObject = open(name + '.qu', 'wb'); # this writes the object a to the file named 'filename.qu'; pickle.dump(data, fileObject); fileObject.close(). [docs]def qload(name):; """"""; Loads data file from file named 'filename.qu' in current directory. Parameters; ----------; name : str; Name of data file to be loaded. Returns; -------; qobject : instance / array_like; Object retrieved from requested file. """"""; fileObject = open(name + '.qu', 'rb') # open the file for reading; out = pickle.load(fileObject) # return the object from the file; if isinstance(out, Qobj): # for quantum objects; print('Loaded Qobj object:'); str1 = ""Quantum object: "" + ""dims = "" + str(out.dims) \; + "", shape = "" + str(out.shape) + "", type = "" + out.type; if out.type == 'oper' or out.type == 'super':; str1 += "", isHerm = "" + str(out.isherm) + ""\n""; else:; str1 += ""\n""; print(str1); elif isinstance(out, Result):; print('Loaded Result object:'); print(out); else:; print(""Loaded "" + str(type(out).__name__) + "" object.""); return out. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/fileio.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/fileio.html
Deployability,install,installation,"﻿. qutip.floquet — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.floquet; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html
Energy Efficiency,energy,energy,"ort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi = -eargs / T. # sort by the quasi energy; if sort:; order = np.argsort(-e_quasi); else:; order = list(range(len(evals))). # prepare a list of kets for the floquet states; new_dims = [U.dims[0], [1] * len(U.dims[0])]; new_shape = [U.shape[0], 1]; kets_order = [Qobj(np.matrix(evecs[:, o]).T,; dims=new_dims, shape=new_shape) for o in order]. return kets_order, e_quasi[order]. [docs]def floquet_modes_t(f_modes_0, f_energies, t, H, T, args=None):; """"""; Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the; initial Floquet modes Phi_alpha(0). Parameters; ----------. f_modes_0 : list of :class:`qutip.qobj` (kets); Floquet modes at :math:`t`. f_energies : list; Floquet energies. t : float; The time at which to evaluate the floquet modes. H : :class:`qutip.qobj`; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html
Integrability,depend,dependent,"tionType; from qutip.qobj import Qobj, isket; from qutip.superoperator import vec2mat_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs +",MatchSource.WIKI,docs/3.1.0/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html
Modifiability,variab,variables,"perator import vec2mat_index, mat2vec, vec2mat; from qutip.mesolve import mesolve; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.states import projection; from qutip.solver import Options; from qutip.propagator import propagator; from qutip.solver import Result; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.expect import expect; from qutip.utilities import n_thermal. [docs]def floquet_modes(H, T, args=None, sort=False, U=None):; """"""; Calculate the initial Floquet modes Phi_alpha(0) for a driven system with; period T. Returns a list of :class:`qutip.qobj` instances representing the Floquet; modes and a list of corresponding quasienergies, sorted by increasing; quasienergy in the interval [-pi/T, pi/T]. The optional parameter `sort`; decides if the output is to be sorted in increasing quasienergies or not. Parameters; ----------. H : :class:`qutip.qobj`; system Hamiltonian, time-dependent with period `T`. args : dictionary; dictionary with variables required to evaluate H. T : float; The period of the time-dependence of the hamiltonian. The default value; 'None' indicates that the 'tlist' spans a single period of the driving. U : :class:`qutip.qobj`; The propagator for the time-dependent Hamiltonian with period `T`.; If U is `None` (default), it will be calculated from the Hamiltonian; `H` using :func:`qutip.propagator.propagator`. Returns; -------. output : list of kets, list of quasi energies. Two lists: the Floquet modes as kets and the quasi energies. """""". if U is None:; # get the unitary propagator; U = propagator(H, T, [], args). # find the eigenstates for the propagator; evals, evecs = la.eig(U.full()). eargs = angle(evals). # make sure that the phase is in the interval [-pi, pi], so that; # the quasi energy is in the interval [-pi/T, pi/T] where T is the; # period of the driving. eargs += (eargs <= -2*pi) * (2*pi) +; # (eargs > 0) * (-2*pi); eargs += (eargs <= -pi) * (2 * pi) + (eargs > pi) * (-2 * pi); e_quasi ",MatchSource.WIKI,docs/3.1.0/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html
Usability,simpl,simple,"on Bloch-Redfield form, or perhaps; # we can use the Lindblad form master equation with some rotating frame; # approximations? ...; #; for a in range(N):; for b in range(N):; if a != b and abs(A[a, b]) > 0.0:; # only relaxation terms included...; c_ops.append(sqrt(A[a, b]) * projection(N, a, b)). return c_ops. def floquet_master_equation_tensor(Alist, f_energies):; """"""; Construct a tensor that represents the master equation in the floquet; basis (with constant Hamiltonian and collapse operators). Simplest RWA approximation [Grifoni et al, Phys.Rep. 304 229 (1998)]. Parameters; ----------. Alist : list; A list of Floquet-Markov master equation rate matrices. f_energies : array; The Floquet energies. Returns; -------. output : array. The Floquet-Markov master equation tensor `R`. """""". if isinstance(Alist, list):; # Alist can be a list of rate matrices corresponding; # to different operators that couple to the environment; N, M = np.shape(Alist[0]); else:; # or a simple rate matrix, in which case we put it in a list; Alist = [Alist]; N, M = np.shape(Alist[0]). R = Qobj(scipy.sparse.csr_matrix((N * N, N * N)), [[N, N], [N, N]],; [N * N, N * N]). R.data = R.data.tolil(); for I in range(N * N):; a, b = vec2mat_index(N, I); for J in range(N * N):; c, d = vec2mat_index(N, J). R.data[I, J] = -1.0j * (f_energies[a] - f_energies[b]) * \; (a == c) * (b == d). for A in Alist:; s1 = s2 = 0; for n in range(N):; s1 += A[a, n] * (n == c) * (n == d) - A[n, a] * \; (a == c) * (a == d); s2 += (A[n, a] + A[n, b]) * (a == c) * (b == d). dR = (a == b) * s1 - 0.5 * (1 - (a == b)) * s2. if dR != 0.0:; R.data[I, J] += dR. R.data = R.data.tocsr(); return R. def floquet_master_equation_steadystate(H, A):; """"""; Returns the steadystate density matrix (in the floquet basis!) for the; Floquet-Markov master equation.; """"""; c_ops = floquet_collapse_operators(A); rho_ss = steadystate(H, c_ops); return rho_ss. def floquet_basis_transform(f_modes, f_energies, rho0):; """"""; Make a basis transform that tak",MatchSource.WIKI,docs/3.1.0/modules/qutip/floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/floquet.html
Deployability,install,installation,"﻿. qutip.graph — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.graph; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; # 2",MatchSource.WIKI,docs/3.1.0/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html
Integrability,rout,routines," endorse or promote products derived; # from this software without specific prior written permission.; #; # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains a collection of graph theory routines used mainly; to reorder matrices for iterative steady state solvers.; """""". __all__ = ['graph_degree', 'breadth_first_search', 'reverse_cuthill_mckee',; 'maximum_bipartite_matching', 'weighted_bipartite_matching']. import numpy as np; import scipy.sparse as sp; from qutip.cy.graph_utils import (; _breadth_first_search, _node_degrees,; _reverse_cuthill_mckee, _maximum_bipartite_matching,; _weighted_bipartite_matching). [docs]def graph_degree(A):; """"""; Returns the degree for the nodes (rows) of a symmetric; graph in sparse CSR or CSC format, or a qobj. Parameters; ----------; A : qobj, csr_matrix, csc_matrix; Input quantum object or csr_matrix. Returns; -------; degree : array; Array of integers giving the degree for each node (row). """"""; if not (sp.isspmatrix_csc(A) or sp.isspmatrix_csr(A)):; raise TypeError('Input must be CSC or CSR sparse matrix.'); return _node_degrees(A.indices, A.indptr, A.shape[0]). [docs]def breadth_first_search(A, start):; """,MatchSource.WIKI,docs/3.1.0/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html
Performance,perform,performing,"s). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. [docs]def weighted_bipartite_matching(A, perm_type='row'):; """"""; Returns an array of row permutations that attempts to maximize; the product of the ABS values of the diagonal elements in; a nonsingular square CSC sparse matrix. Such a permutation is; always possible provided that the matrix is nonsingular. This function looks at both the structure and ABS values of the; underlying matrix. Parameters; ----------; A : csc_matrix; Input matrix. perm_type : str {'row', 'column'}; Type of permutation to generate. Returns; -------; perm : array; Array of row or column permutations. Notes; -----; This function uses a weighted maximum cardinality bipartite matching; algorithm based on breadth-first search (BFS). The columns are weighted; according to the element of max ABS value in the associated rows and; are traversed in descending order by weight. When performing the BFS; traversal, the row associated to a given column is the one with maximum; weight. Unlike other techniques[1]_, this algorithm does not guarantee the; product of the diagonal is maximized. However, this limitation is offset; by the substantially faster runtime of this method. References; ----------; .. [1] I. S. Duff and J. Koster, ""The design and use of algorithms for; permuting large entries to the diagonal of sparse matrices"", SIAM J.; Matrix Anal. and Applics. 20, no. 4, 889 (1997). """"""; nrows = A.shape[0]; if A.shape[0] != A.shape[1]:; raise ValueError('weighted_bfs_matching requires a square matrix.'). if sp.isspmatrix_csr(A) or sp.isspmatrix_coo(A):; A = A.tocsc(); elif not sp.isspmatrix_csc(A):; raise TypeError(""matrix must be in CSC, CSR, or COO format.""). if perm_type == 'column':; A = A.transpose().tocsc(). perm = _weighted_bipartite_matching(; np.asarray(np.abs(A.data), dtype=float),; A.indices, A.indptr, nrows). if np.any(perm == -1):; raise Exception('Possibly singular input matrix.'). return perm. B",MatchSource.WIKI,docs/3.1.0/modules/qutip/graph.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/graph.html
Availability,avail,available,"Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on the IPython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Deployability,install,installation,"﻿. qutip.ipynbtools — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.ipynbtools; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Energy Efficiency,schedul,scheduling,",0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remaining_est(p)); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, p) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)); # display(Javascript(""$('div#%s').width('%i%%')"" % (self.divid,; # p))); self.p_chunk += self.p_chunk_size. def finished(self):; self.t_done = time.time(); lbl = ""Elapsed time: %s"" % self.time_elapsed(); js_code = (""$('div#%s').width('%i%%');"" % (self.divid, 100.0) +; ""$('p#%s').text('%s');"" % (self.textid, lbl)); display(Javascript(js_code)). def _visualize_parfor_data(metadata):; """"""; Visualizing the task scheduling meta data collected from AsyncResults.; """"""; res = numpy.array(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``cl",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Integrability,depend,dependencies,"ICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module contains utility functions for using QuTiP with IPython notebooks.; """""". __all__ = ['version_table', 'parfor', 'plot_animation', 'parallel_map']. from qutip.ui.progressbar import BaseProgressBar. from IPython.parallel import Client; from IPython.display import HTML, Javascript, display. import matplotlib.pyplot as plt; from matplotlib import animation. import datetime; import uuid; import sys; import os; import time; import inspect. import qutip; import numpy; import scipy; import Cython; import matplotlib; import IPython. [docs]def version_table(verbose=False):; """"""; Print an HTML-formatted table with version numbers for QuTiP and its; dependencies. Use it in a IPython notebook to show which versions of; different packages that were used to run the notebook. This should make it; possible to reproduce the environment and the calculation later on. Returns; --------; version_table: string; Return an HTML-formatted string containing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = {""QuTiP"": qutip.__version__,; ""Numpy"": numpy.__version__,; ""SciPy"": scipy.__version__,; ""matplotlib"": matplotlib.__version__,; ""Cython"": Cython.__version__,; ""Python"": sys.version,; ""IPython"": IPython.__version__,; ""OS"": ""%s [%s]"" % (os.name, sys.platform); }. for name in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, packages[name]). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>I",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Performance,load,load-balanced,"rray(metadata); fig, ax = plt.subplots(figsize=(10, res.shape[1])). yticks = []; yticklabels = []; tmin = min(res[:, 1]); for n, pid in enumerate(numpy.unique(res[:, 0])):; yticks.append(n); yticklabels.append(""%d"" % pid); for m in numpy.where(res[:, 0] == pid)[0]:; ax.add_patch(plt.Rectangle((res[m, 1] - tmin, n - 0.25),; res[m, 2] - res[m, 1], 0.5, color=""green"", alpha=0.5)). ax.set_ylim(-.5, n + .5); ax.set_xlim(0, max(res[:, 2]) - tmin + 0.); ax.set_yticks(yticks); ax.set_yticklabels(yticklabels); ax.set_ylabel(""Engine""); ax.set_xlabel(""seconds""); ax.set_title(""Task schedule""). [docs]def parfor(task, task_vec, args=None, client=None, view=None,; show_scheduling=False, show_progressbar=False):; """"""; Call the function ``tast`` for each value in ``task_vec`` using a cluster; of IPython engines. The function ``task`` should have the signature; ``task(value, args)`` or ``task(value)`` if ``args=None``. The ``client`` and ``view`` are the IPython.parallel client and; load-balanced view that will be used in the parfor execution. If these; are ``None``, new instances will be created. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. task_vec: array / list; The list or array of values for which the ``task`` function is to be; evaluated. args: list / dictionary; The optional additional argument to the ``task`` function. For example; a dictionary with parameter values. client: IPython.parallel.Client; The IPython.parallel Client instance that will be used in the; parfor execution. view: a IPython.parallel.Client view; The view that is to be used in scheduling the tasks on the IPython; cluster. Preferably a load-balanced view, which is obtained from the; IPython.parallel.Client instance client by calling,; view = client.load_balanced_view(). show_scheduling: bool {False, True}, default False; Display a graph showing how the tasks (the evaluation of ``task`` for; for the value in ``task_vec1``) was scheduled on",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Safety,timeout,timeout,"ython engine; cluster. show_progressbar: bool {False, True}, default False; Display a HTML-based progress bar during the execution of the parfor; loop. Returns; --------; result : list; The result list contains the value of; ``task(value, task_args, task_kwargs)`` for each; value in ``values``. """"""; submitted = datetime.datetime.now(). if task_args is None:; task_args = tuple(). if task_kwargs is None:; task_kwargs = {}. if client is None:; client = Client(). # make sure qutip is available at engines; dview = client[:]; dview.block = True; dview.execute(""from qutip import *""). if view is None:; view = client.load_balanced_view(). ar_list = [view.apply_async(task, value, *task_args, **task_kwargs); for value in values]. if progress_bar is None:; view.wait(ar_list); else:; if progress_bar is True:; progress_bar = HTMLProgressBar(). n = len(ar_list); progress_bar.start(n); while True:; n_finished = sum([ar.progress for ar in ar_list]); progress_bar.update(n_finished). if view.wait(ar_list, timeout=0.5):; progress_bar.update(n); break; progress_bar.finished(). if show_scheduling:; metadata = [[ar.engine_id,; (ar.started - submitted).total_seconds(),; (ar.completed - submitted).total_seconds()]; for ar in ar_list]; _visualize_parfor_data(metadata). return [ar.get() for ar in ar_list]. def plot_animation(plot_setup_func, plot_func, result, name=""movie"",; verbose=False):; """"""; Create an animated plot of a Result object, as returned by one of; the qutip evolution solvers. .. note :: experimental; """""". fig, axes = plot_setup_func(result). def update(n):; plot_func(result, n, fig=fig, axes=axes). anim = animation.FuncAnimation(; fig, update, frames=len(result.times), blit=True). anim.save(name + '.mp4', fps=10, writer=""avconv"", codec=""libx264""). plt.close(fig). if verbose:; print(""Created %s.m4v"" % name). video = open(name + '.mp4', ""rb"").read(); video_encoded = video.encode(""base64""); video_tag = '<video controls src=""data:video/x-m4v;base64,{0}"">'.format(; video_encoded); r",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Usability,simpl,simple,"ing version information for; QuTiP dependencies. """""". html = ""<table>""; html += ""<tr><th>Software</th><th>Version</th></tr>"". packages = {""QuTiP"": qutip.__version__,; ""Numpy"": numpy.__version__,; ""SciPy"": scipy.__version__,; ""matplotlib"": matplotlib.__version__,; ""Cython"": Cython.__version__,; ""Python"": sys.version,; ""IPython"": IPython.__version__,; ""OS"": ""%s [%s]"" % (os.name, sys.platform); }. for name in packages:; html += ""<tr><td>%s</td><td>%s</td></tr>"" % (name, packages[name]). if verbose:; html += ""<tr><th colspan='2'>Additional information</th></tr>""; qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); html += (""<tr><td>Installation path</td><td>%s</td></tr>"" %; qutip_install_path); try:; import getpass; html += (""<tr><td>User</td><td>%s</td></tr>"" %; getpass.getuser()); except:; pass. html += ""<tr><td colspan='2'>%s</td></tr>"" % time.strftime(; '%a %b %d %H:%M:%S %Y %Z'); html += ""</table>"". return HTML(html). class HTMLProgressBar(BaseProgressBar):; """"""; A simple HTML progress bar for using in IPython notebooks. Based on; IPython ProgressBar demo notebook:; https://github.com/ipython/ipython/tree/master/examples/notebooks. Example usage:. n_vec = linspace(0, 10, 100); pbar = HTMLProgressBar(len(n_vec)); for n in n_vec:; pbar.update(n); compute_with_n(n); """""". def __init__(self, iterations=0, chunk_size=1.0):; self.divid = str(uuid.uuid4()); self.textid = str(uuid.uuid4()); self.pb = HTML(""""""\; <div style=""border: 2px solid grey; width: 600px"">; <div id=""%s"" \; style=""background-color: rgba(121,195,106,0.75); width:0%%"">&nbsp;</div>; </div>; <p id=""%s""></p>; """""" % (self.divid, self.textid)); display(self.pb); super(HTMLProgressBar, self).start(iterations, chunk_size). def start(self, iterations=0, chunk_size=1.0):; super(HTMLProgressBar, self).start(iterations, chunk_size). def update(self, n):; p = (n / self.N) * 100.0; if p >= self.p_chunk:; lbl = (""Elapsed time: %s. "" % self.time_elapsed() +; ""Est. remaining time: %s."" % self.time_remainin",MatchSource.WIKI,docs/3.1.0/modules/qutip/ipynbtools.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/ipynbtools.html
Availability,toler,tolerance," config.h_ind,; config.h_ptr). # initialize ODE solver for RHS; ODE._integrator = qutip_zvode(; method=opt.method, order=opt.order, atol=opt.atol,; rtol=opt.rtol, nsteps=opt.nsteps, first_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp =",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Deployability,install,installation,"﻿. qutip.mcsolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.mcsolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Energy Efficiency,reduce,reduced," CLASS; # -----------------------------------------------------------------------------; class _MC():; """"""; Private class for solving Monte Carlo evolution from mcsolve; """""". def __init__(self, config):. self.config = config; # set output variables, even if they are not used to simplify output; # code.; self.psi_out = None; self.expect_out = []; self.collapse_times_out = None; self.which_op_out = None. # FOR EVOLUTION WITH COLLAPSE OPERATORS; if config.c_num:; # preallocate ntraj arrays for state vectors, collapse times, and; # which operator; self.collapse_times_out = np.zeros(config.ntraj, dtype=np.ndarray); self.which_op_out = np.zeros(config.ntraj, dtype=np.ndarray); if config.e_num == 0 or config.options.store_states:; self.psi_out = [None] * config.ntraj; if config.e_num > 0:; self.expect_out = [None] * config.ntraj. # setup seeds array; if self.config.options.seeds is None:; self.config.options.seeds = \; random_integers(1e8, size=config.ntraj); else:; # if ntraj was reduced but reusing seeds; seed_length = len(config.options.seeds); if seed_length > config.ntraj:; self.config.options.seeds = \; config.options.seeds[0:config.ntraj]; # if ntraj was increased but reusing seeds; elif seed_length < config.ntraj:; newseeds = random_integers(; 1e8, size=(config.ntraj - seed_length)); self.config.options.seeds = np.hstack(; (config.options.seeds, newseeds)). def run(self):. if debug:; print(inspect.stack()[0][3]). if self.config.c_num == 0:; self.config.ntraj = 1; if self.config.e_num == 0 or self.config.options.store_states:; self.expect_out, self.psi_out = \; _evolve_no_collapse_psi_out(self.config); else:; self.expect_out = _evolve_no_collapse_expect_out(self.config). else:; # set arguments for input to monte carlo; map_kwargs = {'progress_bar': self.config.progress_bar,; 'num_cpus': self.config.options.num_cpus}; map_kwargs.update(self.config.map_kwargs). task_args = (self.config, self.config.options,; self.config.options.seeds); task_kwargs = {}. results = conf",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Integrability,integrat,integrate,"RIGHT HOLDERS AND CONTRIBUTORS; # ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = s",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Modifiability,config,config,"F SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for ",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Performance,load,loaded,"#########. __all__ = ['mcsolve']. import os; from types import FunctionType; import numpy as np; from numpy.random import RandomState, random_integers; from scipy.integrate import ode; import scipy.sparse as sp; from scipy.integrate._ode import zvode; from scipy.linalg.blas import get_blas_funcs; from qutip.qobj import Qobj; from qutip.parallel import parfor, parallel_map, serial_map; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_expect_psi_csr, spmv, spmv_csr; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.solver import Options, Result, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.ui.progressbar import TextProgressBar, BaseProgressBar; import qutip.settings. dznrm2 = get_blas_funcs(""znrm2"", dtype=np.float64). if debug:; import inspect. #; # Internal, global variables for storing references to dynamically loaded; # cython functions; #; _cy_col_spmv_func = None; _cy_col_expect_func = None; _cy_col_spmv_call_func = None; _cy_col_expect_call_func = None; _cy_rhs_func = None. class qutip_zvode(zvode):; def step(self, *args):; itask = self.call_args[2]; self.rwork[0] = args[4]; self.call_args[2] = 5; r = self.run(*args); self.call_args[2] = itask; return r. [docs]def mcsolve(H, psi0, tlist, c_ops, e_ops, ntraj=None,; args={}, options=None, progress_bar=True,; map_func=None, map_kwargs=None):; """"""Monte Carlo evolution of a state vector :math:`|\psi \\rangle` for a; given Hamiltonian and sets of collapse operators, and possibly, operators; for calculating expectation values. Options for the underlying ODE solver; are given by the Options class. mcsolve supports time-dependent Hamiltonians and collapse operators using; either Python functions of strings to represent time-dependent; coefficients. Note that, the system Hamiltonian MUST have at least one; constant term. As an example of a time-dependent problem, consider a Hamiltonian with two; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Testability,log,log,"irst_step=opt.first_step,; min_step=opt.min_step, max_step=opt.max_step). if not len(ODE._y):; ODE.t = 0.0; ODE._y = np.array([0.0], complex); ODE._integrator.reset(len(ODE._y), ODE.jac is not None). # set initial conditions; ODE.set_initial_value(config.psi0, tlist[0]). # make array for collapse operator inds; cinds = np.arange(config.c_num). # RUN ODE UNTIL EACH TIME IN TLIST; for k in range(1, num_times):; # ODE WHILE LOOP FOR INTEGRATE UP TO TIME TLIST[k]; while ODE.t < tlist[k]:; t_prev = ODE.t; y_prev = ODE.y; norm2_prev = dznrm2(ODE._y) ** 2; # integrate up to tlist[k], one step at a time.; ODE.integrate(tlist[k], step=1); if not ODE.successful():; raise Exception(""ZVODE failed!""); norm2_psi = dznrm2(ODE._y) ** 2; if norm2_psi <= rand_vals[0]:; # collapse has occured:; # find collapse time to within specified tolerance; # ------------------------------------------------; ii = 0; t_final = ODE.t; while ii < config.norm_steps:; ii += 1; t_guess = t_prev + \; np.log(norm2_prev / rand_vals[0]) / \; np.log(norm2_prev / norm2_psi) * (t_final - t_prev); ODE._y = y_prev; ODE.t = t_prev; ODE._integrator.call_args[3] = 1; ODE.integrate(t_guess, step=0); if not ODE.successful():; raise Exception(; ""ZVODE failed after adjusting step size!""); norm2_guess = dznrm2(ODE._y)**2; if (np.abs(rand_vals[0] - norm2_guess) <; config.norm_tol * rand_vals[0]):; break; elif (norm2_guess < rand_vals[0]):; # t_guess is still > t_jump; t_final = t_guess; norm2_psi = norm2_guess; else:; # t_guess < t_jump; t_prev = t_guess; y_prev = ODE.y; norm2_prev = norm2_guess; if ii > config.norm_steps:; raise Exception(""Norm tolerance not reached. "" +; ""Increase accuracy of ODE solver or "" +; ""Options.norm_steps.""). collapse_times.append(ODE.t). # some string based collapse operators; if config.tflag in [1, 11]:; n_dp = [cy_expect_psi_csr(config.n_ops_data[i],; config.n_ops_ind[i],; config.n_ops_ptr[i],; ODE._y, 1); for i in config.c_const_inds]. _locals = locals(); # calculates the expectation value",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Usability,progress bar,progress bar,"oeff]]. c_ops = [C0, [C1, C1_coeff]]. args={'a': A, 'w': W}. or in String (Cython) format we could write::. H = [H0, [H1, 'sin(w*t)']]. c_ops = [C0, [C1, 'exp(-a*t)']]. args={'a': A, 'w': W}. Constant terms are preferably placed first in the Hamiltonian and collapse; operator lists. Parameters; ----------; H : :class:`qutip.Qobj`; System Hamiltonian. psi0 : :class:`qutip.Qobj`; Initial state vector. tlist : array_like; Times at which results are recorded. ntraj : int; Number of trajectories to run. c_ops : array_like; single collapse operator or ``list`` or ``array`` of collapse; operators. e_ops : array_like; single operator or ``list`` or ``array`` of operators for calculating; expectation values. args : dict; Arguments for time-dependent Hamiltonian and collapse operator terms. options : Options; Instance of ODE solver options. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Set to None to disable the; progress bar. map_func: function; A map function for managing the calls to the single-trajactory solver. map_kwargs: dictionary; Optional keyword arguments to the map_func function. Returns; -------; results : :class:`qutip.solver.Result`; Object storing all results from the simulation. .. note::. It is possible to reuse the random number seeds from a previous run; of the mcsolver by passing the output Result object seeds via the; Options class, i.e. Options(seeds=prev_result.seeds).; """""". if debug:; print(inspect.stack()[0][3]). if options is None:; options = Options(). if ntraj is None:; ntraj = options.ntraj. config.map_func = map_func if map_func is not None else parallel_map; config.map_kwargs = map_kwargs if map_kwargs is not None else {}. if not psi0.isket:; raise Exception(""Initial state must be a state vector.""). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e ",MatchSource.WIKI,docs/3.1.0/modules/qutip/mcsolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mcsolve.html
Availability,error,error,"re output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""mesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm and rho0.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if opt.store_states or expt_callback:; rho.data = vec2mat(r.y). if opt.store_states:; output.states.append(Qobj(rho)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; r.y, 1). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; _cython_build_cleanup(config.tdname). if opt.store_final_state:; rho.data = vec2mat(r.y); output.final_state = Qobj(rho). return output. # -----------------------------------------------------------------------------; # Old style API below.; # -----------------------------------------------------------------------------. # ----------------------------------------------------------------------",MatchSource.WIKI,docs/3.1.0/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html
Deployability,install,installation,"﻿. qutip.mesolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.mesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html
Integrability,integrat,integrate," NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]",MatchSource.WIKI,docs/3.1.0/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html
Modifiability,config,config,"L,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the Lindblad master equation and von Neumann; equation.; """""". __all__ = ['mesolve', 'odesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.sparse as sp; import scipy.integrate; import warnings. from qutip.qobj import Qobj, isket, isoper, issuper; from qutip.superoperator import spre, spost, liouvillian, mat2vec, vec2mat; from qutip.expect import expect_rho_vec; from qutip.solver import Options, Result, config; from qutip.cy.spmatfuncs import cy_ode_rhs, cy_ode_rho_func_td; from qutip.cy.codegen import Codegen; from qutip.cy.utilities import _cython_build_cleanup; from qutip.rhs_generate import rhs_generate; from qutip.states import ket2dm; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug. from qutip.sesolve import (_sesolve_list_func_td, _sesolve_list_str_td,; _sesolve_list_td, _sesolve_func_td, _sesolve_const). from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. if debug:; import inspect. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]def mesolve(H, rho0, tlist, c_ops, e_ops, args={}, options=None,; progress_bar=None):; """"""; Master equation evolution of a density matrix for a given Hamiltonian and; set of collapse operators, or a Liouvillian. Evolve t",MatchSource.WIKI,docs/3.1.0/modules/qutip/mesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/mesolve.html
Deployability,install,installation,"﻿. qutip.metrics — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.metrics; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/metrics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/metrics.html
Availability,error,error,"bj data =; [[ 1. 0.]; [ 0. -1.]]. """"""; return 2.0 * jmat(1.0 / 2, 'z'). #; # DESTROY returns annihilation operator for N dimensional Hilbert space; # out = destroy(N), N is integer value & N>0; #; [docs]def destroy(N, offset=0):; '''Destruction (lowering) operator. Parameters; ----------; N : int; Dimension of Hilbert space. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Returns; -------; oper : qobj; Qobj for lowering operator. Examples; --------; >>> destroy(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j]; [ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # raise error if N not integer; raise ValueError(""Hilbert space dimension must be integer value""); return Qobj(sp.spdiags(np.sqrt(range(offset, N+offset)),; 1, N, N, format='csr')). #; # create returns creation operator for N dimensional Hilbert space; # out = create(N), N is integer value & N>0; #; [docs]def create(N, offset=0):; '''Creation (raising) operator. Parameters; ----------; N : int; Dimension of Hilbert space. Returns; -------; oper : qobj; Qobj for raising operator. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the operator. Examples; --------; >>> create(4); Quantum object: dims = [[4], [4]], \; shape = [4, 4], type = oper, isHerm = False; Qobj data =; [[ 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 1.00000000+0.j 0.00000000+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 1.41421356+0.j 0.00000000+0.j 0.00000000+0.j]; [ 0.00000000+0.j 0.00000000+0.j 1.73205081+0.j 0.00000000+0.j]]. '''; if not isinstance(N, (int, np.integer)): # rais",MatchSource.WIKI,docs/3.1.0/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/operators.html
Deployability,install,installation,"﻿. qutip.operators — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.operators; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.",MatchSource.WIKI,docs/3.1.0/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/operators.html
Integrability,depend,dependencies,"ed in the; state space. Returns; -------; a_ops : list of qobj; A list of annihilation operators for each mode in the composite; quantum system described by dims.; """"""; from qutip.states import enr_state_dictionaries. nstates, state2idx, idx2state = enr_state_dictionaries(dims, excitations). a_ops = [sp.lil_matrix((nstates, nstates), dtype=np.complex); for _ in range(len(dims))]. for n1, state1 in idx2state.items():; for n2, state2 in idx2state.items():; for idx, a in enumerate(a_ops):; s1 = [s for idx2, s in enumerate(state1) if idx != idx2]; s2 = [s for idx2, s in enumerate(state2) if idx != idx2]; if (state1[idx] == state2[idx] - 1) and (s1 == s2):; a_ops[idx][n1, n2] = np.sqrt(state2[idx]). return [Qobj(a, dims=[dims, dims]) for a in a_ops]. [docs]def enr_identity(dims, excitations):; """"""; Generate the identity operator for the excitation-number restricted; state space defined by the `dims` and `exciations` arguments. See the; docstring for enr_fock for a more detailed description of these arguments. Parameters; ----------; dims : list; A list of the dimensions of each subsystem of a composite quantum; system. excitations : integer; The maximum number of excitations that are to be included in the; state space. state : list of integers; The state in the number basis representation. Returns; -------; op : Qobj; A Qobj instance that represent the identity operator in the; exication-number-restricted state space defined by `dims` and; `exciations`.; """"""; from qutip.states import enr_state_dictionaries. nstates, _, _ = enr_state_dictionaries(dims, excitations); data = sp.eye(nstates, nstates, dtype=np.complex); return Qobj(data, dims=[dims, dims]). # Break circular dependencies by a trailing import.; # Note that we use a relative import here to deal with that; # qutip.tensor is the *function* tensor, not the module.; from . import tensor. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/operators.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/operators.html
Deployability,install,installation,"﻿. qutip.parallel — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.parallel; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; ",MatchSource.WIKI,docs/3.1.0/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html
Modifiability,variab,variable,"CLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This function provides functions for parallel execution of loops and function; mappings, using the builtin Python module multiprocessing.; """"""; __all__ = ['parfor', 'parallel_map', 'serial_map']. from scipy import array; from multiprocessing import Pool; from functools import partial; import os; import sys; import signal; import qutip.settings as qset; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. def _task_wrapper(args):; try:; return args[0](*args[1]); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). def _task_wrapper_with_args(args, user_args):; try:; return args[0](*args[1], **user_args); except KeyboardInterrupt:; os.kill(args[2], signal.SIGINT); sys.exit(1). [docs]def parfor(func, *args, **kwargs):; """"""Executes a multi-variable function in parallel on the local machine. Parallel execution of a for-loop over function `func` for multiple input; arguments and keyword arguments. .. note::. From QuTiP 3.1.0, we recommend to use :func:`qutip.parallel_map`; instead of this function. Parameters; ----------; func : function_type; A function to run in parallel on the local machine. The function 'func'; accepts a series of arguments that are passed to the function as; variables. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input par",MatchSource.WIKI,docs/3.1.0/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html
Performance,perform,performance,"bles. In general, the function can have multiple input variables,; and these arguments must be passed in the same order as they are; defined in the function definition. In addition, the user can pass; multiple keyword arguments to the function. The following keyword argument is reserved:. num_cpus : int; Number of CPU's to use. Default uses maximum number of CPU's.; Performance degrades if num_cpus is larger than the physical CPU; count of your machine. Returns; -------; result : list; A ``list`` with length equal to number of input parameters; containing the output from `func`. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs.keys():; kw['num_cpus'] = kwargs['num_cpus']; del kwargs['num_cpus']; if len(kwargs) != 0:; task_func = partial(_task_wrapper_with_args, user_args=kwargs); else:; task_func = _task_wrapper. if kw['num_cpus'] > qset.num_cpus:; print(""Requested number of CPUs (%s) "" % kw['num_cpus'] +; ""is larger than physical number (%s)."" % qset.num_cpus); print(""Reduce 'num_cpus' for greater performance.""). pool = Pool(processes=kw['num_cpus']); args = [list(arg) for arg in args]; var = [[args[j][i] for j in range(len(args))]; for i in range(len(list(args[0])))]; try:; map_args = ((func, v, os.getpid()) for v in var); par_return = list(pool.map(task_func, map_args)). pool.terminate(); pool.join(). if isinstance(par_return[0], tuple):; par_return = [elem for elem in par_return]; num_elems = len(par_return[0]); dt = [type(ii) for ii in par_return[0]]; return [array([elem[ii] for elem in par_return], dtype=dt[ii]); for ii in range(num_elems)]; else:; return list(par_return). except KeyboardInterrupt:; pool.terminate(). [docs]def serial_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Serial mapping function with the same call signature as parallel_map, for; easy switching between serial and parallel execution. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. This function work a",MatchSource.WIKI,docs/3.1.0/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html
Safety,timeout,timeout,"e, *task_args, **task_kwargs); results.append(result); progress_bar.finished(). return results. [docs]def parallel_map(task, values, task_args=tuple(), task_kwargs={}, **kwargs):; """"""; Parallel execution of a mapping of `values` to the function `task`. This; is functionally equivalent to:. result = [task(value, *task_args, **task_kwargs) for value in values]. Parameters; ----------. task: a Python function; The function that is to be called for each value in ``task_vec``. values: array / list; The list or array of values for which the ``task`` function is to be; evaluated. task_args: list / dictionary; The optional additional argument to the ``task`` function. task_kwargs: list / dictionary; The optional additional keyword argument to the ``task`` function. progress_bar: ProgressBar; Progress bar class instance for showing progress. Returns; --------; result : list; The result list contains the value of; ``task(value, *task_args, **task_kwargs)`` for each; value in ``values``. """"""; kw = _default_kwargs(); if 'num_cpus' in kwargs:; kw['num_cpus'] = kwargs['num_cpus']. try:; progress_bar = kwargs['progress_bar']; if progress_bar is True:; progress_bar = TextProgressBar(); except:; progress_bar = BaseProgressBar(). progress_bar.start(len(values)); nfinished = [0]. def _update_progress_bar(x):; nfinished[0] += 1; progress_bar.update(nfinished[0]). try:; pool = Pool(processes=kw['num_cpus']). async_res = [pool.apply_async(task, (value,) + task_args, task_kwargs,; _update_progress_bar); for value in values]. while not all([ar.ready() for ar in async_res]):; for ar in async_res:; ar.wait(timeout=0.1). pool.terminate(); pool.join(). except KeyboardInterrupt as e:; pool.terminate(); pool.join(); raise e. progress_bar.finished(). return [ar.get() for ar in async_res]. def _default_kwargs():; settings = {'num_cpus': qset.num_cpus}; return settings. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/parallel.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/parallel.html
Availability,mask,mask," THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; #; # Significant parts of this code was contributed by Jonas Neergaard-Nielsen; ###############################################################################. __all__ = ['partial_transpose']. import numpy as np; import scipy.sparse as sp. from qutip.qobj import Qobj; from qutip.states import (state_index_number, state_number_index,; state_number_enumerate). [docs]def partial_transpose(rho, mask, method='dense'):; """"""; Return the partial transpose of a Qobj instance `rho`,; where `mask` is an array/list with length that equals; the number of components of `rho` (that is, the length of; `rho.dims[0]`), and the values in `mask` indicates whether; or not the corresponding subsystem is to be transposed.; The elements in `mask` can be boolean or integers `0` or `1`,; where `True`/`1` indicates that the corresponding subsystem; should be tranposed. Parameters; ----------. rho : :class:`qutip.qobj`; A density matrix. mask : *list* / *array*; A mask that selects which subsystems should be transposed. method : str; choice of method, `dense` or `sparse`. The default method; is `dense`. The `sparse` implementation can be faster for; large and sparse systems (hundreds of quantum states). Returns; -------. rho_pr: :class:`qutip.qobj`. A density matrix with the selected subsystems transposed. """"""; if method == 'sparse':; return _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based o",MatchSource.WIKI,docs/3.1.0/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html
Deployability,install,installation,"﻿. qutip.partial_transpose — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.partial_transpose; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the follo",MatchSource.WIKI,docs/3.1.0/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html
Performance,perform,performs,"urn _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html
Testability,test,testing,"urn _partial_transpose_sparse(rho, mask); else:; return _partial_transpose_dense(rho, mask). def _partial_transpose_dense(rho, mask):; """"""; Based on Jonas' implementation using numpy.; Very fast for dense problems.; """"""; nsys = len(mask); pt_dims = np.arange(2 * nsys).reshape(2, nsys).T; pt_idx = np.concatenate([[pt_dims[n, mask[n]] for n in range(nsys)],; [pt_dims[n, 1 - mask[n]] for n in range(nsys)]]). data = rho.data.toarray().reshape(; np.array(rho.dims).flatten()).transpose(pt_idx).reshape(rho.shape). return Qobj(data, dims=rho.dims). def _partial_transpose_sparse(rho, mask):; """"""; Implement the partial transpose using the CSR sparse matrix.; """""". data = sp.lil_matrix((rho.shape[0], rho.shape[1]), dtype=complex). for m in range(len(rho.data.indptr) - 1):. n1 = rho.data.indptr[m]; n2 = rho.data.indptr[m + 1]. psi_A = state_index_number(rho.dims[0], m). for idx, n in enumerate(rho.data.indices[n1:n2]):. psi_B = state_index_number(rho.dims[1], n). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). data[m_pt, n_pt] = rho.data.data[n1 + idx]. return Qobj(data.tocsr(), dims=rho.dims). def _partial_transpose_reference(rho, mask):; """"""; This is a reference implementation that explicitly loops over; all states and performs the transpose. It's slow but easy to; understand and useful for testing.; """""". A_pt = np.zeros(rho.shape, dtype=complex). for psi_A in state_number_enumerate(rho.dims[0]):; m = state_number_index(rho.dims[0], psi_A). for psi_B in state_number_enumerate(rho.dims[1]):; n = state_number_index(rho.dims[1], psi_B). m_pt = state_number_index(; rho.dims[1], np.choose(mask, [psi_A, psi_B])); n_pt = state_number_index(; rho.dims[0], np.choose(mask, [psi_B, psi_A])). A_pt[m_pt, n_pt] = rho.data[m, n]. return Qobj(A_pt, dims=rho.dims). Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/partial_transpose.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/partial_transpose.html
Deployability,install,installation,"﻿. qutip.propagator — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.propagator; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaime",MatchSource.WIKI,docs/3.1.0/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html
Integrability,depend,dependent,"####################. __all__ = ['propagator', 'propagator_steadystate']. import types; import numpy as np; import scipy.linalg as la; import functools. from qutip.qobj import Qobj; from qutip.rhs_generate import rhs_clear; from qutip.superoperator import (vec2mat, mat2vec,; vector_to_operator, operator_to_vector); from qutip.mesolve import mesolve; from qutip.sesolve import sesolve; from qutip.states import basis; from qutip.solver import Options; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar. [docs]def propagator(H, t, c_op_list, args=None, options=None, sparse=False,; progress_bar=None):; """"""; Calculate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """""". if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer,",MatchSource.WIKI,docs/3.1.0/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html
Usability,progress bar,progress bar,"ulate the propagator U(t) for the density matrix or wave function such; that :math:`\psi(t) = U(t)\psi(0)` or; :math:`\\rho_{\mathrm vec}(t) = U(t) \\rho_{\mathrm vec}(0)`; where :math:`\\rho_{\mathrm vec}` is the vector representation of the; density matrix. Parameters; ----------; H : qobj or list; Hamiltonian as a Qobj instance of a nested list of Qobjs and; coefficients in the list-string or list-function format for; time-dependent Hamiltonians (see description in :func:`qutip.mesolve`). t : float or array-like; Time or list of times for which to evaluate the propagator. c_op_list : list; List of qobj collapse operators. args : list/array/dictionary; Parameters to callback functions for time-dependent Hamiltonians and; collapse operators. options : :class:`qutip.Options`; with options for the ODE solver. progress_bar: BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. By default no progress bar; is used, and if set to True a TextProgressBar will be used. Returns; -------; a : qobj; Instance representing the propagator :math:`U(t)`. """""". if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(); options.rhs_reuse = True; rhs_clear(). if isinstance(t, (int, float, np.integer, np.floating)):; tlist = [0, t]; else:; tlist = t. if isinstance(H, (types.FunctionType, types.BuiltinFunctionType,; functools.partial)):; H0 = H(0.0, args); elif isinstance(H, list):; H0 = H[0][0] if isinstance(H[0], list) else H[0]; else:; H0 = H. if len(c_op_list) == 0 and H0.isoper:; # calculate propagator for the wave function. N = H0.shape[0]; dims = H0.dims; u = np.zeros([N, N, len(tlist)], dtype=complex). progress_bar.start(N); for n in range(0, N):; progress_bar.update(n); psi0 = basis(N, n); output = sesolve(H, psi0, tlist, [], args, options); for k, t in enumerate(tlist):; u[:, n, k] = output.states[k].full()",MatchSource.WIKI,docs/3.1.0/modules/qutip/propagator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/propagator.html
Availability,error,error,"ms : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[1]]. Returns; -------; oper : qobj; Nx1 ket state quantum operator. """"""; if dims:; _check_dims(dims, N, 1); X = sp.rand(N, 1, density, format='csr'); X.data = X.data - 0.5; Y = X.copy(); Y.data = 1.0j * np.random.random(len(X.data)) - (0.5 + 0.5j); X = X + Y; X.sort_indices(); X = Qobj(X); if dims:; return Qobj(X / X.norm(), dims=dims, shape=[N, 1]); else:; return Qobj(X / X.norm()). [docs]def rand_dm(N, density=0.75, pure=False, dims=None):; """"""Creates a random NxN density matrix. Parameters; ----------; N : int; Shape of output density matrix.; density : float; Density between [0,1] of output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper : qobj; NxN density matrix quantum operator. Notes; -----; For small density matrices., choosing a low density will result in an error; as no diagonal elements will be generated such that :math:`Tr(\\rho)=1`. """"""; if dims:; _check_dims(dims, N, N); if pure:; dm_density = sqrt(density); psi = rand_ket(N, dm_density); H = psi * psi.dag(); else:; density = density ** 2; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density); H = H.dag() * H; non_zero = sum([H.tr()]); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H.data.sort_indices(); if dims:; return Qobj(H / H.tr(), dims=dims, shape=[N, N]); else:; return Qobj(H / H.tr()). def rand_kraus_map(N, dims=None):; """"""; Creates a random CPTP map on an N-dimensional Hilbert space in Kraus; form. Parameters; ----------; N : int; Length of input/output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper_list : list of qobj; N^2 x N x N qobj operators. """""". if dims:; _check_dims(dims, N, N). # Random un",MatchSource.WIKI,docs/3.1.0/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/random_objects.html
Deployability,install,installation,"﻿. qutip.random_objects — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.random_objects; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following d",MatchSource.WIKI,docs/3.1.0/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/random_objects.html
Integrability,depend,depends,"and_ket(N, dm_density); H = psi * psi.dag(); else:; density = density ** 2; non_zero = 0; tries = 0; while non_zero == 0 and tries < 10:; H = rand_herm(N, density); H = H.dag() * H; non_zero = sum([H.tr()]); tries += 1; if tries >= 10:; raise ValueError(; ""Requested density is too low to generate density matrix.""); H.data.sort_indices(); if dims:; return Qobj(H / H.tr(), dims=dims, shape=[N, N]); else:; return Qobj(H / H.tr()). def rand_kraus_map(N, dims=None):; """"""; Creates a random CPTP map on an N-dimensional Hilbert space in Kraus; form. Parameters; ----------; N : int; Length of input/output density matrix.; dims : list; Dimensions of quantum object. Used for specifying; tensor structure. Default is dims=[[N],[N]]. Returns; -------; oper_list : list of qobj; N^2 x N x N qobj operators. """""". if dims:; _check_dims(dims, N, N). # Random unitary (Stinespring Dilation); big_unitary = rand_unitary(N ** 3).data.todense(); orthog_cols = np.array(big_unitary[:, :N]); oper_list = np.reshape(orthog_cols, (N ** 2, N, N)); return list(map(lambda x: Qobj(inpt=x, dims=dims), oper_list)). def rand_super(dim=5):; H = rand_herm(dim); return propagator(H, np.random.rand(), [; create(dim), destroy(dim), jmat(float(dim - 1) / 2.0, 'z'); ]). def _check_dims(dims, N1, N2):; if len(dims) != 2:; raise Exception(""Qobj dimensions must be list of length 2.""); if (not isinstance(dims[0], list)) or (not isinstance(dims[1], list)):; raise TypeError(; ""Qobj dimension components must be lists. i.e. dims=[[N],[N]]""); if np.prod(dims[0]) != N1 or np.prod(dims[1]) != N2:; raise ValueError(""Qobj dimensions must match matrix shape.""); if len(dims[0]) != len(dims[1]):; raise TypeError(""Qobj dimension components must have same length.""). # TRAILING IMPORTS; # qutip.propagator depends on rand_dm, so we need to put this import last.; from qutip.propagator import propagator. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/random_objects.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/random_objects.html
Availability,error,error,"y setup (r). Calculate the; # required expectation values or invoke callback function at each time step.; #; def _generic_ode_solve(r, psi0, tlist, e_ops, opt, progress_bar,; state_norm_func=None, dims=None):; """"""; Internal function for solving ODEs.; """""". #; # prepare output array; #; n_tsteps = len(tlist); output = Result(); output.solver = ""sesolve""; output.times = tlist. if opt.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):. n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fallback on storing states; output.states = []; opt.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)); else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; progress_bar.start(n_tsteps). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if state_norm_func:; data = r.y / state_norm_func(r.y); r.set_initial_value(data, r.t). if opt.store_states:; output.states.append(Qobj(r.y, dims=dims)). if expt_callback:; # use callback method; e_ops(t, Qobj(r.y, dims=psi0.dims)). for m in range(n_expt_op):; output.expect[m][t_idx] = cy_expect_psi(e_ops[m].data,; r.y, e_ops[m].isherm). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]). progress_bar.finished(). if not opt.rhs_reuse and config.tdname is not None:; try:; os.remove(config.tdname + "".pyx""); except:; pass. if opt.store_final_state:; output.final_state = Qobj(r.y). return output. Back to top. © Copyright 2011 and later, P.D. Nation, J.R. Johansson.; Last updated on Dec 31, 2014.; Created using Sphinx 1.2.3. ",MatchSource.WIKI,docs/3.1.0/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html
Deployability,install,installation,"﻿. qutip.sesolve — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.sesolve; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #;",MatchSource.WIKI,docs/3.1.0/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html
Integrability,integrat,integrate,"# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT; # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A; # PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a call",MatchSource.WIKI,docs/3.1.0/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html
Modifiability,config,config,"RTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT; # HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,; # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT; # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; """"""; This module provides solvers for the unitary Schrodinger equation.; """""". __all__ = ['sesolve']. import os; import types; from functools import partial; import numpy as np; import scipy.integrate; from scipy.linalg import norm. from qutip.qobj import Qobj, isket; from qutip.rhs_generate import rhs_generate; from qutip.solver import Result, Options, config; from qutip.rhs_generate import _td_format_check, _td_wrap_array_str; from qutip.settings import debug; from qutip.cy.spmatfuncs import (cy_expect_psi, cy_ode_rhs,; cy_ode_psi_func_td,; cy_ode_psi_func_td_with_state); from qutip.cy.codegen import Codegen. from qutip.ui.progressbar import BaseProgressBar. if debug:; import inspect. [docs]def sesolve(H, rho0, tlist, e_ops, args={}, options=None,; progress_bar=BaseProgressBar()):; """"""; Schrodinger equation evolution of a state vector for a given Hamiltonian. Evolve the state vector or density matrix (`rho0`) using a given; Hamiltonian (`H`), by integrating the set of ordinary differential; equations that define the system. The output is either the state vector at arbitrary points in time; (`tlist`), or the expectation values of the supplied operators; (`e_ops`). If e_ops is a callback function, it is invoked for each; time in `tlist` with time and the state as arguments, and the function; does not use any return values. Param",MatchSource.WIKI,docs/3.1.0/modules/qutip/sesolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/sesolve.html
Availability,toler,tolerance,", PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,; # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY; # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import os; import warnings; from qutip import __version__. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small v",MatchSource.WIKI,docs/3.1.0/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html
Deployability,install,installation,"﻿. qutip.solver — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.solver; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html
Integrability,integrat,integrator,"THER IN CONTRACT, STRICT LIABILITY, OR TORT; # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE; # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.; ###############################################################################; from __future__ import print_function. __all__ = ['Options', 'Odeoptions', 'Odedata']. import os; import warnings; from qutip import __version__. [docs]class Options():; """"""; Class of options for evolution solvers such as :func:`qutip.mesolve` and; :func:`qutip.mcsolve`. Options can be specified either as arguments to the; constructor::. opts = Options(order=10, ...). or by changing the class attributes after creation::. opts = Options(); opts.order = 10. Returns options class to be used as options in evolution solvers. Attributes; ----------. atol : float {1e-8}; Absolute tolerance.; rtol : float {1e-6}; Relative tolerance.; method : str {'adams','bdf'}; Integration method.; order : int {12}; Order of integrator (<=12 'adams', <=5 'bdf'); nsteps : int {2500}; Max. number of internal steps/call.; first_step : float {0}; Size of initial step (0 = automatic).; min_step : float {0}; Minimum step size (0 = automatic).; max_step : float {0}; Maximum step size (0 = automatic); tidy : bool {True,False}; Tidyup Hamiltonian and initial state by removing small terms.; num_cpus : int; Number of cpus used by mcsolver (default = # of cpus).; norm_tol : float; Tolerance used when finding wavefunction norm in mcsolve.; norm_steps : int; Max. number of steps used to find wavefunction norm to within norm_tol; in mcsolve.; average_states : bool {False}; Average states values over trajectories in stochastic solvers.; average_expect : bool {True}; Average expectation values over trajectories for stochastic solvers.; mc_corr_eps : float {1e-10}; Arbitrarily small value for eliminating any divide-by-zero errors in; correlation calculations when using mcsolve.; ntraj : int {500}; Number of trajectories in stochastic solver",MatchSource.WIKI,docs/3.1.0/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html
Modifiability,variab,variables,"on():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = None # Placeholder for TD col-spmv function.; self.colexpect = None # Placeholder for TD col_expect function.; self.string = None # Holds string of variables passed to td solver. self.soft_reset(). def soft_reset(self):. # Hamiltonian stuff; self.h_td_inds = [] # indicies of time-dependent Hamiltonian operators; self.h_data = None # List of sparse matrix data; self.h_ind = None # List of sparse matrix indices; self.h_ptr = None # List of sparse matrix ptrs. # Expectation operator stuff; self.e_num = 0 # number of expect ops; self.e_ops_data = [] # expect op data; self.e_ops_ind = [] # expect op indices; self.e_ops_ptr = [] # expect op indptrs; self.e_ops_isherm = [] # expect op isherm. # Collapse operator stuff; self.c_num = 0 # number of collapse ops; self.c_const_inds = [] # indicies of constant collapse operators; self.c_td_inds = [] # indicies of time-dependent collapse operators; self.c_ops_data = [] # collapse op data; self.c_ops_ind = [] # collapse op indices; self.c_ops_ptr = [] # collapse op indptrs; self.c_args = [] # store args for time-dependent collapse func. # Norm collapse operator stuff; self.n_ops_data = [] # nor",MatchSource.WIKI,docs/3.1.0/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html
Performance,load,loading,"expect = []; self.num_expect = 0; self.num_collapse = 0; self.ntraj = None; self.seeds = None; self.col_times = None; self.col_which = None. def __str__(self):; s = ""Result object ""; if self.solver:; s += ""with "" + self.solver + "" data.\n""; else:; s += ""missing solver information.\n""; s += ""-"" * (len(s) - 1) + ""\n""; if self.states is not None and len(self.states) > 0:; s += ""states = True\n""; elif self.expect is not None and len(self.expect) > 0:; s += ""expect = True\nnum_expect = "" + str(self.num_expect) + "", ""; else:; s += ""states = True, expect = True\n"" + \; ""num_expect = "" + str(self.num_expect) + "", ""; s += ""num_collapse = "" + str(self.num_collapse); if self.solver == 'mcsolve':; s += "", ntraj = "" + str(self.ntraj); return s. def __repr__(self):; return self.__str__(). def __getstate__(self):; # defines what happens when Qobj object gets pickled; self.__dict__.update({'qutip_version': __version__[:5]}); return self.__dict__. def __setstate__(self, state):; # defines what happens when loading a pickled Qobj; if 'qutip_version' in state.keys():; del state['qutip_version']; (self.__dict__).update(state). class SolverConfiguration():. def __init__(self):. self.cgen_num = 0. self.reset(). def reset(self):. # General stuff; self.tlist = None # evaluations times; self.ntraj = None # number / list of trajectories; self.options = None # options for solvers; self.norm_tol = None # tolerance for wavefunction norm; self.norm_steps = None # max. number of steps to take in finding; # Initial state stuff; self.psi0 = None # initial state; self.psi0_dims = None # initial state dims; self.psi0_shape = None # initial state shape. # flags for setting time-dependence, collapse ops, and number of times; # codegen has been run; self.cflag = 0 # Flag signaling collapse operators; self.tflag = 0 # Flag signaling time-dependent problem. # time-dependent (TD) function stuff; self.tdfunc = None # Placeholder for TD RHS function.; self.tdname = None # Name of td .pyx file; self.colspmv = ",MatchSource.WIKI,docs/3.1.0/modules/qutip/solver.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/solver.html
Availability,down,down,"basis(3,2); >>> ket2dm(x); Quantum object: dims = [[3], [3]], \; shape = [3, 3], type = oper, isHerm = True; Qobj data =; [[ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 0.+0.j]; [ 0.+0.j 0.+0.j 1.+0.j]]. """"""; if Q.type == 'ket':; out = Q * Q.dag(); elif Q.type == 'bra':; out = Q.dag() * Q; else:; raise TypeError(""Input is not a ket or bra vector.""); return Qobj(out). #; # projection operator; #; def projection(N, n, m, offset=0):; """"""The projection operator that projects state |m> on state |n>: |n><m|. Parameters; ----------. N : int; Number of basis states in Hilbert space. n, m : float; The number states in the projection. offset : int (default 0); The lowest number state that is included in the finite number state; representation of the projector. Returns; -------; oper : qobj; Requested projection operator.; """"""; ket1 = basis(N, n, offset=offset); ket2 = basis(N, m, offset=offset). return ket1 * ket2.dag(). #; # composite qubit states; #; def qstate(string):; """"""Creates a tensor product for a set of qubits in either; the 'up' :math:`|0>` or 'down' :math:`|1>` state. Parameters; ----------; string : str; String containing 'u' or 'd' for each qubit (ex. 'ududd'). Returns; -------; qstate : qobj; Qobj for tensor product corresponding to input string. Notes; -----; Look at ket and bra for more general functions; creating multiparticle states. Examples; --------; >>> qstate('udu'); Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 0.]; [ 1.]; [ 0.]; [ 0.]]. """"""; n = len(string); if n != (string.count('u') + string.count('d')):; raise TypeError('String input to QSTATE must consist ' +; 'of ""u"" and ""d"" elements only'); else:; up = basis(2, 1); dn = basis(2, 0); lst = []; for k in range(n):; if string[k] == 'u':; lst.append(up); else:; lst.append(dn); return tensor(lst). #; # different qubit notation dictionary; #; _qubit_dict = {'g': 0, # ground state; 'e': 1, # excited state; 'u': 0, # spin up; 'd': 1, # ",MatchSource.WIKI,docs/3.1.0/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html
Deployability,install,installation,"﻿. qutip.states — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.states; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclaimer.; #; #",MatchSource.WIKI,docs/3.1.0/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html
Testability,log,log," state density matrix. Examples; --------; >>> thermal_dm(5, 1); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.51612903 0. 0. 0. 0. ]; [ 0. 0.25806452 0. 0. 0. ]; [ 0. 0. 0.12903226 0. 0. ]; [ 0. 0. 0. 0.06451613 0. ]; [ 0. 0. 0. 0. 0.03225806]]. >>> thermal_dm(5, 1, 'analytic'); Quantum object: dims = [[5], [5]], \; shape = [5, 5], type = oper, isHerm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. ]; [ 0. 0.25 0. 0. 0. ]; [ 0. 0. 0.125 0. 0. ]; [ 0. 0. 0. 0.0625 0. ]; [ 0. 0. 0. 0. 0.03125]]. Notes; -----; The 'operator' method (default) generates; the thermal state using the truncated number operator ``num(N)``. This; is the method that should be used in computations. The; 'analytic' method uses the analytic coefficients derived in; an infinite Hilbert space. The analytic form is not necessarily normalized,; if truncated too aggressively. """"""; if n == 0:; return fock_dm(N, 0); else:; i = arange(N); if method == 'operator':; beta = np.log(1.0 / n + 1.0); diags = np.exp(-beta * i); diags = diags / np.sum(diags); # populates diagonal terms using truncated operator expression; rm = sp.spdiags(diags, 0, N, N, format='csr'); elif method == 'analytic':; # populates diagonal terms using analytic values; rm = sp.spdiags((1.0 + n) ** (-1.0) * (n / (1.0 + n)) ** (i),; 0, N, N, format='csr'); else:; raise ValueError(; ""'method' keyword argument must be 'operator' or 'analytic'""); return Qobj(rm). def maximally_mixed_dm(N):; """"""; Returns the maximally mixed density matrix for a Hilbert space of; dimension N. Parameters; ----------; N : int; Number of basis states in Hilbert space. Returns; -------; dm : qobj; Thermal state density matrix.; """"""; if (not isinstance(N, (int, np.int64))) or N <= 0:; raise ValueError(""N must be integer N > 0""). dm = sp.spdiags(np.ones(N, dtype=complex)/float(N), 0, N, N, format='csr'). return Qobj(dm, isherm=True). [docs]def ket2dm(Q):; """"""Takes input ket or bra vector and returns density matrix; forme",MatchSource.WIKI,docs/3.1.0/modules/qutip/states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/states.html
Availability,error,error,"ount). elif ss_args['method'] == 'iterative-lgmres':; v, check = lgmres(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'], maxiter=ss_args['maxiter'],; callback=_iter_count). elif ss_args['method'] == 'iterative-bicgstab':; v, check = bicgstab(L, b, tol=ss_args['tol'], M=ss_args['M'],; x0=ss_args['x0'],; maxiter=ss_args['maxiter'], callback=_iter_count); else:; raise Exception(""Invalid iterative solver method.""); _iter_end = time.time(). ss_args['info']['iter_time'] = _iter_end - _iter_start; if 'precond_time' in ss_args['info'].keys():; ss_args['info']['solution_time'] = (ss_args['info']['iter_time'] +; ss_args['info']['precond_time']); ss_args['info']['iterations'] = ss_iters['iter']; if ss_args['return_info']:; ss_args['info']['residual_norm'] = la.norm(b - L*v, np.inf). if settings.debug:; logger.debug('Number of Iterations: %i' % ss_iters['iter']); logger.debug('Iteration. time: %f' % (_iter_end - _iter_start)). if check > 0:; raise Exception(""Steadystate error: Did not reach tolerance after "" +; str(ss_args['maxiter']) + "" steps."" +; ""\nResidual norm: "" +; str(ss_args['info']['residual_norm'])). elif check < 0:; raise Exception(; ""Steadystate error: Failed with fatal error: "" + str(check) + "".""). if ss_args['use_rcm']:; v = v[np.ix_(rev_perm,)]. data = vec2mat(v); data = 0.5 * (data + data.conj().T); if ss_args['return_info']:; return Qobj(data, dims=dims, isherm=True), ss_args['info']; else:; return Qobj(data, dims=dims, isherm=True). def _steadystate_svd_dense(L, ss_args):; """"""; Find the steady state(s) of an open quantum system by solving for the; nullspace of the Liouvillian.; """"""; ss_args['info'].pop('weight', None); atol = 1e-12; rtol = 1e-12; if settings.debug:; logger.debug('Starting SVD solver.'); _svd_start = time.time(); u, s, vh = svd(L.full(), full_matrices=False); tol = max(atol, rtol * s[0]); nnz = (s >= tol).sum(); ns = vh[nnz:].conj().T; _svd_end = time.time(); ss_args['info']['total_time'] = _svd_end-_svd_start; if ss_args['all_state",MatchSource.WIKI,docs/3.1.0/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html
Deployability,install,installation,"﻿. qutip.steadystate — QuTiP 3.1.0 Documentation. QuTiP; 3.1.0. qutip.org. Docs . Frontmatter; About This Documentation; Citing This Project; Funding; About QuTiP; Contributing to QuTiP. Installation; General Requirements; Platform-independent installation; Get the source code; Installing from source; Installation on Ubuntu Linux; Installation on Mac OS X (10.8+); Installation on Windows; Optional Installation Options; Verifying the Installation; Checking Version Information using the About Function. Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Solving for Steady-State Solutions; An Overview of the Eseries Class; Two-time correlation functions; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings. API documentation; Classes; Functions. Change Log; Version 3.1.0 (January 1, 2015):; Version 3.0.1 (Aug 5, 2014):; Version 3.0.0 (July 17, 2014):; Version 2.2.0 (March 01, 2013):; Version 2.1.0 (October 05, 2012):; Version 2.0.0 (June 01, 2012):; Version 1.1.4 (May 28, 2012):; Version 1.1.3 (November 21, 2011):; Version 1.1.2 (October 27, 2011); Version 1.1.1 (October 25, 2011); Version 1.1.0 (October 04, 2011); Version 1.0.0 (July 29, 2011). Developers; Lead Developers; Contributors. Bibliography. Page . Source code for qutip.steadystate; # This file is part of QuTiP: Quantum Toolbox in Python.; #; # Copyright (c) 2011 and later, Paul D. Nation and Robert J. Johansson.; # All rights reserved.; #; # Redistribution and use in source and binary forms, with or without; # modification, are permitted provided that the following conditions are; # met:; #; # 1. Redistributions of source code must retain the above copyright notice,; # this list of conditions and the following disclai",MatchSource.WIKI,docs/3.1.0/modules/qutip/steadystate.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/3.1.0/modules/qutip/steadystate.html
