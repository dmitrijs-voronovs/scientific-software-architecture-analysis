quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Availability,avail,available,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Deployability,integrat,integrated,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Energy Efficiency,efficient,efficient,"ch matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack ",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Integrability,integrat,integrated,"kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Modifiability,adapt,adapted,"es; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom,",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Performance,optimiz,optimized,"ken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-vector analysis to; C++ . We started with his implementation; 5. Siegmund Brandt (http://siux00.physik.uni-siegen.de/~brandt/datan; We adapted his (very-well) documented SVD routines. How to efficiently use this package. 1. Never return complex objects (matrices or vectors); Danger: For example, when the following snippet:; TMatrixD foo(int n); {; TMatrixD foom(n,n); fill_in(foom); return foom;; }; TMatrixD m = foo(5);; runs, it constructs matrix foo:foom, copies it onto stack as a; return value and destroys foo:foom. Return value (a matrix); from foo() is then copied over to m (via a copy constructor),; and the return value is destroyed. So, the matrix constructor is; called 3 times and the destructor 2 times. For big matrices,; the cost of multiple constructing/copying/destroying of objects; may be very large. *Some* optimized compilers can cut down on 1; copying/destroying, but still it leaves at least two calls to; the constructor. Note, TMatrixDLazy (see below) can construct; TMatrixD m ""inplace"", with only a _single_ call to the; constructor. 2. Use ""two-address instructions""; ""void TMatrixD::operator += (const TMatrixD &B);""; as much as possible.; That is, to add two matrices, it's much more efficient to write; A += B;; than; TMatrixD C = A + B;; (if both operand should be preserved,; TMatrixD C = A; C += B;; is still better). 3. Use glorified constructors when returning of an object seems; inevitable:; ""TMatrixD A(TMatrixD::kTransposed,B);""; ""TMatrixD C(A,TMatrixD::kTransposeMult,B);"". like in the following snippet (from $ROOTSYS/test/vmatrix.cxx); that verifies that for an orthogonal matrix T, T'T = TT' = E. TMatrixD haar = THaarMatrixD(5);; TMatrixD unit(TMatrixD::kUnit,haar);; TMatrixD haar_t(TMatrixD::kTransposed,haar);; TMatrixD hth(haar,TMatrixD::kTransposeMult,haar);; TMatrixD hht(haar,TMatrixD::kMult,haar_t);; TMatrixD hht1 = haar; hht1 *",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Safety,avoid,avoiding,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Testability,test,test," additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since TMatrixT et al. are fully integrated in ROOT, they of course; can be stored in a ROOT database. For usage examples see $ROOTSYS/test/stressLinear.cxx. Acknowledgements. 1. Oleg E. Kiselyov; First implementations were based on the his code . We have diverged; quite a bit since then but the ideas/code for lazy matrix and; ""nested function"" are 100% his .; You can see him and his code in action at http://okmij.org/ftp; 2. Chris R. Birchenhall,; We adapted his idea of the implementation for the decomposition; classes instead of our messy installation of matrix inversion; His installation of matrix condition number, using an iterative; scheme using the Hage algorithm is worth looking at !; Chris has a nice writeup (matdoc.ps) on his matrix classes at; ftp://ftp.mcc.ac.uk/pub/matclass/; 3. Mark Fischler and Steven Haywood of CLHEP; They did the slave labor of spelling out all sub-determinants; for Cramer inversion of (4x4),(5x5) and (6x6) matrices; The stack storage for small matrices was also taken from them; 4. Roldan Pozo of TNT (http://math.nist.gov/tnt/); He converted the EISPACK routines for the eigen-ve",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Usability,simpl,simple,"; v = TMatrixDRow(m,0);; TMatrixDColumn m1(m,1); m1(2) = 3; // the same as m(2,1)=3;; Note, constructing of, say, TMatrixDDiag does *not* involve any; copying of any elements of the source matrix. 5. It's possible (and encouraged) to use ""nested"" functions; For example, creating of a Hilbert matrix can be done as follows:. void foo(const TMatrixD &m); {; TMatrixD m1(TMatrixD::kZero,m);; struct MakeHilbert : public TElementPosActionD {; void Operation(Double_t &element); { element = 1./(fI+fJ-1); }; };; m1.Apply(MakeHilbert());; }. of course, using a special method THilbertMatrixD() is; still more optimal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No",MatchSource.WIKI,root/html528/TMatrixTBase_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html
Energy Efficiency,adapt,adapted,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html528/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTCramerInv.html
Integrability,rout,routines,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html528/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTCramerInv.html
Modifiability,adapt,adapted,". TMatrixTCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTCramerInv. namespace TMatrixTCramerInv. TMatrixTCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixT<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixT<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixT<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixT<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixT<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixT<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixT<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixT<Element> &m,Double_t *determ). template<class Element> Bool_t Inv5x5(TMatrixT<",MatchSource.WIKI,root/html528/TMatrixTCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTCramerInv.html
Availability,avail,available,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Double_t>, TMatrixDLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root/html528/TMatrixTLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_double_.html
Availability,avail,available,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Float_t>, TMatrixFLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root/html528/TMatrixTLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_float_.html
Availability,error,error," b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<double>::Determinant() const; virtual voidTMatrixTBase<double>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(double* data, Option_t* = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<double>::GetNcols() const; Int_tTMatrixTBase<double",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Energy Efficiency,allocate,allocated,"lon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const double* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Integrability,depend,depends,"zeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, double* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<double>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Modifiability,flexible,flexible," are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixDSparse, TMatrixTSparse<Double_t>. Function Members (Methods); public:. TMatrixTSparse<double>(); TMatrixTSparse<double>(const TMatrixTSparse<double>& another); TMatrixTSparse<double>(const TMatrixT<double>& another); TMatrixTSparse<double>(Int_t nrows, Int_t ncols); TMatrixTSparse<double>(TMatrixTSparse<double>::EMatrixCreatorsOp1 op, const TMatrixTSparse<double>& prototype); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixTSparse<double>& b); TMatrixTSparse<double>(const TMatrixTSparse<double>& a, TMatrixTSparse<double>::EMatrixCreatorsOp2 op, const TMatrixT<do",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Performance,perform,performance,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const ",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Security,access,access,". TMatrixTSparse<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<double>. class TMatrixTSparse<double>: public TMatrixTBase<double>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); wher",MatchSource.WIKI,root/html528/TMatrixTSparse_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_double_.html
Availability,error,error,"owser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tTMatrixTBase<float>::Determinant() const; virtual voidTMatrixTBase<float>::Determinant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidGetMatrix2Array(float* data, Option_t* = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::GetNcols() const; Int_tTMatrixTBase<float>::GetNo",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Energy Efficiency,allocate,allocated,"silon > 1. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void TMatrixTSparse<Element> Allocate(Int_t nrows, Int_t ncols, Int_t row_lwb = 0, Int_t col_lwb = 0, Int_t init = 0, Int_t nr_nonzeros = 0); Allocate new matrix. Arguments are number of rows, columns, row lowerbound (0 default); and column lowerbound (0 default), 0 initialization flag and number of non-zero; elements (only relevant for sparse format). TMatrixTBase<Element> &TMatrixTSparse<Element> InsertRow(Int_t row, Int_t col, const float* v, Int_t n = -1); Insert in row rown, n elements of array v at column coln. void TMatrixTSparse<Element> ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; Store in array v, n matrix elements of row rown starting at column coln. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMultBt(const TMatrixT<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix multiplication. Create a matrix C such that C = A * B'.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixTSparse<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> APlusB(const TMatrixTSparse<Element> &a,const TMatrixT<Element> &b,Int_t constr); General matrix addition. Create a matrix C such that C = A + B.; Note, matrix C is allocated for constr=1. void TMatrixTSparse<Element> AMinusB(const TMatrixTSparse<Element> &a,const TMatrixT",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Integrability,depend,depends,"onzeros > 0 .; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSparse<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb] with nr_nonzeros; non-zero entries if nr_nonzeros > 0 .; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTSparse<Element> &TMatrixTSparse<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t nr_nonzeros, Int_t* pRowIndex, Int_t* pColIndex, float* pData). TMatrixTBase<Element> &TMatrixTSparse<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTBase<Element> &TMatrixTSparse<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][col_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source-1][col_lwb..col_lwb+ncols_source-1];. TMatrixTSparse<Element> &TMatrixTSparse<Element> Transpose(const TMatrixTSparse<float>& source); Transpose a matrix. TMatrixTBase<Element> &TMatrixTSparse<Element> Zero(). TMatrixTBase<Element> &TMatrixTSparse<Element> UnitMatrix(); Make a unit matrix (matrix need not be a square one). Element TMatrixTSparse<Element> RowNorm() const; Row matrix norm, MAX{ SUM{ |M(i,j)|, over j}, over i}.; The norm is induced by the infinity vector norm. Element TMatrixTSparse<Element> ColNorm() const; Column matrix norm, MAX{ SUM{ |M(i,j)|, over i}, over j}.; The n",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Modifiability,flexible,flexible," are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const TMatrixTBase &source); the matrix to be inserted at position (row_lwb,col_lwb) can be; both dense or sparse . This class is also known as (typedefs to this class)TMatrixFSparse, TMatrixTSparse<Float_t>. Function Members (Methods); public:. TMatrixTSparse<float>(); TMatrixTSparse<float>(const TMatrixTSparse<float>& another); TMatrixTSparse<float>(const TMatrixT<float>& another); TMatrixTSparse<float>(Int_t nrows, Int_t ncols); TMatrixTSparse<float>(TMatrixTSparse<float>::EMatrixCreatorsOp1 op, const TMatrixTSparse<float>& prototype); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixTSparse<float>& b); TMatrixTSparse<float>(const TMatrixTSparse<float>& a, TMatrixTSparse<float>::EMatrixCreatorsOp2 op, const TMatrixT<float>& b); TMatrix",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Performance,perform,performance,"e also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it is expected that the irow,icol and data array contain; nr entries . Only the entries with non-zero data[i] value are; inserted !; 4. TMatrixTSparse a(n,m); for(....) { a(i,j) = ....; This is a very flexible method but expensive :; - if no entry for slot (i,j) is found in the sparse index table; it will be entered, which involves some memory management !; - before invoking this method in a loop it is smart to first; set the index table through a call to SetSparseIndex(..); 5. SetSub(Int_t row_lwb,Int_t col_lwb,const ",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Security,access,access,". TMatrixTSparse<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSparse<float>. class TMatrixTSparse<float>: public TMatrixTBase<float>. TMatrixTSparse. Template class of a general sparse matrix in the Harwell-Boeing; format. Besides the usual shape/size decsriptors of a matrix like fNrows,; fRowLwb,fNcols and fColLwb, we also store a row index, fRowIndex and; column index, fColIndex only for those elements unequal zero:. fRowIndex[0,..,fNrows]: Stores for each row the index range of; the elements in the data and column array; fColIndex[0,..,fNelems-1]: Stores the column number for each data; element != 0. As an example how to access all sparse data elements:. for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }. When checking whether sparse matrices are compatible (like in an; assigment !), not only the shape parameters are compared but also; the sparse structure through fRowIndex and fColIndex . Several methods exist to fill a sparse matrix with data entries.; Most are the same like for dense matrices but some care has to be; taken with regard to performance. In the constructor, always the; shape of the matrix has to be specified in some form . Data can be; entered through the following methods :; 1. constructor; TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; It uses SetMatrixArray(..), see below; 2. copy constructors; 3. SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data); where it",MatchSource.WIKI,root/html528/TMatrixTSparse_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSparse_float_.html
Energy Efficiency,adapt,adapted,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html528/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSymCramerInv.html
Integrability,rout,routines,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html528/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSymCramerInv.html
Modifiability,adapt,adapted,". TMatrixTSymCramerInv. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; namespace description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymCramerInv. namespace TMatrixTSymCramerInv. TMatrixTSymCramerInv. Encapsulate templates of Cramer Inversion routines. The 4x4, 5x5 and 6x6 are adapted from routines written by; Mark Fischler and Steven Haywood as part of the CLHEP package. Although for sizes <= 6x6 the Cramer Inversion has a gain in speed; compared to factorization schemes (like LU) , one pays a price in; accuracy . For Example:; H * H^-1 = U, where H is a 5x5 Hilbert matrix; U is a 5x5 Unity matrix. LU : |U_jk| < 10e-13 for j!=k; Cramer: |U_jk| < 10e-7 for j!=k. however Cramer algorithm is about 10 (!) times faster. Function Members (Methods); public:. Bool_tInv2x2(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv2x2(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv3x3(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv4x4(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv5x5(TMatrixTSym<double>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<float>& m, Double_t* determ); Bool_tInv6x6(TMatrixTSym<double>& m, Double_t* determ). Class Charts; Function documentation; Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv4x4(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv5x5(TMatrixTSym<Element> &m,Double_t *determ). Bool_t Inv6x6(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv2x2(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv3x3(TMatrixTSym<Element> &m,Double_t *determ). template<class Element> Bool_t Inv4x4(TMatrixTSym<Element> &m,",MatchSource.WIKI,root/html528/TMatrixTSymCramerInv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSymCramerInv.html
Availability,avail,available,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Double_t>, TMatrixDSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root/html528/TMatrixTSymLazy_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_double_.html
Availability,avail,available,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFSymLazy, TMatrixTSymLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html528/TMatrixTSymLazy_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_float_.html
Availability,error,error,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html528/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html
Deployability,update,updated,". TMatrixTSym<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSym<double>. class TMatrixTSym<double>: public TMatrixTBase<double>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . This class is also known as (typedefs to this class)TMatrixTSym<Double_t>, TMatrixDSym. Function Members (Methods); public:. TMatrixTSym<double>(); TMatrixTSym<double>(Int_t nrows); TMatrixTSym<double>(const TMatrixTSym<double>& another); TMatrixTSym<double>(const TMatrixTSymLazy<double>& lazy_constructor); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixTSym<double>& prototype); TMatrixTSym<double>(TMatrixTSym<double>::EMatrixCreatorsOp1 op, const TMatrixT<double>& prototype); TMatrixTSym<double>(Int_t nrows, const double* data, Option_t* option = """"); TMatrixTSym<double>(const TMatrixTSym<double>& a, TMatrixTSym<double>::EMatrixCreatorsOp2 op, const TMatrixTSym<double>& b); TMatrixTSym<double>(Int_t row_lwb, Int_t row_upb, const double* data, Option_t* option = """"); virtual~TMatrixTSym<double>(); virtual TMatrixTBase<double>&TMatrixTBase<double>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(con",MatchSource.WIKI,root/html528/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html
Energy Efficiency,efficient,efficient," TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<double>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixT",MatchSource.WIKI,root/html528/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html
Integrability,depend,depends,"ound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<double>& a, const TMatrixTSym<double>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, double* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<double>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<double>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<double>& source); Insert matrix source starti",MatchSource.WIKI,root/html528/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html
Security,access,access,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<double>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficien",MatchSource.WIKI,root/html528/TMatrixTSym_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_double_.html
Availability,error,error,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html528/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html
Deployability,update,updated,". TMatrixTSym<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSym<float>. class TMatrixTSym<float>: public TMatrixTBase<float>. TMatrixTSym. Template class of a symmetric matrix in the linear algebra package. Note that in this implementation both matrix element m[i][j] and; m[j][i] are updated and stored in memory . However, when making the; object persistent only the upper right triangle is stored . This class is also known as (typedefs to this class)TMatrixTSym<Float_t>, TMatrixFSym. Function Members (Methods); public:. TMatrixTSym<float>(); TMatrixTSym<float>(Int_t nrows); TMatrixTSym<float>(const TMatrixTSym<float>& another); TMatrixTSym<float>(const TMatrixTSymLazy<float>& lazy_constructor); TMatrixTSym<float>(const TMatrixTSym<double>& another); TMatrixTSym<float>(Int_t row_lwb, Int_t row_upb); TMatrixTSym<float>(TMatrixTSym<float>::EMatrixCreatorsOp1 op, const TMatrixTSym<float>& prototype); TMatrixTSym<float>(TMatrixTSym<float>::EMatrixCreatorsOp1 op, const TMatrixT<float>& prototype); TMatrixTSym<float>(Int_t nrows, const float* data, Option_t* option = """"); TMatrixTSym<float>(const TMatrixTSym<float>& a, TMatrixTSym<float>::EMatrixCreatorsOp2 op, const TMatrixTSym<float>& b); TMatrixTSym<float>(Int_t row_lwb, Int_t row_upb, const float* data, Option_t* option = """"); virtual~TMatrixTSym<float>(); virtual TMatrixTBase<float>&TMatrixTBase<float>::Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TOb",MatchSource.WIKI,root/html528/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html
Energy Efficiency,efficient,efficient,"st. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSym<Element> &source). TMatrixTSym<Element> &TMatrixTSym<Element> operator=(const TMatrixTSymLazy<Element> &lazy_constructor). TMatrixTSy",MatchSource.WIKI,root/html528/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html
Integrability,depend,depends,"lowerbound (0 default) and column lowerbound (0 default). void TMatrixTSym<Element> Plus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> Minus(const TMatrixTSym<float>& a, const TMatrixTSym<float>& b); Symmetric matrix summation. Create a matrix C such that C = A + B. void TMatrixTSym<Element> TMult(const TMatrixT<Element> &a); Create a matrix C such that C = A' * A. In other words,; c[i,j] = SUM{ a[k,i] * a[k,j] }. void TMatrixTSym<Element> TMult(const TMatrixTSym<Element> &a); Matrix multiplication, with A symmetric; Create a matrix C such that C = A' * A = A * A = A * A'. TMatrixTSym<Element> &TMatrixTSym<Element> Use(Int_t row_lwb, Int_t row_upb, float* data). TMatrixTSym<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, TMatrixTSym<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][row_lwb..row_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..row_upb-row_lwb+1] (default); else : return [row_lwb..row_upb][row_lwb..row_upb]. TMatrixTBase<Element> &TMatrixTSym<Element> GetSub(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, TMatrixTBase<float>& target, Option_t* option = ""S"") const; Get submatrix [row_lwb..row_upb][col_lwb..col_upb]; The indexing range of the; returned matrix depends on the argument option:. option == ""S"" : return [0..row_upb-row_lwb+1][0..col_upb-col_lwb+1] (default); else : return [row_lwb..row_upb][col_lwb..col_upb]. TMatrixTSym<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, const TMatrixTBase<float>& source); Insert matrix source starting at [row_lwb][row_lwb], thereby overwriting the part; [row_lwb..row_lwb+nrows_source][row_lwb..row_lwb+nrows_source];. TMatrixTBase<Element> &TMatrixTSym<Element> SetSub(Int_t row_lwb, Int_t col_lwb, const TMatrixTBase<float>& source); Insert matrix source starting ",MatchSource.WIKI,root/html528/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html
Security,access,access,"MatrixTSym<Element> ResizeTo(Int_t nrows, Int_t ncols, Int_t = -1); Set size of the matrix to nrows x ncols; New dynamic elements are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. TMatrixTBase<Element> &TMatrixTSym<Element> ResizeTo(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.0); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient t",MatchSource.WIKI,root/html528/TMatrixTSym_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html
Availability,error,error,"ect::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual doubleTMatrixTBase<double>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<double>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual doubleTMatrixTBase<double>::E2Norm() const; const TMatrixT<double>EigenVectors(TVectorT<double>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<double>::ExtractRow(Int_t row, Int_t col, double* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<double>::GetColLwb() const; Int_tTMatrixTBase<double>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<double>::GetMatrix2Array(double* data, Option_t* option = """") const; virtual const double*GetMatrixArray() const; virtual double*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<",MatchSource.WIKI,root/html528/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixT_double_.html
Integrability,rout,routine,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, double* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_l",MatchSource.WIKI,root/html528/TMatrixT_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixT_double_.html
Availability,error,error,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root/html528/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixT_float_.html
Integrability,rout,routine,"lement> Minus(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Minus(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); General matrix summation. Create a matrix C such that C = A - B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A general and B symmetric.; Create a matrix C such that C = A * B. void TMatrixT<Element> Mult(const TMatrixTSym<Element> &a,const TMatrixTSym<Element> &b); Matrix multiplication, with A symmetric and B symmetric.; (Actually copied for the moment routine for B general); Create a matrix C such that C = A * B. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixT<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> TMult(const TMatrixT<Element> &a,const TMatrixTSym<Element> &b); Create a matrix C such that C = A' * B. In other words,; c[i,j] = SUM{ a[k,i] * b[k,j] }. void TMatrixT<Element> MultT(const TMatrixT<Element> &a,const TMatrixT<Element> &b); General matrix multiplication. Create a matrix C such that C = A * B^T. void TMatrixT<Element> MultT(const TMatrixTSym<Element> &a,const TMatrixT<Element> &b); Matrix multiplication, with A symmetric and B general.; Create a matrix C such that C = A * B^T. TMatrixT<Element> &TMatrixT<Element> Use(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb, float* data); Use the array data to fill the matrix ([row_lwb..row_upb] x [col_lwb..col_upb]). TMatrixTBase<Element> &TMatrixT<Element> GetSub(Int_t row_lw",MatchSource.WIKI,root/html528/TMatrixT_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMatrixT_float_.html
Availability,error,error,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEnergy() const; Int_tGetFirstChild() const; virtual const char*TObject::GetIconName() const; Int_tGetKF() const; Int_tGetKS() const; Int_tGetLastChild() const; Float_tGetLifetime() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Float_tGetMass() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetP",MatchSource.WIKI,root/html528/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMCParticle.html
Energy Efficiency,energy,energy," TMCParticle(); TMCParticle(const TMCParticle&); TMCParticle(Int_t kS, Int_t kF, Int_t parent, Int_t firstchild, Int_t lastchild, Float_t px, Float_t py, Float_t pz, Float_t energy, Float_t mass, Float_t vx, Float_t vy, Float_t vz, Float_t time, Float_t lifetime); virtual~TMCParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(con",MatchSource.WIKI,root/html528/TMCParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMCParticle.html
Availability,error,error,"idAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFinishEvent(); virtual voidFinishPrimary(); virtual voidFinishRun(); virtual voidGeneratePrimaries(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::",MatchSource.WIKI,root/html528/TMCVerbose.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMCVerbose.html
Availability,avail,available,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Energy Efficiency,allocate,allocated,"ious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Integrability,message,message-digest,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Safety,avoid,avoids,"ar* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMD5(); Create TMD5 object. Set bit count to 0 and buffer to mysterious; initialization constants. TMD5(const UChar_t* digest); Create finalized TMD5 object containing passed in 16 byte digest. TMD5(const TMD5& md5); MD5 copy ctor. Special copy ctor avoids copying unnecessary; temp arrays when finalized. TMD5 & operator=(const TMD5& rhs); MD5 assignment operator. Special assignment operator avoids; copying unnecessary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t ",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Security,hash,hash,"essary temp arrays when finalized. void Update(const UChar_t* buf, UInt_t len); Update TMD5 object to reflect the concatenation of another buffer full; of bytes. void Final(UChar_t* digest); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context.; Returns digest. void Final(); MD5 finalization, ends an MD5 message-digest operation, writing the; the message digest and zeroizing the context. void Print() const; Print digest in ascii hex form. const char * AsString() const; Return message digest as string. Returns """" in case Final() has; not yet been called. Copy result because it points to a statically; allocated string. void Encode(UChar_t* out, const UInt_t* in, UInt_t len); Encodes input into output. Assumes len is a multiple of 4. void Decode(UInt_t* out, const UChar_t* in, UInt_t len); Decodes input into output. Assumes len is a multiple of 4. void Transform(UInt_t* buf, const UChar_t* in); The core of the MD5 algorithm, this alters an existing MD5 hash to; reflect the addition of 16 longwords of new data. Update() blocks; the data and converts bytes into longwords for this routine. Int_t SetDigest(const char* md5ascii); Set the digest from the ASCII representation 'md5ascii'. The caller; is responsible to make sure that the 32 chars md5ascii are valid.; Returns -1 if md5ascii is malformed, returns 0 otherwise. TMD5 * ReadChecksum(const char* file); Returns checksum stored in ASCII in specified file. Use to read files; created via WriteChecksum(). The returned TMD5 object must be deleted; by the user. Returns 0 in case the file cannot be opened or in case of; error. Static utlity function. Int_t WriteChecksum(const char* file, const TMD5* md5); Writes checksum in ASCII format to specified file. This file can; directly be read by ReadChecksum(). The md5 must have been finalized.; Returns -1 in case file cannot be opened or in case of error,; 0 otherwise. Static utility function. TMD5 * FileChecksum(const c",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Testability,test,tested,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root/html528/TMD5.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMD5.html
Availability,error,error,"taBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTQpSolverBase::DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tTQpSolverBase::FinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTQpSolverBase::GetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*TQpSolverBase::GetLinearSystem(); Double_tTQpSolverBase::GetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::H",MatchSource.WIKI,root/html528/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html
Energy Efficiency,monitor,monitor," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html
Performance,optimiz,optimization," Double_tTQpSolverBase::fPhimerit function, defined as the sum of the complementarity gap; Double_t*TQpSolverBase::fPhi_history[fMaxit] history of values of phi obtained on all iterations to date; Double_t*TQpSolverBase::fPhi_min_history[fMaxit] the i-th entry of this array contains the minimum value of phi; Int_tfPrintlevelparameter in range [0,100] determines verbosity. (Higher value; Double_t*TQpSolverBase::fRnorm_history[fMaxit] history of values of residual norm obtained on all iterations to date; TQpVar*fStepstorage for step vectors; TQpLinSolverBase*TQpSolverBase::fSys; Double_tfTsigexponent in Mehrotra's centering parameter, which is usually. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMehrotraSolver(); Default constructor. TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); Constructor. TMehrotraSolver(const TMehrotraSolver& another); Copy constructor. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resid); Solve the quadratic programming problem as formulated through prob, store; the final solution in iterate->fX . Monitor the residuals during the iterations; through resid . The status is returned as defined in TQpSolverBase::ETerminationCode . void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); Print information about the optimization process and monitor the convergence; status of thye algorithm. ~TMehrotraSolver(); Deconstructor. TMehrotraSolver & operator=(const TMehrotraSolver& source); Assignment operator. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TMehrotraSolver.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html
Safety,predict,predictor-corrector,". TMehrotraSolver. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TMehrotraSolver. class TMehrotraSolver: public TQpSolverBase. TMehrotraSolver. Derived class of TQpSolverBase implementing the original Mehrotra; predictor-corrector algorithm. Function Members (Methods); public:. TMehrotraSolver(); TMehrotraSolver(const TMehrotraSolver& another); TMehrotraSolver(TQpProbBase* of, TQpDataBase* prob, Int_t verbose = 0); virtual~TMehrotraSolver(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tTQpSolverBase::DataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t status_code, Int_t level); virtual voidTQpSolverBase::DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tTQpSolverBase::DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTQpSolverBase::DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tTQpSolverBase::DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """");",MatchSource.WIKI,root/html528/TMehrotraSolver.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMehrotraSolver.html
Availability,avail,available,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root/html528/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemberInspector.html
Integrability,message,message,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemberInspector.html
Safety,avoid,avoid,"obj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void GenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); Call ShowMember() on obj.; This could be faster if we implemented this either as a templated; function or by rootcint-generated code using the typeid (i.e. the; difference is a lookup in a TList instead of in a map).; To avoid a spurrious error message in case the data member is; transient and does not have a dictionary we check first. void InspectMember(TObject& obj, const char* name). void InspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient). void InspectMember(TClass* cl, void* pobj, const char* name). void Inspect(TClass* cl, const char* parent, const char* name, const void* addr). obj. ShowMembers(TMemberInspector& insp). » Author: Fons Rademakers 15/07/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TMemberInspector.h 35394 2010-09-17 19:40:12Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemberInspector.html
Security,access,accessing,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root/html528/TMemberInspector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemberInspector.html
Modifiability,variab,variable,". TMemberStreamer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TMemberStreamer. class TMemberStreamer. TMemberStreamer is used to stream a data member. The address passed to operator() will be the address of the data; member. Function Members (Methods); public:. TMemberStreamer(MemberStreamerFunc_t pointer); TMemberStreamer(const TMemberStreamer& rhs); virtual~TMemberStreamer(); virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* pmember, Int_t size = 0); TMemberStreamer&operator=(const TMemberStreamer&); virtual voidSetOnFileClass(const TClass* cl). protected:. TMemberStreamer(). Data Members; private:. TClassReffOnFileClass; MemberStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMemberStreamer(); {}. TMemberStreamer(MemberStreamerFunc_t pointer); {}. TMemberStreamer(const TMemberStreamer& rhs); {}. virtual ~TMemberStreamer(); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. void operator()(TBuffer& b, void* pmember, Int_t size = 0); The address passed to operator() will be the address of the data member.; If the data member is a variable size array, 'size' is the number of elements; to read/write. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TMemberStreamer.h 25450 2008-09-18 21:13:42Z pcanal $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMemberStreamer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemberStreamer.html
Availability,error,error,"virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidClose(); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemStat.html
Deployability,update,updated,"m.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of the nbigleaks largest leaks (default is 20); for each leak, the number of allocs and average alloc size is shown. Simply do:; root > TMemStat::Show(); or specifying arguments; root > TMemStat::Show(0.1,20,""mydir/mymemstat.root"");. The first argument to Show is the percentage of the time of the original job; that produced the file after which the display is updated. By default update=0.1,; ie 10 time intervals will be shown.; The second argument is nbigleaks.; The third argument is the imput file name (result of TMemStat).; If this argument is omitted, Show will take the most recent file; generated by TMemStat. You can restrict the address range to be analyzed via TMemStatShow::SetAddressRange; You can restrict the entry range to be analyzed via TMemStatShow::SetEntryRange. Function Members (Methods); public:. TMemStat(const TMemStat&); TMemStat(Option_t* option = ""read"", Int_t buffersize = 10000, Int_t maxcalls = 5000000); virtual~TMemStat(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; static voidC",MatchSource.WIKI,root/html528/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemStat.html
Energy Efficiency,allocate,allocated,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » MEMSTAT; » TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html528/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemStat.html
Integrability,depend,depending,"ot > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMemStat.system gnubuiltin; Root.TMemStat.buffersize 100000; Root.TMemStat.maxcalls 5000000. TMemStat::Show creates 3 canvases.; -In canvas1 it displays a dynamic histogram showing for pages (10 kbytes by default); the percentage of the page used.; A summary pave shows the total memory still in use when the TMemStat object; goes out of scope and the average occupancy of the pages.; The average occupancy gives a good indication of the memory fragmentation. -In canvas2 it displays the histogram of memory leaks in decreasing order.; when moving the mouse on this canvas, a tooltip shows the backtrace for the leak; in the bin below the mouse. -In canvas3 it displays the histogram of ",MatchSource.WIKI,root/html528/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemStat.html
Modifiability,variab,variable,". TMemStat. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » MEMSTAT; » TMemStat. class TMemStat: public TObject. TMemStat records all the calls to malloc and free and write a TTree; with the position where the memory is allocated/freed , as well as; the number of bytes. To use the class TMemStat, add the following statement at the beginning; of your script or program; TMemStat mm(""gnubuiltin"");; or in an interactive session do something like:; root > TMemStat mm(""gnubuiltin"");; root > .x somescript.C; root > .q. another (may be more practical way) is to modify $ROOTSYS/etc/system.rootrc; and activate the variable; Root.TMemStat: 1. The file collected by TMemStat is named memstat_ProcessID and can be analyzed and results shown; by executing the static function Show.; When TMemStat is active it recors every call to malloc/free in a ROOT Tree.; You must be careful when running jobs with many millions (or more) of calls; to malloc/free because the generated Tree may become very large.; The TMemStat constructor TMemStat(const char* system, Int_t buffersize, Int_t maxcalls); has its 3 arguments optional:; -system refers to the internal algorithm to compute the back traces.; the recommended value is ""gnubuiltin""; -buffersize is the number of calls to malloc or free that can be stored in one memory buffer.; when the buffer is full, the calls to malloc/free pointing to the same location; are eliminated and not written to the final Tree. The default value 100000; is such that between 50 and 90% of the calls are eliminated depending on the application.; You can set buffersize <=1 to keep every single call to malloc/free.; -maxcalls can set a limit for the maximum number of calls to be registered in the Tree.; The default value is 5000000.; The 3 arguments can be set in $ROOTSYS/etc/system.rootrc; Root.TMem",MatchSource.WIKI,root/html528/TMemStat.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMemStat.html
Availability,error,error,"idAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetMergedObjects(); Int_tGetMergedWorkers(); TSlave*GetMerger(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; TList*GetWorkers(); Int_tGetWorkersToMerge(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vir",MatchSource.WIKI,root/html528/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMergerInfo.html
Integrability,message,messages,". TMergerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TMergerInfo. class TMergerInfo: public TObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. TMergerInfo(TSlave* t, Int_t port, Int_t forHowManyWorkers); virtual~TMergerInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddMergedObjects(Int_t objects); voidAddWorker(TSlave* sl); virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tAreAllWorkersAssigned(); Bool_tAreAllWorkersMerged(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDeactivate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) con",MatchSource.WIKI,root/html528/TMergerInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMergerInfo.html
Availability,error,error," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnableSchemaEvolution(Bool_t enable = kTRUE); static voidEnableSchemaEvolutionForAll(Bool_t enable = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidTBuffer::Expand(Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceWriteInfo(TVirtualStreamerInfo* info, Bool_t force); virtual voidTBufferFile::ForceWriteInfoClones(TClonesArray* a); voidForward(); virtual Int_tTBufferFile::GetBufferDisplacement() const; Int_tTBuffer::GetBufferVersion() const; TClass*GetClass() const; Int_tGetCompressionLevel() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static Int_tTBufferFile::GetGlobalReadParam(); static Int_tTBufferFile::GetGlobalWriteParam(); virtual const char*TObject::GetIconName() const; virtual TVirtualStreamerInfo*TBufferFile::GetInfo(); virtual TProcessI",MatchSource.WIKI,root/html528/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessage.html
Integrability,message,message,"; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of fBufCur when message was compressed; Int_tfCompressCompression level from 0 (not compressed) to 9 (max compression); Bool_tfEvolutionTrue if support for schema evolution required; TList*fInfosArray of TStreamerInfo used in WriteObject; UInt_tfWhatMessage type; static Bool_tfgEvolutionTrue if global support for schema evolution required. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); Create a TMessage object for storing objects. The ""what"" integer; describes the type of message. Predifined ROOT system message types; can be found in MessageTypes.h. Make sure your own message types are; unique from the ROOT defined message types (i.e. 0 - 10000 are; reserved by ROOT). In case you OR ""what"" with kMESS_ACK, the message; will wait for an acknowledgement from the remote side. This makes; the sending process synchronous. In case you OR ""what"" with kMESS_ZIP,; the message will be compressed in TSocket using the zip al",MatchSource.WIKI,root/html528/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessage.html
Modifiability,inherit,inherits,". TMessage. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TMessage. class TMessage: public TBufferFile. TMessage. Message buffer class used for serializing objects and sending them; over a network. This class inherits from TBuffer the basic I/O; serializer. Function Members (Methods); public:. TMessage(UInt_t what = kMESS_ANY, Int_t bufsiz = TBuffer::kInitialSize); virtual~TMessage(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); char*TBuffer::Buffer() const; Int_tTBuffer::BufferSize() const; virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const TClass* clss); virtual Int_tTBufferFile::CheckByteCount(UInt_t startpos, UInt_t bcnt, const char* classname); virtual Bool_tTBufferFile::CheckObject(const TObject* obj); virtual Bool_tTBufferFile::CheckObject(const void* obj, const TClass* ptrClass); static TClass*Class(); virtual voidTBufferFile::ClassBegin(const TClass*, Version_t = -1); virtual voidTBufferFile::ClassEnd(const TClass*); virtual voidTBufferFile::ClassMember(const char*, const char* = 0, Int_t = -1, Int_t = -1); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; char*CompBuffer() const; Int_tCompLength() const; Int_tCompress(); virtual voidTObject::Copy(TObject& object) const; virtual voidTBufferFile::DecrementLevel(TVirtualStreamerInfo*); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTBuffer::DetachBuffer(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*",MatchSource.WIKI,root/html528/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessage.html
Performance,cache,cache,"edMemberWise; kNotDecompressed; kTextBasedStreaming; kUser1; kUser2; kUser3; };; enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBufferFile::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; TExMap*TBufferFile::fClassMapMap containing object,class pairs for reading; Int_tTBufferFile::fDisplacementValue to be added to the map offsets; TStreamerInfo*TBufferFile::fInfoPointer to TStreamerInfo object writing/reading the buffer; vector<TStreamerInfo*>TBufferFile::fInfoStackStack of pointers to the TStreamerInfos; TExMap*TBufferFile::fMapMap containing object,offset pairs for reading/writing; Int_tTBufferFile::fMapCountNumber of objects or classes in map; Int_tTBufferFile::fMapSizeDefault size of map; Bool_tTBuffer::fModeRead or write mode; TObject*TBuffer::fParentPointer to parent object owning this buffer; UShort_tTBufferFile::fPidOffsetOffset to be added to the pid index in this key/buffer.; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; Int_tTBuffer::fVersionBuffer format version; static Int_tTBufferFile::fgMapSizeDefault map size for all TBuffer objects. private:. TBitsfBitsPIDsArray of bits to mark the TProcessIDs uids written to the message; char*fBufCompCompressed buffer; char*fBufCompCurCurrent position in compressed buffer; TClass*fClassIf message is kMESS_OBJECT pointer to object's class; char*fCompPosPosition of ",MatchSource.WIKI,root/html528/TMessage.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessage.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual Int_tGetMessageCount(Int_t messId) const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual Int_tGet",MatchSource.WIKI,root/html528/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessageHandler.html
Deployability,install,install,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html528/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessageHandler.html
Integrability,message,messages,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html528/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessageHandler.html
Security,access,access,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html528/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessageHandler.html
Testability,log,logged,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root/html528/TMessageHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMessageHandler.html
Availability,error,error,"d(const TMethod& org); TMethod(MethodInfo_t* info = 0, TClass* cl = 0); virtual~TMethod(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataMember*FindDataMember(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TClass*GetClass() const; virtual const char*GetCommentString(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TList*GetListOfMethodArgs(); virtual const char*TFunction::GetMangledName() const; virtual const char*TNamed::GetName() const; Int_tTFunction::GetNargs() const; Int_tTFunction::GetNargsOpt() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virt",MatchSource.WIKI,root/html528/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethod.html
Deployability,update,updates,"hodInfo_t* info = 0, TClass* cl = 0); Default TMethod ctor. TMethods are constructed in TClass.; Comment strings are pre-parsed to find out whether the method is; a context-menu item. TMethod(const TMethod& org); Copy ctor. TMethod& operator=(const TMethod& rhs); Assignment operator. ~TMethod(); Cleanup. TObject * Clone(const char* newname = """") const; Clone method. const char * GetCommentString(); Returns a comment string from the class declaration. void CreateSignature(); Using the CINT method arg information create a complete signature string. TDataMember * FindDataMember(); Tries to guess DataMember from comment string; and Method's name <==(only if 1 Argument!).; If more then one argument=> returns pointer to the last argument.; It also sets MethodArgs' pointers to point to specified data members. The form of comment string defining arguments is:; void XXX(Int_t x1, Float_t y2) //*ARGS={x1=>fX1,y2=>fY2}; where fX1, fY2 are data fields in the same class.; (""pointers"" to data members). TMethodCall * GetterMethod(); Return call environment for the getter method in case this is a; *TOGGLE method (for the context menu). TMethodCall * SetterMethod(); Return call environment for this method in case this is a; *TOGGLE method which takes a single boolean or integer argument. TList * GetListOfMethodArgs(); Returns methodarg list and additionally updates fDataMember in TMethod by; calling FindDataMember();. TClass * GetClass() const; { return fClass; }. EMenuItemKind IsMenuItem() const; { return fMenuItem; }. const char * Getter() const; { return fGetter; }. void SetMenuItem(EMenuItemKind menuItem); {fMenuItem=menuItem;}. » Author: Rene Brun 09/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TMethod.h 24077 2008-05-31 19:39:09Z brun $ » Last generated: 2010-09-30 11:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethod.html
Availability,error,error,"MethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); virtual~TMethodArg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; const char*GetDefault() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFullTypeName() const; virtual const char*TObject::GetIconName() const; TFunction*GetMethod() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TList*GetOptions() const; virtual const char*TNamed::GetTitle() const; const char*GetTypeName() const; virtual UInt_tTObject::GetUniqueID",MatchSource.WIKI,root/html528/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodArg.html
Usability,learn,learn,"udes; Libraries. Function documentation; TMethodArg(MethodArgInfo_t* info = 0, TFunction* method = 0); Default TMethodArg ctor. TMethodArgs are constructed in TFunction; via a call to TCint::CreateListOfMethodArgs(). ~TMethodArg(); TMethodArg dtor deletes adopted CINT MethodArgInfo object. const char * GetDefault() const; Get default value of method argument. const char * GetTypeName() const; Get type of method argument, e.g.: ""class TDirectory*"" -> ""TDirectory""; Result needs to be used or copied immediately. const char * GetFullTypeName() const; Get full type description of method argument, e.g.: ""class TDirectory*"". Long_t Property() const; Get property description word. For meaning of bits see EProperty. TList * GetOptions() const; Returns list of possible options - according to pointed datamember.; If there is no datamember field assigned to this methodarg - returns 0. TDataMember * GetDataMember() const; Returns TDataMember pointed by this methodarg.; If you want to specify list of options or current value for your; MethodArg (i.e. it is used as initial values in argument-asking dialogs; popped up from context-meny),you can get this value from one of data; members of the class.; The only restriction is, that this DataMember object must have its; Getter/Setter methods set-up correctly - for details look at TDataMember.; To learn how to specify the data member to which the argument should; ""point"", look at TMethod. This is TMethod which sets up fDataMember,; so it could work correctly. TMethodArg(const TMethodArg& ). TMethodArg& operator=(const TMethodArg& ). TFunction * GetMethod() const; { return fMethod; }. » Author: Rene Brun 04/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TMethodArg.h 25986 2008-10-28 08:39:44Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMethodArg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodArg.html
Availability,error,error,"hodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObje",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Integrability,depend,depending,"alling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-12-01 01:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Modifiability,extend,extend,". TMethodBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; ",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Performance,cache,cached,"ROOT; » TREE; » TREE; » TMethodBrowsable. class TMethodBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const ",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Security,access,access,"lass and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being browsed. Bool_t IsMethodBrowsable(const TMethod* m); A TMethod is browsable if it is const, public and not pure virtual,; if does not have any parameter without default value, and if it has; a (non-void) return value.; A method called *, Get*, or get* will not be browsable if there is a; persistent data member called f*, _*, or m*, as data member access is; faster than method access. Examples: if one of fX, _X, or mX is a; persistent data member, the methods GetX(), getX(), and X() will not; be browsable. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... const char * GetIconName() const; return icon shown when browsing a TVirtualBranchBrowsable. ~TMethodBrowsable(); {}. TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-12-01 01:52; This page h",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Usability,simpl,simple,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Brow",MatchSource.WIKI,root/html528/TMethodBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html
Energy Efficiency,efficient,efficient,"kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TClass*fClasspointer to the class info; Bool_tfDtorOnlycall only dtor and not delete when calling ~xxx; CallFunc_t*fFuncCINT method invocation environment; TFunction*fMetPtrpointer to the method or function info; TStringfMethodmethod name; Long_tfOffsetoffset added to object pointer before method invocation; TStringfParamsargument string; TStringfProtoprototype string; TMethodCall::EReturnTypefRetTypemethod return type. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodCall(); Default TMethodCall ctor. Use Init() to initialize the method call; environment. TMethodCall(TClass* cl, const char* method, const char* params); Create a method invocation environment for a specific class, method and; parameters. The parameter string has the form: ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const char* function, const char* params); Create a global function invocation environment. The parameter; string has the form: ""\""aap\"", 3, 4,35"". To execute the; function call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). TMethodCall(const TMethodCall& org); Copy ctor. TMethodCall & operator=(const TMethodCall& rhs); Assignement operator. ~TMethodCall(); TMethodCall dtor. TObject * Clone(const char* newname = """") const; Return an exact copy of this object. void Init(TClass* cl, const char* method, const char* params); Initialize the method invocation environment. Necessary input; information: the class, method name and the parameter string; of the form ""\""aap\"", 3, 4.35"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Exe",MatchSource.WIKI,root/html528/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodCall.html
Integrability,interface,interface,". TMethodCall. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TMethodCall. class TMethodCall: public TObject. TMethodCall. Method or function calling interface. Objects of this class contain; the (CINT) environment to call a global function or a method for an; object of a specific class with the desired arguments. This class is; espicially useful when a method has to be called more times for; different objects and/or with different arguments. If a function or; method needs to be called only once one better uses; TInterpreter::Execute(). Function Members (Methods); public:. TMethodCall(); TMethodCall(const TMethodCall& org); TMethodCall(const char* function, const char* params); TMethodCall(TClass* cl, const char* method, const char* params); virtual~TMethodCall(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCallDtorOnly(Bool_t set = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecute(); voidExecute(void* object); voidExecute(const char* params); voidExecute(Long_t& retLong); voidExecute(Double_t& retDouble); voidExecute(void* object, const char* ",MatchSource.WIKI,root/html528/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodCall.html
Performance,cache,cached,"lize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(void* object, char** retText); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, char** retText); Execute the method for the specified object and argument values. void SetParamPtrs(voi",MatchSource.WIKI,root/html528/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodCall.html
Usability,usab,usable,"lementation(const char* methodname, const char* params, const char* proto, TClass* cl, const ClassInfo_t* cinfo); This function implements Init and InitWithPrototype. void InitWithPrototype(TClass* cl, const char* method, const char* proto); Initialize the method invocation environment. Necessary input; information: the class, method name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(object,...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). void InitWithPrototype(const char* function, const char* proto); Initialize the function invocation environment. Necessary input; information: the function name and the prototype string of; the form: ""char*,int,float"".; To execute the method call TMethodCall::Execute(...).; This two step method is much more efficient than calling for; every invocation TInterpreter::Execute(...). Bool_t IsValid() const; Return true if the method call has been properly initialized and is; usable. TFunction * GetMethod(); Returns the TMethod describing the method to be executed. This takes; all overriding and overloading into account (call TClass::GetMethod()).; Since finding the method is expensive the result is cached. void Execute(void* object); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params); Execute the method for the specified object and argument values. void Execute(void* object, Long_t& retLong); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Long_t& retLong); Execute the method for the specified object and argument values. void Execute(void* object, Double_t& retDouble); Execute the method (with preset arguments) for the specified object. void Execute(void* object, const char* params, Double_t& retDouble); Execute the method for the specified object and argument values. void Execute(vo",MatchSource.WIKI,root/html528/TMethodCall.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMethodCall.html
Availability,down,down,"lected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Deployability,patch,patch,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Integrability,depend,depending,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Modifiability,variab,variables,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Performance,perform,perform,"value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Safety,avoid,avoided,"or more variable parameters. To take a simple example, in case of ROOT histograms (classes TH1C,TH1S,TH1F,TH1D); the Fit function defines the Minuit fitting function as being H1FitChisquare; or H1FitLikelihood depending on the options selected.; H1FitChisquare; calculates the chisquare between the user fitting function (gaussian, polynomial,; user defined,etc) and the data for given values of the parameters.; It is the task of MINUIT to find those values of the parameters; which give the lowest value of chisquare. Basic concepts - The transformation for parameters with limits. For variable parameters with limits, MINUIT uses the following; transformation:. P = arcsin(2((P -a)/(b- a))-1) P = a+((b- a)/(2))(sinP +1); int ext ext int. so that the internal value P can take on any value, while the external; int; value P can take on values only between the lower limit a and the; ext; upper limit b. Since the transformation is necessarily non-linear, it; would transform a nice linear problem into a nasty non-linear one, which; is the reason why limits should be avoided if not necessary. In addition,; the transformation does require some computer time, so it slows down the; computation a little bit, and more importantly, it introduces additional; numerical inaccuracy into the problem in addition to what is introduced in; the numerical calculation of the FCN value. The effects of; non-linearity and numerical roundoff both become more important as the; external value gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if he puts limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. U",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Testability,log,log,"sation function; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated (see example below); grad: array of gradients; Output parameters:; fval: The calculated function value.; grad: The (optional) vector of first derivatives). The meaning of the parameters par is of course defined by the user,; who uses the values of those parameters to calculate his function value.; The starting values must be specified by the user.; Later values are determined by Minuit as it searches for the minimum; or performs whatever analysis is requested by the user. Note that this virtual function may be redefined in a class derived from TMinuit.; The default function calls the function specified in SetFCN. Example of Minimisation function:. if (flag == 1) {; read input data,; calculate any necessary constants, etc.; }; if (flag == 2) {; calculate GRAD, the first derivatives of FVAL; (this is optional); }; Always calculate the value of the function, FVAL,; which is usually a chisquare or log likelihood.; if (iflag == 3) {; will come here only after the fit is finished.; Perform any final calculations, output fitted data, etc.; }. See concrete examples in TH1::H1FitChisquare, H1FitLikelihood. Int_t FixParameter(Int_t parNo); fix a parameter. Int_t GetParameter(Int_t parNo, Double_t& currentValue, Double_t& currentError) const; return parameter value and error. Int_t GetNumFixedPars() const; returns the number of currently fixed parameters. Int_t GetNumFreePars() const; returns the number of currently free parameters. Int_t GetNumPars() const; returns the total number of parameters that have been defined.; (fixed and free). Int_t Migrad(); invokes the MIGRAD minimizer. Int_t Release(Int_t parNo); release a parameter. Int_t SetErrorDef(Double_t up); To get the n-sigma contour the error def parameter ""up"" has to set to n^2. void SetFCN(void (*fcn)(Int_t &, Double_t *, Double_t &f, Double_t *, I",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Usability,simpl,simply,". TMinuit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuit. class TMinuit: public TNamed. The Minimization package*-; -* ======================== ; -* ; -* This package was originally written in Fortran by Fred James ; -* and part of PACKLIB (patch D506) ; -* ; -* It has been converted to a C++ class by R.Brun ; -* The current implementation in C++ is a straightforward conversion ; -* of the original Fortran version: The main changes are: ; -* ; -* - The variables in the various Minuit labelled common blocks ; -* have been changed to the TMinuit class data members. ; -* - The internal arrays with a maximum dimension depending on the ; -* maximum number of parameters are now data members arrays with ; -* a dynamic dimension such that one can fit very large problems ; -* by simply initialising the TMinuit constructor with the maximum ; -* number of parameters. ; -* - The include file Minuit.h has been commented as much as possible; -* using existing comments in the code or the printed documentation; -* - The original Minuit subroutines are now member functions. ; -* - Constructors and destructor have been added. ; -* - Instead of passing the FCN function in the argument ; -* list, the addresses of this function is stored as pointer ; -* in the data members of the class. This is by far more elegant ; -* and flexible in an interactive environment. ; -* The member function SetFCN can be used to define this pointer. ; -* - The ROOT static function Printf is provided to replace all ; -* format statements and to print on currently defined output file.; -* - The functions SetObjectFit(TObject *obj)/GetObjectFit() can be ; -* used inside the FCN function to set/get a referenced object ; -* instead of using global variables. ; *. . Basic concepts of MINUIT. The MINUIT package acts on a mu",MatchSource.WIKI,root/html528/TMinuit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuit.html
Availability,error,errors,"egy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Deployability,update,update,"d FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Integrability,interface,interface,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::Options() const; doubleROOT::Math::Minimizer::Precision()",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Modifiability,plug-in,plug-in,". TMinuitMinimizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MINUIT; » TMinuitMinimizer. class TMinuitMinimizer: public ROOT::Math::Minimizer. TMinuitMinimizer class implementing the ROOT::Math::Minimizer interface using; TMinuit.; This class is normally instantiates using the plug-in manager; (plug-in with name Minuit or TMinuit); In addition the user can choose the minimizer algorithm: Migrad (the default one), Simplex, or Minimize (combined Migrad + Simplex). Function Members (Methods); public:. TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); TMinuitMinimizer(const char* type, unsigned int ndim = 0); virtual~TMinuitMinimizer(); static TClass*Class(); virtual voidROOT::Math::Minimizer::Clear(); virtual boolContour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); virtual doubleROOT::Math::Minimizer::Correlation(unsigned int i, unsigned int j) const; virtual doubleCovMatrix(unsigned int i, unsigned int j) const; virtual intCovMatrixStatus() const; virtual doubleEdm() const; doubleROOT::Math::Minimizer::ErrorDef() const; virtual const double*Errors() const; virtual boolGetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); virtual doubleGlobalCC(unsigned int) const; virtual boolHesse(); virtual TClass*IsA() const; boolROOT::Math::Minimizer::IsValidError() const; unsigned intROOT::Math::Minimizer::MaxFunctionCalls() const; unsigned intROOT::Math::Minimizer::MaxIterations() const; virtual const double*MinGradient() const; virtual boolMinimize(); virtual doubleMinValue() const; virtual unsigned intNCalls() const; virtual unsigned intNDim() const; virtual unsigned intNFree() const; virtual ROOT::Math::MinimizerOptionsROOT::Math::Minimizer::Options() const; doubleROOT::Math::Minimizer::Precision()",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Performance,perform,perform,"on of FCN static function used internally by TMinuit.; Adapt IMultiGenFunction interface to TMinuit FCN static function. void FcnGrad(int& , double* g, double& f, double* , int ); implementation of FCN static function used internally by TMinuit.; Adapt IMultiGradFunction interface to TMinuit FCN static function in the case of user; provided gradient. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set a free variable. bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set a limited variable. bool SetFixedVariable(unsigned int , const string& , double ); set a fixed variable. bool SetVariableValue(unsigned int , double ); set the value of an existing variable; parameter must exist or return false. std::string VariableName(unsigned int ivar) const; return the variable name. int VariableIndex(const string& name) const; return variable index. bool Minimize(); perform the minimization using the algorithm chosen previously by the user; By default Migrad is used.; Return true if the found minimum is valid and update internal chached values of; minimum values, errors and covariance matrix.; Status of minimizer is set to:; migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult. void RetrieveParams(); retrieve from TMinuit minimum parameter values; and errors. void RetrieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. dou",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Security,validat,validated,"egy() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); doubleROOT::Math::Minimizer::Tolerance() const; static boolUseStaticMinuit(bool on = true); virtual intVariableIndex(const string& name) const; virtual stringVariableName(unsigned int ivar) const; virtual const double*X() const. protected:. voidDoClear(); voidDoReleaseFixParameter(int ivar); static voidFcn(int&, double*, double& f, double*, int); static voidFcnGrad(int&, double* g, double& f, double*, int); voidInitTMinuit(int ndim); voidRetrieveErrorMatrix(); voidRetrieveParams(). private:. TMinuitMinimizer(const TMinuitMinimizer&); TMinuitMinimizer&operator=(const TMinuitMinimizer& rhs). Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; doubleROOT::Math::Minimizer::fPrecprecision; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. vector<double>fCovar; unsigned intfDim; vector<double>fErrors; boolfMinosRun; TMinuit*fMinuit; vector<double>fParams; unsigned intfStrategy; ROOT::Minuit::EMinimizerTypefType; boolfUsed; static ROOT::Math::IBaseFunctionMultiDim*fgFunc; static TMinuit*fgMinuit; static boolfgUseStaticMinuitflag to control if using global TMInuit instance (gMinuit); static boolfgUsedflag to control if static instance has done minimization. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuitMinimizer(ROOT::Minuit::EMinimizerType type = ROOT::Minuit::kMigrad, unsigned int ndim = 0); Constructor for TMinuitMinimier class via an enumeration specifying the minim",MatchSource.WIKI,root/html528/TMinuitMinimizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMinuitMinimizer.html
Availability,error,error,"l~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Float_tTMaterial::GetInterLength() const; virtual const char*TNamed::GetName() const; Int_tGetNmixt() const; virtual Int_tTMaterial::GetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjec",MatchSource.WIKI,root/html528/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMixture.html
Safety,detect,detector,". TMixture. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TMixture. class TMixture: public TMaterial. Manages a detector mixture. See class TGeometry. Function Members (Methods); public:. TMixture(); TMixture(const TMixture&); TMixture(const char* name, const char* title, Int_t nmixt); virtual~TMixture(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineElement(Int_t n, Float_t a, Float_t z, Float_t w); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tTMaterial::GetA() const; Float_t*GetAmixt() const; virtual Float_tTMaterial::GetDensity() const; virt",MatchSource.WIKI,root/html528/TMixture.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMixture.html
Availability,error,error,"e = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGatherInformations(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TTree*GetIOTree() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Deployability,continuous,continuous,"sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each output, filled with the; test data events. This method is mainly useful when doing regression; analysis with the MLP (i.e. not classification, but continuous truth; values).; The returned THStack contains all the TProfiles. It is drawn unless; the option ""goff"" is specified.; Options are passed to TProfile::Draw. TProfile* DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); Creates a profile of the difference of the MLP output outnode minus; the true value of outnode vs the input value innode, for all test; data events.; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfi",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Modifiability,variab,variables,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. TMLPAnalyzer(TMultiLayerPerceptron& net); TMLPAnalyzer(TMultiLayerPerceptron* net); TMLPAnalyzer(const TMLPAnalyzer&); virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Performance,optimiz,optimizing," analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TProfile::Draw. THStack* DrawTruthDeviations(Option_t* option = """"); Creates TProfiles of the difference of the MLP output minus the; true value vs the true value, one for each outpu",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Safety,risk,risk," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Testability,test,tests,". TMLPAnalyzer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMLPAnalyzer. class TMLPAnalyzer: public TObject. TMLPAnalyzer. This utility class contains a set of tests usefull when developing; a neural network.; It allows you to check for unneeded variables, and to control; the network structure. Function Members (Methods); public:. TMLPAnalyzer(TMultiLayerPerceptron& net); TMLPAnalyzer(TMultiLayerPerceptron* net); TMLPAnalyzer(const TMLPAnalyzer&); virtual~TMLPAnalyzer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckNetwork(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawDInput(Int_t i); voidDrawDInputs(); voidDrawNetwork(Int_t neuron, const char* signal, const char* bg); TProfile*DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); TProfile*DrawTruthDeviationInOut(Int_t innode, Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviationInsOut(Int_t outnode = 0, Option_t* option = """"); THStack*DrawTruthDeviations(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Usability,learn,learn," some information about the network in the terminal. void GatherInformations(); Collect informations about what is usefull in the network.; This method has to be called first when analyzing a network.; Fills the two analysis trees. void DrawDInput(Int_t i); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; the ith input. void DrawDInputs(); Draws the distribution (on the test sample) of the; impact on the network output of a small variation of; each input.; DrawDInputs() draws something that approximates the distribution of the; derivative of the NN w.r.t. each input. That quantity is recognized as; one of the measures to determine key quantities in the network. What is done is to vary one input around its nominal value and to see; how the NN changes. This is done for each entry in the sample and produces; a distribution. What you can learn from that is:; - is variable a really useful, or is my network insensitive to it ?; - is there any risk of big systematic ? Is the network extremely sensitive; to small variations of any of my inputs ?. As you might understand, this is to be considered with care and can serve; as input for an ""educated guess"" when optimizing the network. void DrawNetwork(Int_t neuron, const char* signal, const char* bg); Draws the distribution of the neural network (using ith neuron).; Two distributions are drawn, for events passing respectively the ""signal""; and ""background"" cuts. Only the test sample is used. TProfile* DrawTruthDeviation(Int_t outnode = 0, Option_t* option = """"); Create a profile of the difference of the MLP output minus the; true value for a given output node outnode, vs the true value for; outnode, for all test data events. This method is mainly useful; when doing regression analysis with the MLP (i.e. not classification,; but continuous truth values).; The resulting TProfile histogram is returned.; It is not drawn if option ""goff"" is specified.; Options are passed to TP",MatchSource.WIKI,root/html528/TMLPAnalyzer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMLPAnalyzer.html
Availability,error,error," const char* doc = """"); virtual~TModuleDocInfo(); voidTObject::AbstractMethod(const char* method) const; voidAddClass(TClassDocInfo* cl); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TList*GetClasses(); const char*GetDoc() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THashList&GetSub(); TModuleDocInfo*GetSuper() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash(",MatchSource.WIKI,root/html528/TModuleDocInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TModuleDocInfo.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMonitor.html
Energy Efficiency,monitor,monitors,". TMonitor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TMonitor. class TMonitor: public TObject, public TQObject. TMonitor. This class monitors activity on a number of network sockets.; The actual monitoring is done by TSystem::DispatchOneEvent().; Typical usage: create a TMonitor object. Register a number of; TSocket objects and call TMonitor::Select(). Select() returns the; socket object which has data waiting. TSocket objects can be added,; removed, (temporary) enabled or disabled. Function Members (Methods); public:. TMonitor(Bool_t mainloop = kTRUE); TMonitor(const TMonitor& m); virtual~TMonitor(); voidTObject::AbstractMethod(const char* method) const; virtual voidActivate(TSocket* sock); virtual voidActivateAll(); virtual voidAdd(TSocket* sock, Int_t interest = kRead); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidT",MatchSource.WIKI,root/html528/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMonitor.html
Integrability,rout,routine," with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of error. TSocket * Select(Long_t timeout); Return pointer to socket for which an event is waiting.; Wait a maximum of timeout milliseconds.; If return is due to timeout it returns (TSocket *)-1.; Select() can be interrupt by a call to Interrupt() (e.g. connected with a; Ctrl-C handler); a call to ResetInterrupt() before Select() is advisable; in such a case.; Return 0 in case of any other error situation. Int_t Select(TList* rdready, TList* wrready, Long_t timeout); Return numbers of sockets that are ready for reading or writing.; Wait a maximum of timeout milliseconds.; Return 0 if timed-out. Return < 0 in case of error.; If rdready and/or wrready are not 0, the lists of sockets with; something to read and/or write are also returned. void SetReady(TSocket* sock); Called by TSocketHandler::Notify() to signal which socket is ready; to be read or written. User should not call this routine. The ready; socket will be returned via the Select() user function.; The Ready(TSocket *sock) signal is emitted. Int_t GetActive(Long_t timeout = -1) const; Return number of sockets in the active list. If timeout > 0, remove from; the list those sockets which did not have any activity since timeout; millisecs. If timeout = 0, then reset activity timestamp on all active; sockets. This time out is typically used if GetActive() is used to see; how many remotes still need to send something. If they pass the timeout; they will be skipped and GetActive() will return 0 and the loop can be; exited. Int_t GetDeActive() const; Return number of sockets in the de-active list. Bool_t IsActive(TSocket* s) const; Check if socket 's' is in the active list. Avoids the duplication; of active list via TMonitor::GetListOfActives(). TList * GetListOfActives() const; Returns a list with all active sockets. This list must be deleted; by the user. DO NOT call Delete() on this list as it will ",MatchSource.WIKI,root/html528/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMonitor.html
Safety,timeout,timeout,"t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetActive(Long_t timeout = -1) const; Int_tGetDeActive() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetListOfActives() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfDeActives() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObje",MatchSource.WIKI,root/html528/TMonitor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMonitor.html
Availability,reliab,reliably," Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Energy Efficiency,energy,energy,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. ",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Integrability,depend,dependent,". TMultiDimFit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TMultiDimFit. class TMultiDimFit: public TNamed. /*. Multidimensional Fits in ROOT. Overview. A common problem encountered in different fields of applied science is; to find an expression for one physical quantity in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. ",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Modifiability,variab,variables,"ty in terms of several; others, which are directly measurable. An example in high energy physics is the evaluation of the momentum of; a charged particle from the observation of its trajectory in a magnetic; field. The problem is to relate the momentum of the particle to the; observations, which may consists of of positional measurements at; intervals along the particle trajectory. The exact functional relationship between the measured quantities; (e.g., the space-points) and the dependent quantity (e.g., the; momentum) is in general not known, but one possible way of solving the; problem, is to find an expression which reliably approximates the; dependence of the momentum on the observations. This explicit function of the observations can be obtained by a; least squares fitting procedure applied to a representive; sample of the data, for which the dependent quantity (e.g., momentum); and the independent observations are known. The function can then be; used to compute the quantity of interest for new observations of the; independent variables. This class TMultiDimFit implements such a procedure in; ROOT. It is largely based on the CERNLIB MUDIFI package; [2]. Though the basic concepts are still sound, and; therefore kept, a few implementation details have changed, and this; class can take advantage of MINUIT [4] to improve the errors; of the fitting, thanks to the class TMinuit. In [5] and [6] H. Wind demonstrates the utility; of this procedure in the context of tracking, magnetic field; parameterisation, and so on. The outline of the method used in this; class is based on Winds discussion, and I refer these two excellents; text for more information. And example of usage is given in; $ROOTSYS/tutorials/fit/multidimfit.C. The Method. Let by the dependent quantity of interest, which depends smoothly; on the observable quantities ; , which we'll denote by. . Given a training sample of tuples of the form,; (TMultiDimFit::AddRow). where ; are independent; variables, is t",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Performance,perform,perform," Therefore, the; user is asked to provide a minimum relative error ; (TMultiDimFit::SetMinRelativeError), and ; will be considered minimized when. Optionally, the user may impose a functional expression by specifying; the powers of each variable in specified functions ; (TMultiDimFit::SetPowers). In that case, only the; coefficients is calculated by the class. Limiting the Number of Terms. As always when dealing with fits, there's a real chance of; over fitting. As is well-known, it's always possible to fit an; polynomial in to points with ; , but; the polynomial is not likely to fit new data at all; [1]. Therefore, the user is asked to provide an upper; limit, to the number of terms in ; (TMultiDimFit::SetMaxTerms). However, since there's an infinite number of to choose from, the; user is asked to give the maximum power. , of each variable; to be considered in the minimization of ; (TMultiDimFit::SetMaxPowers). One way of obtaining values for the maximum power in variable , is; to perform a regular fit to the dependent quantity , using a; polynomial only in . The maximum power is is then the; power that does not significantly improve the one-dimensional; least-square fit over to [5]. There are still a huge amount of possible choices for ; in fact; there are ; possible; choices. Obviously we need to limit this. To this end, the user is; asked to set a power control limit, ; (TMultiDimFit::SetPowerLimit), and a function; is only accepted if. where is the leading power of variable in function; . (TMultiDimFit::MakeCandidates). So the number of; functions increase with (1, 2 is fine, 5 is way out). Gram-Schmidt Orthogonalisation. To further reduce the number of functions in the final expression,; only those functions that significantly reduce is chosen. What; `significant' means, is chosen by the user, and will be; discussed below (see 2.3). The functions are generally not orthogonal, which means one will; have to evaluate all possible 's over all data-points before; fi",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Testability,test,test,"tain; [3],.    if. (6). We now take as a new model ; . We thus want to; minimize. (7). where ; is a vector of the; dependent quantity in the sample. Differentiation with respect to; gives, using (6),. (8). or. (9). Let be the sum of squares of residuals when taking functions; into account. Then. (10). Using (9), we see that.  ;  .  ;  . (11). So for each new function included in the model, we get a; reduction of the sum of squares of residuals of ; ,; where ; is given by (4) and by; (9). Thus, using the Gram-Schmidt orthogonalisation, we; can decide if we want to include this function in the final model,; before the matrix inversion. Function Selection Based on Residual. Supposing that steps of the procedure have been performed, the; problem now is to consider the ; function. The sum of squares of residuals can be written as. (12). where the relation (9) have been taken into account. The; contribution of the ; function to the reduction of S, is; given by. (13). Two test are now applied to decide whether this . function is to be included in the final expression, or not. Test 1. Denoting by the subspace spanned by. the function ; is; by construction (see (4)) the projection of the function; onto the direction perpendicular to . Now, if the; length of ; (given by ; ); is very small compared to the length of ; this new; function can not contribute much to the reduction of the sum of; squares of residuals. The test consists then in calculating the angle; between the two vectors ; and . (see also figure 1) and requiring that it's; greater then a threshold value which the user must set; (TMultiDimFit::SetMinAngle). Figure 1:; (a) Angle between ; and; ; , (b) angle between ; and; . ; Test 2. Let ; be the data vector to be fitted. As illustrated in; figure 1, the ; function . will contribute significantly to the reduction of , if the angle. between ; and ; is smaller than; an upper limit , defined by the user; (TMultiDimFit::SetMaxAngle). However, the method automatically re",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Usability,simpl,simple,"sentive of the problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5]. Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6]. H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):. Define ; are the 5 dependent; quantities that define a track. Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; . Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; . Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent. Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; . To process data, using this parameterisation, do. Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis. Determine ; as before. Detetmine ; as before. Use the result of the fit to determind ; . Transform back to ; from ; , using; the result from the Principal Component Analysis. Testing the parameterization. The class also provides functio",MatchSource.WIKI,root/html528/TMultiDimFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiDimFit.html
Availability,error,error,"ject::AbstractMethod(const char* method) const; virtual voidAdd(TGraph* graph, Option_t* chopt = """"); virtual voidAdd(TMultiGraph* multigraph, Option_t* chopt = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* chopt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TFitResultPtrFit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); virtual TFitResultPtrFit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); virtual voidFitPanel()MENU ; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TF1*GetFunction(const char* name) const; virtual Option_t*GetGraphDrawOption(const TGraph* gr) const; TH1F*GetHistogram() const; virtual const char*TObject::GetIconName() const; TList*GetListOfFunctions(); const TList*GetListOfFuncti",MatchSource.WIKI,root/html528/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiGraph.html
Integrability,interface,interface," TMultigraph is still active. void Add(TMultiGraph* multigraph, Option_t* chopt = """"); add all the graphs in ""multigraph"" to the list of graphs. void Browse(TBrowser* b); Browse multigraph. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to each graph. void Draw(Option_t* chopt = """"); Draw this multigraph with its current attributes. Options to draw a graph are described in TGraph::PainGraph. The drawing option for each TGraph may be specified as an optional; second argument of the Add function. You can use GetGraphDrawOption; to return this option.; If a draw option is specified, it will be used to draw the graph,; otherwise the graph will be drawn with the option specified in; TMultiGraph::Draw. Use GetDrawOption to return the option specified; when drawin the TMultiGraph. TFitResultPtr Fit(const char* formula, Option_t* option = """", Option_t* goption = """", Axis_t xmin = 0, Axis_t xmax = 0); Fit this graph with function with name fname. interface to TF1::Fit(TF1 *f1... TFitResultPtr Fit(TF1* f1, Option_t* option = """", Option_t* goption = """", Axis_t rxmin = 0, Axis_t rxmax = 0); Fit this multigraph with function f1. In this function all graphs of the multigraph are fitted simultaneously. f1 is an already predefined function created by TF1.; Predefined functions such as gaus, expo and poln are automatically; created by ROOT. The list of fit options is given in parameter option.; option = ""W"" Set all errors to 1; = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; = ""R"" Use the Range specified in the function range; = ""N"" Do not store the graphics function, do not draw; = ""0"" Do not plot the result of the fit. By default the fitted function; is drawn unless the option""N"" above is specified.; = ""+"" Add this new fitt",MatchSource.WIKI,root/html528/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiGraph.html
Security,access,access,"::EvaluateChi2.; In case of TGraphErrors an effective chi2 is used; (see TGraphErrors fit in TGraph::Fit) and is implemented in; FitUtil::EvaluateChi2Effective; To specify a User defined fitting function, specify option ""U"" and; call the following functions:; TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); where MyFittingFunction is of type:; extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);. Access to the fit result. The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; By default the TFitResultPtr contains only the status of the fit and it converts; automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; the TFitResult and behaves as a smart pointer to it. For example one can do:; TFitResultPtr r = graph->Fit(""myFunc"",""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function. Associated functions. One or more object (typically a TF1*) can be added to the list; of functions (fFunctions) associated to each graph.; When TGraph::Fit is invoked, the fitted function is added to this list.; Given a graph gr, one can retrieve an associated function; with: TF1 *myfunc = gr->GetFunction(""myfunc"");. If the graph is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParErr",MatchSource.WIKI,root/html528/TMultiGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiGraph.html
Availability,avail,available,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial mo",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Deployability,continuous,continuous,"LPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In all methods implemented, one needs to compute; the first derivative of that error with respect to the weights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimi",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Energy Efficiency,power,powerful,"nimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitely by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Integrability,depend,dependant,"moid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net output; It produces an histogram with the output for the two datasets.; Index is the number of the desired output neuron.; ""option"" can contain:; - test or train to select a dataset; - comp to produce a X-Y comparison plot; - nocanv to not create a new TCanvas for the plot. void DumpWeights(Option_t* filename = ""-"") const; Dumps the weights to a text file.; Set filename to ""-"" (default) to dump to the standard output. void LoadWeights(Option_t* filename = """"); Loads the weights from a text file conforming to the format; defined by DumpWeights. Double_t Evaluate(Int_t index, Double_t* params) const; Returns the Neural Net for a given set of input parameters; #parameters must equal #input neurons. void Export(Option_t* filename = ""NNfunction"", Option_t* language = ""C++"") const; Exports the NN as a function for any non-ROOT-dependant code; Supported languages are: only C++ , FORTRAN and Python (yet); This feature is also usefull if you want to plot the NN as; a function (TF1 or TF2). void Shuffle(Int_t* , Int_t ) const; Shuffle the Int_t index[n] in input.; Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for stochastic training. void MLP_Stochastic(Double_t* ); One step for the stochastic method; buffer should contain the previous dw vector and will be updated. void MLP_Batch(Double_t* ); One step for the batch (stochastic) method.; DEDw should have been updated before calling this. void MLP_Line(Double_t* , Double_t* , Double_t ); Sets the weights to a point along a line; Weights are set to [origin + (dist * dir)]. void SteepestDir(Double_t* ); Sets the search direction to steepest descent. bool LineSearch(Double_t* , Double_t* ); Search along the line defined by direction.; buffer is not used but is updated with the new dw; so that it can be used b",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Modifiability,layers,layers,"eurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try ",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Performance,perform,performance,"ble. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events of dedw for each weight; normalized by the number of events. void Randomize() const; Randomize the weights. void AttachData(); Connects the TTree to Neurons in input and output; layers. The formulas associated to each neuron are created; and reported to the network formula manager.; By default, the branch is not normalised since this would degrade; performance for classification jobs.; Normalisation can be requested by putting '@' in front of the formula. void ExpandStructure(); Expand the structure of the first layer. void BuildNetwork(); Instanciates the network from the description. void BuildFirstLayer(TString& ); Instanciates the neurons in input; Inputs are normalised and the type is set to kOff; (simple forward of the formula value). void BuildHiddenLayers(TString& ); Builds hidden layers. void BuildOneHiddenLayer(const TString& sNumNodes, Int_t& layer, Int_t& prevStart, Int_t& prevStop, Bool_t lastLayer); Builds a hidden layer, updates the number of layers. void BuildLastLayer(TString& , Int_t ); Builds the output layer; Neurons are linear combinations of input, by defaul.; If the structure ends with ""!"", neurons are set up for classification,; ie. with a sigmoid (1 neuron) or softmax (more neurons) activation function. void DrawResult(Int_t index = 0, Option_t* option = ""test"") const; Draws the neural net",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Safety,predict,predictions,"ion, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs ",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Testability,test,test,". TMultiLayerPerceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Usability,learn,learning,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial mo",MatchSource.WIKI,root/html528/TMultiLayerPerceptron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html
Availability,error,error," = kFALSE); virtual~TMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tTVirtualMutex::Acquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual TVirtualMutex*Factory(Bool_t recursive = kFALSE); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virt",MatchSource.WIKI,root/html528/TMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMutex.html
Availability,avail,available,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html528/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMutexImp.html
Integrability,interface,interface,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root/html528/TMutexImp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMutexImp.html
Deployability,configurat,configuration," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Integrability,interface,interface,"Category ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeConfigParameters Interface to different separation critiera used in training algorithms; TMVA::PDEFoam Tree of PDEFoamCells; TMVA::PDEFoamCell Single cell of FOAM; TMVA::PDEFoamDistr Class for Event density; TMVA::PDEFoamVect n-dimensional vector with dynamical allocation; TMVA::PDF PDF wrapper for histograms; TMVA::Ranking Method-specific ranking for input variables ; TMVA::Reader Interpret the trained MVAs in an analysis context; TMVA::RegressionVariance Interface to different separation critiera used in training algorithms; TMVA::RootFinder Root finding using Brents algorithm; TMVA::RuleFit Calculations for Frie",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Modifiability,config,configuration," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Performance,perform,performs," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Testability,test,testing," TMVA ; TMVA::BDTEventWrapper ; TMVA::BinarySearchTree Binary search tree including volume search method ; TMVA::BinarySearchTreeNode Node for the BinarySearchTree; TMVA::BinaryTree Base class for BinarySearch and Decision Trees; TMVA::CCPruner ; TMVA::CCTreeWrapper ; TMVA::Config Singleton class for global configuration settings; TMVA::Config::IONames ; TMVA::Config::VariablePlotting ; TMVA::Configurable Virtual base class for all TMVA method; TMVA::CostComplexityPruneTool ; TMVA::CrossEntropy Implementation of the CrossEntropy as separation criterion; TMVA::DecisionTree implementation of a Decision Tree; TMVA::DecisionTreeNode Node for the Decision Tree ; TMVA::Factory The factory creates all MVA methods, and performs their training and testing; TMVA::FitterBase Baseclass for fitters; TMVA::GeneticAlgorithm Genetic algorithm controller; TMVA::GeneticFitter Fitter using a Genetic Algorithm; TMVA::GeneticGenes Genes definition for genetic algorithm; TMVA::GeneticPopulation Population definition for genetic algorithm; TMVA::GeneticRange Range definition for genetic algorithm; TMVA::GiniIndex Implementation of the GiniIndex as separation criterion; TMVA::GiniIndexWithLaplace Implementation of the GiniIndexWithLaplace as separation criterion; TMVA::IFitterTarget base class for a fitter ""target""; TMVA::IMethod Method Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Usability,simpl,simple,"ethod Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeCo",MatchSource.WIKI,root/html528/TMVA_Index.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA_Index.html
Modifiability,variab,variable,". TMVA::BDTEventWrapper. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BDTEventWrapper. class TMVA::BDTEventWrapper. Function Members (Methods); public:. ~BDTEventWrapper(); TMVA::BDTEventWrapperBDTEventWrapper(const TMVA::Event*); TMVA::BDTEventWrapperBDTEventWrapper(const TMVA::BDTEventWrapper&); Double_tGetCumulativeWeight(Bool_t type) const; Double_tGetVal() const; const TMVA::Event*operator*() const; Bool_toperator<(const TMVA::BDTEventWrapper& other) const; voidSetCumulativeWeight(Bool_t type, Double_t weight); static voidSetVarIndex(Int_t iVar). Data Members; private:. Double_tfBkgWeightcumulative background weight for splitting; const TMVA::Event*fEventpointer to the event; Double_tfSigWeightsame for the signal weights; static Int_tfVarIndexindex of the variable to sort on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BDTEventWrapper(const Event* e); constuctor. ~BDTEventWrapper(); destructor. void SetCumulativeWeight(Bool_t type, Double_t weight); Set the accumulated weight, for sorted signal/background events. * @param fType - true for signal, false for background; * @param weight - the total weight. Double_t GetCumulativeWeight(Bool_t type) const; Get the accumulated weight. Bool_t operator<(const TMVA::BDTEventWrapper& other) const. BDTEventWrapper( const Event* ). void SetVarIndex(Int_t iVar); Set the index of the variable to compare on. * @param iVar - index of the variable in fEvent to use. { if (iVar >= 0) fVarIndex = iVar; }. Double_t GetVal() const; Return the value of variable fVarIndex for this event. * @return value of variable fVarIndex for this event. { return fEvent->GetValue(fVarIndex); }. const Event* operator*() const; { return fEvent; }. » Last changed: Fri Nov 26 14:26:54 2010 » Last generated: 2010-11-26 14:26; T",MatchSource.WIKI,root/html528/TMVA__BDTEventWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BDTEventWrapper.html
Modifiability,variab,variable,"terator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion ; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<std::pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events (weigthed) counted during filling; vector<Double_t>fSumSq[2]Squared Sum for signal and background for each variable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinarySearchTree(const TMVA::BinarySearchTree& b); default constructor. BinarySearchTree(const TMVA::BinarySearchTree& b); copy constructor that creates a true copy, i.e. a completely independent tree. ~BinarySearchTree( void ); destructor. TMVA::BinarySearchTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); re-create a new tree (decision tree or search tree) from XML. void Insert(const TMVA::Eve",MatchSource.WIKI,root/html528/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html
Security,access,access,"hrough the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* CreateTree() const; { return new BinarySearchTree(); }. const char* ClassName() const; { return ""BinarySearchTree""; }. void SetPeriode(Int_t p); set the periode (number of variables). { fPeriod = p; }. UInt_t GetPeriode( void ); return periode (number of variables). { return fPeriod; }. Float_t Mean(TMVA::Types::ESBType sb, UInt_t var); access to mean for signal and background for each variable. { return fMeans[sb==Types::kSignal?0:1][var]; }. Float_t RMS(TMVA::Types::ESBType sb, UInt_t var); access to RMS for signal and background for each variable. { return fRMS[sb==Types::kSignal?0:1][var]; }. Float_t Min(TMVA::Types::ESBType sb, UInt_t var); access to Minimum for signal and background for each variable. { return fMin[sb==Types::kSignal?0:1][var]; }. Float_t Max(TMVA::Types::ESBType sb, UInt_t var); access to Maximum for signal and background for each variable. { return fMax[sb==Types::kSignal?0:1][var]; }. Float_t RMS(UInt_t var); access to RMS for each variable. { return fRMS[0][var]; }. void SetNormalize(Bool_t norm); { fCanNormalize = norm; }. void DestroyNode(TMVA::BinarySearchTreeNode* ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinarySearchTree.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been au",MatchSource.WIKI,root/html528/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html
Testability,log,logger,"aryTree::SetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidTMVA::BinaryTree::DeleteNode(TMVA::Node*); TMVA::MsgLogger&TMVA::BinaryTree::Log() const. private:. voidDestroyNode(TMVA::BinarySearchTreeNode*); voidInsert(const TMVA::Event*, TMVA::Node*); Bool_tInVolume(const vector<Float_t>&, TMVA::Volume*) const; voidNormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator, vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator, UInt_t); TMVA::BinarySearchTreeNode*Search(TMVA::Event*, TMVA::Node*) const; Double_tSearchVolume(TMVA::Node*, TMVA::Volume*, Int_t, vector<const TMVA::BinarySearchTreeNode*>* events). Data Members; protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. Bool_tfCanNormalizethe tree can be normalised; UInt_tfCurrentDepthinternal variable, counting the depth of the tree during insertion ; vector<Float_t>fMax[2]RMS for signal and background for each variable; vector<Float_t>fMeans[2]mean for signal and background for each variable; vector<Float_t>fMin[2]RMS for signal and background for each variable; Double_tfNEventsW[2]Number of events per class, taking into account event weights; vector<std::pair<Double_t,const TMVA::Event*> >fNormalizeTreeTable; UInt_tfPeriodperiode (number of event variables); vector<Float_t>fRMS[2]RMS for signal and background for each variable; Bool_tfStatisticsIsValidflag if last stat calculation is still valid, set to false if new node is insert; vector<Double_t>fSum[2]Sum for signal and background for each variable; Double_tfSumOfWeightsTotal number of events",MatchSource.WIKI,root/html528/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html
Usability,simpl,simple,". TMVA::BinarySearchTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinarySearchTree. class TMVA::BinarySearchTree: public TMVA::BinaryTree. BinarySearchTree. A simple Binary search tree including a volume search method. Function Members (Methods); public:. virtual~BinarySearchTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; TMVA::BinarySearchTreeBinarySearchTree(); TMVA::BinarySearchTreeBinarySearchTree(const TMVA::BinarySearchTree& b); voidCalcStatistics(TMVA::Node* n = 0); static TClass*Class(); virtual const char*ClassName() const; voidClear(TMVA::Node* n = 0); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = NULL); static TMVA::BinarySearchTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual TMVA::Node*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; Double_tFill(const vector<TMVA::Event*>& events, Int_t theType = -1); Double_tFill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); TMVA::Node*TMVA::BinaryTree::GetLeftDaughter(TMVA::Node* n); UInt_tTMVA::BinaryTree::GetNNodes() const; UInt_tGetPeriode() const; TMVA::Node*TMVA::BinaryTree::GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*TMVA::BinaryTree::GetRoot() const; Double_tGetSumOfWeights() const; Double_tGetSumOfWeights(Int_t theType) const; UInt_tTMVA::BinaryTree::GetTotalTreeDepth() const; voidInsert(const TMVA::Event*); virtual TClass*IsA() const; Float_tMax(TMVA::Types::ESBType sb, UInt_t var); Float_tMean(TMVA::Types::ESBType sb, UInt_t var); Float_tMin(TMVA::Types::ESBType sb, UInt_t var); voidNormalizeTree(); TMVA::BinarySearchTree&operator=(const TMVA::BinarySearchTree&); virtual voidTMVA::BinaryTree::Print(ostream& os) const; virtual voidTMVA::BinaryTree::Read(istream& istr, UInt_t tmva_Version_Code ",MatchSource.WIKI,root/html528/TMVA__BinarySearchTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html
Modifiability,variab,variable,". TMVA::BinarySearchTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinarySearchTreeNode. class TMVA::BinarySearchTreeNode: public TMVA::Node. Node for the BinarySearch or Decision Trees. for the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. in case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node, including; the respective cut value. Function Members (Methods); public:. virtual~BinarySearchTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*TMVA::Node::AddXMLTo(void* parent) const; TMVA::BinarySearchTreeNodeBinarySearchTreeNode(const TMVA::Event* e = NULL); TMVA::BinarySearchTreeNodeBinarySearchTreeNode(TMVA::BinarySearchTreeNode* parent, char pos); TMVA::BinarySearchTreeNodeBinarySearchTreeNode(const TMVA::BinarySearchTreeNode& n, TMVA::BinarySearchTreeNode* parent = NULL); static TClass*Class(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; virtual Bool_tEqualsMe(const TMVA::Event&) const; intTMVA::Node::GetCount(); UInt_tTMVA::Node::GetDepth() const; const vector<Float_t>&GetEventV() const; TMVA::Node*TMVA::Node::GetLeft() const; TMVA::Node*TMVA::Node::GetParent() const; TMVA::BinaryTree*TMVA::Node::GetParentTree() const; charTMVA::Node::GetPos() const; TMVA::Node*TMVA::Node::GetRight() const; Short_tGetSelector() const; const vector<Float_t>&GetTargets() const; Float_tGetWeight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; Bool_tIsSignal() const; TMVA::BinarySearchTreeNode&operator=(const TMVA::BinarySearchTreeNode&); virtual voidPrint(ostream& os) c",MatchSource.WIKI,root/html528/TMVA__BinarySearchTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTreeNode.html
Availability,avail,available,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recurs",MatchSource.WIKI,root/html528/TMVA__BinaryTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinaryTree.html
Integrability,depend,depends,"fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recursive, function used by the class destructor and when Pruning. TMVA::Node* GetLeftDaughter(TMVA::Node* n); get left daughter node current node ""n"". TMVA::Node* GetRightDaughter(TMVA::Node* n); get right daughter node current node ""n"". UInt_t CountNodes(TMVA::Node* n = NULL); return the number of nodes in the tree. (make a new count --> takes time). void Print(ostream& os) const; recursively print the tree. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); read attributes from XML. void Read(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the binary tree from an input stream.; The input stream format depends on the tree type,; it is defined be the node of the tree. void SetTotalTreeDepth( Node *n); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. Node* CreateNode(UInt_t size = 0) const. BinaryTree* CreateTree() const; virtual BinaryTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE) = 0;. const char* ClassName() const. void SetRoot(TMVA::Node* r); set the root node of the tree. { fRoot = r; }. Node* GetRoot() const; Retrieves the address of the root node. { return fRoot; }. UInt_t GetNNodes() const; get number of Nodes in the Tree as counted while booking the nodes;. { return fNNodes; }. UInt_t GetTotalTreeDepth() const; { return fDepth; }. void SetTotalTreeDepth(Int_t depth); { fDepth = depth; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: BinaryTree.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically g",MatchSource.WIKI,root/html528/TMVA__BinaryTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinaryTree.html
Testability,log,logger,"* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recursive, function used by the class destructor and when Pruning. TMVA::Node* GetLeftDaughter(TMVA::Node* n); get left daughter node current node ""n"". TMVA::Node* GetRightDaughter(TMVA::Node* n); get right daughter node current node ""n"". UInt_t CountNodes(TMVA::Node* n = NULL); return the number of nodes in the tree. (make a new count --> takes time). void Print(ostream& os) const; recursively print the tree. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); read attributes from XML. void Read(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the binary tree from an",MatchSource.WIKI,root/html528/TMVA__BinaryTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__BinaryTree.html
Security,validat,validationSample,". TMVA::CCPruner. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::CCPruner. class TMVA::CCPruner. Function Members (Methods); public:. ~CCPruner(); TMVA::CCPrunerCCPruner(const TMVA::CCPruner&); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::CCPruner::EventList* validationSample, TMVA::SeparationBase* qualityIndex = NULL); TMVA::CCPrunerCCPruner(TMVA::DecisionTree* t_max, const TMVA::DataSet* validationSample, TMVA::SeparationBase* qualityIndex = NULL); vector<TMVA::DecisionTreeNode*>GetOptimalPruneSequence() const; Float_tGetOptimalPruneStrength() const; Float_tGetOptimalQualityIndex() const; voidOptimize(); voidSetPruneStrength(Float_t alpha = -1.0). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); cons",MatchSource.WIKI,root/html528/TMVA__CCPruner.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CCPruner.html
Integrability,wrap,wrapped,"x; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree output for an event. CCTreeWrapper(TMVA::DecisionTree* T, TMVA::S",MatchSource.WIKI,root/html528/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CCTreeWrapper.html
Security,validat,validationSample,". TMVA::CCTreeWrapper. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::CCTreeWrapper. class TMVA::CCTreeWrapper. Function Members (Methods); public:. ~CCTreeWrapper(); TMVA::CCTreeWrapperCCTreeWrapper(const TMVA::CCTreeWrapper&); TMVA::CCTreeWrapperCCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); Double_tCheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); TMVA::CCTreeWrapper::CCTreeNode*GetRoot(); voidInitTree(TMVA::CCTreeWrapper::CCTreeNode* t); TMVA::CCTreeWrapper&operator=(const TMVA::CCTreeWrapper&); voidPruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); Double_tTestTreeQuality(const TMVA::CCTreeWrapper::EventList* validationSample); Double_tTestTreeQuality(const TMVA::DataSet* validationSample). Data Members; private:. TMVA::DecisionTree*fDTParent! pointer to underlying DecisionTree; TMVA::SeparationBase*fQualityIndex! pointer to the used quality index calculator; TMVA::CCTreeWrapper::CCTreeNode*fRoot! the root node of the (wrapped) decision Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCTreeWrapper(TMVA::DecisionTree* T, TMVA::SeparationBase* qualityIndex); constructor. ~CCTreeWrapper(); destructor. void InitTree(TMVA::CCTreeWrapper::CCTreeNode* t); initialize the node t and all its descendants. void PruneNode(TMVA::CCTreeWrapper::CCTreeNode* t); remove the branch rooted at node t. Double_t TestTreeQuality( const EventList* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using an EventList. Double_t TestTreeQuality( const DataSet* validationSample ); return the misclassification rate of a pruned tree for a validation event sample; using the DataSet. Double_t CheckEvent(const TMVA::Event& e, Bool_t useYesNoLeaf = false); return the decision tree out",MatchSource.WIKI,root/html528/TMVA__CCTreeWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CCTreeWrapper.html
Testability,log,logger,; static voidDestroyInstance(); Bool_tDrawProgressBar() const; TMVA::Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; TMVA::Config&operator=(const TMVA::Config&); voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. (unknown)(); TMVA::ConfigConfig(); TMVA::MsgLogger&Log() const. Data Members; public:. TMVA::Config::IONamesfIONamesCustomisable weight file properties; TMVA::Config::VariablePlottingfVariablePlottingCustomisable plotting properties. private:. Bool_tfDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; Bool_tfSilentno output at all; Bool_tfUseColoredConsolecoloured standard output; Bool_tfWriteOptionsReferenceif set true: Configurable objects write file with option reference; static TMVA::Config*fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariablePlotting; }. IONames& GetIONames(); { retur,MatchSource.WIKI,root/html528/TMVA__Config.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config.html
Usability,progress bar,progress bar,; static voidDestroyInstance(); Bool_tDrawProgressBar() const; TMVA::Config::IONames&GetIONames(); TMVA::Config::VariablePlotting&GetVariablePlotting(); static TMVA::Config&Instance(); virtual TClass*IsA() const; Bool_tIsSilent() const; TMVA::Config&operator=(const TMVA::Config&); voidSetDrawProgressBar(Bool_t d); voidSetSilent(Bool_t s); voidSetUseColor(Bool_t uc); voidSetWriteOptionsReference(Bool_t w); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Bool_tUseColor() const; Bool_tWriteOptionsReference() const. private:. (unknown)(); TMVA::ConfigConfig(); TMVA::MsgLogger&Log() const. Data Members; public:. TMVA::Config::IONamesfIONamesCustomisable weight file properties; TMVA::Config::VariablePlottingfVariablePlottingCustomisable plotting properties. private:. Bool_tfDrawProgressBardraw progress bar to indicate training evolution; TMVA::MsgLogger*fLoggermessage logger; Bool_tfSilentno output at all; Bool_tfUseColoredConsolecoloured standard output; Bool_tfWriteOptionsReferenceif set true: Configurable objects write file with option reference; static TMVA::Config*fgConfigPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Config(); constructor - set defaults. void DestroyInstance(); static function: destroy TMVA instance. TMVA::Config& Instance(); static function: returns TMVA instance. Bool_t UseColor() const; { return fUseColoredConsole; }. void SetUseColor(Bool_t uc); { fUseColoredConsole = uc; }. Bool_t IsSilent() const; { return fSilent; }. void SetSilent(Bool_t s); { fSilent = s; }. Bool_t WriteOptionsReference() const; { return fWriteOptionsReference; }. void SetWriteOptionsReference(Bool_t w); { fWriteOptionsReference = w; }. Bool_t DrawProgressBar() const; { return fDrawProgressBar; }. void SetDrawProgressBar(Bool_t d); { fDrawProgressBar = d; }. VariablePlotting& GetVariablePlotting(); { return fVariablePlotting; }. IONames& GetIONames(); { retur,MatchSource.WIKI,root/html528/TMVA__Config.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config.html
Availability,error,error," voidAddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableConfigurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetConfigDescription() const; const char*GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOptions() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const cha",MatchSource.WIKI,root/html528/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Configurable.html
Integrability,message,message,"ption = 0, Int_t bufsize = 0) const; voidWriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidEnableLooseOptions(Bool_t b = kTRUE); const TString&GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tLooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidResetSetFlag(); voidWriteOptionsReferenceToFile(). private:. voidSplitOptions(const TString& theOpt, TList& loo) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html528/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Configurable.html
Modifiability,config,configurable,"ption = 0, Int_t bufsize = 0) const; voidWriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidEnableLooseOptions(Bool_t b = kTRUE); const TString&GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tLooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidResetSetFlag(); voidWriteOptionsReferenceToFile(). private:. voidSplitOptions(const TString& theOpt, TList& loo) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html528/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Configurable.html
Testability,log,logger,"ption = 0, Int_t bufsize = 0) const; voidWriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidEnableLooseOptions(Bool_t b = kTRUE); const TString&GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tLooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidResetSetFlag(); voidWriteOptionsReferenceToFile(). private:. voidSplitOptions(const TString& theOpt, TList& loo) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfConfigDescriptiondescription of this configurable; TStringfConfigNamethe name of this configurable; TMVA::OptionBase*fLastDeclaredOption! last declared option; TListfListOfOptions! option list; TMVA::MsgLogger*fLogger! message logger; Bool_tfLooseOptionCheckingEnabled! checker for option string; TStringfOptions! options string; TStringfReferenceFilereference file for options writing. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Configurable(const TString& theOption = """"); constructor. ~Configurable(); default destructur. void SplitOptions(const TString& theOpt, TList& loo) const; splits the option string at ':' and fills the list 'loo' with the primitive strings. void ResetSetFlag(); resets the IsSet falg for all declare options; to be called before options are read from stream. void ParseOptions(); options parser. void CheckForUnusedOptions() const; checks for unused options in option string. void PrintOptions() const; prints out the options set in the options string and the defaults. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to output stream (e.g. in writing the MVA weight files. void",MatchSource.WIKI,root/html528/TMVA__Configurable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Configurable.html
Deployability,configurat,configuration,". TMVA::Config::IONames. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Config::IONames. class TMVA::Config::IONames. Config. Singleton class for global configuration settings used by TMVA. Function Members (Methods); public:. ~IONames(); TMVA::Config::IONamesIONames(); TMVA::Config::IONamesIONames(const TMVA::Config::IONames&); TMVA::Config::IONames&operator=(const TMVA::Config::IONames&). Data Members; public:. TStringfOptionsReferenceFileDir; TStringfWeightFileDir; TStringfWeightFileExtension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Andreas Hoecker, Joerg Stelzer, Fredrik Tegenfeldt, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Config.h 33931 2010-06-15 16:49:02Z stelzer $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Config__IONames.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config__IONames.html
Modifiability,config,configuration,". TMVA::Config::IONames. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Config::IONames. class TMVA::Config::IONames. Config. Singleton class for global configuration settings used by TMVA. Function Members (Methods); public:. ~IONames(); TMVA::Config::IONamesIONames(); TMVA::Config::IONamesIONames(const TMVA::Config::IONames&); TMVA::Config::IONames&operator=(const TMVA::Config::IONames&). Data Members; public:. TStringfOptionsReferenceFileDir; TStringfWeightFileDir; TStringfWeightFileExtension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Andreas Hoecker, Joerg Stelzer, Fredrik Tegenfeldt, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Config.h 33931 2010-06-15 16:49:02Z stelzer $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Config__IONames.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config__IONames.html
Deployability,configurat,configuration,". TMVA::Config::VariablePlotting. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Config::VariablePlotting. class TMVA::Config::VariablePlotting. Config. Singleton class for global configuration settings used by TMVA. Function Members (Methods); public:. ~VariablePlotting(); TMVA::Config::VariablePlotting&operator=(const TMVA::Config::VariablePlotting&); TMVA::Config::VariablePlottingVariablePlotting(); TMVA::Config::VariablePlottingVariablePlotting(const TMVA::Config::VariablePlotting&). Data Members; public:. Int_tfMaxNumOfAllowedVariablesForScatterPlots; Int_tfNbins1D; Int_tfNbins2D; Int_tfNbinsXOfROCCurve; Float_tfTimesRMS. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Andreas Hoecker, Joerg Stelzer, Fredrik Tegenfeldt, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Config.h 33931 2010-06-15 16:49:02Z stelzer $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Config__VariablePlotting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config__VariablePlotting.html
Modifiability,config,configuration,". TMVA::Config::VariablePlotting. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Config::VariablePlotting. class TMVA::Config::VariablePlotting. Config. Singleton class for global configuration settings used by TMVA. Function Members (Methods); public:. ~VariablePlotting(); TMVA::Config::VariablePlotting&operator=(const TMVA::Config::VariablePlotting&); TMVA::Config::VariablePlottingVariablePlotting(); TMVA::Config::VariablePlottingVariablePlotting(const TMVA::Config::VariablePlotting&). Data Members; public:. Int_tfMaxNumOfAllowedVariablesForScatterPlots; Int_tfNbins1D; Int_tfNbins2D; Int_tfNbinsXOfROCCurve; Float_tfTimesRMS. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Andreas Hoecker, Joerg Stelzer, Fredrik Tegenfeldt, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id: Config.h 33931 2010-06-15 16:49:02Z stelzer $ » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Config__VariablePlotting.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Config__VariablePlotting.html
Availability,down,down,". private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Fri Nov 26 14:26:56 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html
Testability,test,testEvents,". TMVA::CostComplexityPruneTool. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::CostComplexityPruneTool. class TMVA::CostComplexityPruneTool: public TMVA::IPruneTool. Function Members (Methods); public:. virtual~CostComplexityPruneTool(); virtual TMVA::PruningInfo*CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE); TMVA::CostComplexityPruneToolCostComplexityPruneTool(TMVA::SeparationBase* qualityIndex = NULL); TMVA::CostComplexityPruneToolCostComplexityPruneTool(const TMVA::CostComplexityPruneTool&); TMVA::CostComplexityPruneTool&operator=(const TMVA::CostComplexityPruneTool&). private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(T",MatchSource.WIKI,root/html528/TMVA__CostComplexityPruneTool.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html
Testability,log,log,". TMVA::CrossEntropy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::CrossEntropy. class TMVA::CrossEntropy: public TMVA::SeparationBase. Implementation of the CrossEntropy as separation criterion; -p log (p) - (1-p)log(1-p); p=purity. Function Members (Methods); public:. virtual~CrossEntropy(); static TClass*Class(); TMVA::CrossEntropyCrossEntropy(); TMVA::CrossEntropyCrossEntropy(const TMVA::CrossEntropy& g); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::CrossEntropy&operator=(const TMVA::CrossEntropy&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Cross Entropy defined as; -p log (p) - (1-p)log(1-p); p=purity = s/(s+b). CrossEntropy(); default constructor. { fName = ""CE""; }. CrossEntropy(const TMVA::CrossEntropy& g); copy constructor. {}. virtual ~CrossEntropy(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: CrossEntropy.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__CrossEntropy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__CrossEntropy.html
Availability,down,down,"t rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill in all the ""intermediate"" information; that would normally be there from training. Double_t GetSumWeights(const TMVA::DecisionTree::EventList* validationSample) const; calculate the normalization factor for a pruning validation sample. UInt_t CountLeafNodes(TMVA::Node* n = NULL); return the number of terminal nodes in the sub-tree below Node n. void DescendTree(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes. void PruneNode(TMVA::DecisionTreeNode* node); prune away the subtree below the node. void PruneNodeInPlace(TMVA::DecisionTreeNode* node); prune a node temporaily (without actually deleting its decendants; which allows testing the pruned tree quality for many different; pruning stages without ""touching"" the tree. TMVA::Node* GetNode(ULong_t sequence, UInt_t depth); retrieve node from the tree. Its position (up to a maximal tree depth of 64); is coded as a sequence of left-right moves starting from the root, coded as; 0-1 bit patt",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Modifiability,variab,variable,". TMVA::DecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::DecisionTree. class TMVA::DecisionTree: public TMVA::BinaryTree. Implementation of a Decision Tree. In a decision tree successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; UInt_tBuildTree(const TMVA::DecisionTree::EventList& even",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Performance,perform,perform,"ree::DeleteNode(TMVA::Node*); TMVA::MsgLogger&TMVA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. enum EPruneMethod { kExpectedErrorPruning; kCostComplexityPruning; kNoPruning; };. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); UInt_tfClassclass which is treated as signal when building the tree; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; UInt_tfNNodesMaxmax # of nodes; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of var",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Safety,avoid,avoid,"r of nodes). void FillTree(TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(TMVA::DecisionTree::EventList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. This is then later used; when asking for the ""tree quality"" .. Double_t TestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; return the misclassification rate of a pruned tree; a ""pruned tree"" may have set the variable ""IsTerminal"" to ""arbitrary"" at; any node, hence this tree quality testing will stop there, hence test; the pruned tree (while the full tree is still in place for normal/later use). void CheckEventWithPrunedTree(const TMVA::Event& ) const; pass a single validation event throught a pruned decision tree; on the way down the tree, fill i",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Security,validat,validationSample,"constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Function Members (Methods); public:. virtual~DecisionTree(); virtual void*TMVA::BinaryTree::AddXMLTo(void* parent) const; voidApplyValidationSample(const TMVA::DecisionTree::EventList* validationSample) const; UInt_tBuildTree(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node = NULL); Double_tCheckEvent(const TMVA::Event&, Bool_t UseYesNoLeaf = kFALSE) const; voidCheckEventWithPrunedTree(const TMVA::Event&) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCleanTree(TMVA::DecisionTreeNode* node = NULL); voidClearTree(); UInt_tCountLeafNodes(TMVA::Node* n = NULL); UInt_tTMVA::BinaryTree::CountNodes(TMVA::Node* n = NULL); static TMVA::DecisionTree*CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual TMVA::DecisionTreeNode*CreateNode(UInt_t) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::DecisionTreeDecisionTree(); TMVA::DecisionTreeDecisionTree(const TMVA::DecisionTree& d); TMVA::DecisionTreeDecisionTree(TMVA::SeparationBase* sepType, Int_t minSize, Int_t nCuts, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nNodesMax = 999999, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); voidDescendTree(TMVA::Node* n = NULL); Bool_tDoRegression() const; voidFillEvent(TMVA::Event& event, TMVA::DecisionTreeNode* node); voidFillTree(TMVA::DecisionTree::EventList& eventSample); TMVA::Types::EAnalysisTypeGetAnalysisType(); TMVA::DecisionTreeNode*GetEventNode(const TMVA::Event& e) const; vector<Double_t>GetFisherCoefficients(const TMVA::DecisionT",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Testability,log,logger," voidSetUseFisherCuts(Bool_t t = kTRUE); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Double_tTestPrunedTreeQuality(const TMVA::DecisionTreeNode* dt = NULL, Int_t mode = 0) const; Double_tTrainNode(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node); Double_tTrainNodeFast(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node); Double_tTrainNodeFull(const TMVA::DecisionTree::EventList& eventSample, TMVA::DecisionTreeNode* node). protected:. voidTMVA::BinaryTree::DeleteNode(TMVA::Node*); TMVA::MsgLogger&TMVA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. enum EPruneMethod { kExpectedErrorPruning; kCostComplexityPruning; kNoPruning; };. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); UInt_tfClassclass which is treated as signal when building the tree; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; UInt_tfNNodesMaxmax # of nodes; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""am",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Usability,simpl,simple,"ouble_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of variables used in randomised trees;; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseSearchTreecut scan done with binary trees or simple event loop.; vector<Double_t>fVariableImportancethe relative importance of the different variables ; static const Int_tfgDebugLeveldebug level determining some printout/control plots etc.; static const Int_tfgRandomSeedset nonzero for debugging and zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTree(); default constructor using the GiniIndex as separation criterion,; no restrictions on minium number of events in a leave note or the; separation gain in the node splitting. DecisionTree(TMVA::SeparationBase* sepType, Int_t minSize, Int_t nCuts, UInt_t cls = 0, Bool_t randomisedTree = kFALSE, Int_t useNvars = 0, Bool_t usePoissonNvars = kFALSE, UInt_t nNodesMax = 999999, UInt_t nMaxDepth = 9999999, Int_t iSeed = fgRandomSeed, Float_t purityLimit = 0.5, Int_t treeID = 0); constructor specifying the separation type, the min number of; events in a no that is still subjected to further s",MatchSource.WIKI,root/html528/TMVA__DecisionTree.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html
Modifiability,variab,variable,". TMVA::DecisionTreeNode. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::DecisionTreeNode. class TMVA::DecisionTreeNode: public TMVA::Node. Node for the Decision Tree. The node specifies ONE variable out of the given set of selection variable; that is used to split the sample which ""arrives"" at the node, into a left; (background-enhanced) and a right (signal-enhanced) sample. Function Members (Methods); public:. virtual~DecisionTreeNode(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; voidAddToSumTarget(Float_t t); voidAddToSumTarget2(Float_t t2); void*TMVA::Node::AddXMLTo(void* parent) const; static TClass*Class(); voidClearNodeAndAllDaughters(); Int_tTMVA::Node::CountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; TMVA::DecisionTreeNodeDecisionTreeNode(); TMVA::DecisionTreeNodeDecisionTreeNode(TMVA::Node* p, char pos); TMVA::DecisionTreeNodeDecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = NULL); Double_tGetAlpha() const; Double_tGetAlphaMinSubtree() const; Double_tGetCC() const; intTMVA::Node::GetCount(); Bool_tGetCutType() const; Float_tGetCutValue() const; UInt_tTMVA::Node::GetDepth() const; Double_tGetFisherCoeff(Int_t ivar) const; virtual TMVA::DecisionTreeNode*GetLeft() const; Float_tGetNBkgEvents() const; Float_tGetNBkgEvents_unweighted() const; Double_tGetNBValidation() const; Float_tGetNEvents() const; Float_tGetNEvents_unweighted() const; UInt_tGetNFisherCoeff() const; Double_tGetNodeR() const; Int_tGetNodeType() const; Float_tGetNSigEvents() const; Float_tGetNSigEvents_unweighted() const; Double_tGetNSValidation() const; Int_tGetNTerminal() const; virtual TMVA::DecisionTreeNode*GetParent() const; virtual TMVA::BinaryTree*TMVA::Node::GetParentTree() const; charTMVA::Nod",MatchSource.WIKI,root/html528/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html
Security,validat,validation,"node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE). void AddAttributesToNode(void* node) const; add attribute to xml. void SetFisherCoeff(Int_t ivar, Double_t coeff); set fisher co",MatchSource.WIKI,root/html528/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html
Testability,test,test,"tion, i.e. it is a left (l) or right (r) daughter ; Float_tfPuritythe node purity; Float_tfRMSresponse RMS of the regression node; Float_tfResponseresponse value in case of regression; TMVA::Node*TMVA::Node::fRightpointers to the two ""daughter"" nodes; Short_tfSelectorindex of variable used in node selection (decision tree); TMVA::DTNodeTrainingInfo*fTrainInfo; static TMVA::MsgLogger*fgLoggerstatic because there is a huge number of nodes... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; DecisionTreeNode(); constructor of an essentially ""empty"" node floating in space. DecisionTreeNode(TMVA::Node* p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = NULL); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) con",MatchSource.WIKI,root/html528/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html
Usability,clear,clear," p, char pos); constructor of a daughter node as a daughter of 'p'. DecisionTreeNode(const TMVA::DecisionTreeNode& n, TMVA::DecisionTreeNode* parent = NULL); copy constructor of a node. It will result in an explicit copy of; the node and recursively all it's daughters. ~DecisionTreeNode(); destructor. Bool_t GoesRight(const TMVA::Event& ) const; test event if it decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. void SetPurity( void ); return the S/(S+B) (purity) for the node; REM: even if nodes with purity 0.01 are very PURE background nodes, they still; get a small value of the purity. void Print(ostream& os) const; print the node. void PrintRec(ostream& os) const; recursively print the node and its daughters (--> print the 'tree'). Bool_t ReadDataRecord(istream& is, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); Read the data block. void ClearNodeAndAllDaughters(); clear the nodes (their S/N, Nevents etc), just keep the structure of the tree. void ResetValidationData(); temporary stored node values (number of events, etc.) that originate; not from the training but from the validation data (used in pruning). void PrintPrune(ostream& os) const; printout of the node (can be read in with ReadDataRecord). void PrintRecPrune(ostream& os) const; recursive printout of the node and its daughters. void SetCC(Double_t cc). Float_t GetSampleMin(UInt_t ivar) const; return the minimum of variable ivar from the training sample; that pass/end up in this node. Float_t GetSampleMax(UInt_t ivar) const; return the maximum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMin(UInt_t ivar, Float_t xmin); set the minimum of variable ivar from the training sample; that pass/end up in this node. void SetSampleMax(UInt_t ivar, Float_t xmax); set the maximum of variable ivar from the training sample; that pass/end up in this node. void ReadAttributes(void* ",MatchSource.WIKI,root/html528/TMVA__DecisionTreeNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTreeNode.html
Energy Efficiency,charge,charge,TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken,MatchSource.WIKI,root/html528/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Event.html
Modifiability,variab,variable,escription; function members; data members; class charts. ROOT; » TEST; » TMVA::Event. class TMVA::Event. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //N,MatchSource.WIKI,root/html528/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Event.html
Performance,perform,performance,"he first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken care of by the HistogramManager class. Note: This version of the class Event (see EventMT.h and EventMT.cxx; for an alternative) uses static variables to improve performance (by; reducing the number of memory allocations). Consequently, only one; instance of the class Event should be in use at a time (a 2nd instance; would share the array of Tracks with the first instance). Function Members (Methods); public:. ~Event(); static voidClearDynamicVariables(); voidCopyVarValues(const TMVA::Event& other); TMVA::EventEvent(); TMVA::EventEvent(const TMVA::Event&); TMVA::EventEvent(const vector<Float_t*>*&, UInt_t nvar); TMVA::EventEvent(const vector<Float_t>&, UInt_t theClass, Double_t weight = 1.0, Double_t boostweight = 1.0); TMVA::EventEvent(const vector<Float_t>& values, const vector<Float_t>& targetValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0); TMVA::EventEvent(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0); Double_tGetBoostWeight() const; UInt_tGetClass() const; UInt_tGetNSpectators(",MatchSource.WIKI,root/html528/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Event.html
Security,access,accessors,"used for any calculation; vector<Float_t>fTargetstarget values for regression; vector<Float_t>fValuesthe event values; vector<Float_t*>*fValuesDynamicthe event values; vector<UInt_t>*fVariableArrangementneeded for MethodCategories, where we can train on other than the main variables; Double_tfWeightevent weight (product of global and individual weights). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Event(); Create an Event object.; When the constructor is invoked for the first time, the class static; variable fgTracks is 0 and the TClonesArray fgTracks is created. ~Event(). Event(); constructors. Event(const TMVA::Event& ). explicit Event(const vector<Float_t>& values, const vector<Float_t>& targetValues, const vector<Float_t>& spectatorValues, UInt_t theClass = 0, Double_t weight = 1.0, Double_t boostweight = 1.0). explicit Event(const vector<Float_t>& , UInt_t theClass, Double_t weight = 1.0, Double_t boostweight = 1.0). Bool_t IsDynamic() const; accessors. {return fDynamic; }. Double_t GetWeight() const; { return fWeight*fBoostWeight; }. Double_t GetOriginalWeight() const; { return fWeight; }. Double_t GetBoostWeight() const; { return TMath::Max(Double_t(0.0001),fBoostWeight); }. UInt_t GetClass() const; { return fClass; }. UInt_t GetNVariables() const. UInt_t GetNTargets() const. UInt_t GetNSpectators() const. const std::vector<UInt_t>* GetVariableArrangement() const; { return fVariableArrangement; }. Float_t GetValue(UInt_t ivar) const. const std::vector<Float_t>& GetValues() const. Float_t GetTarget(UInt_t itgt) const; { return fTargets.at(itgt); }. std::vector<Float_t>& GetTargets() const; { return fTargets; }. Float_t GetSpectator(UInt_t ivar) const. std::vector<Float_t>& GetSpectators() const; { return fSpectators; }. void ScaleWeight(Double_t s); { fWeight*=s; }. void SetWeight(Double_t w); { fWeight=w; }. void SetBoostWeight(Double_t w); { fBoostWeight=w; }. void ScaleBoostWeight(Double_t s); { fBoostWeight *= ",MatchSource.WIKI,root/html528/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Event.html
Usability,simpl,simple,. TMVA::Event. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TEST; » TMVA::Event. class TMVA::Event. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of ,MatchSource.WIKI,root/html528/TMVA__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Event.html
Availability,error,error,"nst; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; TTree*CreateEventAssignTrees(const TString& name); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteAllMethods(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEvaluateAllMethods(); voidEvaluateAllVariables(TString options = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TMVA::FactoryFactory(TString theJobName, TFile* theTargetFile, TString theOption = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMVA::IMethod*GetMethod(const TString& title) const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; virtual const",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Deployability,configurat,configuration," AddCut(const TCut& cut, const TString& className = """"). void PrepareTrainingAndTestTree(const TCut& cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString& otherOpt = ""SplitMode=Random:!V""); prepare the training and test trees. void PrepareTrainingAndTestTree(const TCut& cut, Int_t Ntrain, Int_t Ntest = -1); prepare the training and test trees; kept for backward compatibility. void PrepareTrainingAndTestTree(const TCut& cut, const TString& splitOpt); prepare the training and test trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. calls ""Method::Train()"" for different parameter setttings and; keeps in mind the ""optimal one""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iter",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Integrability,message,message,"t; TStringfJobName! jobname, used as extension in weight file names; TMVA::Factory::MVectorfMethods! all MVA methods; TStringfOptions! option string given by construction (presently only ""V""); vector<TTree*>fTestAssignTree! for each class: tmp tree if user wants to assign the events directly; vector<TTree*>fTrainAssignTree! for each class: tmp tree if user wants to assign the events directly; TStringfTransformations! List of transformations to test; Bool_tfVerbose! verbose mode; static TFile*fgTargetFile! ROOT output file. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Factory(TString theJobName, TFile* theTargetFile, TString theOption = """"); standard constructor; jobname : this name will appear in all weight file names produced by the MVAs; theTargetFile : output ROOT file; the test tree and all evaluation plots; will be stored here; theOption : option string; currently: ""V"" for verbose. void Greetings(); print welcome message; options are: kLogoWelcomeMsg, kIsometricWelcomeMsg, kLeanWelcomeMsg. ~Factory( void ); destructor; delete fATreeEvent;. void DeleteAllMethods( void ); delete methods. void SetVerbose(Bool_t v = kTRUE). TMVA::DataSetInfo& AddDataSet( DataSetInfo &dsi ); return DataSetManager::Instance().AddDataSetInfo(dsi); // DSMTEST replaced by following line. TMVA::DataSetInfo& AddDataSet(const TString& ); DataSetInfo* dsi = DataSetManager::Instance().GetDataSetInfo(dsiName); // DSMTEST replaced by following line. TTree* CreateEventAssignTrees(const TString& name); create the data assignment tree (for event-wise data assignment by user). void AddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal training event. void AddSignalTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal testing event. void AddBackgroundTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); add signal training event. void AddBackgroundTestEvent(const vector<Double_t>& e",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Modifiability,variab,variable," option = """") const; voidPrintHelpMessage(const TString& methodTitle = """") const; voidTMVA::Configurable::PrintOptions() const; virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); static TDirectory*RootBaseDir(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidSetBackgroundTree(TTree* background, Double_t weight = 1.0); voidSetBackgroundWeightExpression(const TString& variable); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); voidSetCut(const TString& cut, const TString& className = """"); voidSetCut(const TCut& cut, const TString& className = """"); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetInputTrees(TTree* inputTree, const TCut& SigCut, const TCut& BgCut); voidSetInputTrees(const TString& signalFileName, const TString& backgroundFileName, Double_t signalWeight = 1.0, Double_t backgroundWeight = 1.0); voidSetInputTrees(TTree* signal, TTree* background, Double_t signalWeight = 1.0, Double_t backgroundWeight = 1.0); voidSetInputVariables(vector<TString>* theVariables); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidSetSignalTree(TTree* signal, Double_t weight = 1.0); voidSetSignalWeightExpression(const TString& variable); voidSetTree(TTree* tree, const TString& className, Double_t weight); virtual voidTObject::SetUniqueID(UInt_t uid); voidSetVerbose(Bool_t v = kTRUE); voidSetWeightExpression(const TString& va",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Performance,perform,performance," AddCut(const TCut& cut, const TString& className = """"). void PrepareTrainingAndTestTree(const TCut& cut, Int_t NsigTrain, Int_t NbkgTrain, Int_t NsigTest, Int_t NbkgTest, const TString& otherOpt = ""SplitMode=Random:!V""); prepare the training and test trees. void PrepareTrainingAndTestTree(const TCut& cut, Int_t Ntrain, Int_t Ntest = -1); prepare the training and test trees; kept for backward compatibility. void PrepareTrainingAndTestTree(const TCut& cut, const TString& splitOpt); prepare the training and test trees; -> same cuts for signal and background. void PrepareTrainingAndTestTree(TCut sigcut, TCut bkgcut, const TString& splitOpt); prepare the training and test trees. TMVA::MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"); Book a classifier or regression method. TMVA::MethodBase* BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption = """"); books MVA method; the option configuration string is custom for each MVA; the TString field ""theNameAppendix"" serves to define (and distinguish); several instances of a given MVA, eg, when one wants to compare the; performance of various configurations. TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. void WriteDataInformation(); put correlations of input data and a few (default + user; selected) transformations into the root file. void OptimizeAllMethods(TString fomType = ""ROCIntegral"", TString fitType = ""Scan""); iterates through all booked methods and sees if they use parameter tuning and if so..; does just that i.e. calls ""Method::Train()"" for different parameter setttings and; keeps in mind the ""optimal one""... and that's the one that will later on be used; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iter",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Testability,test,testing,". TMVA::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Factory. class TMVA::Factory: public TMVA::Configurable. This is the main MVA steering class: it creates all MVA methods,; and guides them through the training, testing and evaluation; phases. Function Members (Methods); public:. virtual~Factory(); voidTObject::AbstractMethod(const char* method) const; voidAddBackgroundTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddBackgroundTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddBackgroundTree(TTree* background, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TString datFileB, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TTree* background, Double_t weight, const TString& treetype); voidAddCut(const TString& cut, const TString& className = """"); voidAddCut(const TCut& cut, const TString& className = """"); TMVA::DataSetInfo&AddDataSet(TMVA::DataSetInfo&); TMVA::DataSetInfo&AddDataSet(const TString&); voidAddEvent(const TString& className, TMVA::Types::ETreeType tt, const vector<Double_t>& event, Double_t weight); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0); voidAddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddSignalTree(TTree* signal, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTree(TString datFileS, Do",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Usability,guid,guides,". TMVA::Factory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Factory. class TMVA::Factory: public TMVA::Configurable. This is the main MVA steering class: it creates all MVA methods,; and guides them through the training, testing and evaluation; phases. Function Members (Methods); public:. virtual~Factory(); voidTObject::AbstractMethod(const char* method) const; voidAddBackgroundTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddBackgroundTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddBackgroundTree(TTree* background, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TString datFileB, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddBackgroundTree(TTree* background, Double_t weight, const TString& treetype); voidAddCut(const TString& cut, const TString& className = """"); voidAddCut(const TCut& cut, const TString& className = """"); TMVA::DataSetInfo&AddDataSet(TMVA::DataSetInfo&); TMVA::DataSetInfo&AddDataSet(const TString&); voidAddEvent(const TString& className, TMVA::Types::ETreeType tt, const vector<Double_t>& event, Double_t weight); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0); voidAddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTestEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddSignalTrainingEvent(const vector<Double_t>& event, Double_t weight = 1.0); voidAddSignalTree(TTree* signal, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); voidAddSignalTree(TString datFileS, Do",MatchSource.WIKI,root/html528/TMVA__Factory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Factory.html
Availability,avail,available,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual T",MatchSource.WIKI,root/html528/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html
Integrability,interface,interface,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual T",MatchSource.WIKI,root/html528/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html
Security,access,accessor,"able::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html
Testability,log,logger,"Int_t bufsize = 0) const; voidTMVA::Configurable::WriteOptionsToStream(ostream& o, const TString& prefix) const. protected:. virtual voidDeclareOptions(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*fLoggermessage logger; Int_tfNparsnumber of parameters; const vector<TMVA::Interval*>fRangesallowed intervals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t Run(); estimator function interface for fitting. Double_t EstimatorFunction(vector<Double_t>& parameters); estimator function interface for fitting. virtual ~FitterBase(); {}. Double_t Run(). IFitterTarget& GetFitterTarget() const; { return fFitterTarget; }. Int_t GetNpars() const; accessor. { return fNpars; }. const char* GetName() const; remove namespace in name. { return fClassName; }. void DeclareOptions(); need to implement option declaration. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: FitterBase.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in ",MatchSource.WIKI,root/html528/TMVA__FitterBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html
Energy Efficiency,reduce,reduce,"different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor : than multiply the stepSize ( spread ) by this factor; (if ofSteps == successSteps nothing is changed, if ofSteps < successSteps, the spread; is divided by the factor). using this function one can increase the stepSize of the mutation when we have; good success (to pass fast through the easy phase-space) and reduce the stepSize; if we are in a difficult ""territory"" of the phase-space. Bool_t HasConverged(Int_t steps = 10, Double_t ratio = 0.1); gives back true if the last ""steps"" steps have lead to an improvement of the; ""fitness"" of the ""individuals"" of at least ""improvement"". this gives a simple measure of if the fitness of the individuals is; converging and no major improvement is to be expected soon. GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0). GeneticPopulation& GetGeneticPopulation(); { return fPopulation; }. Double_t GetSpread() const; { return fSpread; }. void SetSpread(Double_t s); { fSpread = s; }. void SetMakeCopies(Bool_t s); { fMakeCopies = s; }. Bool_t GetMakeCopies(); { return fMakeCopies; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticAlgorithm.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-26 20:32; Thi",MatchSource.WIKI,root/html528/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html
Modifiability,variab,variable,"rTarget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; afte",MatchSource.WIKI,root/html528/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html
Testability,log,logger,"pies(); Double_tGetSpread() const; virtual Bool_tHasConverged(Int_t steps = 10, Double_t ratio = 0.1); voidInit(); virtual TClass*IsA() const; virtual Double_tNewFitness(Double_t oldValue, Double_t newValue); voidSetMakeCopies(Bool_t s); voidSetSpread(Double_t s); virtual voidShowMembers(TMemberInspector& insp); virtual Double_tSpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TMVA::MsgLogger&Log() const. Data Members; public:. Int_tfConvCounterconverging? ... keeps track of the number of improvements. protected:. Double_tfBestFitness; Double_tfConvValuekeeps track of the quantity of improvement; Bool_tfFirstTimeif true its the first time, so no evolution yet; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfLastResultremembers the last obtained result (for internal use); TMVA::MsgLogger*fLoggermessage logger; Bool_tfMakeCopiesif true, the population will make copies of the first individuals; Bool_tfMirrornew values for mutation are mirror-mapped if outside of constraints; TMVA::GeneticPopulationfPopulationcontains and controls the ""individual""; Int_tfPopulationSizethe size of the population; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfSpreadregulates the spread of the value change at mutation (sigma); deque<Int_t>fSuccessListto adjust the stepSize . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticAlgorithm(TMVA::IFitterTarget& target, Int_t populationSize, const vector<TMVA::Interval*>& ranges, UInt_t seed = 0); Constructor; Parameters:; int populationSize : defines the number of ""Individuals"" which are created and tested; within one Generation (Iteration of the Evolution); vector<TMVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are op",MatchSource.WIKI,root/html528/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html
Usability,simpl,simply,"MVA::Interval*> ranges : Interval holds the information of an interval, where the GetMin; gets the low and GetMax gets the high constraint of the variable; the size of ""ranges"" is the number of coefficients which are optimised; Purpose:; Creates a random population with individuals of the size ranges.size(). ~GeneticAlgorithm(); destructor; deletes fLogger. void Init(); calls evolution, but if it is not the first time.; If it's the first time, the random population created by the; constructor is still not evaluated, .. therefore we wait for the; second time init is called. Double_t NewFitness(Double_t oldValue, Double_t newValue); if the ""fitnessFunction"" is called multiple times for one set of; factors (because i.e. each event of a TTree has to be assessed with; each set of Factors proposed by the Genetic Algorithm) the value; of the current calculation has to be added(? or else) to the value; obtained up to now.; example: some chi-square is calculated for every event,; after every event the new chi-square (newValue) has to be simply; added to the oldValue. this function has to be overridden eventually; it might contain only the following return statement.; return oldValue + newValue;. Double_t CalculateFitness(); starts the evaluation of the fitness of all different individuals of; the population. this function calls implicitly (many times) the ""fitnessFunction"" which; has been overridden by the user. void Evolution(); this function is called from ""init"" and controls the evolution of the; individuals.; the function can be overridden to change the parameters for mutation rate; sexual reproduction and so on. Double_t SpreadControl(Int_t steps, Int_t ofSteps, Double_t factor); this function provides the ability to change the stepSize of a mutation according to; the success of the last generations. Parameters:; int ofSteps : = if OF the number of STEPS given in this variable (ofSteps); int successSteps : >sucessSteps Generations could improve the result; double factor ",MatchSource.WIKI,root/html528/TMVA__GeneticAlgorithm.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticAlgorithm.html
Availability,error,error,"t::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::GeneticFitterGeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject:",MatchSource.WIKI,root/html528/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticFitter.html
Deployability,configurat,configuration,"t_tfNstepsconvergence criteria: if no improvements > fConvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are included as ""hints"" in the last cycle of GA calculation); Int_tfSaveBestFromGenerationstore the best individuals from one generation (these are included as ""hints"" in the last cycle of GA calculation); UInt_tfSeedSeed for the random generator (0 takes random seeds); Bool_tfTrimtake care, that the number of individuals is less fPopSize (trimming is done after the fitness of the individuals is assessed). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare GA options. void SetParameters(Int_t cycles, Int_t nsteps, Int_t popSize, Int_t SC_steps, Int_t SC_rate, Double_t SC_factor, Double_t convCrit); set GA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~GeneticFitter(); {}. Double_t NewFitness(Double_t oldF, Double_t newF); { return oldF + newF; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticFitter.html
Modifiability,config,configuration,"t_tfNstepsconvergence criteria: if no improvements > fConvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are included as ""hints"" in the last cycle of GA calculation); Int_tfSaveBestFromGenerationstore the best individuals from one generation (these are included as ""hints"" in the last cycle of GA calculation); UInt_tfSeedSeed for the random generator (0 takes random seeds); Bool_tfTrimtake care, that the number of individuals is less fPopSize (trimming is done after the fitness of the individuals is assessed). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare GA options. void SetParameters(Int_t cycles, Int_t nsteps, Int_t popSize, Int_t SC_steps, Int_t SC_rate, Double_t SC_factor, Double_t convCrit); set GA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~GeneticFitter(); {}. Double_t NewFitness(Double_t oldF, Double_t newF); { return oldF + newF; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticFitter.html
Testability,log,logger,"tream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfConvCritimprovements bigger than fConvCrit are counted as ""improvement""; Int_tfCyclesnumber of (nearly) independent calculation cycles; Int_tfNstepsconvergence criteria: if no improvements > fConvCrit was achieved within the last fNsteps: cycle has ""converged""; Int_tfPopSizenumber of individuals to start with; Double_tfSC_factor... with fSC_factor; if there were less improvements: divide by that factor; if there were exactly fSC_rate improvements, dont change anything; Int_tfSC_rate... fSC_rate improvements, than multiply the sigma of the gaussion which defines how the random numbers are generated ...; Int_tfSC_stepsregulates how strong the mutations for the coordinates are: if within fSC_steps there were more than...; Int_tfSaveBestFromCyclestore the best individuals from one cycle (these are inclu",MatchSource.WIKI,root/html528/TMVA__GeneticFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticFitter.html
Integrability,interface,interface,. TMVA::GeneticGenes. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::GeneticGenes. class TMVA::GeneticGenes. Cut optimisation interface class for genetic algorithm. Function Members (Methods); public:. virtual~GeneticGenes(); static TClass*Class(); TMVA::GeneticGenesGeneticGenes(); TMVA::GeneticGenesGeneticGenes(vector<Double_t>& f); TMVA::GeneticGenesGeneticGenes(const TMVA::GeneticGenes&); vector<Double_t>&GetFactors(); Double_tGetFitness() const; virtual TClass*IsA() const; TMVA::GeneticGenes&operator=(const TMVA::GeneticGenes&); voidSetFitness(Double_t fitness); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. vector<Double_t>fFactorsstores the factors (coefficients) of one individual; Double_tfFitness. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticGenes(vector<Double_t>& f); Constructor:; set the factors of this individual. GeneticGenes(); {}. GeneticGenes(vector<Double_t>& f). virtual ~GeneticGenes(); {}. std::vector<Double_t>& GetFactors(); { return fFactors; }. void SetFitness(Double_t fitness); { fFitness = fitness; }. Double_t GetFitness() const; { return fFitness; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticGenes.h 31458 2009-11-30 13:58:20Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html528/TMVA__GeneticGenes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticGenes.html
Modifiability,variab,variables,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticPopulation.h 31574 2009-12-05 18:23:21Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html528/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticPopulation.html
Performance,perform,perform,"lIndex = -1); make a little printout to the stream ""out"" of the individuals up to index ""untilIndex""; this means, .. write out the best ""untilIndex"" individuals. TH1F* VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max); give back a histogram with the distribution of the coefficients; parameters:; int bins : number of bins of the histogram; int min : histogram minimum; int max : maximum value of the histogram. vector<Double_t> VariableDistribution(Int_t varNumber); gives back all the values of coefficient ""varNumber"" of the current generation. void AddPopulation( GeneticPopulation *strangers ); add another population (strangers) to the one of this GeneticPopulation. void AddPopulation( GeneticPopulation &strangers ); add another population (strangers) to the one of this GeneticPopulation. void TrimPopulation(); trim the population to the predefined size. void GiveHint(vector<Double_t>& hint, Double_t fitness = 0); add an individual (a set of variables) to the population; if there is a set of variables which is known to perform good, they can be given as a hint to the population. void Sort(); sort the genepool according to the fitness of the individuals. GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0). Int_t GetPopulationSize() const; { return fGenePool.size(); }. Double_t GetFitness() const; { return fGenePool.size()>0? fGenePool[0].GetFitness() : 0; }. const std::vector<TMVA::GeneticGenes>& GetGenePool() const; { return fGenePool; }. const std::vector<TMVA::GeneticRange*>& GetRanges() const; { return fRanges; }. std::vector<TMVA::GeneticGenes>& GetGenePool(); { return fGenePool; }. std::vector<TMVA::GeneticRange*>& GetRanges(); { return fRanges; }. void NextGeneration(); {}. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GeneticPopulation.h 31574 2009-12-05 18:23:21Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or su",MatchSource.WIKI,root/html528/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticPopulation.html
Testability,log,logger,"lass*IsA() const; voidMakeChildren(); voidMakeCopies(int number); voidMutate(Double_t probability = 20, Int_t startIndex = 0, Bool_t near = kFALSE, Double_t spread = 0.1, Bool_t mirror = kFALSE); voidNextGeneration(); TMVA::GeneticPopulation&operator=(const TMVA::GeneticPopulation&); voidPrint(Int_t untilIndex = -1); voidPrint(ostream& out, Int_t utilIndex = -1); voidSetRandomSeed(UInt_t seed = 0); virtual voidShowMembers(TMemberInspector& insp); voidSort(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTrimPopulation(); vector<Double_t>VariableDistribution(Int_t varNumber); TH1F*VariableDistribution(Int_t varNumber, Int_t bins, Int_t min, Int_t max). private:. TMVA::MsgLogger&Log() const; TMVA::GeneticGenesMakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female). Data Members; private:. vector<TMVA::GeneticGenes>fGenePoolthe ""genePool"" where the individuals of the current generation are stored; TMVA::MsgLogger*fLoggermessage logger; Int_tfPopulationSizeLimit; TRandom3*fRandomGeneratorrandom Generator for this population; vector<TMVA::GeneticRange*>fRangescontains the ranges inbetween the values of the coefficients have to be. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticPopulation(const vector<TMVA::Interval*>& ranges, Int_t size, UInt_t seed = 0); Constructor. ~GeneticPopulation(); destructor. void SetRandomSeed(UInt_t seed = 0); the random seed of the random generator. void MakeCopies(int number); produces offspring which is are copies of their parents; Parameters:; int number : the number of the last individual to be copied. void MakeChildren(); does what the name says,... it creates children out of members of the; current generation; children have a combination of the coefficients of their parents. TMVA::GeneticGenes MakeSex(TMVA::GeneticGenes male, TMVA::GeneticGenes female); this function takes two individuals and produces offspring by mixing (recombining) their; coefficients. v",MatchSource.WIKI,root/html528/TMVA__GeneticPopulation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GeneticPopulation.html
Availability,down,down,"iniIndex: public TMVA::SeparationBase. Implementation of the GiniIndex as separation criterion. Function Members (Methods); public:. virtual~GiniIndex(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); TMVA::GiniIndexGiniIndex(); TMVA::GiniIndexGiniIndex(const TMVA::GiniIndex& g); virtual TClass*IsA() const; TMVA::GiniIndex&operator=(const TMVA::GiniIndex&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Gini(Sample M) = 1 - (c(1)/N)^2 - (c(2)/N)^2 .... - (c(k)/N)^2; Where: M is a smaple of whatever N elements (events); that belong to K different classes; c(k) is the number of elements that belong to class k; for just Signal and Background classes this boils down to:; Gini(Sample) = 2s*b/(s+b)^2 ( = 2 * purity * (1-purity) ). !! what we use here is 2*Gini.. as for the later use the factor; 2 is irrelevant and hence I'd like to save this calculation. GiniIndex(); construtor for the GiniIndex. { fName=""Gini""; }. GiniIndex(const TMVA::GiniIndex& g); copy constructor. {}. virtual ~GiniIndex(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GiniIndex.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__GiniIndex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GiniIndex.html
Availability,down,down,"on criterion. Function Members (Methods); public:. virtual~GiniIndexWithLaplace(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(); TMVA::GiniIndexWithLaplaceGiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); virtual TClass*IsA() const; TMVA::GiniIndexWithLaplace&operator=(const TMVA::GiniIndexWithLaplace&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Gini(Sample M) = 1 - (c(1)/N)^2 - (c(2)/N)^2 .... - (c(k)/N)^2; Where: M is a smaple of whatever N elements (events); that belong to K different classes; c(k) is the number of elements that belong to class k; Laplace's correction to the prob.density c/N --> (c+1)/(N+2); for just Signal and Background classes this then boils down to:; Gini(Sample) = 2(s*b+s+b+1)/(s+b+2)^2. GiniIndexWithLaplace(); construtor for the GiniIndexWithLaplace. { fName=""GiniLaplace""; }. GiniIndexWithLaplace(const TMVA::GiniIndexWithLaplace& g); copy constructor. {}. virtual ~GiniIndexWithLaplace(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: GiniIndexWithLaplace.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__GiniIndexWithLaplace.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__GiniIndexWithLaplace.html
Availability,avail,available,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__IFitterTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__IFitterTarget.html
Integrability,interface,interface,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__IFitterTarget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__IFitterTarget.html
Availability,avail,available,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0); virtual const char*GetName() const; virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; virtual Bool_tMonitorBoost(TMVA::MethodBoost* boost); TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier ",MatchSource.WIKI,root/html528/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__IMethod.html
Energy Efficiency,monitor,monitoring,"erator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. Bool_t MonitorBoost(TMVA::MethodBoost* boost); perfrom extra actions during the boosting at different stages. void Init(). void DeclareOptions(). void ProcessOptions(). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IMethod.h 31458 2009-11-30 13:58:20Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a",MatchSource.WIKI,root/html528/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__IMethod.html
Integrability,message,message,"thod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. Bool_t MonitorBoost(TMVA::MethodBoost* boost); perfrom extra actions during the boosting at different stages. void Init(). void DeclareOptions(). void ProcessOptions(). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IMethod.h 31458 2009-11-30 13:58:20Z stelzer $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__IMethod.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__IMethod.html
Deployability,continuous,continuous,". TMVA::Interval. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Interval. class TMVA::Interval. Interval. Interval definition, continuous and discrete. Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step, min+n*step=max; e.g.: Interval(1,5,5)=1,2,3,4,5; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0. Note: **bin** counting starts from ZERO unlike in ROOT histograms. the TMVA::Interval Class. Interval definition, continuous and discrete; ; Interval(min,max) : a continous interval [min,max]; Interval(min,max,n): a ""discrete interval"" [min,max], i.e the n numbers:; min, min+step, min+2*step,...., min+(n-1)*step=max ; e.g.: Interval(1,5,5)=1,2,3,4,5 ; Interval(.5,1.,6)= .5, .6., .7, .8, .9, 1.0 . Example: Interval(.5,1.,6) ; [ min max ] ; ------------------------------------------------------------; | | | | | |; .5 .6 .7 .8 .9 1.0 ; ; bin 0 1 2 3 4 5 . . Function Members (Methods); public:. virtual~Interval(); static TClass*Class(); Double_tGetElement(Int_t position) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discret",MatchSource.WIKI,root/html528/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Interval.html
Security,access,accessors,"sition) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when =0 continuous interval; static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize() const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Double_t GetWidth() const; { return fMax - fMin; }. Int_t GetNbins() const; { return fNbins; }. Double_t GetMean() const; { return (fMax + fMin)/2; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Interval.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Interval.html
Testability,log,logger,".9, 1.0 . Example: Interval(.5,1.,6) ; [ min max ] ; ------------------------------------------------------------; | | | | | |; .5 .6 .7 .8 .9 1.0 ; ; bin 0 1 2 3 4 5 . . Function Members (Methods); public:. virtual~Interval(); static TClass*Class(); Double_tGetElement(Int_t position) const; Double_tGetMax() const; Double_tGetMean() const; Double_tGetMin() const; Int_tGetNbins() const; Double_tGetRndm(TRandom3&) const; Double_tGetStepSize() const; Double_tGetWidth() const; TMVA::IntervalInterval(const TMVA::Interval& other); TMVA::IntervalInterval(Double_t min, Double_t max, Int_t nbins = 0); virtual TClass*IsA() const; TMVA::Interval&operator=(const TMVA::Interval&); voidSetMax(Double_t m); voidSetMin(Double_t m); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. Double_tfMaxthe constraints of the Interval; Double_tfMin; Int_tfNbinswhen >0 : number of bins (discrete interval); when =0 continuous interval; static TMVA::MsgLogger*fgLoggermessage logger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Interval(Double_t min, Double_t max, Int_t nbins = 0). Interval(const TMVA::Interval& other). ~Interval(); destructor. Double_t GetElement(Int_t position) const; calculates the value of the ""number"" bin in a discrete interval.; Parameters:; Double_t position. Double_t GetStepSize() const; retuns the step size between the numbers of a ""discrete Interval"". Double_t GetRndm(TRandom3& ) const; get uniformely distributed number within interval. Double_t GetMin() const; accessors. { return fMin; }. Double_t GetMax() const; { return fMax; }. Double_t GetWidth() const; { return fMax - fMin; }. Int_t GetNbins() const; { return fNbins; }. Double_t GetMean() const; { return (fMax + fMin)/2; }. void SetMax(Double_t m); { fMax = m; }. void SetMin(Double_t m); { fMin = m; }. » Author: Peter Speckmayer » Copyright (",MatchSource.WIKI,root/html528/TMVA__Interval.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Interval.html
Energy Efficiency,adapt,adaptive,"nelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root/html528/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html
Modifiability,adapt,adaptive,"nelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root/html528/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html
Safety,sanity check,sanity check,"order { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.). const char* GetName() const; modified name (remove TMVA::). { return ""KDEKernel""; }. » Author: Asen Christov » Copyright (c) 2007: *; » Last changed: root/tmva $Id: KDEKernel.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html
Testability,log,logger,"nelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); TMVA::KDEKernel&operator=(const TMVA::KDEKernel&); voidSetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EKernelType { kNone; kGauss; };; enum EKernelIter { kNonadaptiveKDE; kAdaptiveKDE; };; enum EKernelBorder { kNoTreatment; kKernelRenorm; kSampleMirror; };. private:. Float_tfFineFactorfine tuning factor for Adaptive KDE: factor to multiply the ""width"" of the Kernel function; TH1F*fFirstIterHisthistogram to be filled in the hidden iteration; Bool_tfHiddenIterationDefines if whats currently running is the ; TH1F*fHistcopy of input histogram; TMVA::KDEKernel::EKernelIterfIteriteration number; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects; TF1*fKernel_integthe integral of the Kernel function; TMVA::MsgLogger*fLoggermessage logger; Float_tfLowerEdgethe lower edge of the PDF; Float_tfSigmaWidth of the Kernel function; TH1F*fSigmaHistcontains the Sigmas Widths for adaptive KDE ; Float_tfUpperEdgethe upper edge of the PDF. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; KDEKernel(TMVA::KDEKernel::EKernelIter kiter = kNonadaptiveKDE, const TH1* hist = 0, Float_t lower_edge = 0., Float_t upper_edge = 1., TMVA::KDEKernel::EKernelBorder kborder = kNoTreatment, Float_t FineFactor = 1.); constructor; sanity check. ~KDEKernel(); destructor. void SetKernelType(TMVA::KDEKernel::EKernelType ktype = kGauss); fIter == 1 ---> nonadaptive KDE; fIter == 2 ---> adaptive KDE. Float_t GetBinKernelIntegral(Float_t lowr, Float_t highr, Float_t mean, Int_t binnum); calculates the integral of the Kernel. KDEKernel(TMVA::KDEKernel::EKernel",MatchSource.WIKI,root/html528/TMVA__KDEKernel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__KDEKernel.html
Energy Efficiency,charge,charge,TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken,MatchSource.WIKI,root/html528/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__kNN__Event.html
Modifiability,variab,variable,; function members; data members; class charts. ROOT; » TEST; » TMVA::kNN::Event. class TMVA::kNN::Event. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //N,MatchSource.WIKI,root/html528/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__kNN__Event.html
Performance,perform,performance,"he first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken care of by the HistogramManager class. Note: This version of the class Event (see EventMT.h and EventMT.cxx; for an alternative) uses static variables to improve performance (by; reducing the number of memory allocations). Consequently, only one; instance of the class Event should be in use at a time (a 2nd instance; would share the array of Tracks with the first instance). Function Members (Methods); public:. ~Event(); TMVA::kNN::EventEvent(); TMVA::kNN::EventEvent(const TMVA::kNN::Event&); TMVA::kNN::EventEvent(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type); TMVA::kNN::EventEvent(const TMVA::kNN::VarVec& vec, Double_t weight, Short_t type, const TMVA::kNN::VarVec& tvec); TMVA::kNN::VarTypeGetDist(const TMVA::kNN::Event& other) const; TMVA::kNN::VarTypeGetDist(TMVA::kNN::VarType var, UInt_t ivar) const; TMVA::kNN::VarTypeGetDist(const TMVA::kNN::VarType var1, const UInt_t ivar) const; UInt_tGetNTgt() const; UInt_tGetNVar() const; const TMVA::kNN::VarVec&GetTargets() const; TMVA::kNN::VarTypeGetTgt(UInt_t i) const; TMVA::kNN::VarTypeGetTgt(const UInt_t i) const; Short_tGetType() const; TMVA::kNN::VarTypeGetVar(UInt_t i) const; TMVA",MatchSource.WIKI,root/html528/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__kNN__Event.html
Usability,simpl,simple,. TMVA::kNN::Event. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TEST; » TMVA::kNN::Event. class TMVA::kNN::Event. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharg,MatchSource.WIKI,root/html528/TMVA__kNN__Event.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__kNN__Event.html
Availability,error,error,"t::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; virtual const char*TObject::GetT",MatchSource.WIKI,root/html528/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MCFitter.html
Deployability,configurat,configuration,"l_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~MCFitter(); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MCFitter.h 23334 2008-04-19 18:38:57Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MCFitter.html
Modifiability,config,configuration,"l_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~MCFitter(); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MCFitter.h 23334 2008-04-19 18:38:57Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MCFitter.html
Testability,log,logger,"tream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Int_tfSamplesnumber of MC samples; UInt_tfSeedSeed for the random generator (0 takes random seeds); Double_tfSigmanew samples are generated randomly with a gaussian probability with fSigma around the current best value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MCFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); Declare MCFitter options. void SetParameters(Int_t cycles); set MC fitter configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~MCFitter(); {}. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MCFitter.h 23334 2008-04-19 18:38:57Z br",MatchSource.WIKI,root/html528/TMVA__MCFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MCFitter.html
Availability,avail,available,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Dr",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Energy Efficiency,monitor,monitoring,"t DataSet than the own one. protected:. TMVA::TActivation*fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TObjArray*fNetworkTObjArray of TObjArrays representing network; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache t",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Integrability,message,message,"onfigurable::EnableLooseOptions(Bool_t b = kTRUE); voidForceNetworkCalculations(); voidForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); virtual voidTMVA::IMethod::GetHelpMessage() const; TMVA::TNeuron*GetInputNeuron(Int_t index); const TString&TMVA::MethodBase::GetInternalVarName(Int_t ivar) const; Double_tGetNetworkOutput(); const TString&TMVA::MethodBase::GetOriginalVarName(Int_t ivar) const; TMVA::TNeuron*GetOutputNeuron(Int_t index = 0); const TString&TMVA::Configurable::GetReferenceFile() const; static TMVA::MethodBase*TMVA::MethodBase::GetThisBase(); Float_tTMVA::MethodBase::GetTWeight(const TMVA::Event* ev) const; const TString&TMVA::MethodBase::GetWeightFileDir() const; Bool_tTMVA::MethodBase::HasTrainingTree() const; Bool_tTMVA::MethodBase::Help() const; Bool_tTMVA::MethodBase::IgnoreEventsWithNegWeightsInTraining() const; Bool_tTMVA::MethodBase::IsConstructedFromWeightFile() const; Bool_tTMVA::MethodBase::IsNormalised() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidTMVA::MethodBase::MakeClassSpecificHeader(ostream&, const TString& = """") const; voidTObject::MakeZombie(); voidTMVA::MethodBase::NoErrorCalc(Double_t *const err, Double_t *const errUpper); Int_tNumCycles(); vector<Int_t>*ParseLayoutString(TString layerSpec); voidPrintMessage(TString message, Bool_t force = kFALSE) const; voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidWaitForKeyboard(); voidTMVA::Configurable::WriteOptionsReferenceToFile().",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Modifiability,layers,layers,"t DataSet than the own one. protected:. TMVA::TActivation*fActivationactivation function to be used for hidden layers; TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TH1*>fEpochMonHistBepoch monitoring hitograms for background; vector<TH1*>fEpochMonHistSepoch monitoring hitograms for signal; vector<TH1*>fEpochMonHistWepoch monitoring hitograms for weights; TMVA::MethodANNBase::EEstimatorfEstimator; TH1F*fEstimatorHistTestmonitors convergence of independent test sample; TH1F*fEstimatorHistTrainmonitors convergence of training sample; TStringfEstimatorS; TMVA::TActivation*fIdentityactivation for input and output layers; TMVA::TNeuronInput*fInputCalculatorinput calculator for all neurons; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; TMatrixDfInvHessianzjh; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TObjArray*fNetworkTObjArray of TObjArrays representing network; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache t",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Performance,tune,tuneParameters,"it(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Security,access,access,":MethodBase::fNbinsHnumber of bins in evaluation histograms; TObjArray*fNetworkTObjArray of TObjArrays representing network; TMVA::TActivation*fOutputactivation function to be used for output layers, depending on estimator; Int_tfRandomSeedrandom seed for initial synapse weights; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; vector<Int_t>fRegulatorIdxindex to different priors from every synapses; vector<Double_t>fRegulatorsthe priors as regulator; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class; TObjArray*fSynapsesarray of pointers to synapses, no structural data; boolfUseRegulatorzjh; TRandom3*frgenrandom number generator for various uses. private:. TObjArray*fInputLayercache this for fast access; TStringfLayerSpeclayout specification option; Int_tfNcyclesnumber of epochs to train; TStringfNeuronInputTypename of neuron input calculator class; TStringfNeuronTypename of neuron activation function class; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Testability,test,testTime,"dSetActivation(TMVA::TActivation* activation); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Usability,clear,clear,"on activation function class; vector<TNeuron*>fOutputNeuronscache this for fast access; static const Bool_tfgDEBUGdebug flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DeclareOptions(); define the options (their key words) that can be set in the option string; here the options valid for ALL MVA methods are declared.; know options: NCycles=xx :the number of training cycles; Normalize=kTRUE,kFALSe :if normalised in put variables should be used; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers; NeuronType=sigmoid,tanh,radial,linar : the type of activation function; used at the neuronn. void ProcessOptions(); do nothing specific at this moment. vector<Int_t>* ParseLayoutString(TString layerSpec); parse layout specification string and return a vector, each entry; containing the number of neurons to go in each successive layer. void InitANNBase(); initialize ANNBase object. ~MethodANNBase(); destructor. void DeleteNetwork(); delete/clear network. void DeleteNetworkLayer(TObjArray*& layer); delete a network layer. void BuildNetwork(vector<Int_t>* layout, vector<Double_t>* weights = NULL, Bool_t fromFile = kFALSE); build network given a layout (number of neurons in each layer); and optional weights array. void BuildLayers(vector<Int_t>* layout, Bool_t from_file = false); build the network layers. void BuildLayer(Int_t numNeurons, TObjArray* curLayer, TObjArray* prevLayer, Int_t layerIndex, Int_t numLayers, Bool_t from_file = false); build a single layer with neurons and synapses connecting this; layer to the previous layer. void AddPreLinks(TMVA::TNeuron* neuron, TObjArray* prevLayer); add synapses connecting a neuron to its preceding layer. void InitWeights(); initialize the synapse weights randomly. void ForceWeights(vector<Double_t>* weights); force the synapse weights. void ForceNetworkInputs(const TMVA::Event* ev, Int_t ignoreIndex = -1); force the input values of the input neurons; force the value for",MatchSource.WIKI,root/html528/TMVA__MethodANNBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html
Availability,avail,available,"of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*Data() const; TMVA::DataSetInfo&DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual vo",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Deployability,configurat,configuration,"squared> of regression output versus ""true"" value from test sample. bias = average deviation; dev = average absolute deviation; rms = rms of deviation. void TestMulticlass(); test multiclass classification. void TestClassification(); initialization. void WriteStateToStream(ostream& tf) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void AddInfoItem(void* gi, const TString& name, const TString& value) const; xml writing. void AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType). void WriteStateToXML(void* parent) const; general method used in writing the header of the weight files where; the used variables, variable transformation type etc. is specified. void ReadStateFromStream(TFile& rf); write reference MVA distributions (and other information); to a ROOT type weight file. void WriteStateToFile() const; write options and weights to file; note that each one text file for the main configuration information; and one ROOT file for ROOT objects are created. void ReadStateFromFile(); Function to write options and weights to file. void ReadStateFromXMLString(const char* xmlstr); for reading from memory. void ReadStateFromXML(void* parent). void ReadStateFromStream(istream& tf); read the header from the weight files of the different MVA methods. void WriteVarsToStream(ostream& tf, const TString& prefix = """") const; write the list of variables (name, min, max) for a given data; transformation method to the stream. void ReadVarsFromStream(istream& istr); Read the variables (name, min, max) for a given data; transformation method from the stream. In the stream we only; expect the limits which will be set. void AddVarsXMLTo(void* parent) const; write variable info to XML. void AddSpectatorsXMLTo(void* parent) const; write spectator info to XML. void AddClassesXMLTo(void* parent) const; write class info to XML. void AddTargetsXMLTo(void* parent) const; wri",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Energy Efficiency,monitor,monitoring,"void AddTargetsXMLTo(void* parent) const; write target info to XML. void ReadVariablesFromXML(void* varnode); read variable info from XML. void ReadSpectatorsFromXML(void* specnode); read spectator info from XML. void ReadClassesFromXML(void* clsnode); read number of classes from XML. void ReadTargetsFromXML(void* tarnode); read target info from XML. TDirectory* BaseDir() const; returns the ROOT directory where info/histograms etc of the; corresponding MVA method instance are stored. TDirectory* MethodBaseDir() const; returns the ROOT directory where all instances of the; corresponding MVA method are stored. void SetWeightFileDir(TString fileDir); set directory of weight file. void SetWeightFileName(TString ); set the weight file name (depreciated). TString GetWeightFileName() const; retrieve weight file name. void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype); writes all MVA evaluation histograms to file. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file; dummy implementation here -----------------. Bool_t GetLine(istream& fin, char* buf); reads one line from the input stream; checks for certain keywords and interprets; the line if keywords are found. void CreateMVAPdfs(); Create PDFs of the MVA output variables. Double_t GetProba(Double_t mvaVal, Double_t ap_sig); compute likelihood ratio. Double_t GetRarity(Double_t mvaVal, TMVA::Types::ESBType reftype = Types::kBackground) const; compute rarity:; R(x) = Integrate_[-oo..x] { PDF(x') dx' }; where PDF(x) is the PDF of the classifier's signal or background distribution. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& err); fill background efficiency (resp. rejection) versus signal efficiency plots; returns signal efficiency at background efficiency indicated in theString. Double_t GetTrainingEfficiency(const TString& ). std::vector<Float_t> GetMulticlassEfficiency(vector<std::vector<Float_t> >& purity). std::vector<Float_t> GetMulticlassTr",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Integrability,depend,depends,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; pub",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Modifiability,variab,variables," at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidAddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& th",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Performance,perform,performance,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; pub",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Security,access,accessors,"s if it was not yet trained, just instantiated; virtual void Reset() = 0;; for the moment, I provide a dummy (that would not work) default, just to make; compilation/running w/o parameter optimisation still possible. {return;}. Double_t GetMvaValue(Double_t* errLower = 0, Double_t* errUpper = 0); classifier response:; some methods may return a per-event error estimate; error calculation is skipped if err==0. const std::vector<Float_t>& GetRegressionValues(); regression response. const std::vector<Float_t>& GetMulticlassValues(); multiclass classification response. const Ranking* CreateRanking(); create ranking. Bool_t MonitorBoost(TMVA::MethodBoost* ); perfrom extra actions during the boosting at different stages. {return kFALSE;}. void AddWeightsXMLTo(void* parent) const; the actual ""weights"". void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& ). void ReadWeightsFromStream(TFile& ); {}. const TString& GetJobName() const; ---------- public accessors -----------------------------------------------; classifier naming (a lot of names ... aren't they ;-). { return fJobName; }. const TString& GetMethodName() const; { return fMethodName; }. TString GetMethodTypeName() const; { return Types::Instance().GetMethodName(fMethodType); }. Types::EMVA GetMethodType() const; { return fMethodType; }. const char* GetName() const; { return fMethodName.Data(); }. const TString& GetTestvarName() const; { return fTestvar; }. const TString GetProbaName() const; { return fTestvar + ""_Proba""; }. void SetTestvarName(const TString& v = """"); build classifier name in Test tree; MVA prefix (e.g., ""TMVA_""). { fTestvar = (v=="""") ? (""MVA_"" + GetMethodName()) : v; }. UInt_t GetNvar() const; number of input variable used by classifier. { return DataInfo().GetNVariables(); }. UInt_t GetNVariables() const; { return DataInfo().GetNVariables(); }. UInt_t GetNTargets() const; { return DataInfo().GetNTargets(); }. const TString& GetInputVar(Int_t i) const; internal names and expr",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Testability,benchmark,benchmark,". TMVA::MethodBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBase. class TMVA::MethodBase: public TMVA::IMethod, public TMVA::Configurable. Virtual base Class for all MVA method; MethodBase hosts several specific evaluation methods.; The kind of MVA that provides optimal performance in an analysis strongly; depends on the particular application. The evaluation factory provides a; number of numerical benchmark results to directly assess the performance; of the MVA training on the independent test sample. These are:; ; The signal efficiency at three representative background efficiencies; (which is 1 − rejection).; The significance of an MVA estimator, defined by the difference; between the MVA mean values for signal and background, divided by the; quadratic sum of their root mean squares.; The separation of an MVA x, defined by the integral; ½∫(S(x) − B(x))2/(S(x) + B(x))dx, where; S(x) and B(x) are the signal and background distributions, respectively.; The separation is zero for identical signal and background MVA shapes,; and it is one for disjunctive shapes.; ; The average, ∫x μ(S(x))dx, of the signal μ-transform.; The μ-transform of an MVA denotes the transformation that yields; a uniform background distribution. In this way, the signal distributions; S(x) can be directly compared among the various MVAs. The stronger S(x); peaks towards one, the better is the discrimination of the MVA. The; μ-transform is; documented here.; ; The MVA standard output also prints the linear correlation coefficients between; signal and background, which can be useful to eliminate variables that exhibit too; strong correlations.; ; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; pub",MatchSource.WIKI,root/html528/TMVA__MethodBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html
Integrability,message,message,"rived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with 2 classes. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodBayesClassifier( void ); destructor. void Train( void ); some training. void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromStream(istream& istr); read back the training results from a file (stream). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void ReadWeightsFromXML(void* ); {}. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Abhishek Narain » Copyright (c) 2005-2006: *; » Last changed: root/tmva $Id: MethodBayesClassifier.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html
Modifiability,variab,variables,"ile(). private:. virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBayesClassifier(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodBayesClassifier(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Variable can handle classification with 2 classes. void Init( void ); default init",MatchSource.WIKI,root/html528/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodBayesClassifier.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html
Availability,error,error,"ructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as sign",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Deployability,update,update,"). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, as it the vector of events from the ROOT training tree. std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument. void Train(); BDT training. void GetRandomSubSample(); fills fEventSample with fSampleFraction*NEvents random training events. Double_t GetGradBoostMVA(TMVA::Event& e, UInt_t nTrees); returns MVA value: -1 for background, 1 for signal. void UpdateTargets(vector<TMVA::Event*> , UInt_t cls = 0); Calculate residua for all events;. void UpdateTargetsRegression(vector<TMVA::Event*> , Bool_t first = kFALSE); Calculate current residuals for all events and update targets for next iteration. Double_t GetWeightedQuantile(vector<std::pair<Double_t,Double_t> > vec, const Double_t quantile, const Double_t SumOfWeights = 0.0); calculates the quantile of the distribution of the first pair entries weighted with the values in the second pair entries. Double_t GradBoost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, UInt_t cls = 0); Calculate the desired response value for each region. Double_t GradBoostRegression(vector<TMVA::Event*> , TMVA::DecisionTree* dt); Implementation of M_TreeBoost using a Huber loss function as desribed by Friedman 1999. void InitGradBoost(vector<TMVA::Event*> ); initialize targets for first tree. Double_t TestTreeQuality(TMVA::DecisionTree* dt); test the tree quality.. in terms of Miscalssification. Double_t Boost(vector<TMVA::Event*> , TMVA::DecisionTree* dt, Int_t iTree, UInt_t cls = 0); apply the boosting alogrithim (the algorithm is selecte via the the ""option"" given; in ",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Energy Efficiency,adapt,adaptive,"g the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Fo",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Integrability,depend,depending,"termined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. virtual~MethodBDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Double_tBoost(vector<TMVA::Event*>, TMVA::DecisionTree* dt, Int_t iTree, UInt_t cls = 0); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); ",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Modifiability,variab,variable,". TMVA::MethodBDT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBDT. class TMVA::MethodBDT: public TMVA::MethodBase. Analysis of Boosted Decision Trees. Boosted decision trees have been successfully used in High Energy; Physics analysis for example by the MiniBooNE experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. Successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signa",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Performance,tune,tuneParameters,"t(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMaxDepth(Int_t d); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidSetNodeMinEvents(Int_t d); voidSetNodePurityLimit(Double_t l); voidSetNTrees(Int_t d); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidSetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Safety,avoid,avoided,"in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterium; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); UseWeightedTrees use average classification from the trees, or have the individual trees; trees in the forest weighted (e.g. log(boostweight) from AdaBoost; PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruneBeforeBoost flag to prune the tree before applying boosting algorithm; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); IgnoreNegWeightsInTraining Ignore negative weight events in the training.; NNodesMax maximum number of nodes allwed in the tree splitting, then it stops.; MaxDepth maximum depth of the decision tree allowed before further splitting is stopped. void DeclareCompatibilityOptions(). void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the BDT-Method. void Reset( void ); reset the method, as if it had just been instantiated (forget all training etc.). ~MethodBDT( void ); destructor. void InitEventSample( void ); Write all Events from the Tree into a vector of Events, that are; more easily manipulated. This method should never be called without; existing trainingTree, ",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Security,validat,validation,"king object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfAdaBoostBetabeta parameter for AdaBoost algorithm; TStringfAdaBoostR2Lossloss type used in AdaBoostR2 (Linear,Quadratic or Exponential); Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample; Bool_tfBaggedGradBoostturn bagging in combination with grad boost on/off; TStringfBoostTypestring specifying the boost type; Double_tfBoostWeightntuple var: boost weight; vector<double>fBoostWeightsthe weights applied in the individual boosts; Double_tfErrorFractionntuple var: misclassification error fraction; vector<TMVA::Event*>fEventSamplethe training events; Double_tfFValidationEventsfraction of events to use for pruning; vector<TMVA::DecisionTree*,allocator<TMVA::DecisionTree*> >fForestthe collection of decision trees; Int_tfITreentuple var: ith tree; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; TTree*fMonitorNtuplemonitoring ntuple; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNTreesnumber of decision trees requested; Bool_tfNoNegWeightsInTrainingignore negative event weights in the training; Int_tfNodeMinEventsmin number of events in node; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostflag to prune before boosting; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; Bool_tfRenormByClassindividually re-normalize each event class to the original size after bo",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Testability,log,log,"ructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as sign",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Usability,simpl,simple," the training sample. Boosting:. The idea behind adaptive boosting (AdaBoost) is, that signal events; from the training sample, that end up in a background node; (and vice versa) are given a larger weight than events that are in; the correct leave node. This results in a re-weighed training event; sample, with which then a new decision tree can be developed.; The boosting can be applied several times (typically 100-500 times); and one ends up with a set of decision trees (a forest).; Gradient boosting works more like a function expansion approach, where; each tree corresponds to a summand. The parameters for each summand (tree); are determined by the minimization of a error function (binomial log-; likelihood for classification and Huber loss for regression).; A greedy algorithm is used, which means, that only one tree is modified; at a time, while the other trees stay fixed. Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it; uses the bagging algorithm together and bases the determination of the; best node-split during the training on a random subset of variables only; which is individually chosen for each split. Analysis:. Applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection. Function Members (Methods); public:. v",MatchSource.WIKI,root/html528/TMVA__MethodBDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBDT.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetBoostNum(); TMVA::Types::EBoostStageGetBoostStage(); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; TMVA::IMethod*TMVA::MethodCompositeBase::GetCurrentMethod(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Even",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Energy Efficiency,monitor,monitoring,"g* CreateRanking(). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::Types::ETreeType , Bool_t CalcOverlapIntergral = kFALSE); Calculate the ROC integral of a single classifier or even the; whole boosted classifier. The tree type (training or testing; sample) is specified by 'eTT'. If tree type kTraining is set, the original training sample is; used to compute the ROC integral (original weights). - singleMethod - if kTRUE, return ROC integral of single (last; trained) classifier; if kFALSE, return ROC; integral of full classifier. - eTT - tree type (Types::kTraining / Types::kTesting). - CalcOverlapIntergral - if kTRUE, the overlap integral of the; signal/background MVA distributions; is calculated and stored in; 'fOverlap_integral'. void CalcMVAValues(); Calculate MVA values of current method fMethods.back() on; training sample. void SetBoostedMethodName(TString methodName); { fBoostedMethodName = methodName; }. Int_t GetBoostNum(); { return fBoostNum; }. TH1* GetMonitoringHist(Int_t histInd); gives the monitoring historgram from the vector according to index of the; histrogram added in the MonitorBoost function. { return (*fMonitorHist)[fDefaultHistNum+histInd]; }. void AddMonitoringHist(TH1* hist); { return fMonitorHist->push_back(hist); }. Types::EBoostStage GetBoostStage(); { return fBoostStage; }. void ClearAll(); clean up. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; print fit results. MethodBoost* SetStage(TMVA::Types::EBoostStage stage); { fBoostStage = stage; return this; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodBoost.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Integrability,rout,routine,"; Double_tfROC_training; UInt_tfRandomSeed; Bool_tfRecalculateMVACut; vector<TH1*>fTestBgdMVAHist; vector<TH1*>fTestSigMVAHist; vector<TH1*>fTrainBgdMVAHist; vector<TH1*>fTrainSigMVAHist; TStringfTransformString. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodBoost(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = NULL). MethodBoost(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL). ~MethodBoost( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); Boost can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(). Bool_t BookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); just registering the string from which the boosted classifier will be created. void Init(); {}. void InitHistos(); initialisation routine. void CheckSetup(). void Train(). void CleanBoostOptions(). void CreateMVAHistorgrams(). void ResetBoostWeights(); resetting back the boosted weights of the events to 1. void WriteMonitoringHistosToFile( void ). void TestClassification(). void WriteEvaluationHistosToFile(TMVA::Types::ETreeType treetype). void ProcessOptions(); process user options. void SingleTrain(); initialization. void FindMVACut(); find the CUT on the individual MVA that defines an event as; correct or misclassified (to be used in the boosting process). void SingleBoost(). void CalcMethodWeight(); Calculate weight of single method.; This is no longer done in SingleBoost();. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMVA::Ranking* CreateRanking(). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return boosted MVA response. Double_t GetBoostROCIntegral(Bool_t , TMVA::",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Modifiability,variab,variables,"public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; Int_tTMVA::MethodCompositeBase::fMethodIndex; vector<Double_t>TMVA::MethodCompositeBase::fMethodWeight; vector<IMethod*>TMVA::MethodCompositeBase::fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfADABoostBeta; vector<TH1*>fBTrainBgdMVAHist; vector<TH1*>fBTrainSigMVAHist; Int_tfBoostNum; TMVA::Types::EBoostStagefBoostStage; TStringfBoostType; Double_tfBoostWeight; TStringfBoostedMethodName; TStringfBoostedMethodOptions; TStringfBoostedMethodTitle; TMVA::DataSetManager*fDataSetManagerDSMTEST; Int_tfDefaultHistNum; vector<Float_t>*fMVAvalues; Double_tfMethodError; TStringfMethodWeightType; Bool_tfMonitorBoostedMethod; vector<TH1*>*fMonitorHist; TTree*fMonitorTree; Double_tfOrigMethodE",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Performance,perform,performed,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidAddMonitoringHist(TH1* hist); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Testability,test,test,". TMVA::MethodBoost. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodBoost. class TMVA::MethodBoost: public TMVA::MethodCompositeBase. This class is meant to boost a single classifier. Boosting means; training the classifier a few times. Everytime the wieghts of the; events are modified according to how well the classifier performed; on the test sample. Function Members (Methods); public:. virtual~MethodBoost(); voidTObject::AbstractMethod(const char* method) const; voidAddMonitoringHist(TH1* hist); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidTMVA::MethodCompositeBase::AddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Bool_tBookMethod(TMVA::Types::EMVA theMethod, TString methodTitle, TString theOption); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidCleanBoostOptions(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::",MatchSource.WIKI,root/html528/TMVA__MethodBoost.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; TMVA::IMethod*TMVA::MethodCompositeBase::GetCurrentMethod(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA",MatchSource.WIKI,root/html528/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html
Integrability,message,message,""", TDirectory* theTargetDir = NULL); standard constructor. MethodCategory(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodCategory( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t ); check whether method category has analysis type; the method type has to be the same for all sub-methods. void DeclareOptions(); options for this method. TMVA::IMethod* AddMethod(const TCut& , const TString& theVariables, TMVA::Types::EMVA theMethod, const TString& theTitle, const TString& theOptions); adds sub-classifier for a category. TMVA::DataSetInfo& CreateCategoryDSI(const TCut& , const TString& , const TString& ); create a DataSetInfo object for a sub-classifier. void Init(); initialize the method. void InitCircularTree(const TMVA::DataSetInfo& dsi); initialize the circular tree. void Train(); train all sub-classifiers. void AddWeightsXMLTo(void* parent) const; create XML description of Category classifier. void ReadWeightsFromXML(void* wghtnode); read weights of sub-classifiers of MethodCategory from xml weight file. void ProcessOptions(); process user options. void GetHelpMessage() const; Get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const TMVA::Ranking* CreateRanking(); no ranking. Bool_t PassesCut(const TMVA::Event* ev, UInt_t methodIdx). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the mva value of the right sub-classifier. void MakeClass(const TString& = TString("""")) const; {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss, Or Cohen » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCategory.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-01 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html
Modifiability,variab,variab,". TMVA::MethodCategory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCategory. class TMVA::MethodCategory: public TMVA::MethodCompositeBase. This class is meant to allow categorisation of the data. For different; categories, different classifiers may be booked and different variab-; les may be considered. The aim is to account for the difference that; is due to different locations/angles. Function Members (Methods); public:. virtual~MethodCategory(); voidTObject::AbstractMethod(const char* method) const; TMVA::IMethod*AddMethod(const TCut&, const TString& theVariables, TMVA::Types::EMVA theMethod, const TString& theTitle, const TString& theOptions); voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tT",MatchSource.WIKI,root/html528/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodCategory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetClass(Int_t ivar) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetData(Int_t isel, Int_t ivar) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Energy Efficiency,power,power,"ropagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Integrability,interface,interface,"NN can handle classification with 2 classes. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options: NCycles=xx :the number of training cycles; HiddenLayser=""N-1,N-2"" :the specification of the hidden layers. void ProcessOptions(); decode the options in the option string. void Init( void ); default initialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. »",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Modifiability,variab,variables,". TMVA::MethodCFMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType ",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Performance,perform,performed," members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN. class TMVA::MethodCFMlpANN: public TMVA::MethodBase, private TMVA::MethodCFMlpANN_Utils. /*; Interface to Clermond-Ferrand artificial neural network; ; The CFMlpANN belong to the class of Multilayer Perceptrons (MLP), which are; feed-forward networks according to the following propagation schema:. The input layer contains as many neurons as input variables used in the MVA.; The output layer contains two neurons for the signal and background; event classes. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual v",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Security,access,accessors,"ialisation called by all constructors. ~MethodCFMlpANN( void ); destructor. void Train( void ); training of the Clement-Ferrand NN classifier. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns CFMlpANN output (normalised within [0,1]). Double_t EvalANN(vector<Double_t>& , Bool_t& isOK); evaluates NN value as function of input variables. void NN_ava(Double_t* ); auxiliary functions. Double_t NN_fonc(Int_t , Double_t ) const; activation function. void ReadWeightsFromStream(istream& istr); read back the weight from the training from file (stream). Int_t DataInterface(Double_t* , Double_t* , Int_t* , Int_t* , Int_t* , Int_t* , Double_t* , Int_t* , Int_t* ); data interface function. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); read weights from xml file. void PrintWeights(ostream& o) const; write the weights of the neural net. TMVA::MethodCFMlpANN* This( void ); static pointer to this object (required for external functions. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific classifier response for header. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t GetData(Int_t isel, Int_t ivar) const; data accessors for external functions. { return (*fData)(isel, ivar); }. Int_t GetClass(Int_t ivar) const; { return (*fClass)[ivar]; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCFMlpANN.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodCFMlpANN*This(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject:",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Usability,learn,learning,"s. In between the input and output layers are a variable number; of k hidden layers with arbitrary numbers of neurons. (While the; structure of the input and output layers is determined by the problem, the; hidden layers can be configured by the user through the option string; of the method booking.) ; As indicated in the sketch, all neuron inputs to a layer are linear; combinations of the neuron output of the previous layer. The transfer; from input to output within a neuron is performed by means of an ""activation; function"". In general, the activation function of a neuron can be; zero (deactivated), one (linear), or non-linear. The above example uses; a sigmoid activation function. The transfer function of the output layer; is usually linear. As a consequence: an ANN without hidden layer should; give identical discrimination power as a linear discriminant analysis (Fisher).; In case of one hidden layer, the ANN computes a linear combination of; sigmoid. ; The learning method used by the CFMlpANN is only stochastic.; */; . Function Members (Methods); public:. virtual~MethodCFMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html
Availability,avail,available,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t*",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html
Integrability,interface,interface,"t_t a_3); voidWini(); Double_tWw_ref(const Double_t* wwNN, Int_t a_1, Int_t a_2) const; Double_t&Ww_ref(Double_t* wwNN, Int_t a_1, Int_t a_2). private:. TMVA::MsgLogger&ULog(). Data Members; protected:. TMVA::MethodCFMlpANN_Utils::fCost_1; TMVA::MethodCFMlpANN_Utils::fDel_1; TMVA::MethodCFMlpANN_Utils::fNeur_1; TMVA::MethodCFMlpANN_Utils::fParam_1; TMVA::MethodCFMlpANN_Utils::VARn2fVarn2_1; TMVA::MethodCFMlpANN_Utils::VARn2fVarn3_1; TMVA::MethodCFMlpANN_Utils::fVarn_1; static Int_tfg_0constant; static Int_tfg_100constant; static Int_tfg_999constant; static const char*fg_MethodNamemethod name for print; static Int_tfg_max_nNodes_maximum number of nodes per variable; static Int_tfg_max_nVar_static maximum number of input variables. private:. TMVA::MsgLogger*fLogger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MethodCFMlpANN_Utils(); destructor. void Train_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); training interface - called from MethodCFMlpANN class object. void Entree_new(Int_t* , char* , Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t ); first initialisation of ANN. void Wini(); [smart comments to be added]. void En_avant(Int_t* ievent); [smart comments to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ievent); [smart comments to be added]. void Out(Int_t* iii, Int_t* maxcycle); write weights to file. void Innit(char* det, Double_t* tout2, Double_t* tin2, Int_t ); Initialization. void TestNN(); [smart comments to be added]. void Cout(Int_t* , Double_t* xxx); [smart comments to be added]. void Inl(); [smart comments to be added]. Double_t Fdecroi(Int_t* i__); [smart comments to be added]. void GraphNN(Int_t* ilearn, Double_t* , Double_t* , char* , Int_t ); [smart comments to be added]. Double_t Sen3a( void ); [smart comments to ",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html
Modifiability,variab,variable,", Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); Double_tW_ref(const Double_t* wNN, Int_t a_1, Int_t a_2, Int_t a_3) const; Double_t&W_ref(Double_t* wNN, Int_t a_1, Int_t a_2, Int_t a_3); voidWini(); Double_tWw_ref(const Double_t* wwNN, Int_t a_1, Int_t a_2) const; Double_t&Ww_ref(Double_t* wwNN, Int_t a_1, Int_t a_2). private:. TMVA::MsgLogger&ULog(). Data Members; protected:. TMVA::MethodCFMlpANN_Utils::fCost_1; TMVA::MethodCFMlpANN_Utils::fDel_1; TMVA::MethodCFMlpANN_Utils::fNeur_1; TMVA::MethodCFMlpANN_Utils::fParam_1; TMVA::MethodCFMlpANN_Utils::VARn2fVarn2_1; TMVA::MethodCFMlpANN_Utils::VARn2fVarn3_1; TMVA::MethodCFMlpANN_Utils::fVarn_1; static Int_tfg_0constant; static Int_tfg_100constant; static Int_tfg_999constant; static const char*fg_MethodNamemethod name for print; static Int_tfg_max_nNodes_maximum number of nodes per variable; static Int_tfg_max_nVar_static maximum number of input variables. private:. TMVA::MsgLogger*fLogger. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MethodCFMlpANN_Utils(); destructor. void Train_nn(Double_t* tin2, Double_t* tout2, Int_t* ntrain, Int_t* ntest, Int_t* nvar2, Int_t* nlayer, Int_t* nodes, Int_t* ncycle); training interface - called from MethodCFMlpANN class object. void Entree_new(Int_t* , char* , Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t ); first initialisation of ANN. void Wini(); [smart comments to be added]. void En_avant(Int_t* ievent); [smart comments to be added]. void Leclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); [smart comments to be added]. void En_arriere(Int_t* ieven",MatchSource.WIKI,root/html528/TMVA__MethodCFMlpANN_Utils.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html
Availability,error,error," const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const vector<Double_t>&GetBoostWeights() const; const vector<TMVA::IMethod*>&GetCommittee() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::Get",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Integrability,message,message,"ightsFromStream(istream& istr); read the state of the method from an input stream. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return the MVA value (range [-1;1]) that classifies the; event.according to the majority vote from the total number of; decision trees; In the literature I found that people actually use the; weighted majority vote (using the boost weights) .. However I; did not see any improvement in doing so :(; --> this is currently switched off. void WriteMonitoringHistosToFile( void ); here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); return the variable importance. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void ReadWeightsFromXML(void* ); {}. const std::vector<TMVA::IMethod*>& GetCommittee() const; accessors. { return fCommittee; }. const std::vector<Double_t>& GetBoostWeights() const; { return fBoostWeights; }. std::vector<IMethod*>& GetCommittee(); accessors. { return fCommittee; }. std::vector<Double_t>& GetBoostWeights(); { return fBoostWeights; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCommittee.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Modifiability,variab,variables,"e_t>&GetBoostWeights(); vector<IMethod*>&GetCommittee(); virtual voidInit(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Double_tfBoostFactorntuple var: boost weight; TH1F*fBoostFactorHistweights applied in boosting; TStringfBoostTypestring specifying the boost type; vector<Double_t>fBoostWeightsthe weights applied in the individual boosts; vector<IMethod*>fCommitteethe collection of members; TH2F*fErrFractHisterror fraction vs member number; Double_tfErrorFractionntuple var: misclassification error fraction ; Int_tfITreentuple var: ith member; TStringfMemberOptionthe options for that method; TMVA::Types::EMVAfMemberTypethe MVA method to be boosted; TTree*fMonitorNtuplemonitoring ntuple; UInt_tfNMembersnum",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Security,access,accessors,"ightsFromStream(istream& istr); read the state of the method from an input stream. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); return the MVA value (range [-1;1]) that classifies the; event.according to the majority vote from the total number of; decision trees; In the literature I found that people actually use the; weighted majority vote (using the boost weights) .. However I; did not see any improvement in doing so :(; --> this is currently switched off. void WriteMonitoringHistosToFile( void ); here we could write some histograms created during the processing; to the output file. vector< Double_t > GetVariableImportance(); return the relative variable importance, normalized to all; variables together having the importance 1. The importance in; evaluated as the total separation-gain that this variable had in; the decision trees (weighted by the number of events). Double_t GetVariableImportance(UInt_t ivar); return the variable importance. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void ReadWeightsFromXML(void* ); {}. const std::vector<TMVA::IMethod*>& GetCommittee() const; accessors. { return fCommittee; }. const std::vector<Double_t>& GetBoostWeights() const; { return fBoostWeights; }. std::vector<IMethod*>& GetCommittee(); accessors. { return fCommittee; }. std::vector<Double_t>& GetBoostWeights(); { return fBoostWeights; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodCommittee.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Usability,simpl,simple,". TMVA::MethodCommittee. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCommittee. class TMVA::MethodCommittee: public TMVA::MethodBase. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Function Members (Methods); public:. virtual~MethodCommittee(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; Double_tBoost(TMVA::MethodBase*, UInt_t imember); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::",MatchSource.WIKI,root/html528/TMVA__MethodCommittee.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCommittee.html
Availability,avail,available,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::Dista",MatchSource.WIKI,root/html528/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html
Modifiability,variab,variables,"OptionsReferenceToFile(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; Int_tfMethodIndex; vector<Double_t>fMethodWeight; vector<IMethod*>fMethodsvector of all classifiers; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::IMethod* GetMethod(const TString& title) const; returns pointer to MVA that corresponds to given method title. TMVA::IMethod* GetMethod(const Int_t index) const; returns pointer to MVA that corresponds to given method index. void AddWeightsXMLTo(void* parent) const. ~MethodCompositeBase( void ); delete methods. void ReadWeightsFromXML(void* wghtnode); XML streamer. void ReadWeightsFromStream(istream& istr); text streamer. Double_t GetMvaValue(Double_t*",MatchSource.WIKI,root/html528/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html
Performance,load,loading,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::Dista",MatchSource.WIKI,root/html528/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodCompositeBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html
Availability,error,error,"g*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static TMVA::MethodCuts*DynamicCast(TMVA::IMethod* method); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tEstimatorFunction(Int_t ievt1, Int_t ievt2); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; Double_tGetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t&); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) con",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Energy Efficiency,monitor,monitoring,"uble_t>& , Double_t** , Double_t** , Int_t ibin); translate the cuts into parameters (obsolete function). void MatchCutsToPars(vector<Double_t>& , Double_t* , Double_t* ); translates cuts into parameters. void GetEffsfromPDFs(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from PDFs; for given cut sample. void GetEffsfromSelection(Double_t* cutMin, Double_t* cutMax, Double_t& effS, Double_t& effB); compute signal and background efficiencies from event counting; for given cut sample. void CreateVariablePDFs( void ); for PDF method: create efficiency reference histograms and PDFs. void ReadWeightsFromStream(istream& i); read the cuts from stream. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. Double_t GetTrainingEfficiency(const TString& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. Double_t GetEfficiency(const TString& , TMVA::Types::ETreeType , Double_t& ); - overloaded function to create background efficiency (rejection) versus; signal efficiency plot (first call of this function); - the function returns the signal efficiency at background efficiency; indicated in theString. ""theString"" must have two entries:; [0]: ""Efficiency""; [1]: the value of background efficiency at which the signal efficiency; is to be returned. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier ",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Integrability,depend,depending," efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); ",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Modifiability,variab,variables,". TMVA::MethodCuts. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Performance,perform,performed," » TMVA::MethodCuts. class TMVA::MethodCuts: public TMVA::MethodBase, public TMVA::IFitterTarget. Multivariate optimisation of signal efficiency for given background; efficiency, applying rectangular minimum and maximum requirements.; ; Also implemented is a ""decorrelate/diagonlized cuts approach"",; which improves over the uncorrelated cuts ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix.; . Other optimisation criteria, such as maximising the signal significance-; squared, S^2/(S+B), with S and B being the signal and background yields,; correspond to a particular point in the optimised background rejection; versus signal efficiency curve. This working point requires the knowledge; of the expected yields, which is not the case in general. Note also that; for rare signals, Poissonian statistics should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelat",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Safety,sanity check,sanity check,"TargetDir = NULL); construction from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); Cuts can only handle classification with 2 classes. void Init( void ); default initialisation called by all constructors. ~MethodCuts( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; Method <string> Minimisation method; available values are: MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method; available values are: EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the; globale setting. The same values as for the global option are available. Variables 1..10 can be; set this way. CutRangeMin/Max <float> user-defined ranges in which cuts are varied. void ProcessOptions(); process user options; sanity check, do not allow the input variables to be normalised, because this; only creates problems when interpreting the cuts. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); cut evaluation: returns 1.0 if event passed, 0.0 otherwise. void PrintCuts(Double_t effS) const; print cuts. Double_t GetCuts(Double_t effS, Double_t* cutMin, Double_t* cutMax) const; retrieve cut values for given signal efficiency; assume vector of correct size !!. Double_t GetCuts(Double_t effS, vector<Double_t>& cutMin, vector<Double_t>& cutMax) const; retrieve cut values for given signal efficiency. void Train( void ); training method: here the cuts are optimised for the training sample. void TestClassification(); nothing to test. Double_t EstimatorFunction(Int_t ievt1, Int_t ievt2); for full event scan. Double_t EstimatorFunction(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA. Double_t ComputeEstimator(vector<Double_t>& ); returns estimator for ""cut fitness"" used by GA; there are two requirements:; 1) the sign",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Testability,test,tests," should be used, which modifies; the significance criterion.; . The rectangular cut of a volume in the variable space is performed using; a binary tree to sort the training events. This provides a significant; reduction in computing time (up to several orders of magnitudes, depending; on the complexity of the problem at hand).; ; Technically, optimisation is achieved in TMVA by two methods:; ; Monte Carlo generation using uniform priors for the lower cut value,; and the cut width, thrown within the variable ranges.; A Genetic Algorithm (GA) searches for the optimal (""fittest"") cut sample.; The GA is configurable by many external settings through the option; string. For difficult cases (such as many variables), some tuning; may be necessary to achieve satisfying results; . Attempts to use Minuit fits (Simplex ot Migrad) instead have not shown; superior results, and often failed due to convergence at local minima.; . The tests we have performed so far showed that in generic applications,; the GA is superior to MC sampling, and hence GA is the default method.; It is worthwhile trying both anyway.; Decorrelated (or ""diagonalized"") Cuts. See class description for Method Likelihood for a detailed explanation.; . Function Members (Methods); public:. virtual~MethodCuts(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* ",MatchSource.WIKI,root/html528/TMVA__MethodCuts.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodCuts.html
Availability,error,error," const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Integrability,depend,depending,"ain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """,MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Modifiability,variab,variable,". TMVA::MethodDT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodDT. class TMVA::MethodDT: public TMVA::MethodBase. Analysis of Boosted Decision Trees. Boosted decision trees have been successfully used in High Energy; Physics analysis for example by the MiniBooNE experiment; (Yang-Roe-Zhu, physics/0508045). In Boosted Decision Trees, the; selection is done on a majority vote on the result of several decision; trees, which are all derived from the same training sample by; supplying different event weights during the training. Decision trees:. successive decision nodes are used to categorize the; events out of the sample as either signal or background. Each node; uses only a single discriminating variable to decide if the event is; signal-like (""goes right"") or background-like (""goes left""). This; forms a tree like structure with ""baskets"" at the end (leave nodes),; and an event is classified as either signal or background according to; whether the basket where it ends up has been classified signal or; background during the training. Training of a decision tree is the; process to define the ""cut criteria"" for each node. The training; starts with the root node. Here one takes the full training event; sample and selects the variable and corresponding cut value that gives; the best separation between signal and background at this stage. Using; this cut criterion, the sample is then divided into two subsamples, a; signal-like (right) and a background-like (left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" ",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); Double_tTestTreeQuality(TMVA::DecisionTree* dt); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virt",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Safety,avoid,avoided," words) that can be set in the option string; UseRandomisedTrees choose at each node splitting a random set of variables; UseNvars use UseNvars variables in randomised trees; SeparationType the separation criterion applied in the node splitting; known: GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB; nEventsMin: the minimum number of events in a node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then; step size is determined by the events); UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B; (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine; misclassification error rate); PruneMethod The Pruning method:; known: NoPruning // switch off pruning completely; ExpectedError; CostComplexity; PruneStrength a parameter to adjust the amount of pruning. Should be large enouth such that overtraining is avoided"");. void ProcessOptions(); the option string is decoded, for available options see ""DeclareOptions"". void Init( void ); common initialisation with defaults for the DT-Method. ~MethodDT( void ); destructor. void Train( void ). Bool_t MonitorBoost(TMVA::MethodBoost* booster). Double_t PruneTree(const Int_t methodIndex). Double_t TestTreeQuality(TMVA::DecisionTree* dt). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr). Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value. void GetHelpMessage() const. const TMVA::Ranking* CreateRanking(). Double_t GetPruneStrength(); { return fPruneStrength; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodDT.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestion",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Security,validat,validation,"InputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfAutomaticuse user given prune strength or automatically determined one using a validation sample ; Double_tfDeltaPruneStrengthstep size in pruning, is adjusted according to experience of previous trees ; Double_tfErrorFractionntuple var: misclassification error fraction ; vector<TMVA::Event*,allocator<TMVA::Event*> >fEventSamplethe training events; UInt_tfMaxDepthmax depth; Int_tfNCutsgrid used in cut applied in node splitting; UInt_tfNNodesMaxmax # of nodes; Int_tfNodeMinEventsmin number of events in node ; Double_tfNodePurityLimitpurity limit for sig/bkg nodes; Bool_tfPruneBeforeBoostwhether to prune right after the training (before the boosting); TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; TMVA::DecisionTree*fTreethe decision tree; Int_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<Double_t>fVariableImportancethe relative importance of the different variables ; static const Int_tfgDebugLeve",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Testability,test,test,"is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurab",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Usability,simpl,simple,"(left) sample. Two new nodes; are then created for each of the two sub-samples and they are; constructed using the same mechanism as described for the root; node. The devision is stopped once a certain node has reached either a; minimum number of events, or a minimum or maximum signal purity. These; leave nodes are then called ""signal"" or ""background"" if they contain; more signal respective background events from the training sample. Boosting:. the idea behind the boosting is, that signal events from the training; sample, that *end up in a background node (and vice versa) are given a; larger weight than events that are in the correct leave node. This; results in a re-weighed training event sample, with which then a new; decision tree can be developed. The boosting can be applied several; times (typically 100-500 times) and one ends up with a set of decision; trees (a forest). Bagging:. In this particular variant of the Boosted Decision Trees the boosting; is not done on the basis of previous training results, but by a simple; stochasitc re-sampling of the initial training event sample. Analysis:. applying an individual decision tree to a test event results in a; classification of the event as either signal or background. For the; boosted decision tree selection, an event is successively subjected to; the whole set of decision trees and depending on how often it is; classified as signal, a ""likelihood"" estimator is constructed for the; event being signal or background. The value of this estimator is the; one which is then used to select the events from an event sample, and; the cut value on this estimator defines the efficiency and purity of; the selection.; *. Function Members (Methods); public:. virtual~MethodDT(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* p",MatchSource.WIKI,root/html528/TMVA__MethodDT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodDT.html
Availability,error,error,"leTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>&); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Deployability,configurat,configuration,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWrit",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Integrability,message,message," ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double,allocator<double> >::iterator begin, vector<double,allocator<double> >::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write FDA-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. void CheckSetup(); no check of options at this place. {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005-2010: *; » Last changed: root/tmva $Id: MethodFDA.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Modifiability,config,configuration,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWrit",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Usability,simpl,simple,". TMVA::MethodFDA. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFDA. class TMVA::MethodFDA: public TMVA::MethodBase, public TMVA::IFitterTarget. Function discriminant analysis (FDA). This simple classifier; fits any user-defined TFormula (via option configuration string) to; the training data by requiring a formula response of 1 (0) to signal; (background) events. The parameter fitting is done via the abstract; class FitterBase, featuring Monte Carlo sampling, Genetic; Algorithm, Simulated Annealing, MINUIT and combinations of these. Can compute regression value for one dimensional output. Function Members (Methods); public:. virtual~MethodFDA(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidCheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWrit",MatchSource.WIKI,root/html528/TMVA__MethodFDA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFDA.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Energy Efficiency,power,power,"le means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Integrability,message,message,"compute full covariance matrix from sum of within and between matrices. void GetFisherCoeff( void ); Fisher = Sum { [coeff]*[variables] }. let Xs be the array of the mean values of variables for signal evts; let Xb be the array of the mean values of variables for backgd evts; let InvWith be the inverse matrix of the 'within class' correlation matrix. then the array of Fisher coefficients is; [coeff] =sqrt(fNsig*fNbgd)/fNevt*transpose{Xs-Xb}*InvWith. void GetDiscrimPower( void ); computation of discrimination power indicator for each variable; small values of ""fWith"" indicates little compactness of sig & of backgd; big values of ""fBetw"" indicates large separation between sig & backgd. we want signal & backgd classes as compact and separated as possible; the discriminating power is then defined as the ration ""fBetw/fWith"". const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void PrintCoefficients( void ); display Fisher coefficients and discriminating power for each variable; check maximum length of variable name. void ReadWeightsFromStream(istream& i); read Fisher coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description of Fisher classifier. void ReadWeightsFromXML(void* wghtnode); read Fisher coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". EFisherMethod GetFisherMethod( void ); { return fFisherMethod; }. » Author: Andreas Hoecker, Xavier Prudent, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodFisher.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Modifiability,variab,variable,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are v",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Performance,perform,performed,". TMVA::MethodFisher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodFisher. class TMVA::MethodFisher: public TMVA::MethodBase. Fisher and Mahalanobis Discriminants (Linear Discriminant Analysis); ; In the method of Fisher discriminants event selection is performed; in a transformed variable space with zero linear correlations, by; distinguishing the mean values of the signal and background; distributions. The linear discriminant analysis determines an axis in the (correlated); hyperspace of the input variables; such that, when projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are v",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Testability,test,test,"es; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidT",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Usability,simpl,simplifies," projecting the output classes (signal and background); upon this axis, they are pushed as far as possible away from each other,; while events of a same class are confined in a close vicinity.; The linearity property of this method is reflected in the metric with; which ""far apart"" and ""close vicinity"" are determined: the covariance; matrix of the discriminant variable space.; . The classification of the events in signal and background classes; relies on the following characteristics (only): overall sample means,; xi, for each input variable, i,; class-specific sample means, xS(B),i,; and total covariance matrix Tij. The covariance matrix; can be decomposed into the sum of a within- (Wij); and a between-class (Bij) class matrix. They describe; the dispersion of events relative to the means of their own class (within-class; matrix), and relative to the overall sample means (between-class matrix).; The Fisher coefficients, Fi, are then given by . where in TMVA is set NS=NB, so that the factor; in front of the sum simplifies to ½.; The Fisher discriminant then reads. The offset F0 centers the sample mean of xFi; at zero. Instead of using the within-class matrix, the Mahalanobis variant; determines the Fisher coefficients as follows:. with resulting xMa that are very similar to the; xFi. ; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising; the between-class separation, while minimising the within-class dispersion.; A useful measure of the discrimination power of a variable is hence given; by the diagonal quantity: Bii/Wii.; ; Discrimination power: the value of the Fisher coefficient is a; measure of the discriminating power of a variable. The discrimination power; of set of input variables can therefore be measured by the scalar; . The corresponding numbers are printed on standard output.; ; . Function Members (Methods); public:. virtual~MethodFisher(); voidTObject::AbstractMethod(const c",MatchSource.WIKI,root/html528/TMVA__MethodFisher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodFisher.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Integrability,message,message,"TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. void Init( void ); default initialization called by all constructors. ~MethodHMatrix( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void DeclareOptions(); MethodHMatrix options: none (apart from those implemented in MethodBase). void ProcessOptions(); process user options. void Train( void ); computes H-matrices for signal and background samples. void ComputeCovariance(Bool_t , TMatrixD* ); compute covariance matrix. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the H-matrix signal estimator. Double_t GetChi2(TMVA::Event* e, TMVA::Types::ESBType ) const; compute chi2-estimator for event according to type (signal/background). Double_t GetChi2(TMVA::Types::ESBType ) const; compute chi2-estimator for event according to type (signal/background). void AddWeightsXMLTo(void* parent) const. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read variable names and min/max; NOTE: the latter values are mandatory for the normalisation; in the reader application !!!. void MakeClassSpecific(ostream& , const TString& ) const; write Fisher-specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodHMatrix.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Modifiability,variab,variables,". TMVA::MethodHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodHMatrix. class TMVA::MethodHMatrix: public TMVA::MethodBase. /*; H-Matrix method, which is implemented as a simple comparison of; chi-squared estimators for signal and background, taking into; account the linear correlations between the input variables; This MVA approach is used by the DØ collaboration (FNAL) for the; purpose of electron identification (see, eg.,; hep-ex/9507007).; As it is implemented in TMVA, it is usually equivalent or worse than; the Fisher-Mahalanobis discriminant, and it has only been added for; the purpose of completeness.; Two χ2 estimators are computed for an event, each one; for signal and background, using the estimates for the means and; covariance matrices obtained from the training sample:. TMVA then uses as normalised analyser for event (i) the ratio:; (χS(i)2 − χB2(i)); (χS2(i) + χB2(i)).; */. Function Members (Methods); public:. virtual~MethodHMatrix(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTOb",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Usability,simpl,simple,". TMVA::MethodHMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodHMatrix. class TMVA::MethodHMatrix: public TMVA::MethodBase. /*; H-Matrix method, which is implemented as a simple comparison of; chi-squared estimators for signal and background, taking into; account the linear correlations between the input variables; This MVA approach is used by the DØ collaboration (FNAL) for the; purpose of electron identification (see, eg.,; hep-ex/9507007).; As it is implemented in TMVA, it is usually equivalent or worse than; the Fisher-Mahalanobis discriminant, and it has only been added for; the purpose of completeness.; Two χ2 estimators are computed for an event, each one; for signal and background, using the estimates for the means and; covariance matrices obtained from the training sample:. TMVA then uses as normalised analyser for event (i) the ratio:; (χS(i)2 − χB2(i)); (χS2(i) + χB2(i)).; */. Function Members (Methods); public:. virtual~MethodHMatrix(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTOb",MatchSource.WIKI,root/html528/TMVA__MethodHMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodHMatrix.html
Availability,error,error,"t::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Integrability,message,message,", UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void Init(); Initialization. void MakeKNN(); create kNN. void Train(); kNN training. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Compute classifier response. const std::vector< Float_t >& GetRegressionValues(). Return vector of averages for target values of k-nearest neighbors.; Use own copy of the regression vector, I do not like using a pointer to vector. const TMVA::Ranking* CreateRanking(); no ranking available. void AddWeightsXMLTo(void* parent) const; write weights to XML. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read the weights. void WriteWeightsToStream(TFile& rf) const; save weights to ROOT file. void ReadWeightsFromStream(TFile& rf); read weights from ROOT file. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Double_t PolnKernel(Double_t value) const; polynomial kernel. Double_t GausKernel(const TMVA::kNN::Event& event_knn, const TMVA::kNN::Event& event, const vector<Double_t>& svec) const; Gaussian kernel. Double_t getKernelRadius(const list<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float>,allocator<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float> > >& rlist) const. Get polynomial kernel radius. const std::vector<Double_t> getRMS(const list<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float>,allocator<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float> > >& rlist, const TMVA::kNN::Event& event_knn) const. Get polynomial kernel radius. Double_t getLDAValue(const list<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float>,allocator<pair<const TMVA::kNN::Node<TMVA::kNN::Event>*,float> > >& rlist, const TMVA::kNN::Event& event_knn). » Author: Rustem Ospanov » Cop",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Modifiability,variab,variables,"N(); Double_tPolnKernel(Double_t value) const; virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Usability,learn,learning,"Base::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Int_tfBalanceDepthnumber of binary tree levels used for balancing tree; vector<TMVA::kNN::Event,allocator<TMVA::kNN::Event> >fEvent! (untouched) events used for learning; TStringfKernel=""Gaus"",""Poln"" - kernel type for smoothing; TMVA::LDAfLDA! Experimental feature for local knn analysis; TMVA::kNN::ModulekNN*fModule! module where all work is done; Float_tfScaleFracfraction of events used to compute variable width; Float_tfSigmaFactscale factor for Gaussian sigma in Gaus. kernel; Double_tfSumOfWeightsBsum-of-weights for background training events ; Double_tfSumOfWeightsSsum-of-weights for signal training events; Int_tfTreeOptDepthnumber of binary tree levels used for optimization; Bool_tfTrimset equal number of signal and background events; Bool_tfUseKerneluse polynomial kernel weight function; Bool_tfUseLDAuse local linear discriminat analysis to compute MVA; Bool_tfUseWeightuse weights to count kNN; Int_tfnkNNnumber of k-nearest neighbors . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodKNN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""KNN"", TDirectory* theTargetDir = NULL); standard constructor. MethodKNN(",MatchSource.WIKI,root/html528/TMVA__MethodKNN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodKNN.html
Availability,error,error," const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html
Integrability,message,message,"ctor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); LD can handle classification with 2 classes and regression with one regression-target. void Train( void ); compute fSumMatx. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Returns the MVA classification output. const std::vector< Float_t >& GetRegressionValues(); Calculates the regression output. void InitMatrices( void ); Initializaton method; creates global matrices and vectors. void GetSum( void ); Calculates the matrix transposed(X)*W*X with W being the diagonal weight matrix; and X the coordinates values. void GetSumVal( void ); Calculates the vector transposed(X)*W*Y with Y being the target vector. void GetLDCoeff( void ); Calculates the coeffiecients used for classification/regression. void ReadWeightsFromStream(istream& i); read LD coefficients from weight file. void AddWeightsXMLTo(void* parent) const; create XML description for LD classification and regression; (for arbitrary number of output classes/targets). void ReadWeightsFromXML(void* wghtnode); read coefficients from xml weight file. void MakeClassSpecific(ostream& , const TString& ) const; write LD-specific classifier response. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void DeclareOptions(); MethodLD options. void ProcessOptions(); this is the preparation for training. void PrintCoefficients( void ); Display the classification/regression coefficients for each variable. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk, Jan Therhaag » Copyright (c) 2008: *; » Last changed: Fri Nov 26 14:27:10 2010 » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html
Modifiability,variab,variables,"etSumVal(); virtual voidInit(); voidInitMatrices(); voidPrintCoefficients(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TMatrixD*fCoeffMatxMatrix of coefficients; vector<std::vector<Double_t>*>*fLDCoeffLD coefficients; Int_tfNRegOutsize of the output; TMatrixD*fSumMatxSum of coordinates product matrix ; TMatrixD*fSumValMatxSum of values multiplied by coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); standard constructor for the LD. MethodLD(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* ",MatchSource.WIKI,root/html528/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodLD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLD.html
Availability,recover,recovered,"od; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TSt",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Energy Efficiency,monitor,monitoring,"round events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodLikelihood.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Integrability,message,message,"round events:; fill histograms and smooth them; if decorrelation is required, compute; corresponding square-root matrices; the reference histograms require the correct boundaries. Since in Likelihood classification; the transformations are applied using both classes, also the corresponding boundaries; need to take this into account. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns the likelihood estimator for signal; fill a new Likelihood branch into the testTree. Double_t TransformLikelihoodOutput(Double_t ps, Double_t pb) const; returns transformed or non-transformed output. void WriteOptionsToStream(ostream& o, const TString& prefix) const; write options to stream. void AddWeightsXMLTo(void* parent) const; write weights to XML. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void WriteWeightsToStream(TFile& rf) const; write reference PDFs to ROOT file. void ReadWeightsFromXML(void* wghtnode); read weights from XML. void ReadWeightsFromStream(istream& istr); read weight info from file; nothing to do for this method. void ReadWeightsFromStream(TFile& istr); read reference PDF from ROOT file. void WriteMonitoringHistosToFile( void ); write histograms and PDFs to file for monitoring purposes. void MakeClassSpecificHeader(ostream& , const TString& = """") const; write specific header of the classifier (mostly include files). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodLikelihood.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Modifiability,variab,variables,". TMVA::MethodLikelihood. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) th",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Performance,perform,performed,"Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for both signal and background separately, since the; correlation pattern is not the same in the two samples.; ; The above diagonalisation is complete for linearly correlated,; Gaussian distributed variables only. In real-world examples this; is not often the case, so that only little additional information; may be recovered by the diagonalisation procedure. In these cases,; non-linear methods must be applied.; . Function Members (Methods); public:. virtual~MethodLikelihood(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const ch",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Safety,avoid,avoid,"ethodLikelihood. class TMVA::MethodLikelihood: public TMVA::MethodBase. Likelihood analysis (""non-parametric approach""); ; Also implemented is a ""diagonalized likelihood approach"",; which improves over the uncorrelated likelihood ansatz by; transforming linearly the input variables into a diagonal space,; using the square-root of the covariance matrix; ; The method of maximum likelihood is the most straightforward, and; certainly among the most elegant multivariate analyser approaches.; We define the likelihood ratio, RL, for event; i, by:. Here the signal and background likelihoods, LS,; LB, are products of the corresponding probability; densities, pS, pB, of the; Nvar discriminating variables used in the MVA: . and accordingly for LB.; In practise, TMVA uses polynomial splines to estimate the probability; density functions (PDF) obtained from the distributions of the; training variables. Note that in TMVA the output of the likelihood ratio is transformed; by. to avoid the occurrence of heavy peaks at RL=0,1.; Decorrelated (or ""diagonalized"") Likelihood. The biggest drawback of the Likelihood approach is that it assumes; that the discriminant variables are uncorrelated. If it were the case,; it can be proven that the discrimination obtained by the above likelihood; ratio is optimal, ie, no other method can beat it. However, in most; practical applications of MVAs correlations are present. . Linear correlations, measured from the training sample, can be taken; into account in a straightforward manner through the square-root; of the covariance matrix. The square-root of a matrix; C is the matrix C′ that multiplied with itself; yields C: C=C′C′. We compute the; square-root matrix (SQM) by means of diagonalising (D) the; covariance matrix: . and the linear transformation of the linearly correlated into the; uncorrelated variables space is then given by multiplying the measured; variable tuple by the inverse of the SQM. Note that these transformations; are performed for",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodLikelihood.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodLikelihood.html
Availability,error,error," voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*TMVA::MethodANNBase::CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tTMVA::MethodANNBase::Debug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Deployability,update,update,"MSEErr(const TMVA::Event* ev, UInt_t index = 0). Double_t GetCEErr(const TMVA::Event* ev, UInt_t index = 0). void BackPropagationMinimize(Int_t nEpochs); minimize estimator / train network with backpropagation algorithm. void TrainOneEpoch(); train network over a single epoch/cyle of events. void Shuffle(Int_t* index, Int_t n); Input:; index: the array to shuffle; n: the size of the array; Output:; index: the shuffled indexes; This method is used for sequential training. void DecaySynapseWeights(Bool_t lateEpoch); decay synapse weights; in last 10 epochs, lower learning rate even more to find a good minimum. void TrainOneEventFast(Int_t ievt, Float_t*& branchVar, Int_t& type); fast per-event training. void TrainOneEvent(Int_t ievt); train network over a single event; this uses the new event model. Double_t GetDesiredOutput(const TMVA::Event* ev); get the desired output of this event. void UpdateNetwork(Double_t desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void UpdateNetwork(vector<Float_t>& desired, Double_t eventWeight = 1.0); update the network based on how closely; the output matched the desired output. void CalculateNeuronDeltas(); have each neuron calculate its delta by backpropagation. void GeneticMinimize(); create genetics class similar to GeneticCut; give it vector of parameter ranges (parameters = weights); link fitness function of this class to ComputeEstimator; instantiate GA (see MethodCuts); run it; then this should exist for GA, Minuit and random sampling. Double_t EstimatorFunction(vector<Double_t>& parameters); interface to the estimate. Double_t ComputeEstimator(vector<Double_t>& parameters); this function is called by GeneticANN for GA optimization. void UpdateSynapses(); update synapse error fields and adjust the weights (if in sequential mode). void AdjustSynapseWeights(); just adjust the synapse weights (should be called in batch mode). void UpdatePriors(). void UpdateRegul",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Energy Efficiency,monitor,monitoring,,MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Integrability,message,message,"_t ignoreIndex = -1); virtual voidGetHelpMessage() const; TMVA::TNeuron*TMVA::MethodANNBase::GetInputNeuron(Int_t index); const TString&TMVA::MethodBase::GetInternalVarName(Int_t ivar) const; Double_tTMVA::MethodANNBase::GetNetworkOutput(); const TString&TMVA::MethodBase::GetOriginalVarName(Int_t ivar) const; TMVA::TNeuron*TMVA::MethodANNBase::GetOutputNeuron(Int_t index = 0); const TString&TMVA::Configurable::GetReferenceFile() const; static TMVA::MethodBase*TMVA::MethodBase::GetThisBase(); Float_tTMVA::MethodBase::GetTWeight(const TMVA::Event* ev) const; const TString&TMVA::MethodBase::GetWeightFileDir() const; Bool_tTMVA::MethodBase::HasTrainingTree() const; Bool_tTMVA::MethodBase::Help() const; Bool_tTMVA::MethodBase::IgnoreEventsWithNegWeightsInTraining() const; Bool_tTMVA::MethodBase::IsConstructedFromWeightFile() const; Bool_tTMVA::MethodBase::IsNormalised() const; TMVA::MsgLogger&TMVA::Configurable::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; virtual voidMakeClassSpecific(ostream&, const TString&) const; virtual voidTMVA::MethodBase::MakeClassSpecificHeader(ostream&, const TString& = """") const; voidTObject::MakeZombie(); voidTMVA::MethodBase::NoErrorCalc(Double_t *const err, Double_t *const errUpper); Int_tTMVA::MethodANNBase::NumCycles(); vector<Int_t>*TMVA::MethodANNBase::ParseLayoutString(TString layerSpec); voidTMVA::MethodANNBase::PrintMessage(TString message, Bool_t force = kFALSE) const; voidTMVA::Configurable::ResetSetFlag(); voidTMVA::MethodBase::SetNormalised(Bool_t norm); voidTMVA::MethodBase::SetWeightFileDir(TString fileDir); voidTMVA::MethodBase::SetWeightFileName(TString); voidTMVA::MethodBase::Statistics(TMVA::Types::ETreeType treeType, const TString& theVarName, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&); Bool_tTMVA::MethodBase::TxtWeightsOnly() const; Bool_tTMVA::MethodBase::Verbose() const; voidTMVA::MethodANNBase::WaitForKeyboard(); voidTMVA::Configurable::WriteOptionsReferenceToFile().",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Modifiability,layers,layers,,MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Performance,tune,tuneParameters,"ject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Testability,test,testTime,"TActivation* activation); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); voidTMVA::MethodANNBase::SetNeuronInputCalculator(TMVA::TNeuronInput* inputCalculator); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Usability,learn,learning,"napsesarray of pointers to synapses, no structural data; boolTMVA::MethodANNBase::fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, cons",MatchSource.WIKI,root/html528/TMVA__MethodMLP.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html
Availability,error,error,"t::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html
Integrability,depend,depending,"ass Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDEFoam(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""PDEFoam"", TDirectory* theTargetDir = 0); init PDEFoam objects. MethodPDEFoam(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDEFoam can handle classification with 2 classes and regression; with one or more regression-targets. void Init( void ); default initialization called by all constructors. void DeclareOptions(). Declare MethodPDEFoam options. void DeclareCompatibilityOptions(). void ProcessOptions(); process user options. ~MethodPDEFoam( void ); destructor. void CalcXminXmax(); Determine foam range [fXmin, fXmax] for all dimensions, such; that fFrac events lie outside the foam. void Train( void ); Train PDE-Foam depending on the set options. void TrainSeparatedClassification(); Creation of 2 separated foams: one for signal events, one for; backgound events. void TrainUnifiedClassification(); Create only one unified foam which contains discriminator; (N_sig)/(N_sig + N_bg). void TrainMonoTargetRegression(); Training mono target regression foam; - foam density = average Target(0); - dimension of foam = number of non-targets; - cell content = average target 0. void TrainMultiTargetRegression(); Training multi target regression foam; - foam density = Event density; - dimension of foam = number of non-targets + number of targets; - cell content = event density. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); Return Mva-Value. In case of 'fSigBgSeparated==false' return; the cell content (D = N_sig/(N_bg+N_sig)). In case of; 'fSigBgSeparated==false' return D =; Density_sig/(Density_sig+Density_bg). In both cases the error; of the discriminant is stored in 'err'. void SetXminXmax(T",MatchSource.WIKI,root/html528/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html
Modifiability,variab,variables,"; virtual voidInit(); voidPrintCoefficients(); virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Bool_tfCompresscompress foam output file; Bool_tfCutNminKeep for bw compatibility: Grabbing cell with maximal RMS to split next (TFoam default); TStringfDTLogicuse DT algorithm to split cells; TMVA::EDTSeparationfDTSeparationenum which specifies the separation to use for the DT logic; Double_tfDiscrErrCutcut on discrimant error; Int_tfEvPerBinMaximum events (equiv.) per bin in buid-up (1000); Bool_tfFillFoamWithOrigWeightsfill the foam with boost weights; vector<PDEFoam*>fFoam; Double_tfFracFraction used for calc of Xmin, Xmax; TMVA::EKernelfKernelKernel for GetMvaValue(); TStringfKernel",MatchSource.WIKI,root/html528/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); voidTrainMonoTargetRegression(); voidTrainMultiTargetRegression(); voidTrainSeparatedClassification(); voidTrainUnifiedClassification(); TMVA::EKernelUIntToKernel(UInt_t iker); TMVA::ETargetSelec",MatchSource.WIKI,root/html528/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; UInt_tTargetSelectionToUInt(TMVA::ETargetSelection ts) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMeth",MatchSource.WIKI,root/html528/TMVA__MethodPDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDEFoam.html
Availability,error,error,"har* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Deployability,update,update," Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodPDERS.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Energy Efficiency,reduce,reduce,"VC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) cons",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Integrability,rout,routine," Float_tfScaleSweight for signal events; vector<Float_t>*fShiftvolume center; TMVA::MethodPDERS::EVolumeRangeModefVRangeMode; TStringfVolumeRangeoption volume range; static TMVA::MethodPDERS*fgThisPDERSthis pointer (required by root finder); Int_tfkNNMaxmax number of events in kNN tree; Int_tfkNNMinmin number of events in kNN tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodPDERS(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor for the PDERS method. MethodPDERS(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); construct MethodPDERS through from file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); PDERS can handle classification with 2 classes and regression with one or more regression-targets. void Init( void ); default initialisation routine called by all constructors. ~MethodPDERS( void ); destructor. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; VolumeRangeMode <string> Method to determine volume range; available values are: MinMax; Unscaled; RMS; kNN; Adaptive <default>. KernelEstimator <string> Kernel estimation function; available values are: Box <default>; Sphere; Teepee; Gauss; Sinc3; Sinc5; Sinc7; Sinc9; Sinc11; Lanczos2; Lanczos3; Lanczos5; Lanczos8; Trim. DeltaFrac <float> Ratio of #EventsMin/#EventsMax for MinMax and RMS volume range; NEventsMin <int> Minimum number of events for adaptive volume range; NEventsMax <int> Maximum number of events for adaptive volume range; MaxVIterations <int> Maximum number of iterations for adaptive volume range; InitialScale <float> Initial scale for adaptive volume range; GaussSigma <float> Width with respect to the volume size of Gaussian kernel estimator. void ProcessOptions(); process the options ",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Modifiability,variab,variables,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); static TMVA::MethodPDERS*ThisPDERS(); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTO",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Security,access,accessors," Double_t ApplyKernelFunction(Double_t normalized_distance); from the normalized euclidean distance calculate the distance; for a certain kernel. Double_t KernelNormalization(Double_t pdf); Calculating the normalization factor only once (might need a reset at some point.; Can the method be restarted with different params?). Double_t GetNormalizedDistance(const TMVA::Event& base_event, const TMVA::BinarySearchTreeNode& sample_event, Double_t* dim_normalization); We use Euclidian metric here. Might not be best or most efficient. Double_t NormSinc(Double_t x); NormSinc. Double_t LanczosFilter(Int_t level, Double_t x); Lanczos Filter. Float_t GetError(Float_t countS, Float_t countB, Float_t sumW2S, Float_t sumW2B) const; statistical error estimate for RS estimator. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode). void ReadWeightsFromStream(istream& istr); read weight info from file. void WriteWeightsToStream(TFile& rf) const; write training sample (TTree) to file. void ReadWeightsFromStream(TFile& istr); read training sample from file. TMVA::MethodPDERS* ThisPDERS( void ); static pointer to this object. void UpdateThis( void ); update static this pointer. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". BinarySearchTree* GetBinaryTree( void ); accessors. { return fBinaryTree; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Yair Mahalalel, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodPDERS.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Testability,test,test,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Usability,simpl,simple,". TMVA::MethodPDERS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodPDERS. class TMVA::MethodPDERS: public TMVA::MethodBase. /*; This is a generalization of the above Likelihood methods to Nvar; dimensions, where Nvar is the number of input variables; used in the MVA. If the multi-dimensional probability density functions; (PDFs) for signal and background were known, this method contains the entire; physical information, and is therefore optimal. Usually, kernel estimation; methods are used to approximate the PDFs using the events from the; training sample. ; A very simple probability density estimator (PDE) has been suggested; in hep-ex/0211019. The; PDE for a given test event is obtained from counting the (normalized); number of signal and background (training) events that occur in the; ""vicinity"" of the test event. The volume that describes ""vicinity"" is; user-defined. A search; method based on binary-trees is used to effectively reduce the; selection time for the range search. Three different volume definitions; are optional: . MinMax:; the volume is defined in each dimension with respect; to the full variable range found in the training sample. ; RMS:; the volume is defined in each dimensions with respect; to the RMS estimated from the training sample. ; Adaptive:; a volume element is defined in each dimensions with; respect to the RMS estimated from the training sample. The overall; scale of the volume element is then determined for each event so; that the total number of events confined in the volume be within; a user-defined range. The adaptive range search is used by default.; . Function Members (Methods); public:. virtual~MethodPDERS(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::",MatchSource.WIKI,root/html528/TMVA__MethodPDERS.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodPDERS.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Deployability,install,installed,"it threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper ",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Energy Efficiency,monitor,monitor,,MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Integrability,interface,interface,"ble_tfGDValidEveFracGD path: fraction of subsamples used for the fitting; Double_tfLinQuantilequantile cut to remove outliers - see RuleEnsemble; Double_tfMaxFracNEveditto max; Double_tfMinFracNEvemin fraction of number events; Double_tfMinimprule/linear: minimum importance; TStringfModelTypeSrule ensemble: which model (rule,linear or both); TTree*fMonitorNtuplepointer to monitor rule ntuple; Int_tfNCutsgrid used in cut applied in node splitting; Double_tfNTCoefficientntuple: rule coefficient; Double_tfNTImportancentuple: rule importance; Int_tfNTNcutsntuple: rule number of cuts; Int_tfNTNvarsntuple: rule number of vars; Double_tfNTPbbntuple: rule P(tag b, true b); Double_tfNTPbsntuple: rule P(tag b, true s); Double_tfNTPsbntuple: rule P(tag s, true b); Double_tfNTPssntuple: rule P(tag s, true s); Double_tfNTPtagntuple: rule P(tag); Double_tfNTSSBntuple: rule S/(S+B); Double_tfNTSupportntuple: rule support; Int_tfNTTypentuple: rule type (+1->signal, -1->bkg); Int_tfNTreesnumber of trees in forest; TMVA::DecisionTree::EPruneMethodfPruneMethodforest generation: method used for pruning - see DecisionTree ; TStringfPruneMethodSforest generation: prune method - see DecisionTree; Double_tfPruneStrengthforest generation: prune strength - see DecisionTree; Int_tfRFNendnodesmax number of rules (only Friedmans module); Int_tfRFNrulesmax number of rules (only Friedmans module); TStringfRFWorkDirworking directory from Friedmans module; TMVA::RuleFitfRuleFitRuleFit instance; TStringfRuleFitModuleSwhich rulefit module to use; Double_tfRuleMinDistrule min distance - see RuleEnsemble; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSforest generation: separation type - see DecisionTree; Double_tfSignalFractionscalefactor for bkg events to modify initial s/b fraction in training data; Double_tfTreeEveFracfraction of events used for traing each tree; Bool_tfUseBoostuse boosted events for forest generation; Bool_tfUseRuleFitJFif true interface with J.",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Modifiability,variab,variables,"ile(). private:. virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. vector<TMVA::Event*>fEventSamplethe complete training sample; vector<TMVA::DecisionTree*,allocator<TMVA::DecisionTree*> >fForestthe forest; TStringfForestTypeSforest generation: how the trees are generated; Double_tfGDErrScaleGD path: stop ; Int_tfGDNPathStepsGD path: number of steps; Double_tfGDPathEveFracGD path: fraction of subsamples used for the fitting; Double_tfGDPathStepGD path: step size in path; Double_tfGDTauGD path: def threshhold fraction [0..1]; Double_tfGDTauMaxGD path: max threshhold fraction [0..1]; Double_tfGDTauMinGD path: min threshhold fraction [0..1]; Double_tfGDTau",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(c",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Security,access,accessors,"FRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXMLTo(void* parent) const; add the rules to XML node. void ReadWeightsFromStream(istream& istr); read rules from an istream. void ReadWeightsFromXML(void* wghtnode); read rules from XML node. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. void WriteMonitoringHistosToFile( void ); write special monitoring histograms to file (here ntuple). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void MakeClassRuleCuts(ostream& ) const; print out the rule cuts. void MakeClassLinear(ostream& ) const; print out the linear terms. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". Bool_t UseBoost() const; { return fUseBoost; }. RuleFit* GetRuleFitPtr(); accessors. { return &fRuleFit; }. const RuleFit* GetRuleFitConstPtr() const; { return &fRuleFit; }. TDirectory* GetMethodBaseDir() const; { return BaseDir(); }. const std::vector<TMVA::Event*>& GetTrainingEvents() const; { return fEventSample; }. const std::vector<TMVA::DecisionTree*>& GetForest() const; { return fForest; }. Int_t GetNTrees() const; { return fNTrees; }. Double_t GetTreeEveFrac() const; { return fTreeEveFrac; }. const SeparationBase* GetSeparationBaseConst() const; { return fSepType; }. SeparationBase* GetSeparationBase() const; { return fSepType; }. TMVA::DecisionTree::EPruneMethod GetPruneMethod() const; { return fPruneMethod; }. Double_t GetPruneStrength() const; { return fPruneStrength; }. Double_t GetMinFracNEve() const; { return fMinFracNEve; }. Double_t GetMaxFracNEve() const; { return fMaxFracNEve; }. Int_t GetNCuts() const. { return fNCuts; }. Int_t GetGDNPathSteps() const; { return fGDNPathSteps; }. Double_t GetGDPathStep() const; { return fGDPathStep;",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); Bool_tUseBoost() const; virtual voidTObject::UseCurrentS",MatchSource.WIKI,root/html528/TMVA__MethodRuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html
Availability,error,error,"t::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Deployability,configurat,configuration,"nel name; Float_tfThetafor Sigmoidal Kernel; Float_tfTolerancetolerance parameter; TMVA::SVWorkingSet*fWgSetsvm working set . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(). void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodSVM.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-02 14:53; This page has been automatically generated. For comments or suggestions rega",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Integrability,message,message,"r; TMVA::SVWorkingSet*fWgSetsvm working set . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(). void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodSVM.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-12-02 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Modifiability,variab,variables,"bilityOptions(); virtual voidDeclareOptions(); virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. Float_tfBparmfree plane coefficient ; Float_tfCostcost value; Float_tfDoubleSigmaSquaredfor RBF Kernel; Float_tfGammaRBF Kernel parameter; vector<TMVA::SVEvent*>*fInputDatavector of training data in SVM format; Float_tfKappafor Sigmoidal Kernel; UInt_tfMaxItermax number of iteration; TVectorD*fMaxVarsfor normalization //is it still needed?? ; TVectorD*fMinVarsfor normalization //is it still needed?? ; UShort_tfNSubSetsnr of subsets, default 1; Int_tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel function; vector<TMVA::SVEvent*>*fSupportVec",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Performance,tune,tuneParameters,"A::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Testability,test,testTime,"nstMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTMVA::MethodBase::SetAnalysisType(TMVA::Types::EAnalysisType type); voidTMVA::MethodBase::SetBaseDir(TDirectory* methodDir); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObj",MatchSource.WIKI,root/html528/TMVA__MethodSVM.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html
Availability,error,error,"t::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Integrability,interface,interface,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticla",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Modifiability,variab,variables,"tual voidDeclareOptions(); virtual voidInit(); virtual voidProcessOptions(). Data Members; public:. enum TMVA::MethodBase::EWeightFileType { kROOT; kTEXT; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Bool_tTMVA::MethodBase::fSetupCompletedis method setup; const TMVA::Event*TMVA::MethodBase::fTmpEvent! temporary event when testing on a different DataSet than the own one. protected:. TMVA::Types::EAnalysisTypeTMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TStrin",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Performance,tune,tuneParameters,"r); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTMVA::Configurable::SetConfigDescription(const char* d); voidTMVA::Configurable::SetConfigName(const char* n); virtual voidTMVA::MethodBase::SetCurrentEvent(Long64_t ievt) const; virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetHiddenLayer(TString hiddenlayer = """"); voidTMVA::MethodBase::SetMethodBaseDir(TDirectory* methodDir); voidTMVA::MethodBase::SetMethodDir(TDirectory* methodDir); voidTMVA::Configurable::SetMsgType(TMVA::EMsgType t); static voidTObject::SetObjectStat(Bool_t stat); voidTMVA::Configurable::SetOptions(const TString& s); voidTMVA::MethodBase::SetSignalReferenceCut(Double_t cut); voidTMVA::MethodBase::SetTestTime(Double_t testTime); voidTMVA::MethodBase::SetTestvarName(const TString& v = """"); voidTMVA::MethodBase::SetTrainTime(Double_t trainTime); virtual voidTMVA::MethodBase::SetTuneParameters(map<TString,Double_t> tuneParameters); virtual voidTObject::SetUniqueID(UInt_t uid); voidTMVA::MethodBase::SetupMethod(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTMVA::MethodBase::TestClassification(); virtual voidTMVA::MethodBase::TestMulticlass(); virtual voidTMVA::MethodBase::TestRegression(Double_t& bias, Double_t& biasT, Double_t& dev, Double_t& devT, Double_t& rms, Double_t& rmsT, Double_t& mInf, Double_t& mInfT, Double_t& corr, TMVA::Types::ETreeType type); virtual voidTrain(); voidTMVA::MethodBase::TrainMethod(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Security,validat,validation,"TMVA::MethodBase::fAnalysisTypemethod-mode : true --> regression, false --> classification; UInt_tTMVA::MethodBase::fBackgroundClassindex of the Background-class; vector<TString>*TMVA::MethodBase::fInputVarsvector of input variables used in MVA; vector<Float_t>*TMVA::MethodBase::fMulticlassReturnValholds the return-values for the multiclass classification; Int_tTMVA::MethodBase::fNbinsnumber of bins in representative histograms; Int_tTMVA::MethodBase::fNbinsHnumber of bins in evaluation histograms; TMVA::Ranking*TMVA::MethodBase::fRankingpointer to ranking object (created by derived classifiers); vector<Float_t>*TMVA::MethodBase::fRegressionReturnValholds the return-values for the regression; UInt_tTMVA::MethodBase::fSignalClassindex of the Signal-class. private:. TStringfHiddenLayerstring containig the hidden layer structure; TStringfLayerSpecLayer specification option; TStringfLearningMethodthe learning method (given via option string); TTree*fLocalTrainingTreelocal copy of training tree; TMultiLayerPerceptron*fMLPthe TMLP; TStringfMLPBuildOptionsoption string to build the mlp; Int_tfNcyclesnumber of training cylcles; Double_tfValidationFractionfraction of events in training tree used for cross validation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0); standard constructor. MethodTMlpANN(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMlpANN can handle classification with 2 classes. void Init( void ); default initialisations. ~MethodTMlpANN( void ); destructor. void CreateMLPOptions(TString ); translates options from option string into TMlpANN language. void DeclareOptions(); define t",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Testability,test,testing,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticla",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Usability,learn,learning,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticla",MatchSource.WIKI,root/html528/TMVA__MethodTMlpANN.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html
Availability,avail,available,". TMVA::MinuitFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MinuitFitter. class TMVA::MinuitFitter: public TMVA::FitterBase, public TMVA::IFitterTarget. Fitter using MINUIT. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MinuitFitter(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& pars); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root/html528/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html
Integrability,wrap,wrapper,"x) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). » Author: Andreas Hoecker » Copyright (c) 2005: *; ",MatchSource.WIKI,root/html528/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html
Performance,perform,performs,Base::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). » Author: Andreas Hoecker » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MinuitFitter.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html528/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html
Testability,log,logger,"x) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; TMVA::MinuitWrapper*fMinWrapholds a wrapper around TMinuit; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Bool_tfBatchbatch mode; Int_tfErrorLevelminuit error level; Int_tfFitStrategyminuit strategy level; Int_tfMaxCalls(approximate) maximum number of function calls; Int_tfPrintLevelminuit printout level; Bool_tfPrintWarningsminuit warnings level; Double_tfTolerancetolerance to the function value at the minimum; Bool_tfUseImproveflag for 'IMPROVE' use; Bool_tfUseMinosflag for 'MINOS' use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~MinuitFitter(); destructor. void DeclareOptions(); declare SA options. void Init(); minuit-specific settings. Double_t Run(vector<Double_t>& pars); performs the fit. Double_t EstimatorFunction(vector<Double_t>& pars); performs the fit by calliung Run(pars). » Author: Andreas Hoecker » Copyright (c) 2005: *; ",MatchSource.WIKI,root/html528/TMVA__MinuitFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html
Availability,error,error,"ject*Clone(const char*) const; virtual Int_tTMinuit::Command(const char* command); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*TMinuit::Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTMinuit::DefineParameter(Int_t parNo, const char* name, Double_t initVal, Double_t initErr, Double_t lowerLimit, Double_t upperLimit); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTMinuit::DeleteArrays(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEval(Int_t, Double_t*, Double_t&, Double_t*, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTMinuit::FixParameter(Int_t parNo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); virtual const char*TObject::GetIconName() const; Int_tTMinuit::GetMaxIterations() const; TMethodCall*TMinuit::GetMethodCall() const; virtual const char*TNamed::GetName() const; virtual Int_tTMinuit::GetNumFixedPars() const; virtual Int_tTMinuit::GetNumFreePars() const; virtual Int_tTMinui",MatchSource.WIKI,root/html528/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitWrapper.html
Modifiability,variab,variable,"if a heading should be put out for the next parameter definition; Bool_tTMinuit::fLreportrue if exceptional conditions are put out (default=false); Bool_tTMinuit::fLwarntrue if warning messges are to be put out (default=true); Double_t*TMinuit::fMATUvline[fMaxpar] array used in mnmatu; Double_t*TMinuit::fMIGRflnu[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRgs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRstep[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRvg[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMIGRxxs[fMaxpar] array used in mnmigr; Double_t*TMinuit::fMNOTgcc[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTw[fMaxpar] array used in mnmnot; Double_t*TMinuit::fMNOTxdev[fMaxpar] array used in mnmnot; Int_tTMinuit::fMaxIterationsMaximum number of iterations; Int_tTMinuit::fMaxcpt; Int_tTMinuit::fMaxextMaximum number of external parameters; Int_tTMinuit::fMaxintMaximum number of internal parameters; Int_tTMinuit::fMaxparMaximum number of parameters; Int_tTMinuit::fMaxpar1fMaxpar*(fMaxpar+1); Int_tTMinuit::fMaxpar2fMaxpar*fMaxpar; Int_tTMinuit::fMaxpar5fMaxpar*(fMaxpar+1)/2; TMethodCall*TMinuit::fMethodCallPointer to MethodCall in case of interpreted function; Int_tTMinuit::fNblockNumber of Minuit data blocks; Int_tTMinuit::fNewpag; Int_t*TMinuit::fNexofi[fMaxpar] External parameters number for currently variable parameters; Int_tTMinuit::fNfcnNumber of calls to FCN; Int_tTMinuit::fNfcnfr; Int_tTMinuit::fNfcnlc; Int_tTMinuit::fNfcnmxMaximum number of calls to FCN; Int_tTMinuit::fNfcwar[20]; Int_t*TMinuit::fNiofex[fMaxpar2] Internal parameters number, or zero if not currently variable; Int_tTMinuit::fNpaglnNumber of lines per page; Int_tTMinuit::fNpagwdPage width; Int_tTMinuit::fNparNumber of free parameters (total number of pars = fNpar + fNfix); Int_tTMinuit::fNpfixNumber of fixed parameters; Int_tTMinuit::fNstkrd; Int_tTMinuit::fNstkwr; Int_tTMinuit::fNu; Int_t*TMinuit::fNvarl[fMaxpar2] parameters flag (-1=undefined, 0=constant.",MatchSource.WIKI,root/html528/TMVA__MinuitWrapper.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MinuitWrapper.html
Availability,error,error," file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MisClassificationError. class TMVA::MisClassificationError: public TMVA::SeparationBase. Implementation of the MisClassificationError as separation criterion. Function Members (Methods); public:. virtual~MisClassificationError(); static TClass*Class(); const TString&TMVA::SeparationBase::GetName(); Double_tTMVA::SeparationBase::GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::MisClassificationErrorMisClassificationError(); TMVA::MisClassificationErrorMisClassificationError(const TMVA::MisClassificationError& g); TMVA::MisClassificationError&operator=(const TMVA::MisClassificationError&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringTMVA::SeparationBase::fNamename of the concrete Separation Index impementation; Double_tTMVA::SeparationBase::fPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Misclassifiacton error criterion: 1-max(p, 1-p) (p: purity= s/(s+b)). MisClassificationError(); consturctor for the Misclassification error. { fName = ""MisCl""; }. MisClassificationError(const TMVA::MisClassificationError& g); copy constructor. {}. virtual ~MisClassificationError(); destructor. {}. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MisClassificationError.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MisClassificationError.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MisClassificationError.html
Availability,error,error,"; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate excpt); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ios_base::fmtflagsios_base::flags() const; ios_base::fmtflagsios_base::flags(ios_base::fmtflags fmtfl); basic_ostream<char,char_traits<char> >::__ostream_type&basic_ostream<char,char_traits<char> >::flush(); ostream&basic_ostream<char,char_traits<char> >::form(char* format); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorO",MatchSource.WIKI,root/html528/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html
Integrability,message,message,"gfgPrefixthe prefix of the source name; static const stringfgSuffixsuffix following source name; static map<EMsgType,std::string>*fgTypeMapmatches output types with strings. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void InhibitOutput(); { fgInhibitOutput = kTRUE; }. void EnableOutput(). { fgInhibitOutput = kFALSE; }. MsgLogger(const TObject* source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger(const string& source, TMVA::EMsgType minType = kINFO); constructor. MsgLogger( EMsgType minType ); constructor. MsgLogger( const MsgLogger& parent ); copy constructor. ~MsgLogger(); destructor. TMVA::MsgLogger& operator=(const TMVA::MsgLogger& parent); assingment operator. std::string GetFormattedSource() const; make sure the source name is no longer than fgMaxSourceSize:. std::string GetPrintedSource() const; the full logger prefix. void Send(); activates the logger writer. void WriteMsg(TMVA::EMsgType type, const string& line) const; putting the output string, the message type, and the color; switcher together into a single string. TMVA::MsgLogger& Endmsg(TMVA::MsgLogger& logger); end line. void InitMaps(); Create the message type and color maps. void SetSource(const string& source); Accessors. { fStrSource = source; }. EMsgType GetMinType() const; { return fMinType; }. void SetMinType(TMVA::EMsgType minType); { fMinType = minType; }. std::string GetSource() const; { return fStrSource; }. UInt_t GetMaxSourceSize(); { return (UInt_t)fgMaxSourceSize; }. MsgLogger& operator<<( MsgLogger& ( *_f )( MsgLogger& ) ); Accept stream modifiers. MsgLogger& operator<<( std::ostream& ( *_f )( std::ostream& ) ). » Author: Attila Krasznahorkay » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MsgLogger.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html
Testability,log,logger,"n = """"); boolbasic_ios<char,char_traits<char> >::bad() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate state = goodbit); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate excpt); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); boolbasic_ios<char,char_traits<char> >::fail() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill() const; basic_ios<char,char_traits<char> >::char_typebasic_ios<char,char_traits<char> >::fill(basic_ios<char,char_traits<char> >::char_type ch); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) c",MatchSource.WIKI,root/html528/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html
Usability,clear,clear," virtual~MsgLogger(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); boolbasic_ios<char,char_traits<char> >::bad() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidbasic_ios<char,char_traits<char> >::clear(ios_base::iostate state = goodbit); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; basic_ios<char,char_traits<char> >&basic_ios<char,char_traits<char> >::copyfmt(const basic_ios<char,char_traits<char> >& rhs); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEnableOutput(); static TMVA::MsgLogger&Endmsg(TMVA::MsgLogger& logger); boolbasic_ios<char,char_traits<char> >::eof() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; ios_base::iostatebasic_ios<char,char_traits<char> >::exceptions() const; voidbasic_ios<char,char_traits<char> >::exceptions(ios_base::iostate excpt); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject:",MatchSource.WIKI,root/html528/TMVA__MsgLogger.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__MsgLogger.html
Availability,avail,available,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual voidSetRight(TMVA::Node* r); virtual voidShowMembers(TMemberInsp",MatchSource.WIKI,root/html528/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Node.html
Modifiability,variab,variable,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual voidSetRight(TMVA::Node* r); virtual voidShowMembers(TMemberInsp",MatchSource.WIKI,root/html528/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Node.html
Testability,test,test,"fDepthdepth of the node within the tree (seen from root node); TMVA::Node*fLeftpointers to the two ""daughter"" nodes; TMVA::Node*fParentthe previous (parent) node; TMVA::BinaryTree*fParentTreepointer to the parent tree to which the Node belongs ; charfPosposition, i.e. it is a left (l) or right (r) daughter ; TMVA::Node*fRightpointers to the two ""daughter"" nodes. private:. static Int_tfgCountcounter of all nodes present.. for debug.. to spot memory leaks... Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~Node(); node destructor. int GetCount(); retuns the global number of instantiated nodes. Int_t CountMeAndAllDaughters() const; recursively go through the part of the tree below this node and count all daughters. void* AddXMLTo(void* parent) const; add attributes to XML. void ReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); read attributes from XML. Node* CreateNode() const. Bool_t GoesRight(const TMVA::Event& ) const; test event if i{ decends the tree at this node to the right. Bool_t GoesLeft(const TMVA::Event& ) const; test event if it decends the tree at this node to the left. Node* GetLeft() const; test event if it is equal to the event that ""makes the node"" (just for the ""search tree""; return pointer to the left/right daughter or parent node. { return fLeft; }. Node* GetRight() const; { return fRight; }. Node* GetParent() const; { return fParent; }. void SetLeft(TMVA::Node* l); set pointer to the left/right daughter or parent node. { fLeft = l;}. void SetRight(TMVA::Node* r); { fRight = r;}. void SetParent(TMVA::Node* p); { fParent = p;}. void Print(ostream& os) const; printout of the node. void PrintRec(ostream& os) const; recursive printout of the node and it daughters. void AddAttributesToNode(void* node) const. void AddContentToNode(stringstream& s) const. void SetDepth(UInt_t d); Set depth, layer of the where the node is within the tree, seen from the top (root). {fDepth=d;}. UInt_t GetDepth() co",MatchSource.WIKI,root/html528/TMVA__Node.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Node.html
Availability,reliab,reliably,"ring optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAt(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Fri Dec 10 17:05:10 2010 » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html
Integrability,interface,interface,"tionFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAt(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. OptimizeConfigParameters(TMV",MatchSource.WIKI,root/html528/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html
Performance,optimiz,optimize,". TMVA::OptimizeConfigParameters. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::OptimizeConfigParameters. class TMVA::OptimizeConfigParameters: public TMVA::IFitterTarget. Function Members (Methods); public:. virtual~OptimizeConfigParameters(); static TClass*Class(); virtual TClass*IsA() const; TMVA::IFitterTarget&TMVA::IFitterTarget::operator=(const TMVA::IFitterTarget&); map<TString,Double_t>optimize(); TMVA::OptimizeConfigParametersOptimizeConfigParameters(const TMVA::OptimizeConfigParameters&); TMVA::OptimizeConfigParametersOptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); Double_tGetSeparation(); Double_tGetSigEffAt(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for s",MatchSource.WIKI,root/html528/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html
Testability,log,logger,"nst method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); virtual voidTMVA::IFitterTarget::ProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. virtual Double_tEstimatorFunction(vector<Double_t>&); Double_tGetFOM(); TMVA::MethodBase*GetMethod(); voidGetMVADists(); Double_tGetROCIntegral(); Double_tGetSeparation(); Double_tGetSigEffAt(Double_t bkgEff = 0.1); TMVA::MsgLogger&Log() const; voidoptimizeFit(); voidoptimizeScan(). Data Members; private:. map<std::vector<Double_t>,Double_t>fAlreadyTrainedParCombinationsave parameters for which the FOM is already known (GA seems to evaluate the same parameters several times); TStringfFOMTypethe FOM type (Separation, ROC integra.. whaeter you implemented..; vector<Float_t>fFOMvsItergraph showing the develompment of the Figure Of Merit values during the fit; TMVA::MsgLogger*fLoggermessage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<T",MatchSource.WIKI,root/html528/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html
Usability,simpl,simple," be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete p",MatchSource.WIKI,root/html528/TMVA__OptimizeConfigParameters.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html
Availability,error,error,"voidTObject::Browse(TBrowser* b); voidCalcCellDiscr(); voidCalcCellTarget(); voidCheckAll(Int_t); voidCheckCells(Bool_t remove_empty_cells = false); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(const char* opt, Int_t nbin); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev, Bool_t NoNegWeights = kFALSE); voidFillFoamCells(const TMVA::Event* ev, Bool_t NoNegWeights = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAverageNeighborsValue(vector<Float_t>& txvec, TMVA::ECellValue cv); Double_tGetCellDensity(vector<Float_t>& xvec, TMVA::EKernel kernel = kNone); Double_tGetCellDiscr(vector<Float_t>& xvec, TMVA::EKernel kernel = kNone); Double_tGetCellRegValue0(vector<Float_t>&, TMVA::EKernel kernel = kNone); Double_tGetCellValue(vector<Float_t>&, TMVA::ECellValue); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetFillFoamWithOrigWeights() const;",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Deployability,integrat,integration,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an; extension of the PDERS method, which uses self-adapting binning to; divide the multi-dimensional phase space in a finite number of; hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package PDEFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); voidAddXMLTo(void* parent); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcCellDiscr(); voidCalcCellTarget(); voidCheckAll(Int_t); voidCheckCells(Bool_t remove_empty_cells = false); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(const char* opt, Int_t nbin); virtual voidTObject::DrawClass() constMENU ; virtua",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Energy Efficiency,adapt,adapting,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an; extension of the PDERS method, which uses self-adapting binning to; divide the multi-dimensional phase space in a finite number of; hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package PDEFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); voidAddXMLTo(void* parent); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcCellDiscr(); voidCalcCellTarget(); voidCheckAll(Int_t); voidCheckCells(Bool_t remove_empty_cells = false); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(const char* opt, Int_t nbin); virtual voidTObject::DrawClass() constMENU ; virtua",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Integrability,integrat,integration,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an; extension of the PDERS method, which uses self-adapting binning to; divide the multi-dimensional phase space in a finite number of; hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package PDEFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); voidAddXMLTo(void* parent); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcCellDiscr(); voidCalcCellTarget(); voidCheckAll(Int_t); voidCheckCells(Bool_t remove_empty_cells = false); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(const char* opt, Int_t nbin); virtual voidTObject::DrawClass() constMENU ; virtua",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Modifiability,adapt,adapting,". TMVA::PDEFoam. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoam. class TMVA::PDEFoam: public TObject. Implementation of PDEFoam. The PDEFoam method is an; extension of the PDERS method, which uses self-adapting binning to; divide the multi-dimensional phase space in a finite number of; hyper-rectangles (boxes). For a given number of boxes, the binning algorithm adjusts the size; and position of the boxes inside the multidimensional phase space,; minimizing the variance of the signal and background densities inside; the boxes. The binned density information is stored in binary trees,; allowing for a very fast and memory-efficient classification of; events. The implementation of the PDEFoam is based on the monte-carlo; integration package PDEFoam included in the analysis package ROOT. Function Members (Methods); public:. virtual~PDEFoam(); voidTObject::AbstractMethod(const char* method) const; voidAddVariableName(const char* s); voidAddVariableName(TObjString* s); voidAddXMLTo(void* parent); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcCellDiscr(); voidCalcCellTarget(); voidCheckAll(Int_t); voidCheckCells(Bool_t remove_empty_cells = false); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidCreate(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*Draw1Dim(const char* opt, Int_t nbin); virtual voidTObject::DrawClass() constMENU ; virtua",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Performance,load,load,"opt, Bool_t CreateCanvas = kTRUE, Bool_t colors = kTRUE, Bool_t log_colors = kFALSE); Debugging tool which plots the cells of a 2-dimensional PDEFoam; as rectangles in C++ format readable for ROOT. Parameters:; - filename - filename of ouput root macro. - opt - cell_value, rms, rms_ov_mean; If cell_value is set, the following values will be filled into; the result histogram:; - number of events - in case of classification with 2 separate; foams or multi-target regression; - discriminator - in case of classification with one; unified foam; - target - in case of mono-target regression; If none of {cell_value, rms, rms_ov_mean} is given, the cells; will not be filled.; If 'opt' contains the string 'cellnumber', the index of; each cell is draw in addition. - CreateCanvas - whether to create a new canvas or not. - colors - whether to fill cells with colors or shades of grey. - log_colors - whether to fill cells with colors (logarithmic scale). Example:. The following commands load a mono-target regression foam from; file 'foam.root' and create a ROOT macro 'output.C', which; draws all PDEFoam cells with little boxes. The latter are; filled with colors according to the target value stored in the; cell. Also the cell number is drawn. TFile file(""foam.root"");; TMVA::PDEFoam *foam = (TMVA::PDEFoam*) gDirectory->Get(""MonoTargetRegressionFoam"");; foam->RootPlot2dim(""output.C"",""cell_value,cellnumber"");; gROOT->Macro(""output.C"");. void FillBinarySearchTree(const TMVA::Event* ev, Bool_t NoNegWeights = kFALSE); Insert event to internal foam density PDEFoamDistr. void DeleteBinarySearchTree(); Delete the fDistr object, which contains the binary search tree. void Init(); Initialize binary search tree, stored in object of type; PDEFoamDistr. void SetFoamType(TMVA::EFoamType ft); Set the foam type. This determinates the method of the; calculation of the density during the foam build-up. void ReadStream(istream& ); Read PDEFoam variables from stream 'istr'. void PrintStream(ostream& ) ",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Safety,avoid,avoid,"VA::PDEFoamCell* ); Internal subprogram used by Create.; It initializes content of the newly allocated active cell. void Explore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create.; It explores newly defined cell with help of special short MC sampling.; As a result, estimates of kTRUE and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. If fNmin > 0 then the total number of (training) events found in; the cell during the exploration is stored in the cell. This; information is used withing PeekMax() to avoid splitting cells; which contain less than fNmin events. void DTExplore(TMVA::PDEFoamCell* Cell); Internal subprogram used by Create. It explores newly defined; cell with according to the decision tree logic. The separation; set by the 'fDTSeparation' option is used (see also; GetSeparation()). The optimal division point for eventual future cell division is; determined/recorded. Note that links to parents and initial; volume = 1/2 parent has to be already defined prior to calling; this routine. Note, that according to the decision tree logic, a cell is only; split, if the number of (unweighted) events in each dautghter; cell is greater than fNmin. Float_t GetSeparation(Float_t s, Float_t b); Calculate the separation depending on 'fDTSeparation' for the; given number of signal and background events 's', 'b'. Note,; that if (s+b) < 0 or s < 0 or b < 0 than the return value is 0. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Create.; In determines the ",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Testability,log,logic,"ow(Bool_t finished = false); TMVA::PDEFoamPDEFoam(const TMVA::PDEFoam&); Long_tPeekLast(); Long_tPeekMax(); voidSetCellElement(TMVA::PDEFoamCell* cell, UInt_t i, Double_t value); voidVaredu(Double_t*, Int_t&, Double_t&, Double_t&); Float_tWeightGaus(TMVA::PDEFoamCell*, vector<Float_t>&, UInt_t dim = 0); Double_tWeightLinNeighbors(vector<Float_t>& txvec, TMVA::ECellValue cv, Int_t dim1 = -1, Int_t dim2 = -1, Bool_t TreatEmptyCells = kFALSE). private:. TMVA::PDEFoamDistr*GetDistr() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_t*fAlpha[fDim] Internal parameters of the hyperrectangle; TMVA::PDEFoamCell**fCells[fNCells] Array of ALL cells; TMVA::EDTSeparationfDTSeparationsplit cells according to decision tree logic; Int_tfDimDimension of the integration/simulation space; TMVA::PDEFoamDistr*fDistr! distribution of training events; Int_tfEvPerBinMaximum number of effective (wt=1) events per bin; Bool_tfFillFoamWithOrigWeightsfill the foam with boost or orig. weights; TMVA::EFoamTypefFoamTypetype of foam; TObjArray*fHistEdgHistograms of wt, one for each cell edge; Int_t*fInhiDiv! [fDim] Flags for inhibiting cell division; Int_tfLastCeIndex of the last cell; TMVA::MsgLogger*fLogger! message logger; Int_t*fMaskDiv! [fDim] Dynamic Mask for cell division; UInt_tfMaxDepthmaximum depth of cell tree; Int_tfNBinNo. of bins in the edge histogram for cell MC exploration; Int_tfNCellsMaximum number of cells; UInt_tfNElementsnumber of variables in every cell; Int_tfNSamplNo. of MC events, when dividing (exploring) cell; TStringfNameName of a given instance of the FOAM class; UInt_tfNminminimal number of events in cell to split cell; Int_tfNoActNumber of active cells; Bool_tfPeekMaxpeek up cell with max. driver integral for split; TRan",MatchSource.WIKI,root/html528/TMVA__PDEFoam.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoam.html
Availability,error,error," virtual~PDEFoamCell(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcVolume(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Int_t, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*, TMVA::PDEFoamCell*); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBest() const; TMVA::PDEFoamCell*GetDau0() const; TMVA::PDEFoamCell*GetDau1() const; UInt_tGetDepth(); virtual Option_t*TObject::GetDrawOption() const; Double_tGetDriv() const; static Long_tTObject::GetDtorOnly(); TObject*GetElement() const; voidGetHcub(TMVA::P",MatchSource.WIKI,root/html528/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamCell.html
Energy Efficiency,allocate,allocated,"bject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfBestBest Edge for division; TReffDaught0Pointer to daughter 1; TReffDaught1Pointer to daughter 2; Short_tfDimDimension of the vector space; Double_tfDriveDriver integral, only for cell build-up; TObject*fElementmay set by the user to save some data in this cell; Double_tfIntegralIntegral over cell (estimate from exploration); TReffParentPointer to parent cell; Int_tfSerialSerial number; Int_tfStatusStatus (active, inactive); Double_tfVolumeCartesian Volume of cell; Double_tfXdivFactor for division. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamCell(); Default constructor for streamer. PDEFoamCell(Int_t ); User constructor allocating single empty Cell. PDEFoamCell(const TMVA::PDEFoamCell& ); Copy constructor. ~PDEFoamCell(); Destructor. void Fill(Int_t , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* , TMVA::PDEFoamCell* ); Fills in certain data into newly allocated cell. void GetHcub(TMVA::PDEFoamVect& , TMVA::PDEFoamVect& ) const; Provides size and position of the cell; These parameter are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return ",MatchSource.WIKI,root/html528/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamCell.html
Modifiability,variab,variable,"d by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void GetHSize(TMVA::PDEFoamVect& ) const; Provides size of the cell; Size parameters are calculated by analyzing information in all parents; cells up to the root cell. It takes time but saves memory. void CalcVolume(void); Calculates volume of the cell using size params which are calculated. UInt_t GetDepth(); Get depth of cell in binary tree, where the root cell has depth; 1. void Print(Option_t* option) const; Printout of the cell geometry parameters for the debug purpose. Double_t GetXdiv() const; Geometry. { return fXdiv;}. Int_t GetBest() const; { return fBest;}. void SetBest(Int_t Best); { fBest =Best;}. void SetXdiv(Double_t Xdiv); { fXdiv =Xdiv;}. Double_t GetVolume() const; { return fVolume;}. Double_t GetIntg() const; { return fIntegral;}. Double_t GetDriv() const; { return fDrive;}. void SetIntg(Double_t Intg); { fIntegral=Intg;}. void SetDriv(Double_t Driv); linked tree organization. { fDrive =Driv;}. Int_t GetStat() const; { return fStatus;}. void SetStat(Int_t Stat); { fStatus=Stat;}. PDEFoamCell* GetPare() const; { return (PDEFoamCell*) fParent.GetObject(); }. PDEFoamCell* GetDau0() const; { return (PDEFoamCell*) fDaught0.GetObject(); }. PDEFoamCell* GetDau1() const; { return (PDEFoamCell*) fDaught1.GetObject(); }. void SetDau0(TMVA::PDEFoamCell* Daug); { fDaught0 = Daug;}. void SetDau1(TMVA::PDEFoamCell* Daug); { fDaught1 = Daug;}. void SetPare(TMVA::PDEFoamCell* Pare); { fParent = Pare;}. void SetSerial(Int_t Serial); { fSerial=Serial;}. Int_t GetSerial() const; { return fSerial;}. void SetElement(TObject* fobj); getter and setter for user variable. { fElement = fobj; }. TObject* GetElement() const. { return fElement; }. » Last changed: Fri Nov 26 14:27:18 2010 » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__PDEFoamCell.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamCell.html
Availability,error,error," virtual~PDEFoamDistr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDensity(Double_t* Xarg, Double_t& event_density); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBinarySearchTree(const TMVA::Event* ev, TMVA::EFoamType ft, Bool_t NoNegWeights = kFALSE); Bool_tFillDiscriminator(); Bool_tFillEventDensity(); voidFillHist(TMVA::PDEFoamCell* cell, vector<TH1F*>&, vector<TH1F*>&, vector<TH1F*>&, vector<TH1F*>&); Bool_tFillTarget0(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject:",MatchSource.WIKI,root/html528/TMVA__PDEFoamDistr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamDistr.html
Integrability,message,message,"p); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*fLogger! message logger. private:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::TDensityCalcfDensityCalcmethod of density calculation; const TMVA::PDEFoam*fPDEFoamPDEFoam to refer to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDistr(); {}. ~PDEFoamDistr(). PDEFoamDistr(const TMVA::PDEFoamDistr& ); Copy constructor. void Initialize(); Initialisation of binary search tree.; Set dimension and create new BinarySearchTree. void FillBinarySearchTree(const TMVA::Event* ev, TMVA::EFoamType ft, Bool_t NoNegWeights = kFALSE); This method creates an TMVA::Event and inserts it into the; binary search tree. If 'NoNegWeights' is true, an event with negative weight will; not be filled into the foam. (Default value: false). Double_t Density(Double_t* Xarg, Double_t& event_density); This function is needed during the foam buildup.; It return a certain density depending on the selected classification; or regression option",MatchSource.WIKI,root/html528/TMVA__PDEFoamDistr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamDistr.html
Testability,log,logger,"p); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TMVA::MsgLogger&Log() const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::MsgLogger*fLogger! message logger. private:. TMVA::BinarySearchTree*fBstBinary tree to find events within a volume; TMVA::TDensityCalcfDensityCalcmethod of density calculation; const TMVA::PDEFoam*fPDEFoamPDEFoam to refer to. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamDistr(); {}. ~PDEFoamDistr(). PDEFoamDistr(const TMVA::PDEFoamDistr& ); Copy constructor. void Initialize(); Initialisation of binary search tree.; Set dimension and create new BinarySearchTree. void FillBinarySearchTree(const TMVA::Event* ev, TMVA::EFoamType ft, Bool_t NoNegWeights = kFALSE); This method creates an TMVA::Event and inserts it into the; binary search tree. If 'NoNegWeights' is true, an event with negative weight will; not be filled into the foam. (Default value: false). Double_t Density(Double_t* Xarg, Double_t& event_density); This function is needed during the foam buildup.; It return a certain density depending on the selected classification; or regression option",MatchSource.WIKI,root/html528/TMVA__PDEFoamDistr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamDistr.html
Availability,error,error," virtual~PDEFoamVect(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCoord(Int_t i) const; Int_tGetDim() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::G",MatchSource.WIKI,root/html528/TMVA__PDEFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamVect.html
Security,access,access,"e = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_t*fCoords[fDim] Coordinates; Int_tfDimDimension. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDEFoamVect(); Default constructor for streamer. PDEFoamVect(Int_t ); User constructor creating n-dimensional vector; and allocating dynamically array of components. PDEFoamVect(const TMVA::PDEFoamVect& ); Copy constructor. ~PDEFoamVect(); Destructor. Double_t & operator[](Int_t ); [] is for access to elements as in ordinary matrix like a[j]=b[j]; (Perhaps against some strict rules but rather practical.); Range protection is built in, consequently for substitution; one should use rather use a=b than explicit loop!. TMVA::PDEFoamVect& operator*=(const Double_t& ); unary multiplication operator *=. TMVA::PDEFoamVect& operator+=(const TMVA::PDEFoamVect& ); unary addition operator +=; adding vector c*=x,. TMVA::PDEFoamVect& operator-=(const TMVA::PDEFoamVect& ); unary subtraction operator -=. TMVA::PDEFoamVect operator+(const TMVA::PDEFoamVect& ); addition operator +; sum of 2 vectors: c=a+b, a=a+b,; NEVER USE IT, VERY SLOW!!!. TMVA::PDEFoamVect operator-(const TMVA::PDEFoamVect& ); subtraction operator -; difference of 2 vectors; c=a-b, a=a-b,; NEVER USE IT, VERY SLOW!!!. void Print(Option_t* option) const. Int_t GetDim() const; { return fDim; }. Double_t GetCoord(Int_t i) const; { return fCoords[i]; }. » Last changed: Thu Dec 2 14:53:36 2010 » Last generated: 2010-12-02 14:53; This page has been automatically ",MatchSource.WIKI,root/html528/TMVA__PDEFoamVect.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDEFoamVect.html
Availability,error,error," virtual voidTObject::Browse(TBrowser* b); voidBuildPDF(const TH1* theHist); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetHistNBins(Int_t evtNum = 0); virtual const char*TObject::GetIconName() const; Double_tGetIntegral(Double_t xmin, Double_t xmax); TMVA::PDF::EInterpolateMethodGetInterpolMethod(); virtual const char*GetName() const; Int_tGetNBins() const; TH1*GetNSmoothHist() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA:",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Deployability,integrat,integration,"k; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram; static TMVA::PDF*fgThisPDFthis PDF pointer . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor ",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Energy Efficiency,adapt,adaptive,"k; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram; static TMVA::PDF*fgThisPDFthis PDF pointer . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor ",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Integrability,interface,interface,"k; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram; static TMVA::PDF*fgThisPDFthis PDF pointer . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor ",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Modifiability,adapt,adaptive,"k; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram; static TMVA::PDF*fgThisPDFthis PDF pointer . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor ",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Safety,sanity check,sanity check,"Method method = kSpline2, Int_t minnsmooth = 0, Int_t maxnsmooth = 0, Bool_t checkHist = kFALSE, Bool_t norm = kTRUE); constructor of spline based PDF:. PDF(const TString& name, const TH1* theHist, TMVA::KDEKernel::EKernelType ktype, TMVA::KDEKernel::EKernelIter kiter, TMVA::KDEKernel::EKernelBorder kborder, Float_t FineFactor, Bool_t norm = kTRUE); constructor of kernel based PDF:. PDF(const TString& name, const TString& options, const TString& suffix = """", TMVA::PDF* defaultPDF = 0, Bool_t norm = kTRUE). ~PDF(); destructor. void BuildPDF(const TH1* theHist). Int_t GetHistNBins(Int_t evtNum = 0). void BuildSplinePDF(); build the PDF from the original histograms. void BuildKDEPDF(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void SmoothHistogram(). void FillHistToGraph(); Simple conversion. void FillSplineToHist(); creates high-binned reference histogram to be used instead of the; PDF for speed reasons. void CheckHist() const; sanity check: compare PDF with original histogram. void ValidatePDF(TH1* original = 0) const; comparison of original histogram with reference PDF. Double_t GetIntegral() const; computes normalisation. Double_t IGetVal(Double_t* , Double_t* ); static external auxiliary function (integrand). Double_t GetIntegral(Double_t xmin, Double_t xmax); computes PDF integral within given ranges. Double_t GetVal(Double_t x) const; returns value PDF(x). void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; PDFInterpol[ivar] <string> Spline0, Spline1, Spline2 <default>, Spline3, Spline5, KDE used to interpolate reference histograms; if no variable index is given, it is valid for ALL the variables. NSmooth <int> how often the input histos are smoothed; MinNSmooth <int> min number of smoothing iterations, for bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Security,access,accessors,"or bins with most data; MaxNSmooth <int> max number of smoothing iterations, for bins with least data; NAvEvtPerBin <int> minimum average number of events per PDF bin; TransformOutput <bool> transform (often strongly peaked) likelihood output through sigmoid inversion; fKDEtype <KernelType> type of the Kernel to use (1 is Gaussian); fKDEiter <KerneIter> number of iterations (1 --> ""static KDE"", 2 --> ""adaptive KDE""); fBorderMethod <KernelBorder> the method to take care about ""border"" effects (1=no treatment , 2=kernel renormalization, 3=sample mirroring). void ProcessOptions(). void AddXMLTo(void* parent); XML file writing. void ReadXML(void* pdfnode); XML file reading. TMVA::PDF* ThisPDF( void ); return global ""this"" pointer of PDF. TH1* GetPDFHist() const; histogram underlying the PDF. { return fPDFHist; }. TH1* GetOriginalHist() const; { return fHistOriginal; }. TH1* GetSmoothedHist() const; { return fHist; }. TH1* GetNSmoothHist() const; { return fNSmoothHist; }. TSpline* GetSpline() const; accessors. { return fSpline; }. Int_t GetNBins() const; { return fHist->GetNbinsX(); }. Double_t GetXmin() const; { return fHist->GetXaxis()->GetXmin(); }. Double_t GetXmax() const; { return fHist->GetXaxis()->GetXmax(); }. TMVA::PDF::EInterpolateMethod GetInterpolMethod(); { return fInterpolMethod;}. const char* GetName() const; modified name (remove TMVA::). { return fPDFName; }. void SetReadingVersion(UInt_t rv); TMVA version control (for weight files). { fReadingVersion = rv; }. UInt_t GetReadingVersion() const; { return fReadingVersion; }. Double_t GetPdfHistBinWidth() const. Bool_t UseHistogram() const; do we use the original histogram as reference ?. { return fUseHistogram; }. » Author: Asen Christov, Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: PDF.h 33928 2010-06-15 16:19:31Z stelzer $ » Last generated: 2010-12-13 17:53; This page has been automatically generated. For comments or suggestions regarding the",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Testability,log,logger,"k; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStringfBorderMethodString; Bool_tfCheckHistcheck of source histogram; Float_tfFineFactorfine tuning factor for Adaptive KDE; TGraph*fGraph! needed to create PDF from histogram; TH1*fHistcopy of input histogram; Int_tfHistAvgEvtPerBinavg event per source hist bin; Int_tfHistDefinedNBinssource hist bin num set by user; TH1*fHistOriginalthe input histogram; TF1*fIGetValintegration interface; TMVA::PDF::EInterpolateMethodfInterpolMethodinterpolation method; TStringfInterpolateString; TMVA::KDEKernel::EKernelBorderfKDEborderThe method to take care about ""border"" effects (string); TMVA::KDEKernel::EKernelIterfKDEiterNumber of iterations (adaptive or not); TStringfKDEiterString; TMVA::KDEKernel::EKernelTypefKDEtypeKernel type to use for KDE; TStringfKDEtypeStringstrings used to read definitions; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxNsmoothMax number of smoothing iterations; Int_tfMinNsmoothMin number of smoothing iterations; TH1*fNSmoothHistnumber of smooth for each bin; Bool_tfNormalizenormalize histogram (false for cumulative distribution used in GaussTranform); Int_tfNsmoothMin number of smoothing iterations; TH1*fPDFHistthe high-binned histogram corresponding to the PDF; TStringfPDFNamefor output; UInt_tfReadingVersionthe TMVA version of the weight file; TSpline*fSpline! the used spline type; TStringfSuffix! the suffix for options; Bool_tfUseHistogramspline0 uses histogram as reference; static const Double_tfgEpsilonminimum PDF return; static const Bool_tfgManualIntegrationmanual integration (sum over bins) or DGAUSS; static const Int_tfgNbin_PdfHistnumber of bins in high-binned reference histogram; static TMVA::PDF*fgThisPDFthis PDF pointer . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; PDF(const TString& name, Bool_t norm = kTRUE); default constructor ",MatchSource.WIKI,root/html528/TMVA__PDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__PDF.html
Integrability,message,message,"nks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Ranking.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Ranking.html
Modifiability,variab,variables,". TMVA::Ranking. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Ranking.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send ",MatchSource.WIKI,root/html528/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Ranking.html
Testability,log,logger,"nks:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Ranking. class TMVA::Ranking. Ranking for variables in method (implementation). Function Members (Methods); public:. virtual~Ranking(); virtual voidAddRank(const TMVA::Rank& rank); static TClass*Class(); virtual TClass*IsA() const; TMVA::Ranking&operator=(const TMVA::Ranking&); virtual voidPrint() const; TMVA::RankingRanking(); TMVA::RankingRanking(const TMVA::Ranking&); TMVA::RankingRanking(const TString& context, const TString& rankingDiscriminatorName); voidSetContext(const TString& context); voidSetDiscrName(const TString& discrName); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TMVA::MsgLogger&Log() const. Data Members; private:. TStringfContextthe ranking context; TMVA::MsgLogger*fLogger! message logger; vector<TMVA::Rank>fRankingvector of ranks; TStringfRankingDiscriminatorNamethe name of the ranking discriminator. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Ranking(); default constructor. Ranking(const TString& context, const TString& rankingDiscriminatorName); constructor. ~Ranking(); destructor. void SetContext(const TString& context). void AddRank(const TMVA::Rank& rank); Add a new rank; take ownership of it. void Print() const; get maximum length of variable names. Ranking(). void SetDiscrName(const TString& discrName); { fRankingDiscriminatorName = discrName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Ranking.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Ranking.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Ranking.html
Availability,error,error,"p() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; const vector<Float_t>&EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(TMVA::MethodBase* method, Double_t aux = 0); Double_tEvaluateMVA(const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Float_t>&, const TString& methodTag, Double_t aux = 0); Double_tEvaluateMVA(const vector<Double_t>&, const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(const TString& methodTag, Double_t aux = 0); const vector<Float_t>&EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); Float_tEvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TMVA::MethodCuts*FindCutsMVA(const TString& methodTag); TMVA::IMethod*FindMVA(const TString& methodTag); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetMVAError() const; Double_tGetMVAErrorLower() const; Double_tGetMVAErrorUpper() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const ",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Deployability,configurat,configuration,"::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no member variables). void AddVariable(const TString& expression, Float_t* ); Add a float variable or expression to the reader. void AddVariable(const TString& expression, Int_t* ). void AddSpectator(const TString& expression, Float_t* ); Add a float spectator or expression to the reader. void AddSpectator(const TString& expression, Int_t* ); Add an integer spectator or expression to the reader. TString GetMethodTypeFromFile(const TString& filename); read the method type from the file. TMVA::IMethod* BookMVA(const TString& methodTag, const TString& weightfile); read method name from weight file. TMVA::IMethod* BookMVA(TMVA::Types::EMVA method, const TString& weightfile); books MVA method from weightfile. TMVA::IMethod* BookMVA(TMVA::Types::EMVA methodType, const char* xmlstr). Double_t EvaluateMVA( const std::vector<Float_t>& inputVec, con",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Modifiability,variab,variables,". TMVA::Reader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Reader. class TMVA::Reader: public TMVA::Configurable. The Reader class serves to use the MVAs in a specific analysis context.; Within an event loop, a vector is filled that corresponds to the variables; that were used to train the MVA(s) during the training stage. This vector; is transfered to the Reader, who takes care of interpreting the weight; file of the MVA of choice, and to return the MVA's output. This is then; used by the user for further analysis. Usage:. // ------ before starting the event loop (eg, in the initialisation step). // create TMVA::Reader object. TMVA::Reader *reader = new TMVA::Reader();. // create a set of variables and declare them to the reader; // - the variable names must corresponds in name and type to; // those given in the weight file(s) that you use; Float_t var1, var2, var3, var4;; reader->AddVariable( ""var1"", &var1 );; reader->AddVariable( ""var2"", &var2 );; reader->AddVariable( ""var3"", &var3 );; reader->AddVariable( ""var4"", &var4 );. // book the MVA of your choice (prior training of these methods, ie,; // existence of the weight files is required); reader->BookMVA( ""Fisher method"", ""weights/Fisher.weights.txt"" );; reader->BookMVA( ""MLP method"", ""weights/MLP.weights.txt"" );; // ... etc. // ------- start your event loop. for (Long64_t ievt=0; ievt<myTree->GetEntries();ievt++) {. // fill vector with values of variables computed from those in the tree; var1 = myvar1;; var2 = myvar2;; var3 = myvar3;; var4 = myvar4;. // retrieve the corresponding MVA output; double mvaFi = reader->EvaluateMVA( ""Fisher method"" );; double mvaNN = reader->EvaluateMVA( ""MLP method"" );. // do something with these ...., e.g., fill them into your ntuple. } // end of event loop. delete reader;. An example application of t",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Safety,avoid,avoid,"ase* method, Double_t aux = 0); evaluates the MVA. const std::vector< Float_t >& EvaluateRegression(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateRegression(TMVA::MethodBase* method, Double_t aux = 0); evaluates the regression MVA. Float_t EvaluateRegression(UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0); evaluates the regression MVA. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fData",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Security,access,accessors,"A. const std::vector< Float_t >& EvaluateMulticlass(const TString& methodTag, Double_t aux = 0); evaluates MVA for given set of input variables. const std::vector< Float_t >& EvaluateMulticlass(TMVA::MethodBase* method, Double_t aux = 0); evaluates the multiclass MVA. Float_t EvaluateMulticlass(UInt_t clsNumber, const TString& methodTag, Double_t aux = 0); evaluates the multiclass MVA. TMVA::IMethod* FindMVA(const TString& methodTag); return pointer to method with tag ""methodTag"". TMVA::MethodCuts* FindCutsMVA(const TString& methodTag); special function for Cuts to avoid dynamic_casts in ROOT macros,; which are not properly handled by CINT. Double_t GetProba(const TString& methodTag, Double_t ap_sig = 0.5, Double_t mvaVal = -9999999); evaluates probability of MVA for given set of input variables. Double_t GetRarity(const TString& methodTag, Double_t mvaVal = -9999999); evaluates the MVA's rarity. void DecodeVarNames( const std::string& varNames ); decodes ""name1:name2:..."" form. void DecodeVarNames(const TString& varNames); decodes ""name1:name2:..."" form. Double_t GetMVAError() const; returns error on MVA response for given event; NOTE: must be called AFTER ""EvaluateMVA(...)"" call !. { return fMvaEventError; }. Double_t GetMVAErrorLower() const; { return fMvaEventError; }. Double_t GetMVAErrorUpper() const; { return fMvaEventErrorUpper; }. const char* GetName() const; accessors. { return ""Reader""; }. Bool_t Verbose( void ); { return fVerbose; }. void SetVerbose(Bool_t v); { fVerbose = v; }. const DataSetInfo& DataInfo() const; { return fDataSetInfo; }. DataSetInfo& DataInfo(); { return fDataSetInfo; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Reader.h 36966 2010-11-26 09:50:13Z evt $ » Last generated: 2010-11-26 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Testability,log,logger,"seOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. TMVA::IMethod*BookMVA(TMVA::Types::EMVA method, const TString& weightfile); voidDeclareOptions(); voidDecodeVarNames(const string& varNames); voidDecodeVarNames(const TString& varNames); TStringGetMethodTypeFromFile(const TString& filename); voidInit(); TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfCalculateErrorerror calculation mode; Bool_tfColorcolor mode; TMVA::DataInputHandlerfDataInputHandler; TMVA::DataSetInfofDataSetInfothe data set; TMVA::DataSetManager*fDataSetManagerDSMTEST; TMVA::MsgLogger*fLoggermessage logger; map<TString,IMethod*>fMethodMapmap of methods; Double_tfMvaEventErrorper-event error returned by MVA; Double_tfMvaEventErrorUpperper-event error returned by MVA; Bool_tfSilentsilent mode; vector<Float_t>fTmpEvalVectemporary evaluation vector (if user input is v<double>); Bool_tfVerboseverbosity. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Reader(const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader(vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0); constructor. Reader( const std::string& varNames, const TString& theOption, Bool_t verbose ); constructor. Reader(const TString& varNames, const TString& theOption, Bool_t verbose = 0); constructor. void DeclareOptions(); declaration of configuration options. ~Reader( void ); destructor. void Init( void ); default initialisation (no member variables); default initialisation (no",MatchSource.WIKI,root/html528/TMVA__Reader.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Reader.html
Performance,optimiz,optimized,"ual TClass*IsA() const; TMVA::RegressionVariance&operator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RegressionVariance.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or R",MatchSource.WIKI,root/html528/TMVA__RegressionVariance.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RegressionVariance.html
Usability,simpl,simple,"rator=(const TMVA::RegressionVariance&); TMVA::RegressionVarianceRegressionVariance(); TMVA::RegressionVarianceRegressionVariance(const TMVA::RegressionVariance& s); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nLeft, const Double_t& targetLeft, const Double_t& target2Left, const Double_t& nTot, const Double_t& targetTot, const Double_t& target2Tot); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system; for the Regression: as the ""Gain is maximised"", the RMS (sqrt(variance)); which is used as a ""separation"" index should be as small as possible.; the ""figure of merit"" here has to be -(rms left+rms-right) or 1/rms... Double_t GetSeparationIndex(const Double_t& n, const Double_t& target, const Double_t& target2); Separation Index: a simple Variance. RegressionVariance(); default constructor. {fName = ""Variance for Regression"";}. RegressionVariance(const TMVA::RegressionVariance& s); copy constructor. {}. virtual ~RegressionVariance(); destructor. {}. TString GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RegressionVariance.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__RegressionVariance.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RegressionVariance.html
Availability,error,error," virtual~RootFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() c",MatchSource.WIKI,root/html528/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RootFinder.html
Integrability,message,message,"rror(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RootFinder.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RootFinder.html
Testability,log,logger,"rror(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: RootFinder.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__RootFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RootFinder.html
Integrability,message,message,"Eventsall training events; vector<TMVA::Event*>fTrainingEventsRndmidem, but randomly shuffled; Bool_tfVisHistsUseImpif true, use importance as weight; else coef in vis hists; static const Int_trandSEEDset to 1 for debugging purposes or to zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFit( const MethodBase *rfbase ); constructor. RuleFit(); default constructor. ~RuleFit(); destructor. void InitNEveEff(); init effective number of events (using event weights). void InitPtrs(const TMVA::MethodBase* rfbase); initialize pointers. void Initialize(const TMVA::MethodBase* rfbase); initialize the parameters of the RuleFit method and make rules. void SetMethodBase(const TMVA::MethodBase* rfbase); set MethodBase. void Copy(const TMVA::RuleFit& other); copy method. Double_t CalcWeightSum(const vector<TMVA::Event*>* events, UInt_t neve = 0); calculate the sum of weights. void SetMsgType(TMVA::EMsgType t); set the current message type to that of mlog for this class and all other subtools. void BuildTree(TMVA::DecisionTree* dt); build the decision tree using fNTreeSample events from fTrainingEventsRndm. void MakeForest(); make a forest of decisiontrees. void SaveEventWeights(); save event weights - must be done before making the forest. void RestoreEventWeights(); save event weights - must be done before making the forest. void Boost(TMVA::DecisionTree* dt); Boost the events. The algorithm below is the called AdaBoost.; See MethodBDT for details.; Actually, this is a more or less copy of MethodBDT::AdaBoost(). void ForestStatistics(); summary of statistics of all trees; * end-nodes: average and spread. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vect",MatchSource.WIKI,root/html528/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFit.html
Modifiability,variab,variables,"and spread. void FitCoefficients(). Fit the coefficients for the rule ensemble. void CalcImportance(); calculates the importance of each rule. Double_t EvalEvent(const TMVA::Event& e); evaluate single event. void SetTrainingEvents(const vector<TMVA::Event*>& el); set the training events randomly. void GetRndmSampleEvents(vector<const TMVA::Event*>& evevec, UInt_t nevents); draw a random subsample of the training events without replacement. void NormVisHists(vector<TH2F*>& hlist); normalize rule importance hists. if all weights are positive, the scale will be 1/maxweight; if minimum weight < 0, then the scale will be 1/max(maxweight,abs(minweight)). void FillCut(TH2F* h2, const TMVA::Rule* rule, Int_t vind); Fill cut. void FillLin(TH2F* h2, Int_t vind); fill lin. void FillCorr(TH2F* h2, const TMVA::Rule* rule, Int_t v1, Int_t v2); fill rule correlation between vx and vy, weighted with either the importance or the coefficient. void FillVisHistCut(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all variables. void FillVisHistCorr(const TMVA::Rule* rule, vector<TH2F*>& hlist); help routine to MakeVisHists() - fills for all correlation plots. Bool_t GetCorrVars(TString& title, TString& var1, TString& var2); get first and second variables from title. void MakeVisHists(); this will create histograms visualizing the rule ensemble. void MakeDebugHists(); this will create a histograms intended rather for debugging or for the curious user. RuleFit(const TMVA::MethodBase* rfbase); main constructor. void ReshuffleEvents(); { std::random_shuffle(fTrainingEventsRndm.begin(),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetI",MatchSource.WIKI,root/html528/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFit.html
Security,access,accessors,"),fTrainingEventsRndm.end()); }. void SetModelLinear(); set usage of linear term. { fRuleEnsemble.SetModelLinear(); }. void SetModelRules(); set usage of rules. { fRuleEnsemble.SetModelRules(); }. void SetModelFull(); set usage of linear term. { fRuleEnsemble.SetModelFull(); }. void SetImportanceCut(Double_t minimp = 0); set minimum importance allowed. { fRuleEnsemble.SetImportanceCut(minimp); }. void SetRuleMinDist(Double_t d); set minimum rule distance - see RuleEnsemble. { fRuleEnsemble.SetRuleMinDist(d); }. void SetGDTau(Double_t t = 0.0); set path related parameters. { fRuleFitParams.SetGDTau(t); }. void SetGDPathStep(Double_t s = 0.01); { fRuleFitParams.SetGDPathStep(s); }. void SetGDNPathSteps(Int_t n = 100); make visualization histograms. { fRuleFitParams.SetGDNPathSteps(n); }. void SetVisHistsUseImp(Bool_t f); { fVisHistsUseImp = f; }. void UseImportanceVisHists(); { fVisHistsUseImp = kTRUE; }. void UseCoefficientsVisHists(); { fVisHistsUseImp = kFALSE; }. UInt_t GetNTreeSample() const; accessors. { return fNTreeSample; }. Double_t GetNEveEff() const; { return fNEveEffTrain; }. const Event* GetTrainingEvent(UInt_t i) const; { return static_cast< const Event *>(fTrainingEvents[i]); }. Double_t GetTrainingEventWeight(UInt_t i) const; { return fTrainingEvents[i]->GetWeight(); }. const std::vector< TMVA::Event * > & GetTrainingEvents() const; const Event* GetTrainingEvent(UInt_t i, UInt_t isub) const { return &(fTrainingEvents[fSubsampleEvents[isub]])[i]; }. { return fTrainingEvents; }. const std::vector< const TMVA::DecisionTree *> & GetForest() const. { return fForest; }. const RuleEnsemble & GetRuleEnsemble() const; { return fRuleEnsemble; }. RuleEnsemble * GetRuleEnsemblePtr(); { return &fRuleEnsemble; }. const RuleFitParams & GetRuleFitParams() const; { return fRuleFitParams; }. RuleFitParams * GetRuleFitParamsPtr(); { return &fRuleFitParams; }. const MethodRuleFit * GetMethodRuleFit() const; { return fMethodRuleFit; }. const MethodBase * GetMethodBase() c",MatchSource.WIKI,root/html528/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFit.html
Testability,log,logger,"etModelFull(); voidSetModelLinear(); voidSetModelRules(); voidSetMsgType(TMVA::EMsgType t); voidSetRuleMinDist(Double_t d); voidSetTrainingEvents(const vector<TMVA::Event*>& el); voidSetVisHistsUseImp(Bool_t f); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUseCoefficientsVisHists(); voidUseImportanceVisHists(). private:. voidCopy(const TMVA::RuleFit& other); TMVA::MsgLogger&Log() const; TMVA::RuleFitRuleFit(const TMVA::RuleFit& other). Data Members; private:. vector<Double_t>fEventWeightsoriginal weights of the events - follows fTrainingEvents; vector<const TMVA::DecisionTree*>fForestthe input forest of decision trees; TMVA::MsgLogger*fLoggermessage logger; const TMVA::MethodBase*fMethodBasepointer the method base which initialized this RuleFit instance; const TMVA::MethodRuleFit*fMethodRuleFitpointer the method which initialized this RuleFit instance; Double_tfNEveEffTrainreweighted number of events = sum(wi); UInt_tfNTreeSamplenumber of events in sub sample = frac*neve; TMVA::RuleEnsemblefRuleEnsemblethe ensemble of rules; TMVA::RuleFitParamsfRuleFitParamsfit rule parameters; vector<TMVA::Event*>fTrainingEventsall training events; vector<TMVA::Event*>fTrainingEventsRndmidem, but randomly shuffled; Bool_tfVisHistsUseImpif true, use importance as weight; else coef in vis hists; static const Int_trandSEEDset to 1 for debugging purposes or to zero for random seeds. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFit( const MethodBase *rfbase ); constructor. RuleFit(); default constructor. ~RuleFit(); destructor. void InitNEveEff(); init effective number of events (using event weights). void InitPtrs(const TMVA::MethodBase* rfbase); initialize pointers. void Initialize(const TMVA::MethodBase* rfbase); initialize the parameters of the RuleFit method and make rules. void SetMethodBase(const TMVA::MethodBase* rfbase); set MethodBase. void Copy(const T",MatchSource.WIKI,root/html528/TMVA__RuleFit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFit.html
Availability,mask,mask,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRu",MatchSource.WIKI,root/html528/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html
Integrability,message,message,"ERFMode { kRfRegress; kRfClass; };; enum EModel { kRfLinear; kRfRules; kRfBoth; };; enum ERFProgram { kRfTrain; kRfPredict; kRfVarimp; };. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp",MatchSource.WIKI,root/html528/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html
Modifiability,variab,variable,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t WriteTrain(); write training data, columnwise. Bool_t WriteTest(); Write test data. Bool_t WriteVarNames(); write variable names, ascii. Bool_t WriteVarImp(); written by rf_go.exe. Bool_t WriteYhat(); written by rf_go.exe. Bool_t ReadYhat(); read the score. Bool_t ReadVarImp(); read variable importance. Bool_t ReadModelSum(); read model from rulefit.sum. Int_t RunRuleFit(); execute rf_go.exe. void TrainRu",MatchSource.WIKI,root/html528/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html
Safety,abort,aborts,"parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void SetTestParms(); set the test params. void FillRealParmsDef(); set default real params. void FillIntParmsDef(); set default int params. Bool_t WriteAll(); write all files read by rf_go.exe. Bool_t WriteIntParms(); write int params file. Bool_t WriteRealParms(); write int params file. Bool_t WriteLx(); Save input variable mask. If the lx vector size is not the same as inputVars,; resize it and fill it with 1; NOTE: Always set all to 1; if (fRFLx.size() != m_inputVars->size()) {. Bool_t WriteProgram(); write command to rf_go.exe. Bool_t WriteRealVarImp(); write the minimum importance to be considered. Bool_t WriteRfOut(); written by rf_go.exe; write rulefit output (rfout). Bool_t WriteRfStatus(); written by rf_go.exe; write rulefit status. Bool_t WriteRuleFitMod(); written by rf_go.exe (NOTE:Format unknown!). Bool_t WriteRuleFitSum(); written by rf_go.exe (NOTE: format unknown!). Bool_t Wr",MatchSource.WIKI,root/html528/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html
Testability,log,logger," voidSetTestParms(); voidSetTrainParms(); Bool_tWriteAll(); Bool_tWriteFloat(ofstream& f, const Float_t* v, Int_t n = 1); Bool_tWriteInt(ofstream& f, const Int_t* v, Int_t n = 1); Bool_tWriteIntParms(); Bool_tWriteLx(); Bool_tWriteProgram(); Bool_tWriteRealParms(); Bool_tWriteRealVarImp(); Bool_tWriteRfOut(); Bool_tWriteRfStatus(); Bool_tWriteRuleFitMod(); Bool_tWriteRuleFitSum(); Bool_tWriteTest(); Bool_tWriteTrain(); Bool_tWriteVarImp(); Bool_tWriteVarNames(); Bool_tWriteYhat(). private:. TMVA::RuleFitAPIRuleFitAPI(). Data Members; public:. enum ERFMode { kRfRegress; kRfClass; };; enum EModel { kRfLinear; kRfRules; kRfBoth; };; enum ERFProgram { kRfTrain; kRfPredict; kRfVarimp; };. private:. TMVA::MsgLoggerfLoggermessage logger; const TMVA::MethodRuleFit*fMethodRuleFitparent method - set in constructor; TStringfModelTypemodel type string; TMVA::RuleFitAPI::IntParmsfRFIntParmsinteger parameters; vector<int>fRFLxvariable selector; TMVA::RuleFitAPI::ERFProgramfRFProgramwhat to run; TMVA::RuleFitAPI::RealParmsfRFRealParmsreal parameters; vector<Float_t>fRFVarImpvariable importances; vector<Int_t>fRFVarImpIndvariable index; TStringfRFWorkDirworking directory; vector<Float_t>fRFYhatscore results from test sample; TMVA::RuleFit*fRuleFitnon const ptr to RuleFit class in MethodRuleFit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RuleFitAPI(const TMVA::MethodRuleFit* rfbase, TMVA::RuleFit* rulefit, TMVA::EMsgType minType); standard constructor. ~RuleFitAPI(); destructor. void WelcomeMessage(); welcome message. void HowtoSetupRF(); howto message. void InitRuleFit(); default initialisation; SetRFWorkDir(""./rulefit"");. void ImportSetup(); import setup from MethodRuleFit. void SetRFWorkDir(const char* wdir); set the directory containing rf_go.exe. void CheckRFWorkDir(); check if the rulefit work dir is properly setup.; it aborts (kFATAL) if not. Check existance of directory. void SetTrainParms(); set the training parameters. void Se",MatchSource.WIKI,root/html528/TMVA__RuleFitAPI.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__RuleFitAPI.html
Availability,avail,available,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last ",MatchSource.WIKI,root/html528/TMVA__SeparationBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SeparationBase.html
Performance,optimiz,optimized,"e. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: SeparationBase.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__SeparationBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SeparationBase.html
Energy Efficiency,adapt,adaptiveSpeed,". TMVA::SimulatedAnnealing. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SimulatedAnnealing. class TMVA::SimulatedAnnealing. Implementation of Simulated Annealing fitter. Function Members (Methods); public:. virtual~SimulatedAnnealing(); static TClass*Class(); virtual TClass*IsA() const; Double_tMinimize(vector<Double_t>& parameters); voidSetAccuracy(Double_t eps); voidSetAdaptiveSpeed(Double_t speed); voidSetInitTemp(Double_t it); voidSetMaxCalls(Int_t mc); voidSetMinTemp(Double_t min); voidSetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); voidSetTemperatureScale(Double_t scale); virtual voidShowMembers(TMemberInspector& insp); TMVA::SimulatedAnnealingSimulatedAnnealing(const TMVA::SimulatedAnnealing&); TMVA::SimulatedAnnealingSimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidFillWithRandomValues(vector<Double_t>& parameters); Double_tGenerateMaxTemperature(vector<Double_t>& parameters); vector<Double_t>GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; public:. enum EKernelTemperature { kSqrt; kIncreasingAdaptive; kDecreasingAdaptiv",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html
Modifiability,adapt,adaptiveSpeed,". TMVA::SimulatedAnnealing. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SimulatedAnnealing. class TMVA::SimulatedAnnealing. Implementation of Simulated Annealing fitter. Function Members (Methods); public:. virtual~SimulatedAnnealing(); static TClass*Class(); virtual TClass*IsA() const; Double_tMinimize(vector<Double_t>& parameters); voidSetAccuracy(Double_t eps); voidSetAdaptiveSpeed(Double_t speed); voidSetInitTemp(Double_t it); voidSetMaxCalls(Int_t mc); voidSetMinTemp(Double_t min); voidSetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); voidSetTemperatureScale(Double_t scale); virtual voidShowMembers(TMemberInspector& insp); TMVA::SimulatedAnnealingSimulatedAnnealing(const TMVA::SimulatedAnnealing&); TMVA::SimulatedAnnealingSimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. voidFillWithRandomValues(vector<Double_t>& parameters); Double_tGenerateMaxTemperature(vector<Double_t>& parameters); vector<Double_t>GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; public:. enum EKernelTemperature { kSqrt; kIncreasingAdaptive; kDecreasingAdaptiv",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html
Security,access,accessors,"alTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random starting parameters. void ReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); copy parameters. void GenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); generate adjacent parameters. std::vector<Double_t> GenerateNeighbour(vector<Double_t>& parameters, Double_t currentTemperature); generate adjacent parameters. void GenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); generate new temperature. Bool_t ShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature); result checker. void SetDefaultScale(); setting of default scale. Double_t GenerateMaxTemperature(vector<Double_t>& parameters); maximum temperature. Double_t Minimize(vector<Double_t>& parameters); minimisation algorithm. SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges). void SetMaxCalls(Int_t mc); accessors. { fMaxCalls = mc; }. void SetInitTemp(Double_t it); { fInitialTemperature = it; }. void SetMinTemp(Double_t min); { fMinTemperature = min; }. void SetAccuracy(Double_t eps); { fEps = eps; }. void SetTemperatureScale(Double_t scale); { fTemperatureScale = scale; }. void SetAdaptiveSpeed(Double_t speed); { fAdaptiveSpeed = speed; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id: SimulatedAnnealing.h 31574 2009-12-05 18:23:21Z stelzer $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html
Testability,log,logger,"ble_t>& parameters, Double_t currentTemperature); voidGenerateNeighbour(vector<Double_t>& parameters, vector<Double_t>& oldParameters, Double_t currentTemperature); voidGenerateNewTemperature(Double_t& currentTemperature, Int_t Iter); TMVA::MsgLogger&Log() const; voidReWriteParameters(vector<Double_t>& from, vector<Double_t>& to); voidSetDefaultScale(); Bool_tShouldGoIn(Double_t currentFit, Double_t localFit, Double_t currentTemperature). Data Members; public:. enum EKernelTemperature { kSqrt; kIncreasingAdaptive; kDecreasingAdaptive; kLog; kHomo; kSin; kGeo; };. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsepsilon; TMVA::IFitterTarget&fFitterTargetthe fitter target; Double_tfInitialTemperatureinitial temperature; TMVA::SimulatedAnnealing::EKernelTemperaturefKernelTemperature; TMVA::MsgLogger*fLoggermessage logger; Int_tfMaxCallsmaximum number of minimisation calls; Double_tfMinTemperaturemimimum temperature; Double_tfProgress; TRandom*fRandomrandom generator; const vector<TMVA::Interval*>&fRangesparameter ranges; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealing(TMVA::IFitterTarget& target, const vector<TMVA::Interval*>& ranges); constructor. void SetOptions(Int_t maxCalls, Double_t initialTemperature, Double_t minTemperature, Double_t eps, TString kernelTemperatureS, Double_t temperatureScale, Double_t adaptiveSpeed, Double_t temperatureAdaptiveStep, Bool_t useDefaultScale, Bool_t useDefaultTemperature); option setter. ~SimulatedAnnealing(); destructor. void FillWithRandomValues(vector<Double_t>& parameters); random star",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealing.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealing.html
Availability,error,error,"t::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&TMVA::Configurable::GetOptions() const; virtual const char*TObject::GetT",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Deployability,configurat,configuration,"terTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~SimulatedAnnealingFitter(); {}. » Author: Andreas Hoecker, Krzysztof Danielowski, Kamil Kraszewski, Maciej Kruk » Copyright (c) 2008: *; » Last changed: root/tmva $Id: SimulatedAnnealingFitter.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Energy Efficiency,adapt,adaptive,"areOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~Simulated",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Integrability,depend,depends,"areOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~Simulated",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Modifiability,adapt,adaptive,"areOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA::IFitterTarget& target, const TString& name, const vector<TMVA::Interval*>& ranges, const TString& theOption); constructor. void DeclareOptions(); declare SA options. void SetParameters(Int_t fMaxCalls, Double_t fInitialTemperature, Double_t fMinTemperature, Double_t fEps, TString fKernelTemperatureS, Double_t fTemperatureScale, Double_t fTemperatureAdaptiveStep, Bool_t fUseDefaultScale, Bool_t fUseDefaultTemperature); set SA configuration parameters. Double_t Run(vector<Double_t>& pars); Execute fitting. virtual ~Simulated",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Testability,log,logger,"tream& o, const TString& prefix) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTMVA::Configurable::EnableLooseOptions(Bool_t b = kTRUE); const TString&TMVA::Configurable::GetReferenceFile() const; TMVA::MsgLogger&TMVA::FitterBase::Log() const; Bool_tTMVA::Configurable::LooseOptionCheckingEnabled() const; voidTObject::MakeZombie(); voidTMVA::Configurable::ResetSetFlag(); voidTMVA::Configurable::WriteOptionsReferenceToFile(). private:. virtual voidDeclareOptions(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTMVA::FitterBase::fClassNameremove TMVA:: from TObject name; TMVA::IFitterTarget&TMVA::FitterBase::fFitterTargetpointer to target of fitting procedure; TMVA::MsgLogger*TMVA::FitterBase::fLoggermessage logger; Int_tTMVA::FitterBase::fNparsnumber of parameters; const vector<TMVA::Interval*>TMVA::FitterBase::fRangesallowed intervals. private:. Double_tfAdaptiveSpeedhow fast temperature change in adaptive (in adaptive two variables describe; Double_tfEpsrelative required FCN accuracy at minimum; Double_tfInitialTemperatureinitial temperature (depends on FCN); TStringfKernelTemperatureSstring just to set fKernelTemperature; Int_tfMaxCallsmax number of FCN calls; Double_tfMinTemperatureminimum temperature before SA quit; Double_tfTemperatureAdaptiveStepused to calculate InitialTemperature if fUseDefaultTemperature; Double_tfTemperatureScalehow fast temperature change; Bool_tfUseDefaultScaleif TRUE, SA calculates its own TemperatureScale; Bool_tfUseDefaultTemperatureif TRUE, SA calculates its own InitialTemperature (MinTemperautre). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SimulatedAnnealingFitter(TMVA",MatchSource.WIKI,root/html528/TMVA__SimulatedAnnealingFitter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SimulatedAnnealingFitter.html
Modifiability,variab,variables,"ol_tIsInI3() const; voidPrint(ostream& os) const; voidPrintData(); voidSetAlpha(Float_t alpha); voidSetAlpha_p(Float_t alpha); voidSetErrorCache(Float_t err_cache); voidSetIdx(Int_t idx); voidSetIsShrinked(Int_t isshrinked); voidSetLine(Float_t* line); voidSetNs(UInt_t ns); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::SVEventSVEvent(); TMVA::SVEventSVEvent(const TMVA::SVEvent&); TMVA::SVEventSVEvent(const TMVA::Event*, Float_t); TMVA::SVEventSVEvent(const vector<Float_t>*, Float_t alpha, Int_t typeFlag, UInt_t ns); TMVA::SVEventSVEvent(const vector<Float_t>* svector, Float_t alpha, Float_t alpha_p, Int_t typeFlag); voidUpdateErrorCache(Float_t upercache). Data Members; private:. Float_tfAlphalagrange multiplier; Float_tfAlpha_plagrange multiplier; const Float_tfCweightsvm cost weight; vector<Float_t>fDataVector; Float_tfErrorCacheoptimization parameter; Int_tfIdxindex flag; Int_tfIsShrinkedshrinking flag, see documentation; Float_t*fLinepointer to column of kerenl matrix ; UInt_tfNVarnumber of variables; UInt_tfNsdocumentation; const Float_tfTargetregression target; const Int_tfTypeFlagis sig or bkg - svm requieres 1 for sig and -1 for bkg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SVEvent(). SVEvent(const TMVA::Event* , Float_t ); constructor. SVEvent(const vector<Float_t>* , Float_t alpha, Int_t typeFlag, UInt_t ns); constructor. SVEvent(const vector<Float_t>* svector, Float_t alpha, Float_t alpha_p, Int_t typeFlag); constructor. ~SVEvent(); destructor. void Print(ostream& os) const; printout. void PrintData(); printout. SVEvent(). void SetAlpha(Float_t alpha); { fAlpha = alpha; }. void SetAlpha_p(Float_t alpha); { fAlpha_p = alpha; }. void SetErrorCache(Float_t err_cache); { fErrorCache = err_cache; }. void SetIsShrinked(Int_t isshrinked); { fIsShrinked = isshrinked; }. void SetLine(Float_t* line); { fLine = line; }. void SetIdx(Int_t idx)",MatchSource.WIKI,root/html528/TMVA__SVEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__SVEvent.html
Availability,avail,available,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__TActivation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivation.html
Integrability,message,message,ass charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html528/TMVA__TActivationChooser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationChooser.html
Testability,log,logger,ass charts. ROOT; » TMVA; » TMVA::TActivationChooser. class TMVA::TActivationChooser. TActivationChooser. Class for easily choosing activation functions. Function Members (Methods); public:. virtual~TActivationChooser(); static TClass*Class(); TMVA::TActivation*CreateActivation(TMVA::TActivationChooser::EActivationType type) const; TMVA::TActivation*CreateActivation(const TString& type) const; vector<TString>*GetAllActivationNames() const; virtual TClass*IsA() const; TMVA::TActivationChooser&operator=(const TMVA::TActivationChooser&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationChooserTActivationChooser(); TMVA::TActivationChooserTActivationChooser(const TMVA::TActivationChooser&). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum EActivationType { kLinear; kSigmoid; kTanh; kRadial; };. private:. TStringfLINEARactivation function name; TMVA::MsgLogger*fLogger! message logger; TStringfRADIALactivation function name; TStringfSIGMOIDactivation function name; TStringfTANHactivation function name. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationChooser(); defaut constructor. ~TActivationChooser(); destructor. CreateActivation(EActivationType type); instantiate the correct activation object according to the; type choosen (given as the enumeration type). CreateActivation(const TString& type) const; instantiate the correct activation object according to the; type choosen (given by a TString). GetAllActivationNames() const; retuns the names of all know activation functions. TActivationChooser(). » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivationChooser.h 29195 2009-06-24 10:39:49Z brun $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ,MatchSource.WIKI,root/html528/TMVA__TActivationChooser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationChooser.html
Energy Efficiency,efficient,efficient,". TMVA::TActivationRadial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationRadial. class TMVA::TActivationRadial: public TMVA::TActivation. Radial basis activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationRadial(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationRadial&operator=(const TMVA::TActivationRadial&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationRadialTActivationRadial(); TMVA::TActivationRadialTActivationRadial(const TMVA::TActivationRadial&). Data Members; private:. TFormula*fEqnequation of radial basis function; TFormula*fEqnDerivativeequation of derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationRadial(); constructor for gaussian with center 0, width 1. ~TActivationRadial(); destructor. Double_t Eval(Double_t arg); evaluate gaussian. Double_t EvalDerivative(Double_t arg); evaluate derivative. TString GetExpression(); get expressions for the gaussian and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationRadial(). Double_t GetMin(); minimum of the range of the activation function. { return 0; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last ch",MatchSource.WIKI,root/html528/TMVA__TActivationRadial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationRadial.html
Usability,simpl,simple,". TMVA::TActivationRadial. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationRadial. class TMVA::TActivationRadial: public TMVA::TActivation. Radial basis activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationRadial(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationRadial&operator=(const TMVA::TActivationRadial&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationRadialTActivationRadial(); TMVA::TActivationRadialTActivationRadial(const TMVA::TActivationRadial&). Data Members; private:. TFormula*fEqnequation of radial basis function; TFormula*fEqnDerivativeequation of derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationRadial(); constructor for gaussian with center 0, width 1. ~TActivationRadial(); destructor. Double_t Eval(Double_t arg); evaluate gaussian. Double_t EvalDerivative(Double_t arg); evaluate derivative. TString GetExpression(); get expressions for the gaussian and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationRadial(). Double_t GetMin(); minimum of the range of the activation function. { return 0; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last ch",MatchSource.WIKI,root/html528/TMVA__TActivationRadial.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationRadial.html
Energy Efficiency,efficient,efficient,". TMVA::TActivationSigmoid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationSigmoid. class TMVA::TActivationSigmoid: public TMVA::TActivation. Sigmoid activation function for TNeuron. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationSigmoid(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationSigmoid&operator=(const TMVA::TActivationSigmoid&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationSigmoidTActivationSigmoid(); TMVA::TActivationSigmoidTActivationSigmoid(const TMVA::TActivationSigmoid&). Data Members; private:. TFormula*fEqnequation of sigmoid; TFormula*fEqnDerivativeequation of sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationSigmoid(); constructor for sigmoid normalized in [0,1]. ~TActivationSigmoid(); destructor. Double_t Eval(Double_t arg); evaluate the sigmoid. Double_t EvalDerivative(Double_t arg); evaluate the derivative of the sigmoid. TString GetExpression(); get expressions for the sigmoid and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationSigmoid(). Double_t GetMin(); minimum of the range of the activation function. { return 0; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyrigh",MatchSource.WIKI,root/html528/TMVA__TActivationSigmoid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationSigmoid.html
Usability,simpl,simple,". TMVA::TActivationSigmoid. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationSigmoid. class TMVA::TActivationSigmoid: public TMVA::TActivation. Sigmoid activation function for TNeuron. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationSigmoid(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationSigmoid&operator=(const TMVA::TActivationSigmoid&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationSigmoidTActivationSigmoid(); TMVA::TActivationSigmoidTActivationSigmoid(const TMVA::TActivationSigmoid&). Data Members; private:. TFormula*fEqnequation of sigmoid; TFormula*fEqnDerivativeequation of sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationSigmoid(); constructor for sigmoid normalized in [0,1]. ~TActivationSigmoid(); destructor. Double_t Eval(Double_t arg); evaluate the sigmoid. Double_t EvalDerivative(Double_t arg); evaluate the derivative of the sigmoid. TString GetExpression(); get expressions for the sigmoid and its derivatives. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationSigmoid(). Double_t GetMin(); minimum of the range of the activation function. { return 0; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyrigh",MatchSource.WIKI,root/html528/TMVA__TActivationSigmoid.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationSigmoid.html
Energy Efficiency,efficient,efficient,". TMVA::TActivationTanh. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationTanh. class TMVA::TActivationTanh: public TMVA::TActivation. Tanh activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationTanh(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationTanh&operator=(const TMVA::TActivationTanh&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationTanhTActivationTanh(); TMVA::TActivationTanhTActivationTanh(const TMVA::TActivationTanh&). Data Members; private:. TFormula*fEqnequation of tanh sigmoid; TFormula*fEqnDerivativeequation of tanh sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationTanh(); constructor for tanh sigmoid (normalized in [-1,1]). ~TActivationTanh(); destructor. Double_t Eval(Double_t arg); evaluate the tanh. Double_t EvalDerivative(Double_t arg); evaluate the derivative. TString GetExpression(); get expressions for the tanh and its derivative. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationTanh(). Double_t GetMin(); minimum of the range of the activation function. { return -1; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActiv",MatchSource.WIKI,root/html528/TMVA__TActivationTanh.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationTanh.html
Usability,simpl,simple,". TMVA::TActivationTanh. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivationTanh. class TMVA::TActivationTanh: public TMVA::TActivation. Tanh activation function for ANN. This really simple implementation; uses TFormulas and should probably be replaced with something more; efficient later. Function Members (Methods); public:. virtual~TActivationTanh(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivationTanh&operator=(const TMVA::TActivationTanh&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); TMVA::TActivationTanhTActivationTanh(); TMVA::TActivationTanhTActivationTanh(const TMVA::TActivationTanh&). Data Members; private:. TFormula*fEqnequation of tanh sigmoid; TFormula*fEqnDerivativeequation of tanh sigmoid derivative. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivationTanh(); constructor for tanh sigmoid (normalized in [-1,1]). ~TActivationTanh(); destructor. Double_t Eval(Double_t arg); evaluate the tanh. Double_t EvalDerivative(Double_t arg); evaluate the derivative. TString GetExpression(); get expressions for the tanh and its derivative. void MakeFunction(ostream& fout, const TString& fncName); writes the sigmoid activation function source code. TActivationTanh(). Double_t GetMin(); minimum of the range of the activation function. { return -1; }. Double_t GetMax(); maximum of the range of the activation function. { return 1; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActiv",MatchSource.WIKI,root/html528/TMVA__TActivationTanh.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TActivationTanh.html
Availability,error,error,"er* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetElapsedTime(Bool_t Scientific = kTRUE); virtual const char*TObject::GetIconName() const; TStringGetLeftTime(Int_t icounts); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, cons",MatchSource.WIKI,root/html528/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Timer.html
Testability,log,logger,"unts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const; TStringSecToText(Double_t, Bool_t) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts"" ; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void ",MatchSource.WIKI,root/html528/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Timer.html
Usability,progress bar,progress bar,". TMVA::Timer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Timer. class TMVA::Timer: public TStopwatch. Timing information for training and evaluation of MVA methods. Usage:. TMVA::Timer timer( Nloops, ""MyClassName"" );; for (Int_t i=0; i<Nloops; i++) {; ... // some code. // now, print progress bar:; timer.DrawProgressBar( i );. // **OR** text output of left time (never both !); fLogger << "" time left: "" << timer.GetLeftTime( i ) << Endl;. }; fLogger << ""MyClassName"" << "": elapsed time: "" << timer.GetElapsedTime(); << Endl;. Remark: in batch mode, the progress bar is quite ugly; you may; want to use the text output then. Function Members (Methods); public:. virtual~Timer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidTStopwatch::Continue(); virtual voidTObject::Copy(TObject& object) const; Int_tTStopwatch::Counter() const; Double_tTStopwatch::CpuTime(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawProgressBar(); voidDrawProgressBar(TString); voidDrawProgressBar(Int_t, const TString& comment = """"); virtual voidTObject::Dump() constMENU ; Double_tElapsedSeconds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, ",MatchSource.WIKI,root/html528/TMVA__Timer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Timer.html
Availability,error,error,"ynapse* pre); voidAdjustSynapseWeights(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateActivationValue(); voidCalculateDelta(); voidCalculateValue(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeletePreLinks(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceValue(Double_t value); Double_tGetActivationValue() const; Double_tGetDEDw() const; Double_tGetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetValue() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash",MatchSource.WIKI,root/html528/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html
Deployability,update,update,"on(); standard constructor. ~TNeuron(); destructor. void InitNeuron(); initialize the neuron, most variables still need to be set via setters. void ForceValue(Double_t value); force the value, typically for input and bias neurons. void CalculateValue(); calculate neuron input. void CalculateActivationValue(); calculate neuron activation/output. void CalculateDelta(); calculate error field. void SetInputCalculator(TMVA::TNeuronInput* calculator); set input calculator. void SetActivationEqn(TMVA::TActivation* activation); set activation equation. void AddPreLink(TMVA::TSynapse* pre); add synapse as a pre-link to this neuron. void AddPostLink(TMVA::TSynapse* post); add synapse as a post-link to this neuron. void DeletePreLinks(); delete all pre-links. void DeleteLinksArray(TObjArray*& links); delete an array of TSynapses. void SetError(Double_t error); set error, this should only be done for an output neuron. void UpdateSynapsesBatch(); update and adjust the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void UpdateSynapsesSequential(); update the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in sequential mode. void AdjustSynapseWeights(); adjust the pre-synapses' weights for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void InitSynapseDeltas(); initialize the error fields of all pre-neurons; this method should only be called in batch mode. void PrintLinks(TObjArray* links) const; print an array of TSynapses, for debugging. void PrintActivationEqn(); print activation equation, for debugging. void PrintMessage(TMVA::EMsgType , TString message); print message, for debugging. TNeuron(ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """" ); {}. Double_t GetValue() const. void SetDEDw(Double_t DEDw). Double_t GetDEDw() const; { return fDEDw; ",MatchSource.WIKI,root/html528/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html
Integrability,message,message,"t::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; TMVA::TNeuronTNeuron(); TMVA::TNeuronTNeuron(const TMVA::TNeuron&); voidUpdateSynapsesBatch(); voidUpdateSynapsesSequential(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidDeleteLinksArray(TObjArray*& links); voidInitNeuron(); TMVA::MsgLogger&Log() const; voidNullifyLinks(TObjArray*& links); Int_tNumLinks(TObjArray* links) const; voidPrintLinks(TObjArray* links) const; voidPrintMessage(TMVA::EMsgType, TString message). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function do",MatchSource.WIKI,root/html528/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html
Modifiability,variab,variables,"ing message). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuron(); standard constructor. ~TNeuron(); destructor. void InitNeuron(); initialize the neuron, most variables still need to be set via setters. void ForceValue(Double_t value); force the value, typically for input and bias neurons. void CalculateValue(); calculate neuron input. void CalculateActivationValue(); calculate neuron activation/output. void CalculateDelta(); calculate error field. void SetInputCalculator(TMVA::TNeuronInput* calculator); set input calculator. void SetActivationEqn(TMVA::TActivation* activation); set activation equation. void AddPreLink(TMVA::TSynapse* pre); add synapse as a pre-link to this neuron. void AddPostLink(TMVA::TSynapse* post); add synapse as a post-link to this neuron. void DeletePreLinks(); delete all pre-links. void DeleteLinksArray(TObjArray*& links); delete an array of TSynapses. void SetError(Double_t error); set error, this should only be done for an output neuron. void UpdateSynapsesBatch(); update and adjust the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void UpdateSyn",MatchSource.WIKI,root/html528/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html
Testability,log,logger,"har* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidDeleteLinksArray(TObjArray*& links); voidInitNeuron(); TMVA::MsgLogger&Log() const; voidNullifyLinks(TObjArray*& links); Int_tNumLinks(TObjArray* links) const; voidPrintLinks(TObjArray* links) const; voidPrintMessage(TMVA::EMsgType, TString message). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuron(); standard constructor. ~TNeuron(); destructor. void InitNeuron(); initialize the neuron, most variables still need to be set via setters. void ForceValue(Double_t value); force the value, typically for input and bias neurons. void CalculateValue(); calculate neuron input. void CalculateActivationValue(); calculate neuron activation/output. void CalculateDelta(); calculate error field. void SetInputCalculator(TMVA::TNeuronInput* calculator); set input calculator. void SetActivationEqn(TMVA::TActivation* activation); set activation equation. void AddPreLink(TMVA::TSynapse* pre); add synapse as a pre-link to this neuron. void AddPostLink(T",MatchSource.WIKI,root/html528/TMVA__TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html
Availability,avail,available,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__TNeuronInput.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TNeuronInput.html
Availability,avail,available,"egular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add attribute to node. void* AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false). Bool_t AddComment(void* node, const char* comment). void* GetParent(void* child). void* GetChild(void* parent, const char* childname = 0). void* GetNextChild(void* prevchild, const char* childname = 0); XML helpers. const char* GetContent(void* node); XML helpers. const char* GetName(void* node); XML helpers. Bool_t AddRawLine(void* node, const char* raw); XML helpers. std::vector<TString> SplitString(const TString& theOpt, const char separator) const;",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Deployability,configurat,configuration,"ary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<std::vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, co",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Integrability,depend,dependency,"ble vector. void Scale(vector<Float_t>& , Float_t ); scales float vector. void UsefulSortAscending(vector<std::vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. void UsefulSortDescending(vector<std::vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; that the ""first vector is sorted"" and the other vectors are reshuffled; in the same way as necessary to have the first vector sorted.; I.e. the correlation between the elements is kept. Double_t GetMutualInformation(const TH2F& ); Mutual Information method for non-linear correlations estimates in 2D histogram; Author: Moritz Backes, Geneva (2009). Double_t GetCorrelationRatio(const TH2F& ); Compute Correlation Ratio of 2D histogram to estimate functional dependency between two variables; Author: Moritz Backes, Geneva (2009). Double_t GetYMean_binX(const TH2& , Int_t bin_x); Compute the mean in Y for a given bin X of a 2D histogram. TH2F* TransposeHist(const TH2F& ); Transpose quadratic histogram. Bool_t CheckForSilentOption(const TString& ) const; check for ""silence"" option in configuration option string. Bool_t CheckForVerboseOption(const TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expr",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Modifiability,variab,variable,". Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S^2(x) - B^2(x))/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x)2 - B(x)2)/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.0); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* , const TSpline* ); check quality of splining by comparing splines and histograms in each bin. std::vector<Double_t> MVADiff(vector<Double_t>& , vector<Double_t>& ); computes difference between two vectors. void Scale(vector<Double_t>& , Double_t ); scales double vector. void Scale(vector<Float_t>& , Float_t ); scales float vector. void UsefulSortAscending(vector<std::vector<Double_t> >& , vector<TString>* vs = 0); sort 2D vector (AND in parallel a TString vector) in such a way; t",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Safety,sanity check,sanity check,"g; kSmall2WelcomeMsg; kOriginalWelcomeMsgColor; kOriginalWelcomeMsgBW; };; enum ECitation { kPlainText; kBibTeX; kLaTeX; kHtmlLink; };. public:. TMVA::MsgLogger*fLogger; const TStringfRegexp; TXMLEngine*fXMLEngine; static TMVA::Tools*fgTools. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMVA::Tools& Instance(); { return fgTools?*(fgTools): *(fgTools = new Tools()); }. void DestroyInstance(). Tools(); constructor. ~Tools(); destructor. Double_t NormVariable(Double_t x, Double_t xmin, Double_t xmax); normalise to output range: [-1, 1]. Double_t GetSeparation(TH1* S, TH1* B) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S^2(x) - B^2(x))/(S(x) + B(x)) dx }. Double_t GetSeparation(const TMVA::PDF& pdfS, const TMVA::PDF& pdfB) const; compute ""separation"" defined as; <s2> = (1/2) Int_-oo..+oo { (S(x)2 - B(x)2)/(S(x) + B(x)) dx }. void ComputeStat(const vector<TMVA::Event*>& , vector<Float_t>* , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Double_t& , Int_t signalClass, Bool_t norm = kFALSE); sanity check. TMatrixD* GetSQRootMatrix(TMatrixDSym* symMat); square-root of symmetric matrix; of course the resulting sqrtMat is also symmetric, but it's easier to; treat it as a general matrix. const TMatrixD* GetCorrelationMatrix(const TMatrixD* covMat); turns covariance into correlation matrix. TH1* projNormTH1F(TTree* theTree, const TString& theVarName, const TString& name, Int_t nbins, Double_t xmin, Double_t xmax, const TString& cut); projects variable from tree into normalised histogram. Double_t NormHist(TH1* theHist, Double_t norm = 1.0); normalises histogram. TList* ParseFormatLine(TString theString, const char* sep = "":""); Parse the string and cut into labels separated by "":"". vector<Int_t>* ParseANNOptionString(TString theOptions, Int_t nvar, vector<Int_t>* nodes); parse option string for ANN methods; default settings (should be defined in theOption string). Bool_t CheckSplines(const TH1* ,",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Testability,log,logger,". TMVA::Tools. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Tools. class TMVA::Tools. Function Members (Methods); public:. ~Tools(); voidAddAttr(void* node, const char* attrname, const char* value); void*AddChild(void* parent, const char* childname, const char* content = 0, bool isRootNode = false); Bool_tAddComment(void* node, const char* comment); Bool_tAddRawLine(void* node, const char* raw); vector<TMatrixDSym*>*CalcCovarianceMatrices(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events, Int_t maxCls); Bool_tCheckForSilentOption(const TString&) const; Bool_tCheckForVerboseOption(const TString&) const; Bool_tCheckSplines(const TH1*, const TSpline*); const TString&Color(const TString&); voidComputeStat(const vector<TMVA::Event*>&, vector<Float_t>*, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Double_t&, Int_t signalClass, Bool_t norm = kFALSE); Double_tComputeVariance(Double_t sumx2, Double_t sumx, Int_t nx); Bool_tContainsRegularExpression(const TString& s); static voidDestroyInstance(); voidFormattedOutput(const TMatrixD&, const vector<TString>&, TMVA::MsgLogger& logger); voidFormattedOutput(const TMatrixD&, const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); voidFormattedOutput(const vector<Double_t>&, const vector<TString>&, const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); void*GetChild(void* parent, const char* childname = 0); const char*GetContent(void* node); const TMatrixD*GetCorrelationMatrix(const TMatrixD* covMat); Double_tGetCorrelationRatio(const TH2F&); Int_tGetIndexMaxElement(vector<Double_t>&); Int_tGetIndexMinElement(vector<Double_t>&); Double_tGetMutualInformation(const TH2F&); const char*GetName(void* node); void*GetNextChild(void* prevchild, const char* childna",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Usability,simpl,simple,"TString& ) const; check if verbosity ""V"" set in option. void UsefulSortDescending(vector<Double_t>& ); sort vector. void UsefulSortAscending(vector<Double_t>& ); sort vector. Int_t GetIndexMaxElement(vector<Double_t>& ); find index of maximum entry in vector. Int_t GetIndexMinElement(vector<Double_t>& ); find index of minimum entry in vector. Bool_t ContainsRegularExpression(const TString& s); check if regular expression; helper function to search for ""$!%^&()'<>?= "" in a string. TString ReplaceRegularExpressions(const TString& s, const TString& replace = ""+""); replace regular expressions; helper function to remove all occurences ""$!%^&()'<>?= "" from a string; and replace all ::,$,*,/,+,- with _M_,_S_,_T_,_D_,_P_,_M_ respectively. const TString& Color(const TString& ); human readable color strings. void FormattedOutput(const vector<Double_t>& , const vector<TString>& , const TString titleVars, const TString titleValues, TMVA::MsgLogger& logger, TString format = ""%+1.3f""); formatted output of simple table. void FormattedOutput(const TMatrixD& , const vector<TString>& , TMVA::MsgLogger& logger); formatted output of matrix (with labels). void FormattedOutput(const TMatrixD& , const vector<TString>& vert, const vector<TString>& horiz, TMVA::MsgLogger& logger); formatted output of matrix (with labels). TString GetXTitleWithUnit(const TString& title, const TString& unit); histogramming utility. TString GetYTitleWithUnit(const TH1& h, const TString& unit, Bool_t normalised); histogramming utility. void WriteFloatArbitraryPrecision(Float_t val, ostream& os); writes a float value with the available precision to a stream. void ReadFloatArbitraryPrecision(Float_t& val, istream& is); reads a float value with the available precision from a stream. Bool_t HasAttr(void* node, const char* attrname); add attribute from xml. void ReadAttr(void* node, const char* attrname, TString& value); add attribute from xml. void AddAttr(void* node, const char* attrname, const char* value); add at",MatchSource.WIKI,root/html528/TMVA__Tools.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Tools.html
Availability,error,error,"on_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildCoeff(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; const TGraph*GetGraph() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; v",MatchSource.WIKI,root/html528/TMVA__TSpline1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSpline1.html
Availability,error,error,"on_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildCoeff(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTSpline::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTSpline::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTSpline::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTSpline::GetDelta() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TH1F*TSpline::GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual voidGetKnot(Int_t i, Double_t& x, Double_t& y) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMar",MatchSource.WIKI,root/html528/TMVA__TSpline2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSpline2.html
Integrability,rout,routine,"tance between equidistant knots; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TGraph*TSpline::fGraphGraph for drawing the knots; TH1F*TSpline::fHistogramTemporary histogram; Bool_tTSpline::fKstepTrue of equidistant knots; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TStringTNamed::fNameobject identifier; Int_tTSpline::fNpNumber of knots; Int_tTSpline::fNpxNumber of points used for graphical representation; TStringTNamed::fTitleobject title; Double_tTSpline::fXmaxMaximum value of abscissa; Double_tTSpline::fXminMinimum value of abscissa. private:. TGraph*fGraphgraph that is splined. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSpline2(const TString& title, TGraph* theGraph); constructor from TGraph; TSpline is a TNamed object. ~TSpline2( void ); destructor. Double_t Eval(Double_t x) const; returns quadratically interpolated TGraph entry around x. void BuildCoeff( void ); no coefficients to precompute. void GetKnot(Int_t i, Double_t& x, Double_t& y) const; no knots. Double_t Quadrax(Float_t dm, Float_t dm1, Float_t dm2, Float_t dm3, Float_t cos1, Float_t cos2, Float_t cos3) const; quadratic interpolation; Revised and checked by Francois Nov, 16th, 2000; Note the beautiful non-spontaneous symmetry breaking ...; It was checked that the old routine gave exactly the same answers. TSpline2(const TString& title, TGraph* theGraph). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TSpline2.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__TSpline2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSpline2.html
Availability,error,error,"e(); voidTObject::AbstractMethod(const char* method) const; voidAdjustWeight(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalculateDelta(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDecayLearningRate(Double_t rate); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetDEDw(); Double_tGetDelta(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetLearningRate(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetWeight(); Double_tGetWeightedDelta(); Double_tGetWeightedValue(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash()",MatchSource.WIKI,root/html528/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html
Deployability,update,updates,"napse(); TMVA::TSynapseTSynapse(const TMVA::TSynapse&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Doub",MatchSource.WIKI,root/html528/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html
Integrability,message,message,"napse(); TMVA::TSynapseTSynapse(const TMVA::TSynapse&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Doub",MatchSource.WIKI,root/html528/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html
Testability,log,logger,"napse(); TMVA::TSynapseTSynapse(const TMVA::TSynapse&); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Doub",MatchSource.WIKI,root/html528/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html
Usability,learn,learning,"write; kWriteDelete; };. private:. Int_tfCountnumber of updates contributing to error field; Double_tfDEDwsum of deltas; Double_tfDeltalocal error field; Double_tfLearnRatelearning rate parameter; TMVA::TNeuron*fPostNeuronpointer to post-neuron; TMVA::TNeuron*fPreNeuronpointer to pre-neuron; Double_tfWeightweight of the synapse; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); constructor. ~TSynapse(); destructor. void SetWeight(Double_t weight); set synapse weight. Double_t GetWeightedValue(); get output of pre-neuron weighted by synapse weight. Double_t GetWeightedDelta(); get error field of post-neuron weighted by synapse weight. void AdjustWeight(); adjust the weight based on the error field all ready calculated by CalculateDelta. void CalculateDelta(); calculate/adjust the error field for this synapse. TSynapse(). Double_t GetWeight(); get the weight of the synapse. { return fWeight; }. void SetLearningRate(Double_t rate); set the learning rate. { fLearnRate = rate; }. Double_t GetLearningRate(); get the learning rate. { return fLearnRate; }. void DecayLearningRate(Double_t rate); decay the learning rate. { fLearnRate *= (1-rate); }. void SetPreNeuron(TMVA::TNeuron* pre); set the pre-neuron. { fPreNeuron = pre; }. void SetPostNeuron(TMVA::TNeuron* post); set hte post-neuron. { fPostNeuron = post; }. void InitDelta(); initialize the error field of the synpase to 0. { fDelta = 0.0; fCount = 0; }. void SetDEDw(Double_t DEDw); { fDEDw = DEDw; }. Double_t GetDEDw(); { return fDEDw; }. Double_t GetDelta(); { return fDelta; }. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TSynapse.h 33928 2010-06-15 16:19:31Z stelzer $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__TSynapse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__TSynapse.html
Testability,log,logger,"pes::EMVA method) const; TMVA::Types::EMVAGetMethodType(const TString& method) const; static TMVA::Types&Instance(); TMVA::Types&operator=(const TMVA::Types&); TMVA::TypesTypes(const TMVA::Types&). private:. TMVA::MsgLogger&Log() const; TMVA::TypesTypes(). Data Members; public:. enum EMVA { kVariable; kCuts; kLikelihood; kPDERS; kHMatrix; kFisher; kKNN; kCFMlpANN; kTMlpANN; kBDT; kDT; kRuleFit; kSVM; kMLP; kBayesClassifier; kFDA; kCommittee; kBoost; kPDEFoam; kLD; kPlugins; kCategory; kMaxMethod; };; enum EVariableTransform { kIdentity; kDecorrelated; kNormalized; kPCA; kGaussDecorr; kGauss; kUniform; kMaxVariableTransform; };; enum EAnalysisType { kClassification; kRegression; kMulticlass; kNoAnalysisType; kMaxAnalysisType; };; enum ESBType { kSignal; kBackground; kSBBoth; kMaxSBType; kTrueType; };; enum ETreeType { kTraining; kTesting; kMaxTreeType; kValidation; kTrainingOriginal; };; enum EBoostStage { kBoostProcBegin; kBeforeTraining; kBeforeBoosting; kAfterBoosting; kBoostValidation; kBoostProcEnd; };. private:. TMVA::MsgLogger*fLoggermessage logger; map<TString,TMVA::Types::EMVA>fStr2typetypes-to-text map; static TMVA::Types*fgTypesPtr. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Types(); constructor. ~Types(); destructor. TMVA::Types& Instance(); the the single instance of ""Types"" if existin already, or create it (Signleton). void DestroyInstance(); ""destructor"" of the single instance. Bool_t AddTypeMapping(TMVA::Types::EMVA method, const TString& methodname). TString GetMethodName(TMVA::Types::EMVA method) const. Types::EMVA GetMethodType(const TString& method) const. Types(). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: Types.h 37399 2010-12-08 15:22:07Z evt $ » Last generated: 2010-12-08 16:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__Types.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__Types.html
Availability,error,error," virtual~VariableDecorrTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) ",MatchSource.WIKI,root/html528/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html
Integrability,message,message,"e::GetNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalcSQRMats(const vector<TMVA::Event*,allocator<TMVA::Event*> >&, Int_t maxCls). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the decorrelation transformation. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse decorrelat",MatchSource.WIKI,root/html528/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html
Modifiability,variab,variable,"nHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the decorrelation transformation. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse decorrelation transformation ...; TODO : this is only a copy of the transform method... build the inverse transformation. void CalcSQRMats(const vector<TMVA::Event*,allocator<TMVA::Event*> >& , Int_t maxCls); compute square-root matrices for signal and background. void WriteTransformationToStream(ostream& ) const; write the decorrelation matrix to the stream. void AttachXMLTo(void* parent); node attachment to parent. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read the decorellation matrix from an input stream. void PrintTransformation(ostream& o); prints the transformation matrix. void MakeFunction(ostream& fout, c",MatchSource.WIKI,root/html528/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html
Testability,log,logger,"e::GetNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalcSQRMats(const vector<TMVA::Event*,allocator<TMVA::Event*> >&, Int_t maxCls). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fDecorrMatrices! Decorrelation matrix [class0/class1/.../all classes]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableDecorrTransform( DataSetInfo& dsi ); constructor. ~VariableDecorrTransform(); destructor. void Initialize(); initialisation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the decorrelation matrix and the normalization. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the decorrelation transformation. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse decorrelat",MatchSource.WIKI,root/html528/TMVA__VariableDecorrTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableDecorrTransform.html
Availability,error,error," virtual~VariableGaussTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TOb",MatchSource.WIKI,root/html528/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableGaussTransform.html
Integrability,message,message,"bject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCleanUpCumulativeArrays(TString opt = ""ALL""); voidGetCumulativeDist(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); Double_tOldCumulant(Float_t x, TH1* h) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<std::vector<TH1F*> >fCumulativeDist! The Cummulative distributions ; vector<std::vector<PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the cumulative distributions. const TMVA::Event* Transform(const TMVA::Event *const",MatchSource.WIKI,root/html528/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableGaussTransform.html
Modifiability,variab,variables,". TMVA::VariableGaussTransform. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableGaussTransform. class TMVA::VariableGaussTransform: public TMVA::VariableTransformBase. Gaussian Transformation of input variables. Function Members (Methods); public:. virtual~VariableGaussTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TOb",MatchSource.WIKI,root/html528/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableGaussTransform.html
Testability,log,logger,"bject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCleanUpCumulativeArrays(TString opt = ""ALL""); voidGetCumulativeDist(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); Double_tOldCumulant(Float_t x, TH1* h) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<std::vector<TH1F*> >fCumulativeDist! The Cummulative distributions ; vector<std::vector<PDF*> >fCumulativePDFThe cumulative PDF; UInt_tfElementsperbinav number of events stored per bin in cum dist; Bool_tfFlatNotGauss; Int_tfPdfMaxSmooth; Int_tfPdfMinSmooth. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableGaussTransform(TMVA::DataSetInfo& dsi, TString strcor = """"); constructor; can only be applied one after the other when they are created. But in order to; determine the Gauss transformation. ~VariableGaussTransform( void ); destructor. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the cumulative distributions. const TMVA::Event* Transform(const TMVA::Event *const",MatchSource.WIKI,root/html528/TMVA__VariableGaussTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableGaussTransform.html
Availability,error,error," virtual~VariableIdentityTransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, In",MatchSource.WIKI,root/html528/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableIdentityTransform.html
Integrability,message,message," const; Int_tTMVA::VariableTransformBase::GetNClasses() const; UInt_tTMVA::VariableTransformBase::GetNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; identity transform returns same event. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates ",MatchSource.WIKI,root/html528/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableIdentityTransform.html
Testability,log,logger," const; Int_tTMVA::VariableTransformBase::GetNClasses() const; UInt_tTMVA::VariableTransformBase::GetNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableIdentityTransform( DataSetInfo& dsi ); constructor. void Initialize(); nothing to initialize. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); the identity does not need to be prepared, only calculate the normalization. void AttachXMLTo(void* parent); identity transformation to write to XML; Log() << kFATAL << ""Please implement writing of transformation as XML"" << Endl;. void ReadFromXML(void* trfnode); reding the identity transformation from XML. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; identity transform returns same event. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates ",MatchSource.WIKI,root/html528/TMVA__VariableIdentityTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableIdentityTransform.html
Availability,error,error,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); voidBuildTransformationFromVarInfo(const vector<TMVA::VariableInfo>& var); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TStringTMVA::VariableTransformBase::GetShortName() const; virtual const char*TObject::GetTitle() const; virtual vector<TString>*GetTransformationStrings(Int_t cls) const; virtual UInt_tTObject::GetUniqueID() const; TMVA::Types::EVariableTransformTMVA::VariableTransformBase::GetVariableTransfor",MatchSource.WIKI,root/html528/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableNormalizeTransform.html
Integrability,message,message,"tNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<std::vector<Float_t> >fMax! Max of source range; vector<std::vector<Float_t> >fMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse transformation. void CalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events); compute offset and scale from min and max.",MatchSource.WIKI,root/html528/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableNormalizeTransform.html
Modifiability,variab,variable,"::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<std::vector<Float_t> >fMax! Max of source range; vector<std::vector<Float_t> >fMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse transformation. void CalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events); compute offset and scale from min and max. std::vector<TString>* GetTransformationStrings(Int_t cls) const; creates string with variable transformations applied. void WriteTransformationToStream(ostream& ) const; write the decorrelation matrix to the stream. void AttachXMLTo(void* parent); create XML description of Normalize transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. BuildTransformationFromVarInfo(const vector<TMVA::VariableInfo>& var); this method is only used when building a normalization transformation; from old text files; in this case regression didn't exist and there were no targets. void ReadTransformationFromStream(istream& , const TString& ); Read the variable ranges from an input stream. void PrintTransformation(ostream& o); prints the transformation ranges. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates a normalizing function; TODO include target-transformation into makefunction. VariableNormalizeTransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg",MatchSource.WIKI,root/html528/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableNormalizeTransform.html
Testability,log,logger,"tNTargets() const; UInt_tTMVA::VariableTransformBase::GetNVariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<std::vector<Float_t> >fMax! Max of source range; vector<std::vector<Float_t> >fMin! Min of source range. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariableNormalizeTransform( DataSetInfo& dsi ); constructor. ~VariableNormalizeTransform(). void Initialize(); initialization of the normalization transformation. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); prepare transformation. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the inverse transformation. void CalcNormalizationParams(const vector<TMVA::Event*,allocator<TMVA::Event*> >& events); compute offset and scale from min and max.",MatchSource.WIKI,root/html528/TMVA__VariableNormalizeTransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableNormalizeTransform.html
Availability,error,error," virtual~VariablePCATransform(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TMVA::VariableTransformBase::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; stati",MatchSource.WIKI,root/html528/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html
Energy Efficiency,allocate,allocated,"; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components using the ROOT class TPrincipal; and the normalization. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the principal component analysis. const TMVA::Event* InverseTransform(const TMVA::Event *const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation. void CalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. std::vector<Float_t> X2P(const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: VariablePCATransform.h 33993 2010-06-19 11:25:14Z stelzer $ » Last generated: 2010-11-26 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html
Integrability,message,message,"ariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); vector<Float_t>X2P(const vector<Float_t>&, Int_t cls) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components using the ROOT class TPrincipal; and the normalization. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the principal component an",MatchSource.WIKI,root/html528/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html
Testability,log,logger,"ariables() const; voidTObject::MakeZombie(); voidTMVA::VariableTransformBase::SetCreated(Bool_t c = kTRUE); voidTMVA::VariableTransformBase::SetName(const TString& c); voidTMVA::VariableTransformBase::SetNVariables(UInt_t i); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Targets(); vector<TMVA::VariableInfo>&TMVA::VariableTransformBase::Variables(). private:. voidCalculatePrincipalComponents(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); vector<Float_t>X2P(const vector<Float_t>&, Int_t cls) const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*TMVA::VariableTransformBase::fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&TMVA::VariableTransformBase::fDsi; TMVA::MsgLogger*TMVA::VariableTransformBase::fLogger! message logger; TMVA::TMVAVersion_tTMVA::VariableTransformBase::fTMVAVersion; TMVA::Event*TMVA::VariableTransformBase::fTransformedEventholds the current transformed event. private:. vector<TMatrixD*>fEigenVectorseigenvectors; vector<TVectorD*>fMeanValuesmean values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; VariablePCATransform( DataSetInfo& dsi ); constructor. ~VariablePCATransform(); destructor. void Initialize(); initialization of the transformation.; Has to be called in the preparation and not in the constructor,; since the number of classes it not known at construction, but; only after the creation of the DataSet which might be later. Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); calculate the principal components using the ROOT class TPrincipal; and the normalization. const TMVA::Event* Transform(const TMVA::Event *const , Int_t cls) const; apply the principal component an",MatchSource.WIKI,root/html528/TMVA__VariablePCATransform.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariablePCATransform.html
Availability,avail,available,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Deployability,update,update,"nt transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); update min and max of a given variable (target) and a given transformation method. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classnam",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Integrability,message,message,"Int_t bufsize = 0) const; virtual voidWriteTransformationToStream(ostream& o) const. protected:. voidCalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tGetNClasses() const; UInt_tGetNTargets() const; UInt_tGetNVariables() const; voidTObject::MakeZombie(); voidSetCreated(Bool_t c = kTRUE); voidSetName(const TString& c); voidSetNVariables(UInt_t i); vector<TMVA::VariableInfo>&Targets(); vector<TMVA::VariableInfo>&Variables(). private:. voidUpdateNorm(Int_t ivar, Double_t x). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::MsgLogger*fLogger! message logger; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only in",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Modifiability,variab,variables,"() const; voidTObject::MakeZombie(); voidSetCreated(Bool_t c = kTRUE); voidSetName(const TString& c); voidSetNVariables(UInt_t i); vector<TMVA::VariableInfo>&Targets(); vector<TMVA::VariableInfo>&Variables(). private:. voidUpdateNorm(Int_t ivar, Double_t x). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::MsgLogger*fLogger! message logger; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); update min and max of a given variable (target) and a given transformation method. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. co",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Security,access,accessors," if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only indicate that transformation occurred. void UpdateNorm(Int_t ivar, Double_t x); update min and max of a given variable (target) and a given transformation method. void Initialize(). Bool_t PrepareTransformation(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ). const Event* Transform(const TMVA::Event *const , Int_t cls) const. const Event* InverseTransform(const TMVA::Event *const , Int_t cls) const. void SetEnabled(Bool_t e); accessors. { fEnabled = e; }. void SetNormalise(Bool_t n); { fNormalise = n; }. Bool_t IsEnabled() const; { return fEnabled; }. Bool_t IsCreated() const; { return fCreated; }. Bool_t IsNormalised() const; { return fNormalise; }. void SetUseSignalTransform(Bool_t e = kTRUE); { fUseSignalTransform = e; }. Bool_t UseSignalTransform() const; { return fUseSignalTransform; }. const char* GetName() const; { return fTransformName.Data(); }. TString GetShortName() const; { TString a(fTransformName); a.ReplaceAll(""Transform"",""""); return a; }. void WriteTransformationToStream(ostream& o) const. void ReadTransformationFromStream(istream& istr, const TString& classname = """"). void AttachXMLTo(void* parent). void ReadFromXML(void* trfnode). Types::EVariableTransform GetVariableTransform() const; { return fVariableTransform; }. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); writer of function code. void PrintTransformation(ostream& ); provi",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Testability,log,logger,"Int_t bufsize = 0) const; virtual voidWriteTransformationToStream(ostream& o) const. protected:. voidCalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tGetNClasses() const; UInt_tGetNTargets() const; UInt_tGetNVariables() const; voidTObject::MakeZombie(); voidSetCreated(Bool_t c = kTRUE); voidSetName(const TString& c); voidSetNVariables(UInt_t i); vector<TMVA::VariableInfo>&Targets(); vector<TMVA::VariableInfo>&Variables(). private:. voidUpdateNorm(Int_t ivar, Double_t x). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMVA::Event*fBackTransformedEventholds the current back-transformed event; TMVA::DataSetInfo&fDsi; TMVA::MsgLogger*fLogger! message logger; TMVA::TMVAVersion_tfTMVAVersion; TMVA::Event*fTransformedEventholds the current transformed event. private:. Bool_tfCreatedhas been created; Bool_tfEnabledhas been enabled; UInt_tfNVarsnumber of variables; Bool_tfNormalisenormalise input variables; vector<TMVA::VariableInfo>fTargetsevent targets [saved to weight file --> TODO ]; TStringfTransformNamename of transformation; Bool_tfUseSignalTransformtrue if transformation bases on signal data; TMVA::Types::EVariableTransformfVariableTransformDecorrelation, PCA, etc.; vector<TMVA::VariableInfo>fVariablesevent variables [saved to weight file]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~VariableTransformBase(). void CalcNorm(const vector<TMVA::Event*,allocator<TMVA::Event*> >& ); method to calculate minimum, maximum, mean, and RMS for all; variables used in the MVA. std::vector<TString>* GetTransformationStrings(Int_t cls) const; default transformation output; --> only in",MatchSource.WIKI,root/html528/TMVA__VariableTransformBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html
Availability,error,error,"const TMySQLResult&); virtual~TMySQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTSQLResult::GetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidT",MatchSource.WIKI,root/html528/TMySQLResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLResult.html
Availability,error,error,"ult, ULong_t rowHandle); virtual~TMySQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, con",MatchSource.WIKI,root/html528/TMySQLRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLRow.html
Availability,error,error,"""""); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidTSQLServer::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_tExec(const char* sql); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSQLResult*GetColumns(const char* dbname, const char* table, const char* wild = 0); virtual TSQLResult*GetDataBases(const char* wild = 0); const char*TSQLServer::GetDB() const; const char*TSQLServer::GetDBMS() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLServer::GetErrorCode() const; virtual const char*TSQLServer::GetErrorMsg() const; static const char*TSQLServer::GetFloatFormat(); const char*TSQLServer::GetHost() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetMaxIdentifierLength(); virtual const char*TObject::GetName() const; virtual ch",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Integrability,interface,interface,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Modifiability,plugin,plugin,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Safety,timeout,timeout,"er; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLServer(const char* db, const char* uid, const char* pw); Open a connection to a MySQL DB server. The db arguments should be; of the form ""mysql://<host>[:<port>][/<database>]"", e.g.:; ""mysql://pcroot.cern.ch:3456/test"". The uid is the username and pw; the password that should be used for the connection. In addition, several parameters can be specified in url after ""?"" symbol:; timeout=N n is connect timeout is seconds; socket=socketname socketname should be name of Unix socket, used; for connection; multi_statements tell the server that the client may send multiple; statements in a single string (separated by ;);; multi_results tell the server that the client can handle multiple; result sets from multiple-statement executions or; stored procedures; reconnect=0|1 enable or disable automatic reconnection to the server; if the connection is found to have been lost; compress use the compressed client/server protocol; cnf_file=filename Read options from the named option file instead of; from my.cnf; cnf_group=groupname Read options from the named group from my.cnf or the; file specified with cnf_file option; If several parameters are specified, they should be separated by ""&"" symbol; Example of connection argument:; TSQLServer::Connect(""mysql://host.domain/test?timeout=10&multi_statements"");. ~TMySQLServer(); Close connection to MySQL DB server. void Close(Option_t* opt = """"); Close connection to MySQL DB server. TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. Bool",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Security,access,access,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Testability,test,test,". TMySQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » MYSQL; » TMySQLServer. class TMySQLServer: public TSQLServer. TMySQLServer. MySQL server plugin implementing the TSQLServer interface. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; mysql://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test. As an example of connecting to mysql we assume that the server is; running on the local host and that you have access to a database; named ""test"" by connecting using an account that has a username and; password of ""tuser"" and ""tpass"". You can set up this account; by using the ""mysql"" program to connect to the server as the MySQL; root user and issuing the following statement:. mysql> GRANT ALL ON test.* TO 'tuser'@'localhost' IDENTIFIED BY 'tpass';. If the test database does not exist, create it with this statement:. mysql> CREATE DATABASE test;. If you want to use a different server host, username, password,; or database name, just substitute the appropriate values.; To connect do:. TSQLServer *db = TSQLServer::Connect(""mysql://localhost/test"", ""tuser"", ""tpass"");. Function Members (Methods); public:. TMySQLServer(const TMySQLServer&); TMySQLServer(const char* db, const char* uid, const char* pw); virtual~TMySQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db",MatchSource.WIKI,root/html528/TMySQLServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLServer.html
Availability,error,error,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTSQLStatement::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static unsigned longGetAllocSizeLimit(); virtual Bool_tGetBinary(Int_t npar, void*& mem, Long_t& size); virtual Int_tGetBufferLength() const; virtual Bool_tGetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); virtual Bool_tGetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Int_tTSQLStatement::GetDay(Int_t); virtual Double_tGetDouble(Int_t npar); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLStatement::GetErrorCode() const; virtual const char*TSQLStatement::GetErrorMsg() const; virtual const char*GetFieldName(Int_t nfield); ",MatchSource.WIKI,root/html528/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLStatement.html
Energy Efficiency,allocate,allocate,"g64(Int_t npar); Return field value as unsigned 64-bit integer. Double_t GetDouble(Int_t npar); Return field value as double. const char * GetString(Int_t npar); Return field value as string. Bool_t GetBinary(Int_t npar, void*& mem, Long_t& size); Return field value as binary array. Bool_t GetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); Return field value as date. Bool_t GetTime(Int_t npar, Int_t& hour, Int_t& min, Int_t& sec); Return field value as time. Bool_t GetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Return field value as date & time. Bool_t GetTimestamp(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec, Int_t& ); Return field value as time stamp. Bool_t SetSQLParamType(Int_t npar, int sqltype, bool sig, unsigned long sqlsize = 0); Set parameter type to be used as buffer.; Used in both setting data to database and retriving data from data base.; Initialize proper MYSQL_BIND structure and allocate required buffers. void * BeforeSet(const char* method, Int_t npar, Int_t sqltype, Bool_t sig = kTRUE, unsigned long size = 0); Check boundary condition before setting value of parameter.; Return address of parameter buffer. Bool_t SetNull(Int_t npar); Set NULL as parameter value.; If NULL should be set for statement parameter during first iteration,; one should call before proper Set... method to identify type of argument for; the future. For instance, if one suppose to have double as type of parameter,; code should look like:; stmt->SetDouble(2, 0.);; stmt->SetNull(2);. Bool_t SetInt(Int_t npar, Int_t value); Set parameter value as integer. Bool_t SetUInt(Int_t npar, UInt_t value); Set parameter value as unsigned integer. Bool_t SetLong(Int_t npar, Long_t value); Set parameter value as long integer. Bool_t SetLong64(Int_t npar, Long64_t value); Set parameter value as 64-bit integer. Bool_t SetULong64(Int_t npar, ULong64_t value); Set parameter value as unsigned 64-bi",MatchSource.WIKI,root/html528/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLStatement.html
Integrability,message,message,"tring(Int_t npar); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidFreeBuffers(); Bool_tIsResultSetMode() const; Bool_tIsSetParsMode() const; voidTObject::MakeZombie(); voidSetBuffersNumber(Int_t n); voidTSQLStatement::SetError(Int_t code, const char* msg, const char* method = 0); Bool_tSetSQLParamType(Int_t npar, int sqltype, bool sig, unsigned long sqlsize = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. MYSQL_BIND*fBind! array of bind data; TMySQLStatement::TParamData*fBuffer! parameter definition structures; Int_tTSQLStatement::fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output ; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Re",MatchSource.WIKI,root/html528/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLStatement.html
Security,access,access,"fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output ; Int_tfIterationCount! number of iteration; Bool_tfNeedParBind! indicates when parameters bind should be called; Int_tfNumBuffers! number of statement parameters; MYSQL_STMT*fStmt! executed statement; Int_tfWorkingMode! 1 - setting parameters, 2 - retrieving results; static ULong64_tfgAllocSizeLimit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMySQLStatement(MYSQL_STMT* stmt, Bool_t errout = kTRUE); Normal constructor.; Checks if statement contains parameters tags. ~TMySQLStatement(); Destructor. void Close(Option_t* = """"); Close statement. Bool_t Process(); Process statement. Int_t GetNumAffectedRows(); Return number of affected rows after statement is processed. Int_t GetNumParameters(); Return number of statement parameters. Bool_t StoreResult(); Store result of statement processing to access them; via GetInt(), GetDouble() and so on methods. Int_t GetNumFields(); Return number of fields in result set. const char* GetFieldName(Int_t nfield); Returns field name in result set. Bool_t NextResultRow(); Shift cursor to nect row in result set. Bool_t NextIteration(); Increment iteration counter for statement, where parameter can be set.; Statement with parameters of previous iteration; automatically will be applied to database. void FreeBuffers(); Release all buffers, used by statement. void SetBuffersNumber(Int_t n); Allocate buffers for statement parameters/ result fields. const char* ConvertToString(Int_t npar); Convert field value to string. long double ConvertToNumeric(Int_t npar); Convert field to numeric value. Bool_t IsNull(Int_t npar); Checks if field value is null. Int_t GetInt(Int_t npar); Return field value as integer. UInt_t GetUInt(Int_t npar); Return field value as unsigned integer. Long_t GetLong(Int_t npar); Return field value as long integer. Long64_t ",MatchSource.WIKI,root/html528/TMySQLStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TMySQLStatement.html
Availability,error,error," TNamed(const char* name, const char* title); TNamed(const TString& name, const TString& title); virtual~TNamed(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tHash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* cl",MatchSource.WIKI,root/html528/TNamed.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNamed.html
Availability,error,error,"TFile::CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*TFile::CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTFile::DrawMap(const char* keys = ""*"", Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTFile::FillBuffer(char*& buffer); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(const char* name); static TFile::EAsyncOpenStatusTFile::GetAsyncOpenStatus(TFileOpenHandle* handle); Int_tTFile::GetBestBuffer() cons",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Integrability,protocol,protocol,". TNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TNetFile. class TNetFile: public TFile. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Performance,cache,cacheDir,"adTObject(TObject* obj, const char* keyname); virtual Int_tTFile::Recover(); virtual voidTDirectory::RecursiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeou",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Safety,safe,safe,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetFile(); TNetFile(const char* url, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); virtual~TNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(co",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Security,password,password,"iption; function members; data members; class charts. ROOT; » NET; » NET; » TNetFile. class TNetFile: public TFile. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by ha",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Testability,log,login,"e is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (M",MatchSource.WIKI,root/html528/TNetFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetFile.html
Availability,error,error,"_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp = 0); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TS",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Integrability,protocol,protocol,". TNetSystem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TNetSystem. class TNetSystem: public TSystem. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the pro",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Modifiability,config,configure,"onst char* path, const char* proto). private:. TNetSystem(const TNetSystem&); virtual void*GetDirPtr() const; TNetSystem&operator=(const TNetSystem&). Data Members; public:. enum TSystem::EAclicMode { kDefault; kDebug; kOpt; };; enum TSystem::EAclicProperties { kFlatBuildDir; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSystem::EAclicModeTSystem::fAclicModeWhether the compilation should be done debug or opt; Int_tTSystem::fAclicPropertiesVarious boolean flag for change ACLiC's behavior.; Int_tTSystem::fBeepDurationUsed by Beep(); Int_tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel o",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Performance,optimiz,optimized,"tTSystem::fBeepFreqUsed by Beep(); TStringTSystem::fBuildArchArchitecure for which ROOT was built (passed to ./configure); TStringTSystem::fBuildCompilerCompiler used to build this ROOT; TStringTSystem::fBuildCompilerVersionCompiler version used to build this ROOT; TStringTSystem::fBuildDirLocation where to build ACLiC shared library and use as scratch area.; TStringTSystem::fBuildNodeDetailed information where ROOT was built; TSeqCollection*TSystem::fCompiledList of shared libs from compiled macros to be deleted; Bool_tTSystem::fDoneTrue if eventloop should be finished; TSeqCollection*TSystem::fFileHandlerList of file handlers; TStringTSystem::fFlagsDebugFlags for debug compilation; TStringTSystem::fFlagsOptFlags for optimized compilation; TSeqCollection*TSystem::fHelpersList of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); Bool_tfIsLocalTRUE if the path points to this host; TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringfLocalPrefixif fIsLocal, prefix to be prepend locally; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; ",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Safety,safe,safe,"/ after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (Methods); public:. TNetSystem(Bool_t ftpowner = kTRUE); TNetSystem(const char* url, Bool_t ftpowner = kTRUE); virtual~TNetSystem(); virtual voidTSystem::Abort(int code = 0); voidTObject::AbstractMethod(const char* method) const; virtual intTSystem::AcceptConnection(int sock); virtual Bool_tAccessPathName(const char* path, EAccessMode mode); virtual voidTSystem::AddFileHandler(TFileHandler* fh); virtual voidTSystem::AddIncludePath(const char* includePath); virtual voidTSystem::AddLinkedLibs(const char* linkedLib); virtual voidTSystem::AddSignalHandler(TSignalHandler* sh); virtual voidTSystem::AddStdExceptionHand",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Security,password,password,"; function members; data members; class charts. ROOT; » NET; » NET; » TNetSystem. class TNetSystem: public TSystem. TNetFile. A TNetFile is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by ha",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Testability,log,login,"e is like a normal TFile except that it reads and writes; its data via a rootd server (for more on the rootd daemon see the; source files root/rootd/src/*.cxx). TNetFile file names are in; standard URL format with protocol ""root"" or ""roots"". The following; are valid TNetFile URL's:. roots://hpsalo/files/aap.root; root://hpbrun.cern.ch/root/hsimple.root; root://pcna49a:5151/~na49/data/run821.root; root://pcna49d.cern.ch:5050//v1/data/run810.root. The only difference with the well known httpd URL's is that the root; of the remote file tree is the user's home directory. Therefore an; absolute pathname requires a // after the host or port specifier; (see last example). Further the expansion of the standard shell; characters, like ~, $, .., are handled as expected.; TNetFile (actually TUrl) uses 1094 as default port for rootd. Connecting to a rootd requires the remote user id and password.; TNetFile allows three ways for you to provide your login:; 1) Setting it globally via the static functions:; TAuthenticate::SetGlobalUser() and; TAuthenticate::SetGlobalPasswd(); 2) Getting it from the ~/.netrc file (same file as used by ftp); 3) Command line prompt; The different methods will be tried in the order given above.; On machines with AFS rootd will authenticate using AFS (if it was; compiled with AFS support). If the protocol is specified as ""roots"" a secure authetication; method will be used. The secure method uses the SRP, Secure Remote; Passwords, package. SRP uses a so called ""asymmetric key exchange //; protocol"" in which no passwords are ever send over the wire. This //; protocol is safe against all known security attacks. For more see:. NetFile //; ; //; If the protocol is specified as ""rootk"" kerberos5 will be used for; authentication. The rootd daemon lives in the directory $ROOTSYS/bin. It can be; started either via inetd or by hand from the command line (no need; to be super user). For more info about rootd see the web page:. NetFile //; ; //. Function Members (M",MatchSource.WIKI,root/html528/TNetSystem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNetSystem.html
Availability,error,error,"r* extF = """", const char* extD = """"); virtual~TNeuron(); voidTObject::AbstractMethod(const char* method) const; voidAddInLayer(TNeuron*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidForceExternalValue(Double_t value); Double_tGetBranch() const; Double_tGetDeDw() const; Double_tGetDEDw() const; Double_tGetDerivative() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetError() const; virtual const char*TObject::GetIconName() const; TNeuron*GetInLayer(Int_t n) const; Double_tGetInput() const; virtual const char*TNamed::GetName() const; const Double_t*GetNormalisation() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption()",MatchSource.WIKI,root/html528/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNeuron.html
Modifiability,variab,variables,"uron an input.; The formula is automatically normalized to mean=0, RMS=1.; This normalisation is used by GetValue() (input neurons); and GetError() (output neurons). Double_t GetBranch() const; Returns the formula value. Double_t GetInput() const; Returns neuron input. Double_t GetValue() const; Computes the output using the appropriate function and all; the weighted inputs, or uses the branch as input.; In that case, the branch normalisation is also used. Double_t GetDerivative() const; computes the derivative for the appropriate function; at the working point. Double_t GetError() const; Computes the error for output neurons.; Returns 0 for other neurons. Double_t GetTarget() const; Computes the normalized target pattern for output neurons.; Returns 0 for other neurons. Double_t GetDeDw() const; Computes the derivative of the error wrt the neuron weight. void ForceExternalValue(Double_t value); Uses the branch type to force an external value. void SetNormalisation(Double_t mean, Double_t RMS); Sets the normalization variables.; Any input neuron will return (branch-mean)/RMS.; When UseBranch is called, mean and RMS are automatically set; to the actual branch mean and RMS. void SetWeight(Double_t w); Sets the neuron weight to w.; The neuron weight corresponds to the bias in the; linear combination of the inputs. void SetNewEvent() const; Inform the neuron that inputs of the network have changed,; so that the buffered values have to be recomputed. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the neuron weight. TNeuron(TNeuron::ENeuronType type = kSigmoid, const char* name = """", const char* title = """", const char* extF = """", const char* extD = """"); {}. TSynapse* GetPre(Int_t n) const; { return (TSynapse*) fpre.At(n); }. TSynapse* GetPost(Int_t n) const; { return (TSynapse*) fpost.At(n); }. TNeuron* GetInLayer(Int_t n) const; { return (TNeuron*) flayer.At(n); }. ENeuronType GetType() const. Double_t GetWeight() const; { return fWeight; }. const ",MatchSource.WIKI,root/html528/TNeuron.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNeuron.html
Availability,avail,available,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0); virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); stat",MatchSource.WIKI,root/html528/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNewChainDlg.html
Integrability,message,messages,"e::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelButtoncancel button; TObject*fChainactual TDSet or TChain; TSeqCollection*fChainscollection of datasets; TGFileContainer*fContentsmacro files container; TGLVContainer*fLVContainerand its container; TGListView*fListViewmemory objects list view; TGTextEntry*fNamedataset name text entry; TGTextBuffer*fNameBufbuffer for dataset name; TGTextButton*fOkButtonok button. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0); Create a new chain dialog box. Used to list chains present in memory; and offers the possibility to create new ones by executing macros; directly from the associate file container. ~TNewChainDlg(); Delete chain dialog. void OnElementSelected(TObject* obj); Emits OnElementSelected signal if dset is not zero. void OnElementClicked(TGLVEntry* entry, Int_t btn); Handle click in the Memory list view and put the type; and name of selected object in the text entry. void UpdateList(); Update Memory list view. void DisplayDirectory(const TString& fname); Display content of directory. void OnDoubleClick(TGLVEntry* , Int_t ); Handle double click in the File container. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new chain dialog. void CloseWindow(); Close file dialog. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionDialogs.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TNewChainDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNewChainDlg.html
Availability,avail,available,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(",MatchSource.WIKI,root/html528/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNewQueryDlg.html
Deployability,update,update," changed; TGNumberEntry*fNumEntriesnumber of entries selector; TGNumberEntry*fNumFirstEntryfirst entry selector; TQueryDescription*fQueryquery description class; TGTextEntry*fTxtChainchain name text entry; TGTextEntry*fTxtEventListevent list text entry; TGTextEntry*fTxtOptionsoptions text entry; TGTextEntry*fTxtQueryNamequery name text entry; TGTextEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; »",MatchSource.WIKI,root/html528/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNewQueryDlg.html
Integrability,message,messages,"ns text entry; TGTextEntry*fTxtQueryNamequery name text entry; TGTextEntry*fTxtSelectorselector name text entry; TSessionViewer*fViewerpointer on main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); Create a new Query dialog, used by the Session Viewer, to Edit a Query if; the editmode flag is set, or to create a new one if not set. ~TNewQueryDlg(); Delete query dialog. void Build(TSessionViewer* gui); Build the ""new query"" dialog. void CloseWindow(); Called when window is closed via the window manager. void OnNewQueryMore(); Show/hide options frame and update button text accordingly. void OnBrowseChain(); Call new chain dialog. void OnElementSelected(TObject* obj); Handle OnElementSelected signal coming from new chain dialog. void OnBrowseSelector(); Open file browser to choose selector macro. void OnBrowseEventList(); Browse event list. void OnBtnSaveClicked(); Save current settings in main session viewer. void OnBtnSubmitClicked(); Save and submit query description. void OnBtnCloseClicked(); Close dialog. void Popup(); Display dialog and set focus to query name text entry. void SettingsChanged(); Settings have changed, update GUI accordingly. void UpdateFields(TQueryDescription* desc); Update entry fields with query description values. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Process messages for new query dialog.; Essentially used to navigate between text entry fields. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionDialogs.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TNewQueryDlg.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNewQueryDlg.html
Availability,error,error,"Browse(TBrowser* b); virtual voidBuildListOfNodes(); virtual voidcd(const char* path = 0)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*GetListOfNodes() const; virtual TRotMatrix*GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*GetNode(const char* name) const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html528/TNode.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNode.html
Availability,error,error,"rtual voidTNode::BuildListOfNodes(); virtual voidTNode::cd(const char* path = 0)MENU ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTNode::DrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TList*TNode::GetListOfNodes() const; virtual TRotMatrix*TNode::GetMatrix() const; virtual const char*TNamed::GetName() const; virtual TNode*TNode::GetNode(const char* name) const; virtual char*TNode::GetObjectInfo(Int_t px, In",MatchSource.WIKI,root/html528/TNodeDiv.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNodeDiv.html
Availability,error,error,"rowsable(const TNonSplitBrowsable&); virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() ",MatchSource.WIKI,root/html528/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html
Integrability,depend,depending,"tic voidTVirtualBranchBrowsable::UnregisterGenerator(TVirtualBranchBrowsable::MethodCreateListOfBrowsables_t generator). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Constructor. Creates a TNonSplitBrowsable from a TStreamerElement, containing branch; and (if applicable) parent TVirtualBranchBrowsable. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Given either a branch ""branch"" or a ""parent"" TVirtualBranchBrowsable, we fill; ""list"" with objects of type TNonSplitBrowsable which represent the members; of class ""cl"" (and its base classes' members). void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TNonSplitBrowsable(); {}. TNonSplitBrowsable(const TStreamerElement* element, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-12-01 01:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html
Modifiability,extend,extend,". TNonSplitBrowsable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* bra",MatchSource.WIKI,root/html528/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html
Performance,cache,cached,"; » TREE; » TREE; » TNonSplitBrowsable. class TNonSplitBrowsable: public TVirtualBranchBrowsable. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TNonSplitBrowsable(cons",MatchSource.WIKI,root/html528/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html
Usability,simpl,simple,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TNonSplitBrowsable(const TNonSplitBrowsable&); virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable",MatchSource.WIKI,root/html528/TNonSplitBrowsable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html
Availability,error,error,"TTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Float_t* x); Int_tFill(Int_t x0); Int_tFill(Double_t x0); virtual Int_tFill(Float_t x0, Float_t x1 = 0, Float_t x2 = 0, Float_t x3 = 0, Float_t x4 = 0, Float_t x5 = 0, Float_t x6 = 0, Float_t x7 = 0, Float_t x8 = 0, Float_t x9 = 0, Float_t x10 = 0, Float_t x11 = 0, Float_t x12 = 0, Float_t x13 = 0, Float_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t ",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Deployability,update,updateExisting,"tBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::Se",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Energy Efficiency,energy,energy,"onds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtuple(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtuple(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content of the ntuple. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Float_t",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Modifiability,variab,variables,". TNtuple. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtuple. class TNtuple: public TTree. TNtuple. A simple tree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtuple(name,title,varlist,bufsize); It is filled via:; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....). Function Members (Methods); public:. TNtuple(); TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); virtual~TNtuple(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, long address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const ",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Performance,cache,cachesize,"rtual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolo",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Usability,simpl,simple,". TNtuple. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtuple. class TNtuple: public TTree. TNtuple. A simple tree restricted to a list of float variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtuple(name,title,varlist,bufsize); It is filled via:; TNtuple::Fill(*x) or; TNtuple::Fill(v1,v2,v3.....). Function Members (Methods); public:. TNtuple(); TNtuple(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); virtual~TNtuple(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, long address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const ",MatchSource.WIKI,root/html528/TNtuple.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtuple.html
Availability,error,error,"TTree::Delete(Option_t* option = """")MENU ; virtual voidTTree::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTree::Draw(Option_t* opt); virtual Long64_tTTree::Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tTTree::Draw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(const Double_t* x); virtual Int_tFill(Double_t x0, Double_t x1, Double_t x2 = 0, Double_t x3 = 0, Double_t x4 = 0, Double_t x5 = 0, Double_t x6 = 0, Double_t x7 = 0, Double_t x8 = 0, Double_t x9 = 0, Double_t x10 = 0, Double_t x11 = 0, Double_t x12 = 0, Double_t x13 = 0, Double_t x14 = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*TTree::FindBranch(const char* name); virtual TLeaf*TTree::FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t f",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Deployability,update,updateExisting,"tBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTTree::SetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMarker::SetMarkerColor(Color_t tcolor = 1); virtual voidTAttMarker::Se",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Energy Efficiency,energy,energy,"nds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNtupleD(); Default constructor for Ntuple*-*-*-*-*-*-*-*-; *-* ==============================. TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); Create an Ntuple*-*-; *-* ================; The parameter varlist describes the list of the ntuple variables; separated by a colon:; example: ""x:y:z:energy""; For each variable in the list a separate branch is created. NOTE:; -Use TTree to create branches with variables of different data types.; -Use TTree when the number of branches is large (> 100).; -. ~TNtupleD(); Default destructor for an Ntuple*-*-*-*-*-*-; *-* ================================. void ResetBranchAddress(TBranch* ); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void ResetBranchAddresses(); Reset the branch addresses to the internal fArgs array. Use this; method when the addresses were changed via calls to SetBranchAddress(). void Browse(TBrowser* b); Browse content. Int_t Fill(); -*-*Fill a Ntuple with current values in fArgs; *-* ==========================================; Note that this function is protected.; Currently called only by TChain::Merge. Int_t Fill(const Double_t* x); Fill a",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Modifiability,variab,variables,". TNtupleD. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtupleD. class TNtupleD: public TTree. TNtupleD. A simple tree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtupleD(name,title,varlist,bufsize); It is filled via:; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....). Function Members (Methods); public:. TNtupleD(); TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); virtual~TNtupleD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, long address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Br",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Performance,cache,cachesize,"rtual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolo",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Usability,simpl,simple,". TNtupleD. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TNtupleD. class TNtupleD: public TTree. TNtupleD. A simple tree restricted to a list of double variables only. Each variable goes to a separate branch. A Ntuple is created via; TNtupleD(name,title,varlist,bufsize); It is filled via:; TNtupleD::Fill(*x) or; TNtupleD::Fill(v1,v2,v3.....). Function Members (Methods); public:. TNtupleD(); TNtupleD(const char* name, const char* title, const char* varlist, Int_t bufsize = 32000); virtual~TNtupleD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTTree::AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); virtual voidTTree::AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual TFriendElement*TTree::AddFriend(const char* treename, const char* filename = """"); virtual TFriendElement*TTree::AddFriend(const char* treename, TFile* file); virtual TFriendElement*TTree::AddFriend(TTree* tree, const char* alias = """", Bool_t warn = kFALSE); virtual voidTTree::AddTotBytes(Int_t tot); virtual voidTTree::AddZipBytes(Int_t zip); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Long64_tTTree::AutoSave(Option_t* option = """"); virtual Int_tTTree::Branch(TList* list, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual Int_tTTree::Branch(TCollection* list, Int_t bufsize = 32000, Int_t splitlevel = 99, const char* name = """"); virtual TBranch*TTree::Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, char* address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Branch(const char* name, long address, const char* leaflist, Int_t bufsize = 32000); TBranch*TTree::Br",MatchSource.WIKI,root/html528/TNtupleD.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TNtupleD.html
Availability,error,error,"ction::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntries() const; Int_tGetEntriesFast() const; virtual const char*TObject::GetIconName() const; Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int",MatchSource.WIKI,root/html528/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjArray.html
Energy Efficiency,efficient,efficient," if obj is last object. TObject * Before(const TObject* obj) const; Return the object before obj. Returns 0 if obj is first object. void Clear(Option_t* option = """"); Remove all objects from the array. Does not delete the objects; unless the TObjArray is the owner (set via SetOwner()). void Compress(); Remove empty slots from array. void Delete(Option_t* option = """"); Remove all objects from the array AND delete all heap based objects. void Expand(Int_t newSize); Expand or shrink the array to newSize elements. TObject * FindObject(const char* name) const; Find an object in this collection using its name. Requires a sequential; scan till the object has been found. Returns 0 if object with specified; name is not found. TObject * FindObject(const TObject* obj) const; Find an object in this collection using the object's IsEqual(); member function. Requires a sequential scan till the object has; been found. Returns 0 if object is not found.; Typically this function is overridden by a more efficient version; in concrete collection classes (e.g. THashTable). void Streamer(TBuffer& b); Stream all objects in the array to or from the I/O buffer. TObject * First() const; Return the object in the first slot. TObject * Last() const; Return the object in the last filled slot. Returns 0 if no entries. Int_t GetEntries() const; Return the number of objects in array (i.e. number of non-empty slots).; Attention: use this method ONLY if you want to know the number of; non-empty slots. This function loops over the complete array and; is therefore very slow when applied in a loop. Most of the time you; better use GetEntriesFast() (only in case when there are no empty slots). Int_t GetAbsLast() const; Return absolute index to last object in array. Returns -1 in case; array is empty. Int_t GetLast() const; Return index of last object in array. Returns lowerBound-1 in case; array is empty. TObject ** GetObjectRef(const TObject* obj) const; Return address of pointer obj. If obj is 0 returns ",MatchSource.WIKI,root/html528/TObjArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjArray.html
Availability,error,error,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Energy Efficiency,allocate,allocated,"rite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidDoError(int level, const char* location, const char* fmt, va_list va) const; voidMakeZombie(). Data Members; public:. enum EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. UInt_tfBitsbit field status word; UInt_tfUniqueIDobject unique identifier; static Long_tfgDtorOnlyobject for which to call dtor only (i.e. no delete); static Bool_tfgObjectStatif true keep track of objects in TObjectTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TObject(); TObject constructor. It sets the two data words of TObject to their; initial values. The unique ID is set to 0 and the status word is; set depending if the object is created on the stack or allocated; on the heap. Depending on the ROOT environment variable ""Root.MemStat""; (see TEnv) the object is added to the global TObjectTable for; bookkeeping. TObject(const TObject& object); TObject copy ctor. TObject& operator=(const TObject& rhs); TObject assignment operator. void Copy(TObject& object) const; Copy this to obj. ~TObject(); TObject destructor. Removes object from all canvases and object browsers; if observer bit is on and remove from the global object table. void AppendPad(Option_t* option = """"); Append graphics object to current pad. In case no current pad is set; yet, create a default canvas with the name ""c1"". void Browse(TBrowser* b); Browse object. May be overridden for another default action. const char * ClassName() const; Returns name of class to which the object belongs. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If the object derives from TNamed, this functi",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Integrability,protocol,protocol,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Modifiability,inherit,inherits,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Safety,safe,safer,"uffer object is filled via the class::Streamer function. -If the file is compressed (default) a second buffer is created to; hold the compressed buffer. -Reservation of the corresponding space in the file by looking; in the TFree list of free blocks of the file. -The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object.; By default, the buffersize will be taken from the average buffer size; of all objects written to the current file so far. If a name is specified, it will be the name of the key.; If name is not given, the name of the key will be the name as returned; by GetName(). The option can be a combination of:; kSingleKey, kOverwrite or kWriteDelete; Using the kOverwrite option a previous key with the same name is; overwritten. The previous key is deleted before writing the new object.; Using the kWriteDelete option a previous key with the same name is; deleted only after the new object has been written. This option; is safer than kOverwrite but it is slower.; The kSingleKey option is only used by TCollection::Write() to write; a container with a single key instead of each object in the container; with its own key. An object is read from the file into memory via TKey::Read() or; via TObject::Read(). The function returns the total number of bytes written to the file.; It returns 0 if the object cannot be written. Int_t Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); Write this object to the current directory. For more see the; const version of this method. void Streamer(TBuffer& b); Stream an object of class TObject. void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). void Info(const char *location, const char *va_(fmt), ...); Issue info message. Use ""location"" to specify the method where the; warning occured. Accepts standard printf formatting arguments. void Warning(const char *location, const char *va_(fmt), ...); Issue warn",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Security,hash,hash,"me.; Classes that give objects a name should override this method. const char * GetIconName() const; Returns mime type name of object. Used by the TBrowser (via TGMimeTypes; class). Override for class of which you would like to have different; icons for objects of the same class. UInt_t GetUniqueID() const; Return the unique object id. char * GetObjectInfo(Int_t px, Int_t py) const; Returns string containing info about the object at position (px,py).; This method is typically overridden by classes of which the objects; can report peculiarities for different positions.; Returned string will be re-used (lock in MT environment). const char * GetTitle() const; Returns title of object. This default method returns the class title; (i.e. description). Classes that give objects a title should override; this method. Bool_t HandleTimer(TTimer* timer); Execute action in response of a timer timing out. This method; must be overridden if an object has to react to timers. ULong_t Hash() const; Return hash value for this object. Bool_t InheritsFrom(const char* classname) const; Returns kTRUE if object inherits from class ""classname"". Bool_t InheritsFrom(const TClass* cl) const; Returns kTRUE if object inherits from TClass cl. void Inspect() const; Dump contents of this object in a graphics canvas.; Same action as Dump but in a graphical form.; In addition pointers to other objects can be followed. The following picture is the Inspect of a histogram object:. /*; ; */. Bool_t IsFolder() const; Returns kTRUE in case object contains browsable objects (like containers; or lists of other objects). Bool_t IsEqual(const TObject* obj) const; Default equal comparison (objects are equal if they have the same; address in memory). More complicated classes might want to override; this function. void ls(Option_t* option = """") const; The ls function lists the contents of a class on stdout. Ls output; is typically much less verbose then Dump(). Bool_t Notify(); This method must be overridden to han",MatchSource.WIKI,root/html528/TObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObject.html
Availability,error,error,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root/html528/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectRefSpy.html
Safety,avoid,avoids,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root/html528/TObjectRefSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectRefSpy.html
Availability,error,error," dataset); virtual TObject*AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDoOwner(Bool_t done = kTRUE); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TDataSet::GetList() c",MatchSource.WIKI,root/html528/TObjectSet.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectSet.html
Availability,error,error,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html528/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectSpy.html
Safety,avoid,avoids,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root/html528/TObjectSpy.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectSpy.html
Availability,error,error,"dTObject::AbstractMethod(const char* method) const; voidAdd(TObject* obj); static voidAddObj(TObject* obj); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); void*CheckPtrAndWarn(const char* msg, void* vp); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(cons",MatchSource.WIKI,root/html528/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectTable.html
Deployability,toggle,toggle,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html528/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectTable.html
Performance,perform,performance,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html528/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectTable.html
Security,hash,hash,". TObjectTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TObjectTable. class TObjectTable: public TObject. This class registers all instances of TObject and its derived; classes in a hash table. The Add() and Remove() members are called; from the TObject ctor and dtor, repectively. Using the Print(); member one can see all currently active objects in the system.; Using the resource (in .rootrc): Root.ObjectStat one can toggle this; feature on or off.; Using the compile option R__NOSTATS one can de-active this feature; for the entire system (for maximum performance in highly time; critical applications). The following output has been produced in a ROOT interactive session; via the command gObjectTable->Print(); class cnt on heap size total size heap size. TKey 4 4 72 288 288; TClass 84 84 80 6720 6720; TDataMember 276 276 24 6624 6624; TObject 11 11 12 132 132; TMethod 1974 1974 64 126336 126336; TDataType 34 34 56 1904 1904; TList 2328 2328 36 83808 83808; TH1F 1 1 448 448 448; TText 2688 2688 56 150528 150528; TGaxis 1 0 120 120 0; TAxis 6 3 88 528 264; TBox 57 57 52 2964 2964; TLine 118 118 40 4720 4720; TWbox 1 1 56 56 56; TArrow 1 1 64 64 64; TPaveText 59 59 124 7316 7316; TPave 1 1 92 92 92; TFile 1 1 136 136 136; TCanvas 3 3 444 1332 1332; TPad 1 1 312 312 312; TContextMenu 3 3 48 144 144; TMethodArg 2166 2166 44 95304 95304; TPaveLabel 1 1 120 120 120; THtml 1 1 32 32 32; TROOT 1 0 208 208 0; TApplication 1 1 28 28 28; TFileHandler 1 1 20 20 20; TColor 163 163 40 6520 6520; TStyle 1 1 364 364 364; TRealData 117 117 28 3276 3276; TBaseClass 88 88 36 3168 3168; THashList 5 5 40 200 200; THashTable 5 5 36 180 180; TGeometry 1 1 64 64 64; TLink 7 7 60 420 420; TPostScript 1 1 764 764 764; TMinuit 1 1 792 792 792; TStopwatch 1 0 56 56 0; TRootGuiFactory 1 1 28 28 28; TGX11 1 1 1",MatchSource.WIKI,root/html528/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectTable.html
Testability,test,test,"ject* obj); Add an object to the object table. void AddObj(TObject* obj); Add an object to the global object table gObjectTable. If the global; table does not exist create it first. This member function may only; be used by TObject::TObject. Use Add() to add objects to any other; TObjectTable object. This is a static function. void Delete(Option_t* opt = """"); Delete all objects stored in the TObjectTable. void Remove(TObject* obj); Remove an object from the object table. void RemoveQuietly(TObject* obj); Remove an object from the object table. If op is 0 or not in the table; don't complain. Currently only used by the TClonesArray dtor. Should not; be used anywhere else, except in places where ""special"" allocation and; de-allocation tricks are performed. void Terminate(); Deletes the object table (this static class function calls the dtor). Int_t FindElement(TObject* obj); Find an object in the object table. Returns the slot where to put; the object. To test if the object is actually already in the table; use PtrIsValid(). void FixCollisions(Int_t index); Rehash the object table in case an object has been removed. void Expand(Int_t newsize); Expand the object table. void InstanceStatistics() const; Print the object table. void UpdateInstCount() const; Histogram all objects according to their classes. void * CheckPtrAndWarn(const char* msg, void* vp); Issue a warning in case an object still appears in the table; while it should not. Bool_t HighWaterMark(); { return (Bool_t) (fTally >= ((3*fSize)/4)); }. Bool_t PtrIsValid(TObject* op); { return fTable[FindElement(op)] != 0; }. TObjectTable(const TObjectTable& ). TObjectTable& operator=(const TObjectTable& ). Int_t GetSize() const; { return fSize; }. Int_t Instances() const; { return fTally; }. void Statistics(); { Print(); }. » Author: Fons Rademakers 11/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TObjectTable.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 201",MatchSource.WIKI,root/html528/TObjectTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjectTable.html
Availability,error,error," TObjString(const char* s = """"); TObjString(const TObjString& s); virtual~TObjString(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html528/TObjString.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TObjString.html
Availability,error,error,"st char* tableName); virtual~TOracleResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFieldCount(); virtual const char*GetFieldName(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tGetRowCount() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetUpdateCount(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; vi",MatchSource.WIKI,root/html528/TOracleResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleResult.html
Deployability,update,update,"tual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitResultSet(Statement* stmt); voidTObject::MakeZombie(); voidProducePool(). private:. Bool_tIsValid(Int_t field). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_tTSQLResult::fRowCountnumber of rows in result. private:. Connection*fConnconnection to Oracle ; Int_tfFieldCountnum of fields in resultset; vector<MetaData>*fFieldInfoinfo for each field in the row; stringfNameBufferbuffer for GetFieldName() argument; TList*fPoolarray of results, produced when number of rows are requested ; ResultSet*fResultquery result (rows); Int_tfResultType0 - nothing; 1 - Select; 2 - table metainfo, 3 - update counter; Statement*fStmtexecuted statement; UInt_tfUpdateCountfor dml query, mutual exclusive with above. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initResultSet(Statement* stmt); Oracle query result. TOracleResult(Connection* conn, Statement* stmt). TOracleResult(Connection* conn, const char* tableName); This construction func is only used to get table metainfo. ~TOracleResult(); Cleanup Oracle query result. void Close(Option_t* opt = """"); Close query result. Bool_t IsValid(Int_t field); Check if result set is open and field index within range. Int_t GetFieldCount(); Get number of fields in result. const char * GetFieldName(Int_t field); Get name of specified field. TSQLRow * Next(); Get next query result row. The returned object must be; deleted by the user. Int_t GetRowCount() const. void Produc",MatchSource.WIKI,root/html528/TOracleResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleResult.html
Availability,error,error,"aData>* fieldMetaData); virtual~TOracleRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, con",MatchSource.WIKI,root/html528/TOracleRow.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleRow.html
Availability,avail,available,". TOracleServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » ORACLE; » TOracleServer. class TOracleServer: public TSQLServer. TOracleServer. This class implements an OCCI interface to Oracle data bases.; It uses the instantclient10 software available from Oracle.; To install this client software do:; 1) Download Instant Client Packages (4 files) from:; http://www.oracle.com/technology/software/tech/oci/instantclient/index.html; 2) Unzip the files into instantclient10_2 (Mac OS X example here):; unzip instantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root/html528/TOracleServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleServer.html
Deployability,install,install,". TOracleServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » ORACLE; » TOracleServer. class TOracleServer: public TSQLServer. TOracleServer. This class implements an OCCI interface to Oracle data bases.; It uses the instantclient10 software available from Oracle.; To install this client software do:; 1) Download Instant Client Packages (4 files) from:; http://www.oracle.com/technology/software/tech/oci/instantclient/index.html; 2) Unzip the files into instantclient10_2 (Mac OS X example here):; unzip instantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root/html528/TOracleServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleServer.html
Integrability,interface,interface,". TOracleServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » ORACLE; » TOracleServer. class TOracleServer: public TSQLServer. TOracleServer. This class implements an OCCI interface to Oracle data bases.; It uses the instantclient10 software available from Oracle.; To install this client software do:; 1) Download Instant Client Packages (4 files) from:; http://www.oracle.com/technology/software/tech/oci/instantclient/index.html; 2) Unzip the files into instantclient10_2 (Mac OS X example here):; unzip instantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root/html528/TOracleServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleServer.html
Security,password,password,"tantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*TSQLServer::Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t p",MatchSource.WIKI,root/html528/TOracleServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleServer.html
Testability,test,test,"ode of last operation; TStringTSQLServer::fErrorMsgerror message of last operation; Bool_tTSQLServer::fErrorOutenable error output; TStringTSQLServer::fHosthost to which we are connected; Int_tTSQLServer::fPortport to which we are connected; TStringTSQLServer::fTypetype of DBMS (MySQL, Oracle, SysBase, ...); static const char*TSQLServer::fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. private:. Connection*fConnconnection to Oracle server; Environment*fEnvenvironment of Oracle access; TStringfInfoinfo string with Oracle version information; static const char*fgDatimeFormat! format for converting date and time stamps into string . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleServer(const char* db, const char* uid, const char* pw); Open a connection to a Oracle DB server. The db arguments should be; of the form ""oracle://connection_identifier[/<database>]"", e.g.:; ""oracle://cmscald.fnal.gov/test"". The uid is the username and pw; the password that should be used for the connection. ~TOracleServer(); Close connection to Oracle DB server. void Close(Option_t* opt = """"); Close connection to Oracle DB server. TSQLStatement * Statement(const char* sql, Int_t niter = 100). TSQLResult * Query(const char* sql); Execute SQL command. Result object must be deleted by the user.; Returns a pointer to a TSQLResult object if successful, 0 otherwise. Bool_t Exec(const char* sql); Execute sql command wich does not produce any result set.; Return kTRUE if succesfull. TSQLResult * GetTables(const char* dbname, const char* wild = 0); List all tables in the specified database. Wild is for wildcarding; ""t%"" list all tables starting with ""t"".; Returns a pointer to a TSQLResult object if successful, 0 otherwise.; The result object must be deleted by the user. TList* GetTablesList(const char* wild = 0). TSQLTableInfo * GetTableInfo(const char* tablename); Produces SQL table info; Object must be del",MatchSource.WIKI,root/html528/TOracleServer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleServer.html
Availability,error,error,"stractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTSQLStatement::EnableErrorOutput(Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Bool_tGetBinary(Int_t npar, void*& mem, Long_t& size); virtual Int_tGetBufferLength() const; virtual Bool_tGetDate(Int_t npar, Int_t& year, Int_t& month, Int_t& day); virtual Bool_tGetDatime(Int_t npar, Int_t& year, Int_t& month, Int_t& day, Int_t& hour, Int_t& min, Int_t& sec); Int_tTSQLStatement::GetDay(Int_t); virtual Double_tGetDouble(Int_t npar); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSQLStatement::GetErrorCode() const; virtual const char*TSQLStatement::GetErrorMsg() const; virtual const char*GetFieldName(Int_t nfield); Int_tTSQLStatement::GetHour(Int_t); virtu",MatchSource.WIKI,root/html528/TOracleStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleStatement.html
Integrability,message,message,"tement::ClearError(); voidCloseBuffer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tIsParSettMode() const; Bool_tIsResultSet() const; voidTObject::MakeZombie(); voidSetBufferSize(Int_t size); voidTSQLStatement::SetError(Int_t code, const char* msg, const char* method = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TOracleStatement::TBufferRec*fBufferbuffer of values and field names; Int_tfBufferSizesize of fBuffer; Connection*fConnconnection to Oracle; Environment*fEnvenviroment ; Int_tTSQLStatement::fErrorCodeerror code of last operation; TStringTSQLStatement::fErrorMsgerror message of last operation; Bool_tTSQLStatement::fErrorOutenable error output ; vector<MetaData>*fFieldInfoinfo for each field in the row; Int_tfIterCountercounts nextiteration calls and process iterations, if required; Int_tfNumIterationssize of internal statement buffer; ResultSet*fResultquery result (rows); Statement*fStmtexecuted statement; TStringfTimeFmtformat for date to string conversion, default ""MM/DD/YYYY, HH24:MI:SS"" ; Int_tfWorkingMode1 - settingpars, 2 - getting results. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TOracleStatement(Environment* env, Connection* conn, Statement* stmt, Int_t niter, Bool_t errout = kTRUE); Normal constructor of TOracleStatement class; On creation time specifies buffer length, which should be; used in data fetching or data inserting. ~TOracleStatement(); Destructor of TOracleStatement clas. void Close(Option_t* = """"); Close Oracle statement; Removes and destroys all buffers and metainfo. void SetBufferSize(Int_t size); Set buffer size, which is used to keep string values of; currently fetched column. void ",MatchSource.WIKI,root/html528/TOracleStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleStatement.html
Security,access,access,"nteger values for parameter npar. Bool_t SetVUInt(Int_t npar, const vector<UInt_t> value, const char* schemaName, const char* typeName); Set vector of unsigned integer values for parameter npar. Bool_t SetVLong(Int_t npar, const vector<Long_t> value, const char* schemaName, const char* typeName); Set vector of long integer values for parameter npar. Bool_t SetVLong64(Int_t npar, const vector<Long64_t> value, const char* schemaName, const char* typeName); Set vector of 64-bit integer values for parameter npar. Bool_t SetVULong64(Int_t npar, const vector<ULong64_t> value, const char* schemaName, const char* typeName); Set vector of unsigned 64-bit integer values for parameter npar. Bool_t SetVDouble(Int_t npar, const vector<Double_t> value, const char* schemaName, const char* typeName); Set vector of double values for parameter npar. Bool_t NextIteration(); Add next iteration for statement with parameters. Bool_t StoreResult(); Store result of statement processing.; Required to access results of SELECT queries. Bool_t SetMaxFieldSize(Int_t nfield, Long_t maxsize); Defines maximum size for field which must be used for read or write operation; Some Oracle types as LONG (long binary continer) requires this call; before any data can be read from database. Call it once before first call to NextResultRow(). Int_t GetNumFields(); Returns number of fields in result set. const char* GetFieldName(Int_t nfield); Return field name in result set. Bool_t NextResultRow(); Move cursor to next row in result set.; For Oracle it may lead to additional request to database. Bool_t IsNull(Int_t ); Checks if fieled value in result set is NULL. Int_t GetInt(Int_t npar); return field value as integer. UInt_t GetUInt(Int_t npar); return field value as unsigned integer. Long_t GetLong(Int_t npar); return field value as long integer. Long64_t GetLong64(Int_t npar); return field value as 64-bit integer. ULong64_t GetULong64(Int_t npar); return field value as unsigned 64-bit integer. Double_t GetDo",MatchSource.WIKI,root/html528/TOracleStatement.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOracleStatement.html
Availability,error,error,"obj); virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const c",MatchSource.WIKI,root/html528/TOrdCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOrdCollection.html
Availability,error,error,"torDataMap(const TOutputListSelectorDataMap&); virtual~TOutputListSelectorDataMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static TOutputListSelectorDataMap*FindInList(TCollection* coll); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TCollection*GetMap() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const",MatchSource.WIKI,root/html528/TOutputListSelectorDataMap.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TOutputListSelectorDataMap.html
Availability,error,error,"cription(); TPackageDescription(const TPackageDescription&); ~TPackageDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TPackageDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPackageDescription.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtu",MatchSource.WIKI,root/html528/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizer.html
Deployability,configurat,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizer.html
Modifiability,config,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizer.html
Performance,perform,performance,". TPacketizer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizer. class TPacketizer: public TVirtualPacketizer. TPacketizer. This class generates packets to be processed on PROOF worker servers.; A packet is an event range (begin entry and number of entries) or; object range (first object and number of objects) in a TTree; (entries) or a directory (objects) in a file.; Packets are generated taking into account the performance of the; remote machine, the time it took to process a previous packet on; the remote machine, the locality of the database files, etc. Function Members (Methods); public:. TPacketizer(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizer(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* meth",MatchSource.WIKI,root/html528/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizer.html
Safety,abort,abort,"::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TPacketizer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizer.html
Availability,error,error,"Status* st, Double_t latency, TList** listOfMissingFiles = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const c",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Deployability,configurat,configuration,"irtualPacketizer::EStatusBits { kIsInitializing; kIsDone; kIsTree; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Energy Efficiency,adapt,adaptive," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Integrability,synchroniz,synchronization," / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::fTimeUpdttime between updates; Long64_tTVirtualPacketizer::fTotalEntriestotal number of entries to be distributed;; TVirtualPacketizer::EUseEstOptTVirtualPacketizer::fUseEstOptControl usage of estimated values for the progress info; Bool_tTVirtualPacketizer::fValidConstructed properly?. private:. TList*fActivenodes with unfinished files; Float_tfBaseLocalPreferenceindicates how much more likely the nodes will be; Bool_tfCachePacketSynccontrol synchronization of cache and packet sizes; TList*fFileNodesnodes with files; TSortedList*fFilesToProcessGlobal list of files (TFileStat) to be processed; Bool_tfForceLocalif 1 - eliminate the remote processing; Float_tfFractionOfRemoteFilesfraction of TDSetElements that are on non-workers; Double_tfMaxEntriesRatiomax file entries to avg allowed ratio for cache-to-packet sync; Int_tfMaxPerfIdxmaximum of our slaves' performance index; Long_tfMaxSlaveCntmaximum number of workers per filenode (Long_t to avoid; Long64_tfNEventsOnRemLocnumber of events in currently; Int_tfPacketAsAFractionused to calculate the packet size; TList*fPartitionslist of partitions on nodes; Int_tfStrategy0 means the classic and 1 (default) - the adaptive strategy; TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of acti",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Modifiability,config,configuration,"irtualPacketizer::EStatusBits { kIsInitializing; kIsDone; kIsTree; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Performance,load,load-balancing,". TPacketizerAdaptive. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerAdaptive. class TPacketizerAdaptive: public TVirtualPacketizer. TPacketizerAdaptive. This packetizer is based on TPacketizer but uses different; load-balancing algorithms and data structures.; Two main improvements in the load-balancing strategy:; - First one was to change the order in which the files are assigned; to the computing nodes in such a way that network transfers are; evenly distributed in the query time. Transfer of the remote files; was often becoming a bottleneck at the end of a query.; - The other improvement is the use of time-based packet size. We; measure the processing rate of all the nodes and calculate the; packet size, so that it takes certain amount of time. In this way; packetizer prevents the situation where the query can't finish; because of one slow node. The data structures: TFileStat, TFileNode and TSlaveStat are; enriched + changed and TFileNode::Compare method is changed. Function Members (Methods); public:. TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) con",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Safety,abort,abort,"::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Usability,learn,learnent," TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); virtual~TPacketizerAdaptive(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) con",MatchSource.WIKI,root/html528/TPacketizerAdaptive.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerAdaptive.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPa",MatchSource.WIKI,root/html528/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerFile.html
Deployability,configurat,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerFile.html
Modifiability,config,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerFile.html
Safety,abort,abort,"::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TPacketizerFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerFile.html
Availability,error,error,":AbstractMethod(const char* method) const; virtual Int_tAddProcessed(TSlave* wrk, TProofProgressStatus* st, Double_t lat, TList** missing); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const",MatchSource.WIKI,root/html528/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html
Deployability,configurat,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html
Modifiability,config,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html
Safety,abort,abort,"irtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TPacketizerMulti.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerMulti.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPa",MatchSource.WIKI,root/html528/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html
Deployability,configurat,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html
Modifiability,config,configuration,"; enum TVirtualPacketizer::EStatusBits { kIsInitializing; kIsDone; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTVirtualPacketizer::fAWLastFillWhether to fill the last measurement; Int_tTVirtualPacketizer::fActWrksLastActive workers at fProcTimeLast; Long_tTVirtualPacketizer::fCircNCircularity; TNtupleD*TVirtualPacketizer::fCircProgKeeps circular info for ""instantenous""; TList*TVirtualPacketizer::fConfigParamsList of configuration parameters; TStringTVirtualPacketizer::fDataSetName of the dataset being processed (for dataset-driven runs); Float_tTVirtualPacketizer::fEffSessLastNumber of effective sessions at fProcTimeLast; Float_tTVirtualPacketizer::fEvtRateLastEvt rate at fProcTimeLast; TList*TVirtualPacketizer::fFailedPacketsa list of packets that failed while processing; Float_tTVirtualPacketizer::fInitTimetime before processing; Float_tTVirtualPacketizer::fMBsReadLastMBs read at fProcTimeLast; Double_tTVirtualPacketizer::fMaxPacketTimemaximum packet time; Double_tTVirtualPacketizer::fMinPacketTimeminimum packet time; Float_tTVirtualPacketizer::fProcTimetime since start of processing; Float_tTVirtualPacketizer::fProcTimeLastTime of the last measurement; TTimer*TVirtualPacketizer::fProgressprogress updates timer; TNtuple*TVirtualPacketizer::fProgressPerf{Active workers, evt rate, MBs read} as a function of processing time; TProofProgressStatus*TVirtualPacketizer::fProgressStatuspointer to status in the player.; Float_tTVirtualPacketizer::fReportPeriodTime between reports if nothing changes (estimated proc time / 100); TMap*TVirtualPacketizer::fSlaveStatsslave status, keyed by correspondig TSlave; TTimeTVirtualPacketizer::fStartTimetime offset; Bool_tTVirtualPacketizer::fStopTermination of Process() requested?; Float_tTVirtualPacketizer::f",MatchSource.WIKI,root/html528/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html
Performance,perform,performance,". TPacketizerUnit. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPacketizerUnit. class TPacketizerUnit: public TVirtualPacketizer. TPacketizerUnit. This packetizer generates packets of generic units, representing the; number of times an operation cycle has to be repeated by the worker; node, e.g. the number of Monte carlo events to be generated.; Packets sizes are generated taking into account the performance of; worker nodes, based on the time needed to process previous packets. Function Members (Methods); public:. TPacketizerUnit(TList* slaves, Long64_t num, TList* input, TProofProgressStatus* st = 0); virtual~TPacketizerUnit(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t",MatchSource.WIKI,root/html528/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html
Safety,abort,abort,"::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTVirtualPacketizer::SetFailedPackets(TList* list); virtual voidTVirtualPacketizer::SetInitTime(); static voidTObject::SetObjectStat(Bool_t stat); voidTVirtualPacketizer::SetProgressStatus(TProofProgressStatus* st); voidTVirtualPacketizer::SetTotalEntries(Long64_t ent); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTVirtualPacketizer::StopProcess(Bool_t abort); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TPacketizerUnit.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPacketizerUnit.html
Availability,error,error,"nst char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; Int_tGetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEvent() const; virtual Int_tGetEventX",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Deployability,release,released,"n is called when a TPad object is clicked. If the mouse is clicked in one of the 4 corners of the pad (pA,pB,pC,pD); the pad is resized with the rubber rectangle. If the mouse is clicked inside the pad, the pad is moved. If the mouse is clicked on the 4 edges (pL,pR,pTop,pBot), the pad is scaled; parallel to this edge. pA pTop pB; +--------------------------------------------+; | |; | |; | |; pL| pINSIDE |pR; | |; | |; | |; | |; +--------------------------------------------+; pD pBot pC. Note that this function duplicates on purpose the functionality; already implemented in TBox::ExecuteEvent.; If somebody modifies this function, may be similar changes should also; be applied to TBox::ExecuteEvent. void ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); Execute action corresponding to one event for a TAxis object; (called by TAxis::ExecuteEvent.); This member function is called when an axis is clicked with the locator. The axis range is set between the position where the mouse is pressed; and the position where it is released.; If the mouse position is outside the current axis range when it is released; the axis is unzoomed with the corresponding proportions.; Note that the mouse does not need to be in the pad or even canvas; when it is released. TObject * FindObject(const char* name) const; Search if object named name is inside this pad or in pads inside this pad. In case name is in several subpads the first one is returned. TObject * FindObject(const TObject* obj) const; Search if obj is in pad or in pads inside this pad. In case obj is in several subpads the first one is returned. Int_t GetCanvasID() const; Get canvas identifier. TCanvasImp * GetCanvasImp() const; Get canvas implementation pointer if any. Int_t GetEvent() const; Get Event. Int_t GetEventX() const; Get X event. Int_t GetEventY() const; Get Y event. TVirtualPad * GetVirtCanvas() const; Get virtual canvas. Color_t GetHighLightColor() const; Get highlight color. Int_t GetMaxPickDistance(",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Energy Efficiency,power,powerful,"mands; contained in the fExecs list are executed in the order found in the list.; This facility is activated by default. It can be deactivated by using; the canvas ""Option"" menu.; The following examples of TExec commands are provided in the tutorials:; macros exec1.C and exec2.C.; Example1 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpx.Draw(); Root > c1.AddExec(""ex1"","".x exec1.C""); At this point you can use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to to build automatically a TLegend from the primitives in; a TPad. Only those deriving from TAttLine, TAttMarker and TAttFill are; added, excluding TPave and TFrame derived classes.; x1, y1, x2, y2 are the Tlegend coordinates.; title is the legend title. By default it is "" "". If the pad contains some TMultiGraph or THStack the individual graphs or; histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number su",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Integrability,rout,routine,"ad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xclipr, Double_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t ClippingCode(Double_t x, Double_t y, Double_t xcl1, Double_t ycl1, Double_t xcl2, Double_t ycl2); Compute the endpoint c",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Modifiability,variab,variable,"in the pad. A simple method to to build automatically a TLegend from the primitives in; a TPad. Only those deriving from TAttLine, TAttMarker and TAttFill are; added, excluding TPave and TFrame derived classes.; x1, y1, x2, y2 are the Tlegend coordinates.; title is the legend title. By default it is "" "". If the pad contains some TMultiGraph or THStack the individual graphs or; histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to set attributes; of the current pad.; Note3: One can get a pointer to one of the sub-pads of pad with:; TPad *subpad = (TPad*)pad->GetPad(subpadnumber);. void Clear(Option_t* option = """"); Delete all pad primitives. If the bit kClearAfterCR has been set for this pad, the Clear function; will execute only after having pressed a CarriageReturn; Set the bit with mypad->SetBit(TPad::kClearAfterCR). Int_t Clip(Float_t* x, Float_t* y, Float_t xclipl, Float_t yclipb, Float_t xclipr, Float_t yclipt); Clipping routine: Cohen Sutherland algorithm. If Clip ==2 the segment is outside the boundary.; If Clip ==1 the segment has one point outside the boundary.; If Clip ==0 the segment is inside the boundary. _Input parameters:. x[2], y[2] : Segment coordinates; xclipl, yclipb, xclipr, yclipt : Clipping boundary. _Output parameters:. x[2], y[2] : New segment coordinates. Int_t Clip(Double_t* x, Double_t* y, Double_t xclipl, Double_t yclipb, Double_t xcl",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Performance,perform,performed,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::Dista",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Safety,detect,detectors,". TPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TPad. class TPad: public TVirtualPad. The Pad class is the most important graphics class in the ROOT system. /*. */. A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects,; histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw; member function of the object classes.; It is important to realize that the pad is a linked list of references; to the original object.; For example, in case of a histogram, the histogram.Draw() operation; only stores a reference to the histogram object and not a graphical; representation of this histogram.; When the mouse is used to change (say the bin content), the bin content; of the original histogram is changed !!. The convention used in ROOT is that a Draw operation only adds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::Dista",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Testability,log,log,"ds; a reference to the object. The effective drawing is performed; when the canvas receives a signal to be painted.; This signal is generally sent when typing carriage return in the; command input or when a graphical operation has been performed on one; of the pads of this canvas.; When a Canvas/Pad is repainted, the member function Paint for all; objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive; is called for all the elements in the pad. DistancetoPrimitive returns; the distance in pixels to this object.; when the object is within the distance window, the member function; ExecuteEvent is called for this object.; in ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions,; see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent. A Pad supports linear and log scales coordinate systems.; The transformation coefficients are explained in TPad::ResizePad.; An example of pads hierarchy is shown below:. /*. */. Function Members (Methods); public:. TPad(); TPad(const char* name, const char* title, Double_t xlow, Double_t ylow, Double_t xup, Double_t yup, Color_t color = -1, Short_t bordersize = -1, Short_t bordermode = -2); virtual~TPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual voidAbsPixeltoXY(Int_t xpixel, Int_t ypixel, Double_t& x, Double_t& y); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidAutoExec(); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); virtual TLeg",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Usability,simpl,simple,"s point you can use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to to build automatically a TLegend from the primitives in; a TPad. Only those deriving from TAttLine, TAttMarker and TAttFill are; added, excluding TPave and TFrame derived classes.; x1, y1, x2, y2 are the Tlegend coordinates.; title is the legend title. By default it is "" "". If the pad contains some TMultiGraph or THStack the individual graphs or; histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; points to the current pad. One can use gPad to se",MatchSource.WIKI,root/html528/TPad.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPad.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPadEditor.html
Integrability,interface,interface," Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPadEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of TPad editor GUI. ~TPadEditor(); Destructor of fill editor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Pick up the used fill attributes. void ActivateBaseClassEditors(TClass* cl); Exclude TAttLineEditor from this interface. void DoEditable(Bool_t on); Slot connected to the check box 'Editable'. void DoCrosshair(Bool_t on); Slot connected to the check box 'Crosshair'. void DoFixedAspectRatio(Bool_t on); Slot connected to the check box 'Fixed aspect ratio'. void DoGridX(Bool_t on); Slot connected to the check box 'GridX'. void DoGridY(Bool_t on); Slot connected to the check box 'GridY'. void DoLogX(Bool_t on); Slot connected to the check box 'LogX'. void DoLogY(Bool_t on); Slot connected to the check box 'LogY'. void DoLogZ(Bool_t on); Slot connected to the check box 'LogZ'. void DoTickX(Bool_t on); Slot connected to the check box 'TickX'. void DoTickY(Bool_t on); Slot connected to the check box 'TickY'. void DoBorderMode(); Slot connected to the border mode settings. void DoBorderSize(Int_t size); Slot connected to the border size settings. » Author: Ilka Antcheva 24/06/04 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: ",MatchSource.WIKI,root/html528/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPadEditor.html
Testability,log,log,"CheckButton*fCrosshairset crosshair ; Int_tTGFrame::fDNDStateEDNDFlags; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEditableset pad editable; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGCheckButton*fFixedARset fixed aspect ratio; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGCheckButton*fGridXset grid on X; TGCheckButton*fGridYset grid on Y; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TGCheckButton*fLogXset log scale on X; TGCheckButton*fLogYset log scale on Y; TGCheckButton*fLogZset log scale on Z; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::fModelClassclass corresponding to instantiated GedFrame; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; UInt_tTGFrame::fOptionsframe options; TPad*fPadPointerTPad object; const TGWindow*TGWindow::fParentParent window; Int_tTGedFrame::fPrioritylocation in GedEditor; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TGCheckButton*fTickXset ticks on X; TGCheckButton*fTickYset ticks on Y; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::f",MatchSource.WIKI,root/html528/TPadEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPadEditor.html
Usability,simpl,simple,"Float_t GetTextAngle() const; Delegate to gVirtualX. Color_t GetTextColor() const; Delegate to gVirtualX. Font_t GetTextFont() const; Delegate to gVirtualX. Float_t GetTextSize() const; Delegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. v",MatchSource.WIKI,root/html528/TPadPainter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPadPainter.html
Availability,error,error,""") constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t** xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMove1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceMove3(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster1(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); voidDrawFaceRaster2(Int_t* icodes, Double_t* xyz, Int_t np, Int_t* iface, Double_t* tt); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillPolygon(Int_t n, Double_t* p, Double_t* f); voidFillPolygonBorder(Int_t nn, Double_t* xy); voidFindLevelLines(Int_t np, Double_t* f, Double_t* t); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPartEdge(Double_t* p1, Double_t* p2, Double_t f1, Double_t f2, Double_t fmin, Double_t fmax, Int_t& kpp, Double_t* pp); voidFindVisibleDraw(Double_t* r1, Double_t* r2); voidFindVisibleLine(Double_t* p1, Double_t* p2, Int_t ntmax, Int_t& nt, Double_t* t); voidFrontBox(Double_t ang); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const c",MatchSource.WIKI,root/html528/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html
Energy Efficiency,adapt,adapted,". TPainter3dAlgorithms. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TPainter3dAlgorithms. class TPainter3dAlgorithms: public TObject, public TAttLine, public TAttFill. Legos and Surfaces package; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; . Function Members (Methods); public:. TPainter3dAlgorithms(); TPainter3dAlgorithms(const TPainter3dAlgorithms&); TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); virtual~TPainter3dAlgorithms(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidBackBox(Double_t ang); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearRaster(); virtual TObject*TObject::Clone(const char* newname = """") const; voidColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDefineGridLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t** xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_",MatchSource.WIKI,root/html528/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html
Integrability,depend,depending,"_tfNqs; Int_tfNxrast; Int_tfNyrast; Double_tfP8[8][3]; Double_tfPlines[1200]; Double_tfQA; Double_tfQD; Double_tfQS; Int_t*fRasterpointer to raster buffer; Double_tfRmax[3]Upper limits of lego; Double_tfRmin[3]Lower limits of lego; G__p2memfuncfSurfaceFunctionpointer to surface function; Int_tfSystemCoordinate system; Double_tfT[200]; Double_tfU[2000]; Double_tfVls[12]; Double_tfX0; Double_tfXrast; Double_tfYdl; Double_tfYls[4]; Double_tfYrast; static TF3*fgCurrentF3Pointer to the 3D function to be paint.; static Int_tfgF3ClippingClipping box is off (0) or on (1); static Double_tfgF3XClipClipping plne along X; static Double_tfgF3YClipClipping plne along Y; static Double_tfgF3ZClipClipping plne along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPainter3dAlgorithms(); Lego default constructor. TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); Normal default constructor. rmin[3], rmax[3] are the limits of the lego object depending on; the selected coordinate system. ~TPainter3dAlgorithms(); Lego default destructor. void BackBox(Double_t ang); Draw back surfaces of surrounding box. Input ANG - angle between X and Y axis. DRFACE(ICODES,XYZ,NP,IFACE,T) - routine for face drawing; ICODES(*) - set of codes for this face; NP - number of nodes in face; IFACE(NP) - face; T(NP) - additional function. void ClearRaster(); Clear screen. void ColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); Set correspondance between function and color levels. Input: NL - number of levels; FL(NL) - function levels; ICL(NL+1) - colors for levels. Output: IREP - reply: 0 O.K.; -1 error in parameters:; illegal number of levels; function levels must be in increasing order; negative color index. void DefineGridLevels(Int_t ndivz); Define the grid levels drawn in the background of surface and lego plots.; The grid levels are aligned on the Z axis' main tick marks. void DrawFaceMode1(Int_t* icodes, Double_t* xyz, Int_t n",MatchSource.WIKI,root/html528/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html
Modifiability,adapt,adapted,". TPainter3dAlgorithms. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HISTPAINTER; » TPainter3dAlgorithms. class TPainter3dAlgorithms: public TObject, public TAttLine, public TAttFill. Legos and Surfaces package; This package was originally written by Evgueni Tcherniaev from IHEP/Protvino. The original Fortran implementation was adapted to HIGZ/PAW by Olivier Couet; and Evgueni Tcherniaev. This class is a subset of the original system. It has been converted to a C++; class by Rene Brun.; . Function Members (Methods); public:. TPainter3dAlgorithms(); TPainter3dAlgorithms(const TPainter3dAlgorithms&); TPainter3dAlgorithms(Double_t* rmin, Double_t* rmax, Int_t system = 1); virtual~TPainter3dAlgorithms(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidBackBox(Double_t ang); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearRaster(); virtual TObject*TObject::Clone(const char* newname = """") const; voidColorFunction(Int_t nl, Double_t* fl, Int_t* icl, Int_t& irep); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidDefineGridLevels(Int_t ndivz); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawFaceGouraudShaded(Int_t* icodes, Double_t** xyz, Int_t np, Int_t* iface, Double_t* t); voidDrawFaceMode1(Int_t* icodes, Double_",MatchSource.WIKI,root/html528/TPainter3dAlgorithms.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPainter3dAlgorithms.html
Availability,error,error," TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual ",MatchSource.WIKI,root/html528/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPair.html
Energy Efficiency,efficient,efficient,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; hash table for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function. Both key and; value need to inherit from TObject. This class is also known as (typedefs to this class)TAssoc. Function Members (Methods); public:. TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual ",MatchSource.WIKI,root/html528/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPair.html
Modifiability,inherit,inherit,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; hash table for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function. Both key and; value need to inherit from TObject. This class is also known as (typedefs to this class)TAssoc. Function Members (Methods); public:. TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual ",MatchSource.WIKI,root/html528/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPair.html
Security,hash,hash,". TPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TPair. class TPair: public TObject. TMap. TMap implements an associative array of (key,value) pairs using a; hash table for efficient retrieval (therefore TMap does not conserve; the order of the entries). The hash value is calculated; using the value returned by the keys Hash() function. Both key and; value need to inherit from TObject. This class is also known as (typedefs to this class)TAssoc. Function Members (Methods); public:. TPair(const TPair& a); TPair(TObject* key, TObject* value); virtual~TPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual ",MatchSource.WIKI,root/html528/TPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPair.html
Energy Efficiency,allocate,allocated,"rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *colors); if ncolors <= 0 a default palette (see below) of 50 colors; is defined. if ncolors == 1 && colors == 0, then; a Pretty Palette with a Spectrum Violet->Red is created. if ncolors > 50 and colors=0, the DeepSea palette is used.; (see TStyle::CreateGradientColorTable for more details). if ncolors > 0 and colors = 0, the default palette is used; with a maximum of ncolors. The default palette defines:; index 0->9 : ",MatchSource.WIKI,root/html528/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaletteEditor.html
Integrability,depend,depends,". TPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *col",MatchSource.WIKI,root/html528/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaletteEditor.html
Modifiability,inherit,inheritance,". TPaletteEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaletteEditor. class TPaletteEditor. TAttImage. Image attributes are:; Image Quality (see EImageQuality for the list of qualities); Compression defines the compression rate of the color data in the; internal image structure. Speed and memory depends; on this rate, but not the image display itself; 0: no compression; 100: max compression; Radio Flag: kTRUE the x/y radio of the displayed image is always; identical to the original image; kFALSE the x and y size of the displayed image depends; on the size of the pad; Palette: Defines the conversion from a pixel value to the; screen color. This class is used (in general by secondary inheritance); by some other classes (image display). TImagePalette. A class to define a conversion from pixel values to pixel color.; A Palette is defined by some anchor points. Each anchor point has; a value between 0 and 1 and a color. An image has to be normalized; and the values between the anchor points are interpolated.; All member variables are public and can be directly manipulated.; In most cases the default operator will be used to create a; TImagePalette. In this case the member arrays have to be allocated; by an application and will be deleted in the destructor of this; class. We provide few predifined palettes:. o gHistImagePalette - palette used in TH2::Draw(""col""). o gWebImagePalette; The web palette is a set of 216 colors that will not dither or; shift on PCs or Macs. Browsers use this built-in palette when; they need to render colors on monitors with only 256 colors; (also called 8-bit color monitors).; The 6x6x6 web palette provides very quick color index lookup; and can be used for good quality convertion of images into; 2-D histograms. o TImagePalette(Int_t ncolors, Int_t *col",MatchSource.WIKI,root/html528/TPaletteEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaletteEditor.html
Availability,error,error,"ethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTBRIK::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAlpha() const; virtual const TBuffer3D&TBRIK::GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tTBRIK::GetDx() const; Float_tTBRIK::GetDy() const; Float_tTBRIK::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() con",MatchSource.WIKI,root/html528/TPARA.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPARA.html
Availability,error,error,"arameter<double>(const char* name, const double& val); virtual~TParameter<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const double&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const ",MatchSource.WIKI,root/html528/TParameter_double_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParameter_double_.html
Availability,error,error," TParameter<float>(const char* name, const float& val); virtual~TParameter<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const float&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const c",MatchSource.WIKI,root/html528/TParameter_float_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParameter_float_.html
Availability,error,error,"nt>&); TParameter<int>(const char* name, const int& val); virtual~TParameter<int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const int&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const cha",MatchSource.WIKI,root/html528/TParameter_int_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParameter_int_.html
Availability,error,error," virtual~TParameter<long long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(",MatchSource.WIKI,root/html528/TParameter_Long64_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParameter_Long64_t_.html
Availability,error,error,"&); TParameter<long>(const char* name, const long& val); virtual~TParameter<long>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const ch",MatchSource.WIKI,root/html528/TParameter_long_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParameter_long_.html
Availability,error,error,"ption_t* option = """"); Int_tBeauty(); virtual voidTObject::Browse(TBrowser* b); Int_tCharm(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Double_tEnergy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetCalcMass() const; Int_tGetDaughter(Int_t i) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFirstDaughter() const; Int_tGetFirstMother() const; virtual const char*TObject::GetIconName() const; Int_tGetLastDaughter() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Double_tGetMass(); Int_tGetMother(Int_t i) const; virtual const char*GetName() const; Int_tGetNDaughters() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtua",MatchSource.WIKI,root/html528/TParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticle.html
Safety,detect,detectors,". TParticle. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticle. class TParticle: public TObject, public TAttLine, public TAtt3D. a dynamic particle class created by event generators and used during; the propagation in detectors. The static attributes of a TParticle; are described by TParticlePDG. Int_t fPdgCode; // PDG code of the particle; Int_t fStatusCode; // generation status code; Int_t fMother[2]; // Indices of the mother particles; Int_t fDaughter[2]; // Indices of the daughter particles; Float_t fWeight; // particle weight. Double_t fCalcMass; // Calculated mass. Double_t fPx; // x component of momentum; Double_t fPy; // y component of momentum; Double_t fPz; // z component of momentum; Double_t fE; // Energy. Double_t fVx; // x of production vertex; Double_t fVy; // y of production vertex; Double_t fVz; // z of production vertex; Double_t fVt; // t of production vertex. Double_t fPolarTheta; // Polar angle of polarisation; Double_t fPolarPhi; // azymutal angle of polarisation. TParticlePDG* fParticlePDG; //! reference to the particle record in PDG database. Function Members (Methods); public:. TParticle(); TParticle(const TParticle& part); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, const TLorentzVector& p, const TLorentzVector& v); TParticle(Int_t pdg, Int_t status, Int_t mother1, Int_t mother2, Int_t daughter1, Int_t daughter2, Double_t px, Double_t py, Double_t pz, Double_t etot, Double_t vx, Double_t vy, Double_t vz, Double_t time); virtual~TParticle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty(); virtual voidTObject::Browse(TBrowser* b); Int_tCharm(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual v",MatchSource.WIKI,root/html528/TParticle.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticle.html
Availability,error,error,"leClassPDG(const char* name = 0); virtual~TParticleClassPDG(); voidTObject::AbstractMethod(const char* method) const; voidAddParticle(TObject* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TObjArray*GetListOfParticles(); virtual const char*TNamed::GetName() const; Int_tGetNParticles(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParticlePDG*GetParticle(Int_t i); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; vi",MatchSource.WIKI,root/html528/TParticleClassPDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticleClassPDG.html
Security,access,access,"r* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TParticleClassPDG(const TParticleClassPDG& pcp); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TParticleClassPDG&operator=(const TParticleClassPDG& pcp). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fListOfParticleslist of (non-owned) particles; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticleClassPDG(const char* name = 0); default constructor. ~TParticleClassPDG(); destructor, class doesn't own its particles... void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. void Browse(TBrowser* b); browse this particle class. TParticleClassPDG(const TParticleClassPDG& pcp); { }. TParticleClassPDG& operator=(const TParticleClassPDG& pcp). Int_t GetNParticles(); ****** access methods. TParticlePDG* GetParticle(Int_t i). TObjArray* GetListOfParticles(); { return fListOfParticles; }. void AddParticle(TObject* p); ****** modifiers. { fListOfParticles->Add(p); }. Bool_t IsFolder() const; { return kTRUE; }. » Author: Pasha Murat 12/02/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/eg:$Id: TParticleClassPDG.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TParticleClassPDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticleClassPDG.html
Availability,error,error,"iParticle(); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; TDecayChannel*DecayChannel(Int_t i); TObjArray*DecayList(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Double_tI3() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const",MatchSource.WIKI,root/html528/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticlePDG.html
Energy Efficiency,charge,charge,". TParticlePDG. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TParticlePDG. class TParticlePDG: public TNamed. Description of the static properties of a particle.; The class is typically generated by the TDatabasePDG class.; It is referenced by the dynamic particle class TParticle.; Int_t fPdgCode; // PDG code of the particle; Double_t fMass; // particle mass in GeV; Double_t fCharge; // charge in units of |e|/3; Double_t fLifetime; // proper lifetime in seconds; Double_t fWidth; // total width in GeV; Int_t fParity; // parity; Double_t fSpin; // spin; Double_t fIsospin; // isospin; Double_t fI3; // i3; Int_t fStrangeness; // flavours are defined if i3 != -1; Int_t fCharm; // 1 or -1 for C-particles, 0 for others; Int_t fBeauty;; Int_t fTop;; Int_t fY; // X,Y: quantum numbers for the 4-th generation; Int_t fX;; Int_t fStable; // 1 if stable, 0 otherwise. TObjArray* fDecayList; // array of decay channels. TString fParticleClass; // lepton, meson etc. Int_t fTrackingCode; // G3 tracking code of the particle; TParticlePDG* fAntiParticle; // pointer to antiparticle. Function Members (Methods); public:. TParticlePDG(); TParticlePDG(int pdg_code); TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode); virtual~TParticlePDG(); voidTObject::AbstractMethod(const char* method) const; Int_tAddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); TParticlePDG*AntiParticle(); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tBeauty() const; virtual voidTObject::Browse(TBrowser* b); Double_tCharge() const; Int_tCharm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Cle",MatchSource.WIKI,root/html528/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticlePDG.html
Security,access,access,"tum numbers for the 4-th generation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TParticlePDG(); default constructor. TParticlePDG(Int_t ); empty for the time being. TParticlePDG(const char* Name, const char* Title, Double_t Mass, Bool_t Stable, Double_t Width, Double_t Charge, const char* ParticleClass, Int_t PdgCode, Int_t Anti, Int_t TrackingCode). TParticlePDG(const TParticlePDG& ); copy constructor. TParticlePDG& operator=(const TParticlePDG& ); assignement operator. ~TParticlePDG(); destructor. Int_t AddDecayChannel(Int_t Type, Double_t BranchingRatio, Int_t NDaughters, Int_t* DaughterPdgCode); add new decay channel, Particle owns those... TDecayChannel* DecayChannel(Int_t i); return pointer to decay channel object at index i. void PrintDecayChannel(TDecayChannel* dc, Option_t* opt = """") const; print the list of decays. void Print(Option_t* opt = """") const. Print the entire information of this kind of particle. Int_t PdgCode() const; ****** access methods. { return fPdgCode; }. Double_t Mass() const; { return fMass; }. Double_t Charge() const; { return fCharge; }. Double_t Lifetime() const; { return fLifetime; }. Double_t Width() const; { return fWidth; }. Int_t Parity() const; { return fParity; }. Double_t Spin() const; { return fSpin; }. Double_t Isospin() const; { return fIsospin; }. Double_t I3() const; { return fI3; }. Int_t Strangeness() const; { return fStrangeness; }. Int_t Charm() const; { return fCharm; }. Int_t Beauty() const; { return fBeauty; }. Int_t Top() const; { return fTop; }. Int_t X() const; { return fX; }. Int_t Y() const; { return fY; }. Int_t Stable() const; { return fStable; }. const char* ParticleClass() const; { return fParticleClass.Data(); }. TObjArray* DecayList(); { return fDecayList; }. Int_t NDecayChannels() const. Int_t TrackingCode() const; { return fTrackingCode; }. TParticlePDG* AntiParticle(); { return fAntiParticle; }. void SetAntiParticle(TParticlePDG* ap); ****** modifiers. ",MatchSource.WIKI,root/html528/TParticlePDG.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TParticlePDG.html
Availability,error,error,"tual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConvertNDCtoPad(); virtual voidCopy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetBorderSize() const; Double_tGetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Int_tGetShadowColor() const; virtual const char",MatchSource.WIKI,root/html528/TPave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPave.html
Availability,error,error,"eVar) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveLabel::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual voidDrawClasses(const char* classes = ""this"")MENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTPaveLabel::DrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; TClassTree*GetClassTree() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveLabel::GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject",MatchSource.WIKI,root/html528/TPaveClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveClass.html
Availability,error,error,"t* obj) const; virtual voidTPave::ConvertNDCtoPad(); virtual voidCopy(TObject& pavelabel) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidDrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPave::Ge",MatchSource.WIKI,root/html528/TPaveLabel.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveLabel.html
Availability,error,error,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters.; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewnes",MatchSource.WIKI,root/html528/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveStats.html
Deployability,update,updated,"w (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st ",MatchSource.WIKI,root/html528/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveStats.html
Security,access,accessed,"eter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the painting should be forced using gPad->Update(); in order to make sure the statistics box is created:. h->Draw();; gPad->Update();; TPaveStats *st = (TPaveStats*)h->FindObject(""stats"");. Without gPad->Update() the line h->FindObject(""stats""); returns a null pointer.; When a histogram is drawn with the option ""SAME"", the statistics box; is not drawn. To force the statistics box drawing with the option; ""SAME"", the option ""SAMES"" must be used.; If the new statistics box hides the previous statistics box, one can change; its position with these lines (""h"" being the pointer to the histogram):. Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); Root > st->SetX1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //ne",MatchSource.WIKI,root/html528/TPaveStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveStats.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TPaveStatsEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveStatsEditor.html
Availability,error,error,"NDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTPaveText::DeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidTPaveText::EditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TList*TPaveText::GetListOfLines() ",MatchSource.WIKI,root/html528/TPavesText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPavesText.html
Availability,error,error,"const; virtual voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual TText*GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*GetLineWith(const char* text) const; virtual TList*GetListOfLines() const; Float_tGetMargin() const; virtual Opt",MatchSource.WIKI,root/html528/TPaveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveText.html
Modifiability,inherit,inherits,"FontText font number; Float_tTAttText::fTextSizeText size; Double_tTBox::fX1X of 1st point; Double_tTPave::fX1NDCX1 point in NDC coordinates; Double_tTBox::fX2X of 2nd point; Double_tTPave::fX2NDCX2 point in NDC coordinates; Double_tTBox::fY1Y of 1st point; Double_tTPave::fY1NDCY1 point in NDC coordinates; Double_tTBox::fY2Y of 2nd point; Double_tTPave::fY2NDCY2 point in NDC coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPaveText(); pavetext default constructor. TPaveText(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Option_t* option = ""br""); pavetext normal constructor. a PaveText is a Pave with several lines of text; The Pave is by default defined bith bordersize=5 and option =""br"".; option = ""T"" Top frame; option = ""B"" Bottom frame; option = ""R"" Right frame; option = ""L"" Left frame; option = ""NDC"" x1,y1,x2,y2 are given in NDC; option = ""ARC"" corners are rounded. The individual text items are entered via AddText; By default, text items inherits from the default pavetext AttText.; A title can be added later to this pavetext via TPaveText::SetLabel. IMPORTANT NOTE:; Because TPave objects (and objects deriving from TPave) have their; master coordinate system in NDC, one cannot use the TBox functions; SetX1,SetY1,SetX2,SetY2 to change the corner coordinates. One should use; instead SetX1NDC, SetY1NDC, SetX2NDC, SetY2NDC. ~TPaveText(); pavetext default destructor. TPaveText(const TPaveText& pavetext); pavetext copy constructor. TPaveText& operator=(const TPaveText& ); assignment operator. TBox * AddBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Add a new graphics box to this pavetext. TLine * AddLine(Double_t x1 = 0, Double_t y1 = 0, Double_t x2 = 0, Double_t y2 = 0); Add a new graphics line to this pavetext. TText * AddText(Double_t x1, Double_t y1, const char* label); Add a new Text line to this pavetext at given coordinates. TText * AddText(const char* label); Add a new Text line to this pavet",MatchSource.WIKI,root/html528/TPaveText.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPaveText.html
Availability,error,error," option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Float_tGetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() const; virtual Int_tGet",MatchSource.WIKI,root/html528/TPCON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPCON.html
Modifiability,extend,extends,". TPCON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPCON. class TPCON: public TShape. . PCON is a polycone. It has the following parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - phi1 the azimuthal angle phi at which the volume begins (angles; are counted counterclockwise); - dphi opening angle of the volume, which extends from; phi1 to phi1+dphi; - nz number of planes perpendicular to the z axis where; the dimension of the section is given -- this number; should be at least 2; - rmin array of dimension nz with minimum radius at a given plane; - rmax array of dimension nz with maximum radius at a given plane; - z array of dimension nz with z position of given plane. Function Members (Methods); public:. TPCON(); TPCON(const char* name, const char* title, const char* material, Float_t phi1, Float_t dphi1, Int_t nz); virtual~TPCON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dum",MatchSource.WIKI,root/html528/TPCON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPCON.html
Availability,error,error,"tion_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Float_t* x, Float_t* y); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Double_t* x, Double_t* y); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFontEncode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual cha",MatchSource.WIKI,root/html528/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPDF.html
Energy Efficiency,green,green,"_t space = kTRUE); virtual voidWriteReal(Float_t r); Double_tXtoPDF(Double_t x); Double_tYtoPDF(Double_t y). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfBluePer cent of blue; char*TVirtualPS::fBufferFile buffer; Bool_tfCompressTrue when fBuffer must be compressed; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Float_tfGreenPer cent of green; const char*TVirtualPS::fImplicitCREscEscape symbol before enforced new line; Int_tTVirtualPS::fLenBufferBuffer length; Color_tTAttLine::fLineColorline color; Float_tfLineScaleLine width scale factor; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTVirtualPS::fNByteNumber of bytes written in the file (PDF); TStringTNamed::fNameobject identifier; Int_tfNbObjNumber of objects; Int_tfNbPageNumber of pages; Int_t*fObjPosObjets position; Int_tfObjPosSizeReal size of fObjPos; Int_tfPageFormatPage format (A4, Letter etc ...); Bool_tfPageNotEmptyTrue if the current page is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font ",MatchSource.WIKI,root/html528/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPDF.html
Integrability,interface,interface,". TPDF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TPDF. class TPDF: public TVirtualPS. TPDF: Graphics interface to PDF; Like PostScript, PDF is a vector graphics output format allowing a very high; graphics output quality. The functionnalities provided by this class are very; similar to those provided by TPostScript. Compare to PostScript output, the PDF files are usually smaller because some; parts of them can be compressed. PDF also allows to define table of contents. This facility can be used in ROOT.; The following example shows how to proceed:. {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }. Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; . Function Members (Methods); public:. TPDF(); TPDF(const char* filename, Int_t type = -111); virtual~TPDF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TO",MatchSource.WIKI,root/html528/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPDF.html
Modifiability,inherit,inherits,"ge is not empty; Int_tfPageOrientationPage orientation (Portrait, Landscape); Bool_tTVirtualPS::fPrintedTrue when a page must be printed; Bool_tfRangeTrue when a range has been defined; Float_tfRedPer cent of red; Int_tTVirtualPS::fSizBufferBuffer size; Int_tfStartStream; ofstream*TVirtualPS::fStreamFile stream identifier; Short_tTAttText::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; Int_tfTypeWorkstation type used to know if the PDF is open; Float_tfXsizePage size along X; Float_tfYsizePage size along Y. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPDF(); Default PDF constructor. TPDF(const char* filename, Int_t type = -111); Initialize the PDF interface. fname : PDF file name; wtype : PDF workstation type. Not used in the PDF driver. But as TPDF; inherits from TVirtualPS it should be kept. Anyway it is not; necessary to specify this parameter at creation time because it; has a default value (which is ignore in the PDF case). ~TPDF(); Default PDF destructor. void CellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); Begin the Cell Array painting. void CellArrayFill(Int_t r, Int_t g, Int_t b); Paint the Cell Array. void CellArrayEnd(); End the Cell Array painting. void Close(Option_t* opt = """"); Close a PDF file. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Draw a Box. void DrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); Draw a Frame around a box. mode = -1 box looks as it is behind the screen; mode = 1 box looks as it is in front of the screen; border is the border size in already precomputed PDF units; dark is the color for the dark part of the frame; light is the color for the light part of the frame. void DrawHatch(Float_t ",MatchSource.WIKI,root/html528/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPDF.html
Testability,test,test,". TPDF. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TPDF. class TPDF: public TVirtualPS. TPDF: Graphics interface to PDF; Like PostScript, PDF is a vector graphics output format allowing a very high; graphics output quality. The functionnalities provided by this class are very; similar to those provided by TPostScript. Compare to PostScript output, the PDF files are usually smaller because some; parts of them can be compressed. PDF also allows to define table of contents. This facility can be used in ROOT.; The following example shows how to proceed:. {; TCanvas* canvas = new TCanvas(""canvas"");; TH1F* histo = new TH1F(""histo"",""test 1"",10,0.,10.);; histo->SetFillColor(2);; histo->Fill(2.);; histo->Draw();; canvas->Print(""plots.pdf("",""Title:One bin filled"");; histo->Fill(4.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Two bins filled"");; histo->Fill(6.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Three bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf"",""Title:Four bins filled"");; histo->Fill(8.);; histo->Draw();; canvas->Print(""plots.pdf)"",""Title:The fourth bin content is 2"");; }. Each character string following the keyword ""Title:"" makes a new entry in; the table of contents.; . Function Members (Methods); public:. TPDF(); TPDF(const char* filename, Int_t type = -111); virtual~TPDF(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TO",MatchSource.WIKI,root/html528/TPDF.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPDF.html
Availability,error,error," TPerfEvent(TTimeStamp* offset = 0); TPerfEvent(const TPerfEvent&); virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root/html528/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfEvent.html
Integrability,interface,interface,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfEvent(TTimeStamp* offset = 0); TPerfEvent(const TPerfEvent&); virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root/html528/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfEvent.html
Performance,perform,performance,". TPerfEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfEvent. class TPerfEvent: public TObject. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfEvent(TTimeStamp* offset = 0); TPerfEvent(const TPerfEvent&); virtual~TPerfEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjec",MatchSource.WIKI,root/html528/TPerfEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfEvent.html
Availability,error,error," voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Optio",MatchSource.WIKI,root/html528/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfStats.html
Energy Efficiency,monitor,monitoring,"ntType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The proofquerylog table has the format:; CREATE TABLE proofquerylog (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; user VARCHAR(32) NOT NULL,; group VARCHAR(32),; begin DATETIME,; end DATETIME,; walltime INT,; cputime FLOAT,; bytesread BIGINT,; events BIGINT,; workers INT; ); The same info is send to Monalisa (or other monitoring systems) in the; form of a list of name,value pairs. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. TPerfStats(TList* input, TList* output). virtual ~TPerfStats(); {}. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TPerfStats.h 30965 2009-11-04 11:15:25Z ganis $ » Last generated: 2010-10-03 18:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfStats.html
Integrability,interface,interface,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfStats(const TPerfStats&); virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start",MatchSource.WIKI,root/html528/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfStats.html
Performance,perform,performance,". TPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TPerfStats. class TPerfStats: public TVirtualPerfStats. TPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods); public:. TPerfStats(const TPerfStats&); virtual~TPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start",MatchSource.WIKI,root/html528/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfStats.html
Testability,log,log,"time of this run. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPerfStats(TList* input, TList* output); Normal constructor. void SimpleEvent(TVirtualPerfStats::EEventType type); Simple event. void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead); Packet event. void FileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); File event. void FileOpenEvent(TFile* file, const char* filename, Double_t start); Open file event. void FileReadEvent(TFile* file, Int_t len, Double_t start); Read file event. void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead); Rate event. void SetBytesRead(Long64_t num); Set number of bytes read. Long64_t GetBytesRead() const; Get number of bytes read. void WriteQueryLog(); Connect to SQL server and register query log used for quotas.; The proofquerylog table has the format:; CREATE TABLE proofquerylog (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; user VARCHAR(32) NOT NULL,; group VARCHAR(32),; begin DATETIME,; end DATETIME,; walltime INT,; cputime FLOAT,; bytesread BIGINT,; events BIGINT,; workers INT; ); The same info is send to Monalisa (or other monitoring systems) in the; form of a list of name,value pairs. void Setup(TList* input); Setup the PROOF input list with requested statistics and tracing options. void Start(TList* input, TList* output); Initialize PROOF statistics run. void Stop(); Terminate the PROOF statistics run. TPerfStats(TList* input, TList* output). virtual ~TPerfStats(); {}. void SetNumEvents(Long64_t num); { fNumEvents = num; }. Long64_t GetNumEvents() const; { return fNumEvents; }. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TPerfStats.h 30965 2009-11-04",MatchSource.WIKI,root/html528/TPerfStats.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPerfStats.html
Availability,error,error," virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTPCON::DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPCON::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TPCON::GetBuffer3D(Int_t reqSections) const; virtual Float_tTPCON::GetDhi1() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_t*TPCON::GetDz() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*TShape::GetMaterial() const; virtual const char*TNamed::GetName() co",MatchSource.WIKI,root/html528/TPGON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPGON.html
Modifiability,extend,extends,". TPGON. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPGON. class TPGON: public TPCON. . PGON is a polygon. It has the following parameters:. - name name of the shape; - title shape's title; - material (see TMaterial); - phi1 the azimuthal angle &phi at which the volume begins (angles; are counted counterclockwise); - dphi1 opening angle of the volume, which extends from phi1 to; phi1+dphi; - npdv number of sides of the cross section between the given; phi limits; - nz number of planes perpendicular to the z axis where; the dimension of the section is given -- this number; should be at least 2; - rmin array of dimension nz with minimum radius at a given plane; - rmax array of dimension nz with maximum radius at a given plane; - z array of dimension nz with z position of given plane. Function Members (Methods); public:. TPGON(); TPGON(const TPGON&); TPGON(const char* name, const char* title, const char* material, Float_t phi1, Float_t dphi1, Int_t npdv, Int_t nz); virtual~TPGON(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTPCON::DefineSection(Int_t secNum, Float_t z, Float_t rmin, Float_t rmax); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPCON::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObje",MatchSource.WIKI,root/html528/TPGON.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPGON.html
Availability,error,error,", Int_t* cols = 0, const char** lbls = 0); virtual~TPie(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); Int_tDistancetoSlice(Int_t, Int_t); virtual voidDraw(Option_t* option = ""l"")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t, Int_t, Int_t); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAngle3D(); Double_tGetAngularOffset(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntries(); Int_tGetEntryFillColor(Int_t); Int_tGetEntryFillStyle(Int_t); const char*GetEntryLabel(Int_t); Int_tGetEntryLineColor(Int_t); Int_tGetEntryLineStyle(Int_t); Int_tGetEntryLineWidth(Int_t); Double_tGetEntryRadiusOffset(Int_t); Double_tGetEntryVal(Int_t); const char*GetFractionFormat(); Double_tGetHeight(); virtual const char*TObject::GetIconName() const; const char*GetLabelFormat(); Float_tGetLabelsOffset(); TLegend*GetLegend(); virtual const char*TNamed::Get",MatchSource.WIKI,root/html528/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPie.html
Energy Efficiency,allocate,allocate,"Text::fTextAlignText alignment; Float_tTAttText::fTextAngleText angle; Color_tTAttText::fTextColorText color index; Font_tTAttText::fTextFontText font number; Float_tTAttText::fTextSizeText size; TStringTNamed::fTitleobject title; TStringfValueFormatVform numeric format for the value; Double_tfXX coordinate of the pie centre; Double_tfYY coordinate of the pie centre. private:. TLegend*fLegend!Legend for this piechart; Float_t*fSlices!Subdivisions of the slices; Float_tfSum!Sum for the slice values. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPie(); Default constructor. TPie(const char* , const char* , Int_t ); This constructor creates a pie chart when only the number of; the slices is known. The number of slices is fixed. TPie(const char* , const char* , Int_t , Double_t* , Int_t* cols = 0, const char** lbls = 0); Normal constructor. The 1st and 2nd parameters are the name of the object; and its title. The number of points passed at this point is used to allocate the memory. Slices values are given as Double_t. The 4th elements is an array containing, in double precision format,; the value of each slice. It is also possible to specify the filled color; of each slice. If the color array is not specfied the slices are colored; using a color sequence in the standard palette. TPie(const char* , const char* , Int_t , Float_t* , Int_t* cols = 0, const char** lbls = 0); Normal constructor (Float_t). TPie(const TH1* h); Constructor from a TH1. TPie(const TPie& ); Copy constructor. ~TPie(); Destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Evaluate the distance to the chart in gPad. Int_t DistancetoSlice(Int_t , Int_t ); Returns the slice number at the pixel position (px,py).; Returns -1 if no slice is picked. Used by DistancetoPrimitive. void Draw(Option_t* option = ""l""); Draw the pie chart. The possible options are listed in the TPie::Paint() method. void DrawGhost(); This method is for internal use. It is used by Ex",MatchSource.WIKI,root/html528/TPie.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPie.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPieEditor.html
Integrability,interface,interface,"xel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; TGButtonGroup*fgrGroup the Radiobuttons:. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPieEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor of graph editor. ~TPieEditor(); Destructor of pie editor. void ConnectSignals2Slots(); Connect signals to slots. void ActivateBaseClassEditors(TClass* ); Exclude TAttTextEditor from this interface. void SetModel(TObject* ); Pick up the used values of graph attributes. void DoTitle(const char* text); Slot for setting the graph title. void DoShape(); Slot connected to the draw options. void DoMarkerOnOff(Bool_t on); Slot for setting markers as visible/invisible. void DoChange3DAngle(); Slot for setting the 3D angle. void DoGraphLineWidth(); Slot connected to the graph line width. void DoTextChange(); Change text. TGComboBox* BuildFontSizeComboBox(TGFrame* , Int_t ); Create text size combo box. » Author: Guido Volpi 04/10/2007 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id: TPieEditor.h 31945 2009-12-21 19:03:21Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPieEditor.html
Usability,simpl,simple,,MatchSource.WIKI,root/html528/TPieEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPieEditor.html
Availability,error,error,"ct::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t, Int_t); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRadiusOffset(); virtua",MatchSource.WIKI,root/html528/TPieSlice.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPieSlice.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TPieSliceEditor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPieSliceEditor.html
Availability,error,error,,MatchSource.WIKI,root/html528/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginHandler.html
Integrability,depend,dependencies,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Int_tCheckPlugin() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtu",MatchSource.WIKI,root/html528/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginHandler.html
Modifiability,plugin,plugin,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html528/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginHandler.html
Performance,load,load,". TPluginHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginHandler. class TPluginHandler: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html528/TPluginHandler.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginHandler.html
Availability,error,error,"Handler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TPluginHandler*FindHandler(const char* base, const char* uri = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) co",MatchSource.WIKI,root/html528/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginManager.html
Integrability,depend,dependencies,"xisting definition of TSQLServer, useful when there is more than; one plugin that can extend the same base class. The ""<constructor>""; should be the constructor or a static method that generates an; instance of the specified class. Global methods should start with; ""::"" in their name, like ""::CreateFitter()"".; Instead of being a shared library a plugin can also be a CINT; script, so instead of libDialog.so one can have Dialog.C.; The * is a placeholder in case there is no need for a URI to; differentiate between different plugins for the same base class.; For the default plugins see $ROOTSYS/etc/system.rootrc. Plugin handlers can also be registered at run time, e.g.:. gPluginMgr->AddHandler(""TSQLServer"", ""^sapdb:"",; ""TSapDBServer"", ""SapDB"",; ""TSapDBServer(const char*,const char*, const char*)"");. A list of currently defined handlers can be printed using:. gPluginMgr->Print(); // use option=""a"" to see ctors. The use of the plugin library manager removes all textual references; to hard-coded class and library names and the resulting dependencies; in the base classes. The plugin manager is used to extend a.o.; TFile, TSQLServer, TGrid, etc. functionality. Function Members (Methods); public:. TPluginManager(); virtual~TPluginManager(); voidTObject::AbstractMethod(const char* method) const; voidAddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = ",MatchSource.WIKI,root/html528/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginManager.html
Modifiability,plugin,plugin,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html528/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginManager.html
Performance,load,load,". TPluginManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPluginManager. class TPluginManager: public TObject. TPluginManager. This class implements a plugin library manager. It keeps track of; a list of plugin handlers. A plugin handler knows which plugin; library to load to get a specific class that is used to extend the; functionality of a specific base class and how to create an object; of this class. For example, to extend the base class TFile to be; able to read RFIO files one needs to load the plugin library; libRFIO.so which defines the TRFIOFile class. This loading should; be triggered when a given URI contains a regular expression defined; by the handler.; Plugin handlers can be defined via macros in a list of plugin; directories. With $ROOTSYS/etc/plugins the default top plugin; directory specified in $ROOTSYS/etc/system.rootrc. Additional; directories can be specified by adding them to the end of the list.; Macros for identical plugin handlers in later directories will; override previous ones (the inverse of normal search path behavior).; The macros must have names like <BaseClass>/PX0_<PluginClass>.C,; e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a; namespace the directory must have the name NameSpace@@BaseClass as; : is a reserved pathname character on some operating systems.; Macros not beginning with 'P' and ending with "".C"" are ignored.; These macros typically look like:. void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*)"");; }. Plugin handlers can also be defined via resources in the .rootrc; file. Although now deprecated this method still works for backward; compatibility, e.g.:. Plugin.TFile: ^rfio: ",MatchSource.WIKI,root/html528/TPluginManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPluginManager.html
Performance,perform,performed,"into at most maxfields. If maxfields is unspecified or; 0, trailing empty matches are discarded. If maxfields is; positive, no more than maxfields fields will be returned and; trailing empty matches are preserved. If maxfields is empty,; all fields (including trailing empty ones) are returned. This; *should* be the same as the perl behaviour. If pattern produces sub-matches, these are also stored in; the result. A pattern matching the null string will split the value of EXPR; into separate characters at each point it matches that way. Args:; s - string to split; maxfields - maximum number of fields to be split out. 0 means; split all fields, but discard any trailing empty bits.; Negative means split all fields and keep trailing empty bits.; Positive means keep up to N fields including any empty fields; less than N. Anything remaining is in the last field.; Returns: - number of fields found. Int_t Substitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE); Substitute matching part of s with r, dollar back-ref; substitution is performed if doDollarSubst is true (default).; Returns the number of substitutions made. After the substitution, another pass is made over the resulting; string and the following special tokens are interpreted:; \l - lowercase next char,; \u - uppercase next char,; \L - lowercase till \E,; \U - uppercase till \E, and; \E - end case modification. TString operator[](Int_t ); Returns the sub-string from the internal fMarkers vector.; Requires having run match or split first. void Print(Option_t* option = """"); Print the regular expression and modifier options.; If 'option' contains ""all"", prints also last string match and; match results. TPRegexp & operator=(const TPMERegexp& ). virtual ~TPMERegexp(); {}. Int_t GetNMaxMatches() const; { return fNMaxMatches; }. void SetNMaxMatches(Int_t nm); { fNMaxMatches = nm; }. Int_t GetGlobalPosition() const; { return fLastGlobalPosition; }. Int_t NMatches() const; { return fNMatches; }. » Author: Edd",MatchSource.WIKI,root/html528/TPMERegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPMERegexp.html
Usability,simpl,simply,". TPMERegexp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPMERegexp. class TPMERegexp: protected TPRegexp. Wrapper for PCRE library (Perl Compatible Regular Expressions).; Based on PME - PCRE Made Easy by Zachary Hansen. Supports main Perl operations using regular expressions (Match,; Substitute and Split). To retrieve the results one can simply use; operator[] returning a TString. See $ROOTSYS/tutorials/regexp_pme.C for examples. Function Members (Methods); public:. TPMERegexp(); TPMERegexp(const TPMERegexp& r); TPMERegexp(const TString& s, const TString& opts = """", Int_t nMatchMax = 10); TPMERegexp(const TString& s, UInt_t opts, Int_t nMatchMax = 10); virtual~TPMERegexp(); voidAssignGlobalState(const TPMERegexp& re); static TClass*Class(); Int_tGetGlobalPosition() const; Int_tGetNMaxMatches() const; virtual TClass*IsA() const; Int_tMatch(const TString& s, UInt_t start = 0); Int_tNMatches() const; TStringoperator[](Int_t); virtual voidPrint(Option_t* option = """"); voidReset(const TString& s, const TString& opts = """", Int_t nMatchMax = -1); voidReset(const TString& s, UInt_t opts, Int_t nMatchMax = -1); voidResetGlobalState(); voidSetNMaxMatches(Int_t nm); virtual voidShowMembers(TMemberInspector& insp); Int_tSplit(const TString& s, Int_t maxfields = 0); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); Int_tSubstitute(TString& s, const TString& r, Bool_t doDollarSubst = kTRUE). protected:. voidTPRegexp::Compile(); TStringTPRegexp::GetModifiers() const; TStringTPRegexp::GetPattern() const; Bool_tTPRegexp::MatchB(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Int_tTPRegexp::MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); TObjArray*TPRegexp::MatchS(const TString& s, const TString& mods = """", Int_t ",MatchSource.WIKI,root/html528/TPMERegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPMERegexp.html
Integrability,rout,routines,". TPoint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TPoint. class TPoint. TPoint. TPoint implements a 2D screen (device) point (see also TPoints). Don't add in dictionary since that will add a virtual table pointer; and that will destroy the data layout of an array of TPoint's which; should match the layout of an array of XPoint's (so no extra copying; needs to be done in the X11 drawing routines). Function Members (Methods); public:. TPoint(); TPoint(SCoord_t xy); TPoint(const TPoint&); TPoint(SCoord_t x, SCoord_t y); ~TPoint(); SCoord_tGetX() const; SCoord_tGetY() const; TPoint&operator=(const TPoint& p); voidSetX(SCoord_t x); voidSetY(SCoord_t y). Data Members; public:. SCoord_tfXX device coordinate; SCoord_tfYY device coordinate. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPoint(); { }. TPoint(SCoord_t xy); { }. TPoint(SCoord_t x, SCoord_t y); { }. ~TPoint(); { }. SCoord_t GetX() const; { return (SCoord_t)fX; }. SCoord_t GetY() const; { return (SCoord_t)fY; }. void SetX(SCoord_t x); { fX = x; }. void SetY(SCoord_t y); { fY = y; }. TPoint& operator=(const TPoint& p); { fX = p.fX; fY = p.fY; return *this; }. » Last changed: Thu Sep 23 20:19:19 2010 » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPoint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPoint.html
Availability,error,error," x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidDelete(); virtual voidDelete(Option_t* opt); static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const",MatchSource.WIKI,root/html528/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPoints3D.html
Energy Efficiency,allocate,allocates,". TPoints3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPoints3D. class TPoints3D: public TPoints3DABC. TPoints3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implemenatation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPoints3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPoints3D *pl1 = new TPoints3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPoints3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPoints3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPoints3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. TPoints3D(TPoints3DABC* points = 0); TPoints3D(const TPoints3D& points); TPoints3D(Int_t n, Option_t* option = """"); TPoints3D(Int_t n, Float_t* p, Option_t* option = """"); TPoints3D(Int_t n, Float_t* x, Float_t* y, Float_t* z, Option_t* option = """"); virtual~TPoints3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") co",MatchSource.WIKI,root/html528/TPoints3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPoints3D.html
Availability,avail,available,". TPoints3DABC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPoints3DABC. class TPoints3DABC: public TObject. The TPoints3DABC class; Abstract class to define Arrays of 3D points.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TPoints3DABC(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Float_t x, Float_t y, Float_t z); virtual Int_tAddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObje",MatchSource.WIKI,root/html528/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPoints3DABC.html
Energy Efficiency,allocate,allocated,"its last element. Int_t DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); Compute distance from point px,py to an axis of the band defined.; by pair points (x1,y1),(x2,y2) where lineWidth is the width of the band. Compute the closest distance of approach from point px,py to this line.; The distance is computed in pixels units. Algorithm:. A(x1,y1) P B(x2,y2). I; I; I; I; M(x,y). Let us call a = distance AM a2=a**2; b = distance BM b2=b**2; c = distance AB c2=c**2; d = distance PM d2=d**2; u = distance AP u2=u**2; v = distance BP v2=v**2 c = u + v. d2 = a2 - u2; d2 = b2 - v2 = b2 -(c-u)**2; ==> u = (a2 -b2 +c2)/2c. Float_t x1 = gPad->XtoAbsPixel(xp1);; Float_t y1 = gPad->YtoAbsPixel(yp1);; Float_t x2 = gPad->XtoAbsPixel(xp2);; Float_t y2 = gPad->YtoAbsPixel(yp2);. Int_t SetNextPoint(Float_t x, Float_t y, Float_t z); Add one 3D point defined by x,y,z to the array of the points; as its last element. Int_t GetN() const; GetN() returns the number of allocated cells if any.; GetN() > 0 shows how many cells; can be available via GetP() method.; GetN() == 0 then GetP() must return 0 as well. Float_t * GetP() const; GetP() returns the pointer to the float point array; of points if available; The number of the available celss can be found via; GetN() method.; GetN() > 0 shows how many cells. Float_t * GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const; GetXYZ(Float_t *xyz,Int_t idx,Int_t num=1) fills the buffer supplied; by the calling code with the points information. Input parameters:. Float_t *xyz - an external user supplied floating point array.; Int_t num - the total number of the points to be copied; the dimension of that array the size of the; array is num*sizeof(Float_t) at least; Int_t idx - The index of the first copy to be taken. Return: The pointer to the buffer array supplied. virtual ~TPoints3DABC(); {;}. Int_t DistancetoPrimitive(Int_t px, Int_t py). Int_t GetLastPosition() const; GetN() returns the number",MatchSource.WIKI,root/html528/TPoints3DABC.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPoints3DABC.html
Availability,error,error," x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& points) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*GetXYZ(Int_t idx); virtual Float_t*GetXYZ(Float_t* xyz, Int_t idx, Int_t num = 1) const",MatchSource.WIKI,root/html528/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointsArray3D.html
Energy Efficiency,allocate,allocates,". TPointsArray3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TPointsArray3D. class TPointsArray3D: public TPoints3DABC. TPointsArray3D is an abstract class of the array of 3-dimensional points.; It has 4 different constructors. This class has no implementation for Paint, Draw, and SavePrimitive methods. First one, without any parameters TPointsArray3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPointsArray3D *pl1 = new TPointsArray3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPointsArray3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPointsArray3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPointsArray3D pl1(150, xArray, yArray, zArray);. Function Members (Methods); public:. TPointsArray3D(); TPointsArray3D(const TPointsArray3D& points); TPointsArray3D(Int_t n, Option_t* option = """"); TPointsArray3D(Int_t n, Float_t* p, Option_t* option = """"); TPointsArray3D(Int_t n, Float_t* x, Float_t* y, Float_t* z, Option_t* option = """"); virtual~TPointsArray3D(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tTPoints3DABC::Add(Float_t x, Float_t y, Float_t z); virtual Int_tTPoints3DABC::AddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """");",MatchSource.WIKI,root/html528/TPointsArray3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointsArray3D.html
Availability,error,error,"t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPolyMarker3D::DrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPolyMarker3D::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_t*TAttBBox::GetBBox(); Bool_tTAttBBox::GetBBoxOK() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tTPolyMarker3D::GetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tTPolyMarker3D::GetN() const; virtual const char*TPolyMarker3D::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPolyMarker3D::GetOptio",MatchSource.WIKI,root/html528/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointSet3D.html
Modifiability,extend,extend,"ptions; Bool_tfOwnIdsFlag specifying id-objects are owned by the point-set; Float_t*TPolyMarker3D::fP[3*fN] Array of X,Y,Z coordinates. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPointSet3D(const TPointSet3D& t); Copy constructor. ~TPointSet3D(); Destructor. void CopyIds(const TPointSet3D& t); Copy id objects from point-set 't'. TPointSet3D& operator=(const TPointSet3D& t); Assignement operator. void ComputeBBox(); Compute the bounding box of this points set. void SetPointId(TObject* id); Set id of last point.; Use this method if you also use TPolyMarker3D::SetNextPoint(). void SetPointId(Int_t n, TObject* id); Set id of point n. void ClearIds(); Clears the id-array. If ids are owned the TObjects are deleted. void PointSelected(Int_t n); This virtual method is called from TPointSet3DGL when a point is; selected.; At this point it just prints out n and id of the point (if it exists).; To make something useful out of this do:; a) subclass and re-implement this method;; b) extend this class to include TExec or some other kind of callback. void Streamer(TBuffer& b); Stream an object of class TPointSet3D. TPointSet3D(); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); { fName=""TPointSet3D""; }. TObject* GetPointId(Int_t n) const; { return fIds.At(n); }. Bool_t GetOwnIds() const; { return fOwnIds; }. void SetOwnIds(Bool_t o); { fOwnIds = o; }. » Author: Matevz Tadel 7/4/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id: TPointSet3D.h 27556 2009-02-20 17:38:28Z matevz $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointSet3D.html
Usability,clear,cleared,". TPointSet3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPointSet3D. class TPointSet3D: public TPolyMarker3D, public TAttBBox. TPolyMarker3D using TPointSet3DGL for direct OpenGL rendering.; Supports only elementary marker types:; 4, 20, 24 : round points, size in pixels;; 2, 3, 5 : crosses, size in scene units;; 28 : as above, line width 2 pixels;; all other : square points, size in pixels. Marker-size (from TAttMarker) is multiplied by 5!. An identification of type TObject* can be assigned to each point; via SetPointId() method. Set the fOwnIds flag if the ids are owned; by the point-set and should be deleted when pointset is cleared or; destructed. Copy-constructor and assignment operator COPIES the ids if the are; not owned and CLONES them if they are owned. The ids are not streamed. Function Members (Methods); public:. TPointSet3D(); TPointSet3D(const TPointSet3D& t); TPointSet3D(Int_t n, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Float_t* p, Marker_t m = 1, Option_t* opt = """"); TPointSet3D(Int_t n, Double_t* p, Marker_t m = 1, Option_t* opt = """"); virtual~TPointSet3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Float_t*TAttBBox::AssertBBox(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearIds(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeBBox(); virtual voidTPolyMarker3D::Copy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTPolyMarker3D::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPolyMarker3D::Draw(Option_t* option = """")",MatchSource.WIKI,root/html528/TPointSet3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointSet3D.html
Performance,cache,cached,"tSet3DGL(); voidTGLLogicalShape::AddRef(TGLPhysicalShape* phys) const; virtual Bool_tTGLLogicalShape::AlwaysSecondarySelect() const; const TGLBoundingBox&TGLLogicalShape::BoundingBox() const; static TClass*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLObject::KeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root/html528/TPointSet3DGL.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPointSet3DGL.html
Availability,error,error,"dPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual const char*TObject::GetTitle() cons",MatchSource.WIKI,root/html528/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine.html
Deployability,release,released,"polyline. First looks for distances to the points of the polyline. Stops search; and returns if a vertex of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this polyline with its attributes.; The option string is ignored. Int_t Merge(TCollection* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetND",MatchSource.WIKI,root/html528/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine.html
Integrability,depend,depend,"ion.; Allocates n points. The option string is ignored. TPolyLine(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); PolyLine normal constructor (single precision).; Makes n points with (x, y) coordinates from x and y.; The option string is ignored. TPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); PolyLine normal constructor (double precision).; Makes n points with (x, y) coordinates from x and y.; The option string is ignored. TPolyLine& operator=(const TPolyLine& ); assignment operator. ~TPolyLine(); PolyLine default destructor. TPolyLine(const TPolyLine& polyline); PolyLine copy constructor. void Copy(TObject& polyline) const; Copy this polyline to polyline. Int_t DistancetoPrimitive(Int_t px, Int_t py); Returns closest distance in pixels from point (px, py) to a polyline. First looks for distances to the points of the polyline. Stops search; and returns if a vertex of the polyline is found to be closer than 10; pixels. Thus the return value may depend on the ordering of points; in the polyline. Then looks for distances to the lines of the polyline. There is no; arbitrary cutoff; any distance may be found. Finally checks whether (px, py) is inside a closed and filled polyline.; (Must be EXACTLY closed. ""Filled"" means fill color and fill style are; both non-zero.) If so, returns zero. Returns 9999 if the polyline has no points. void Draw(Option_t* option = """"); Draw this polyline with its current attributes. void DrawPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function is called when a polyline is clicked with the locator. If Left button clicked on one of the line end points, this point; follows the cursor until button is released. if Middle button clicked, the line is moved parallel to itself; until the button is released. void ls(Option_t* option = """") const; List this",MatchSource.WIKI,root/html528/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine.html
Modifiability,extend,extended,"* list); Merge polylines in the collection in this polyline. void Paint(Option_t* option = """"); Paint this polyline with its current attributes. void PaintPolyLine(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates. If option = 'f' or 'F' the fill area is drawn.; The default is to draw the lines only. void PaintPolyLineNDC(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw this polyline with new coordinates in NDC. void Print(Option_t* option = """") const; Dump this polyline with its attributes.; The option string is ignored. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SetNDC(Bool_t isNDC = kTRUE); Set NDC mode on if isNDC = kTRUE, off otherwise. Int_t SetNextPoint(Double_t x, Double_t y); Set point following LastPoint to x, y.; Returns index of the point (new last point). void SetPoint(Int_t point, Double_t x, Double_t y); Set point number n to (x, y); If n is greater than the current size, the arrays are automatically; extended. void SetPolyLine(Int_t n); Resize this polyline to size n.; If n <= 0 the current arrays of points are deleted.; If n is greater than the current size, the new points are set to (0, 0). void SetPolyLine(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); Set new values for this polyline (single precision). If n <= 0 the current arrays of points are deleted. void SetPolyLine(Int_t n, Double_t* x, Double_t* y3, Option_t* option = """"); Set new values for this polyline (double precision). If n <= 0 the current arrays of points are deleted. void Streamer(TBuffer& b); Stream a class object. Int_t GetLastPoint() const; { return fLastPoint;}. Int_t GetN() const; {return fN;}. Double_t * GetX() const; {return fX;}. Double_t * GetY() const; {return fY;}. Option_t * GetOption() const; {return fOption.Data();}. void SetOption(Option_t* option = """"); {fOption = option;}. Int_t Size() const; {return fLastPoint+1;}.",MatchSource.WIKI,root/html528/TPolyLine.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine.html
Availability,error,error,"ser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidDrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTime",MatchSource.WIKI,root/html528/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine3D.html
Energy Efficiency,allocate,allocates,". TPolyLine3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPolyLine3D. class TPolyLine3D: public TObject, public TAttLine, public TAtt3D. PolyLine3D is a 3-dimensional polyline. It has 4 different constructors. First one, without any parameters TPolyLine3D(), we call 'default; constructor' and it's used in a case that just an initialisation is; needed (i.e. pointer declaration). Example:; TPolyLine3D *pl1 = new TPolyLine3D;. Second one is 'normal constructor' with, usually, one parameter; n (number of points), and it just allocates a space for the points. Example:; TPolyLine3D pl1(150);. Third one allocates a space for the points, and also makes; initialisation from the given array. Example:; TPolyLine3D pl1(150, pointerToAnArray);. Fourth one is, almost, similar to the constructor above, except; initialisation is provided with three independent arrays (array of; x coordinates, y coordinates and z coordinates). Example:; TPolyLine3D pl1(150, xArray, yArray, zArray);. Example:; void pl3() {; TCanvas *c1 = new TCanvas(""c1"");; TView *view = TView::CreateView(1);; view->SetRange(0,0,0,2,2,2);; const Int_t n = 100;; TPolyLine3D *l = new TPolyLine3D(n);; for (Int_t i=0;i<n;i++) {; Double_t x = 2*gRandom->Rndm();; Double_t y = 2*gRandom->Rndm();; Double_t z = 2*gRandom->Rndm();; l->SetPoint(i,x,y,z);; }; l->Draw();; }. Function Members (Methods); public:. TPolyLine3D(); TPolyLine3D(const TPolyLine3D& polylin); TPolyLine3D(Int_t n, Option_t* option = """"); TPolyLine3D(Int_t n, Float_t* p, Option_t* option = """"); TPolyLine3D(Int_t n, Double_t* p, Option_t* option = """"); TPolyLine3D(Int_t n, Float_t* x, Float_t* y, Float_t* z, Option_t* option = """"); TPolyLine3D(Int_t n, Double_t* x, Double_t* y, Double_t* z, Option_t* option = """"); virtual~TPolyLine3D(); voidTObject::AbstractMethod(const cha",MatchSource.WIKI,root/html528/TPolyLine3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLine3D.html
Availability,error,error,"dTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&TShape::GetBuffer3D(Int_t reqSections) const; virtual Color_tGetColorAttribute() const; virtual TShape*GetConnection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TPoints3DABC*GetMarker() const; virtual Color_tTAttMarker::GetMarkerColor()",MatchSource.WIKI,root/html528/TPolyLineShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLineShape.html
Integrability,rout,routine,"of the start point of the current segment; Double_t *end - coordinate of the end point of the current segment. void Paint(Option_t* opt); to be documented. void PaintPoints(Int_t n, Float_t* p = 0, Option_t* opt = """"); Draw this 3-D polyline with new coordinates*-; *-* ===========================================. void PaintPolyMarker(Int_t n, Float_t* p = 0, Marker_t m = 0, Option_t* opt = """"); -*Paint polymarker in CurrentPad World coordinates; *-* ================================================. void Paint3d(Option_t* opt); to be documented. void PaintX3DLine(Option_t* opt = """"); to be documented. void PaintX3DMarker(Option_t* opt = """"); to be documented. Float_t Product(Float_t* v1, Float_t* v2, Int_t ndim = 3); to be documented. Double_t Product(Double_t* v1, Double_t* v2, Int_t ndim = 3); to be documented. Double_t * Gyrot(Double_t* dirc, Double_t cosang, Double_t sinang, Double_t** trans). call gyrot(dirc,angp,trans,ntrans) vp 880722; revised vp 921009; revised (f->c++) vf 981006; routine for filling rotation transformation matrix; from axis and rotation angle around. arguments:; dirc direct cosinuses (may be not normalised); cosang, sinang - cos and sin of the rotation angle; tranz rotation & shift matrix 3*3 (input/output). This code is provided by Victor Perevoztchikov. Color_t SetColorAttribute(Color_t color); to be documented. Size_t SetSizeAttribute(Size_t size); to be documented. Style_t SetStyleAttribute(Style_t style); SetStyleAttribute(Style_t style) - set new style for this line; Returns:; previous value of the line style. void SetShape(TShape* shape); to be documented. Int_t Size() const; to be documented. void Sizeof3D() const; -*Return total X3D size of this shape with its attributes; *-* =======================================================. void SetConnection(TShape* connection); { fConnection = connection;}. TPolyLineShape(). TShape * GetConnection() const; { return fConnection;}. TPoints3DABC * GetMarker() const; { return fPoints;}. TPoint",MatchSource.WIKI,root/html528/TPolyLineShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLineShape.html
Safety,avoid,avoid,"istancetoPrimitive(Int_t px, Int_t py); virtual voidSetConnection(TShape* connection); Int_tTShape::ShapeDistancetoPrimitive(Int_t numPoints, Int_t px, Int_t py). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TShape*fConnectionshape to represent the each ""end"" of the polyline; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Bool_tfHasDrawnflag to avoid multiply plots; Color_tTAttLine::fLineColorline color; Bool_tfLineFlagFlag whether we should connect the points with ""line"" (option ""L""); Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTShape::fNumberShape number; Bool_tfPointFlagFlag whether we should paint ""points"" (option ""P""); TPoints3DABC*fPointsPolyLine itself; TShape*fShapeshape for draw each segment of the polylins; EShapeTypesfShapeTypeshape of the segment connections; _x3d_sizeof_*fSizeX3D! the X3D buffer sizes; Bool_tfSmoothMake smooth connections; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_tfWidthFactorfactor to calculate the the tube diameters. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPolyLineShape(); to be documented. TPolyLineShape(TPoints3DABC* points, Option_t* option = ""P""); fShape = new TTUBE(""tube"",""tube"",""void"",0.5,0.5);. ~TPolyLineShape(); to be documented. void Create(); to be documented. Size3D * CreateX3DSize(Bool_t marker = kFALSE); to be documented. Int_t SetConnection(EShapeTypes connection = kBrik); to be documented. In",MatchSource.WIKI,root/html528/TPolyLineShape.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyLineShape.html
Availability,error,error,"irtual~TPolyMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX() const; Double",MatchSource.WIKI,root/html528/TPolyMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyMarker.html
Modifiability,extend,extended,"id DrawPolyMarker(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Draw polymarker. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the window. void ls(Option_t* option = """") const; ls. Int_t Merge(TCollection* list); Merge polymarkers in the collection in this polymarker. void Paint(Option_t* option = """"); Paint. void PaintPolyMarker(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); Paint polymarker. void Print(Option_t* option = """") const; Print polymarker. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. Int_t SetNextPoint(Double_t x, Double_t y); Set point following LastPoint to x, y.; Returns index of the point (new last point). void SetPoint(Int_t point, Double_t x, Double_t y); Set point number n.; if n is greater than the current size, the arrays are automatically; extended. void SetPolyMarker(Int_t n); If n <= 0 the current arrays of points are deleted. void SetPolyMarker(Int_t n, Float_t* x, Float_t* y, Option_t* option = """"); If n <= 0 the current arrays of points are deleted. void SetPolyMarker(Int_t n, Double_t* x, Double_t* y, Option_t* option = """"); If n <= 0 the current arrays of points are deleted. void Streamer(TBuffer& b); Stream a class object. Int_t GetLastPoint() const; { return fLastPoint;}. Int_t GetN() const; {return fN;}. Option_t * GetOption() const; {return fOption.Data();}. Double_t * GetX() const; {return fX;}. Double_t * GetY() const; {return fY;}. Int_t Size() const; {return fLastPoint+1;}. » Author: Rene Brun 12/12/94 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: TPolyMarker.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ",MatchSource.WIKI,root/html528/TPolyMarker.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyMarker.html
Availability,error,error,"l~TPolyMarker3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polymarker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPolyMarker(Int_t n, Float_t* p, Marker_t marker, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPoint() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual Int_tGetN() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*GetP() const; virtual voidGetPoint(Int_t n, Float_t& x, Float_t& y, Float_t& z) const; virtual voidGetPoint(Int_",MatchSource.WIKI,root/html528/TPolyMarker3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPolyMarker3D.html
Availability,error,error,"dition(const TPosixCondition&); virtual~TPosixCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TPosixCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixCondition.html
Deployability,release,released,"ted:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. pthread_cond_tfCondthe pthread condition variable; TPosixMutex*fMutexmutex used around Wait() and TimedWait(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPosixCondition(TMutexImp* m); Create Condition variable. Ctor must be given a pointer to an; existing mutex. The condition variable is then linked to the mutex,; so that there is an implicit unlock and lock around Wait() and; TimedWait(). ~TPosixCondition(); TCondition dtor. Int_t Wait(); Wait for the condition variable to be signalled. The mutex is; implicitely released before waiting and locked again after waking up.; If Wait() is called by multiple threads, a signal may wake up more; than one thread. See POSIX threads documentation for details. Int_t TimedWait(ULong_t secs, ULong_t nanoSecs = 0); TimedWait() is given an absolute time to wait until. To wait for a; relative time from now, use TThread::GetTime(). See POSIX threads; documentation for why absolute times are better than relative.; Returns 0 if successfully signalled, 1 if time expired. Int_t Signal(); If one or more threads have called Wait(), Signal() wakes up at least; one of them, possibly more. See POSIX threads documentation for details. Int_t Broadcast(); Broadcast is like signal but wakes all threads which have called Wait(). TPosixCondition(TMutexImp* m). » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TPosixCondition.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:19; This page has been ",MatchSource.WIKI,root/html528/TPosixCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixCondition.html
Integrability,interface,interface,". TPosixCondition. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TPosixCondition. class TPosixCondition: public TConditionImp. TPosixCondition. This class provides an interface to the posix condition variable; routines. Function Members (Methods); public:. TPosixCondition(TMutexImp* m); TPosixCondition(const TPosixCondition&); virtual~TPosixCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObj",MatchSource.WIKI,root/html528/TPosixCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixCondition.html
Modifiability,variab,variable,". TPosixCondition. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TPosixCondition. class TPosixCondition: public TConditionImp. TPosixCondition. This class provides an interface to the posix condition variable; routines. Function Members (Methods); public:. TPosixCondition(TMutexImp* m); TPosixCondition(const TPosixCondition&); virtual~TPosixCondition(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tBroadcast(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObj",MatchSource.WIKI,root/html528/TPosixCondition.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixCondition.html
Availability,error,error,"(Bool_t recursive = kFALSE); TPosixMutex(const TPosixMutex&); virtual~TPosixMutex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TPosixMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixMutex.html
Integrability,interface,interface,". TPosixMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TPosixMutex. class TPosixMutex: public TMutexImp. TPosixMutex. This class provides an interface to the posix mutex routines. Function Members (Methods); public:. TPosixMutex(Bool_t recursive = kFALSE); TPosixMutex(const TPosixMutex&); virtual~TPosixMutex(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t",MatchSource.WIKI,root/html528/TPosixMutex.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixMutex.html
Availability,error,error,"ion_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsF",MatchSource.WIKI,root/html528/TPosixThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixThread.html
Integrability,interface,interface,". TPosixThread. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TPosixThread. class TPosixThread: public TThreadImp. TPosixThread. This class provides an interface to the posix thread routines. Function Members (Methods); public:. TPosixThread(); TPosixThread(const TPosixThread&); virtual~TPosixThread(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ret); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDra",MatchSource.WIKI,root/html528/TPosixThread.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixThread.html
Availability,error,error,"voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TPosixThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixThreadFactory.html
Modifiability,variab,variable,"f() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPosixThreadFactory(const char* name = ""Posix"", const char* title = ""Posix Thread Factory""); Create Posix thread factory. Also sets global gThreadFactory to this. TMutexImp * CreateMutexImp(Bool_t recursive); Return a Posix Mutex. TThreadImp * CreateThreadImp(); Return a Posix thread. TConditionImp * CreateConditionImp(TMutexImp* m); Return a Posix condition variable. TPosixThreadFactory(const char* name = ""Posix"", const char* title = ""Posix Thread Factory""). virtual ~TPosixThreadFactory(); { }. » Author: Fons Rademakers 01/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TPosixThreadFactory.h 29797 2009-08-17 14:35:51Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPosixThreadFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPosixThreadFactory.html
Availability,error,error,"tion_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Float_t* x, Float_t* y); voidDrawHatch(Float_t dy, Float_t angle, Int_t n, Double_t* x, Double_t* y); voidDrawPolyLine(Int_t n, TPoints* xy); voidDrawPolyLineNDC(Int_t n, TPoints* uv); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virtual voidDrawPS(Int_t n, Float_t* xw, Float_t* yw); virtual voidDrawPS(Int_t n, Double_t* xw, Double_t* yw); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFontEncode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TNamed::GetName() const; virtual cha",MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Energy Efficiency,green,green,,MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Integrability,interface,interface,". TPostScript. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » POSTSCRIPT; » TPostScript. class TPostScript: public TVirtualPS. TPostScript: Graphics interface to PostScript; This code was initially developed in the context of HIGZ and PAW; by Olivier Couet and Pierre Juillot. It has been converted to a C++ class by; Rene Brun.; To generate a Postscript (or encapsulated ps) file corresponding to; a single image in a canvas, you can:. Select the Print PostScript item in the canvas File menu.; By default, a Postscript file with the name of the canvas.ps is generated. Click in the canvas area, near the edges, with the right mouse button; and select the Print item. You can select the name of the Postscript; file. If the file name is xxx.ps, you will generate a Postscript file named; xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript; file instead. In your program (or macro), you can type:. c1->Print(""xxx.ps"") or c1->Print(""xxx.eps""). This will generate a file corresponding to the picture in the canvas; pointed by c1.; pad1->Print(""xxx.ps""); prints only the picture in the pad pointed by pad1. The size; of the Postscript picture, by default, is computed to keep the aspect ratio; of the picture on the screen, where the size along x is always 20cm. You; can set the size of the PostScript picture before generating the picture; with a command such as:. TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();. You can set the default paper size with:. gStyle->SetPaperSize(xsize,ysize);. You can resume writing again in this file with myps.Open();.; Note that you may have several Postscript files opened simultaneously. Output type; The output type allows to define how the PostScript output will looks like.; It allows to define the page format (A4",MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Safety,detect,detect,"->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added to ""c1.ps""; h3.Draw();; c1.Print(""c1.ps)""); // canvas is added to ""c1.ps"" and ps file is closed; }. The TCanvas::Print(""file.ps("") mechanism is very useful, but it can; be a little inconvenient to have the action of opening/closing a file being; atomic with printing a page. Particularly if pages are being generated in some; loop one needs to detect the special cases of first and last page and then; munge the argument to Print() accordingly.; The ""["" and ""]"" can be used instead of ""("" and "")"" as shown below.; Example:. c1.Print(""file.ps[""); // No actual print, just open file.ps; for (int i=0; i<10; ++i) {; // fill canvas for context i; // ...; c1.Print(""file.ps""); // Actually print canvas to the file; }; c1.Print(""file.ps]""); // No actual print, just close the file. Color Model; TPostScript support two color model RGB and CMYK. CMY and CMYK models are; subtractive color models unlike RGB which is an additive. They are mainly; used for printing purposes. CMY means Cyan Magenta Yellow to convert RGB; to CMY it is enough to do: C=1-R, M=1-G and Y=1-B. CMYK has one more; component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK add the black c",MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Testability,test,test,"age.; 5 : Landscape mode with a large margin at the bottom of the page.; The large margin is useful for some PostScript printers (very often; for the colour printers) as they need more space to grip the paper; for mechanical reasons. Note that some PostScript colour printers; can also use the so called special A4 format permitting the full; usage of the A4 area; in this case larger margins are not necessary; and Type=1 or 2 can be used.; 3 : Encapsulated PostScript. This Type permits the generation of files; which can be included in other documents, for example in LaTeX; files.; . Making several pictures in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw(). {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }. Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture. {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();; // picture 2; ps->",MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Usability,resume,resume,"nvas area, near the edges, with the right mouse button; and select the Print item. You can select the name of the Postscript; file. If the file name is xxx.ps, you will generate a Postscript file named; xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript; file instead. In your program (or macro), you can type:. c1->Print(""xxx.ps"") or c1->Print(""xxx.eps""). This will generate a file corresponding to the picture in the canvas; pointed by c1.; pad1->Print(""xxx.ps""); prints only the picture in the pad pointed by pad1. The size; of the Postscript picture, by default, is computed to keep the aspect ratio; of the picture on the screen, where the size along x is always 20cm. You; can set the size of the PostScript picture before generating the picture; with a command such as:. TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();. You can set the default paper size with:. gStyle->SetPaperSize(xsize,ysize);. You can resume writing again in this file with myps.Open();.; Note that you may have several Postscript files opened simultaneously. Output type; The output type allows to define how the PostScript output will looks like.; It allows to define the page format (A4, Legal etc..), the orientation; (Portrait, Landscape) and the number of images (zones) per page.; The output type has the following form:. [Format][Nx][Ny][Type]. Where:. Format : Is an integer between 0 and 99 defining the page format.; Example:; Format = 3 the paper is in the standard A3 format.; Format = n (1 Format = 4 and Format=0 are the same and define an A4 page.; The A0 format is selected by Format=99.; The US format Letter is selected by Format = 100.; The US format Legal is selected by Format = 200.; The US format Ledger is selected by Format = 300.; Nx, Ny : Specify respectively the number of zones on the x and y axis.; Nx and Ny are integers between 1 and 9.; Type : Can be equal to:; ; 1 : Portrait mode with a small margin at the bottom of ",MatchSource.WIKI,root/html528/TPostScript.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPostScript.html
Availability,avail,available,"Copy ctor. ~TPRegexp(); Cleanup. TPRegexp & operator=(const TPRegexp& p); Assignement operator. UInt_t ParseMods(const TString& mods) const; Translate Perl modifier flags into pcre flags.; The supported modStr characters are: g, i, m, o, s, x, and the; special d for debug. The meaning of the letters is:; - m; Treat string as multiple lines. That is, change ""^"" and ""$"" from; matching the start or end of the string to matching the start or; end of any line anywhere within the string.; - s; Treat string as single line. That is, change ""."" to match any; character whatsoever, even a newline, which normally it would not match.; Used together, as /ms, they let the ""."" match any character whatsoever,; while still allowing ""^"" and ""$"" to match, respectively, just after and; just before newlines within the string.; - i; Do case-insensitive pattern matching.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t",MatchSource.WIKI,root/html528/TPRegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPRegexp.html
Integrability,rout,routine,"elf. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects. The first entry is the full; matched pattern, followed by the subpatterns.; If a pattern was not matched, it will return an empty substring:. TObjArray *subStrL = TPRegexp(""(a|(z))(bc)"").MatchS(""abc"");; for (Int_t i = 0; i < subStrL->GetLast()+1; i++) {; const TString subStr = ((TObjString *)subStrL->At(i))->GetString();; cout << ""\"""" << subStr << ""\"" "";; }; cout << subStr << endl;. produces: ""abc"" ""a"" """" ""bc""; For meaning of mods see ParseMods(). Int_t SubstituteInternal(TString& s, const TString& replace, Int_t start, Int_t nMaxMatch0, Bool_t doDollarSubst); Perform pattern substitution with optional back-ref replacement; - protected method. Int_t Substitute(TString& s, const TString& replace, const TString& mods = """", Int_t s",MatchSource.WIKI,root/html528/TPRegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPRegexp.html
Performance,optimiz,optimizer," which normally it would not match.; Used together, as /ms, they let the ""."" match any character whatsoever,; while still allowing ""^"" and ""$"" to match, respectively, just after and; just before newlines within the string.; - i; Do case-insensitive pattern matching.; - x; Extend your pattern's legibility by permitting whitespace and comments.; - p; Preserve the string matched such that ${^PREMATCH}, ${^MATCH},; and ${^POSTMATCH} are available for use after matching.; - g and c; Global matching, and keep the Current position after failed matching.; Unlike i, m, s and x, these two flags affect the way the regex is used; rather than the regex itself. See Using regular expressions in Perl in; perlretut for further explanation of the g and c modifiers.; For more detail see: http://perldoc.perl.org/perlre.html#Modifiers. TString GetModifiers() const; Return PCRE modifier options as string.; For meaning of mods see ParseMods(). void Compile(); Compile the fPattern. void Optimize(); Send the pattern through the optimizer. Int_t ReplaceSubs(const TString& s, TString& final, const TString& replacePattern, Int_t* ovec, Int_t nmatch) const; Returns the number of expanded '$' constructs. Int_t MatchInternal(const TString& s, Int_t start, Int_t nMaxMatch, TArrayI* pos = 0); Perform the actual matching - protected method. Int_t Match(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10, TArrayI* pos = 0); The number of matches is returned, this equals the full match +; sub-pattern matches.; nMaxMatch is the maximum allowed number of matches.; pos contains the string indices of the matches. Its usage is; shown in the routine MatchS.; For meaning of mods see ParseMods(). TObjArray * MatchS(const TString& s, const TString& mods = """", Int_t start = 0, Int_t nMaxMatch = 10); Returns a TObjArray of matched substrings as TObjString's.; The TObjArray is owner of the objects. The first entry is the full; matched pattern, followed by the subpatterns.; If a patter",MatchSource.WIKI,root/html528/TPRegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPRegexp.html
Availability,error,error,"AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFirstMother() const; virtual Int_tGetGeneration() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const TAttParticle*GetParticle() const; virtual Int_tGetSecondMother() const; virtual Double_tGetTime() const;",MatchSource.WIKI,root/html528/TPrimary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrimary.html
Energy Efficiency,energy,energy,"Streamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tfEtotTotal energy in GeV; Int_tfFirstMotherIndex of the first mother particle; Int_tfGenerationGeneration flag: last gen. (0) or not (1) or ghost (2); Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tfPartParticle id produced; Double_tfPxMomentum in x direction in GeV/c; Double_tfPyMomentum in y direction in GeV/c; Double_tfPzMomentum in z direction in GeV/c; Int_tfSecondMotherIndex of the second mother particle(if any); Double_tfTimeTime of particle production in user units; Double_tfTimeEndTime of particle destruction (always in the pp-cms!); TStringfTypeIndicator of primary type; Double_tfVxProduction vertex x position in user units; Double_tfVyProduction vertex y position in user units; Double_tfVzProduction vertex z position in user units. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPrimary(). Primary vertex particle default constructor. TPrimary(Int_t part, Int_t first, Int_t second, Int_t gener, Double_t px, Double",MatchSource.WIKI,root/html528/TPrimary.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrimary.html
Availability,error,error,"ncipal Components Method consists of applying a; linear transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:. (2). and the brackets indicate mean value over the sample of ; prototypes. This matrix is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and belonging to the largest eigenvalues, corresponds to the most; significant features of the description of the original prototypes. let the prototypes be expanded on into a set of basis vectors. ,. (3). The `best' feature coordinates , spanning a feature; space, will be obtained by minimizing the error due to this; truncated expansion, i.e.,. (4). with the conditions:. (5). Multiplying (3) by. using (5),; we get. (6). so the error becomes.  ;  .  ;  .  ;  . (7). The minimization of the sum in (7) is obtained when each; term. is minimum, since is; positive definite. By the method of Lagrange multipliers, and the; condition (5), we get. (8). The minimum condition. leads to the; equation. (9). which shows that is an eigenvector of the covariance; matrix with eigenvalue . The estimated minimum error is; then given by. (10). where. are the eigenvalues associated with the; omitted eigenvectors in the expansion (3). Thus, by choosing; the largest eigenvalues, and their associated eigenvectors, the; error is minimized. The transformation matrix to go from the pattern space to the feature; space consists of the ordered eigenvectors. for its columns. (11). This is an orthogonal transformation, or rotation, of the pattern; space and feature selection results in ",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Deployability,update,update,"ean value over all data points; TStringTNamed::fNameobject identifier; Int_tfNumberOfDataPointsNumber of data points; Int_tfNumberOfVariablesNumber of variables; TVectorDfOffDiagonalelements of the tridiagonal; TVectorDfSigmasvector of sigmas; Bool_tfStoreDataShould we store input data?; TStringTNamed::fTitleobject title; Double_tfTraceTrace of covarience matrix; TVectorDfUserDataVector of original data points. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPrincipal(); Empty CTOR, Do not use. TPrincipal(Int_t nVariables, Option_t* opt = ""ND""); Ctor. Argument is number of variables in the sample of data; Options are:; N Normalize the covariance matrix (default); D Store input data (default). The created object is named ""principal"" by default. TPrincipal(const TPrincipal& ); copy constructor. TPrincipal& operator=(const TPrincipal& ); assignement operator. ~TPrincipal(); destructor. void AddRow(const Double_t* x). /*; >; Add a data point and update the covariance matrix. The input; array must be fNumberOfVariables long. The Covariance matrix and mean values of the input data is caculated; on the fly by the following equations:. since this is a really fast method, with no rounding errors (please; refer to CERN 72-21 pp. 54-106). The data is stored internally in a TVectorD, in the following; way:. With as defined in the class description.; ; */; . void Browse(TBrowser* b); Browse the TPrincipal object in the TBrowser. void Clear(Option_t* option = """"); Clear the data in Object. Notice, that's not possible to change; the dimension of the original data. const Double_t * GetRow(Int_t row); Return a row of the user supplied data.; If row is out of bounds, 0 is returned.; It's up to the user to delete the returned array.; Row 0 is the first row;. void MakeCode(const char* filename = ""pca"", Option_t* option = """"); Generates the file <filename>, with .C appended if it does; argument doesn't end in .cxx or .C. The file contains the ",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Energy Efficiency,power,powerful,". TPrincipal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TPrincipal. class TPrincipal: public TNamed. ; >. Principal Components Analysis (PCA). The current implementation is based on the LINTRA package from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, Function Parameterization, CERN; 72-21). Overview. Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:. in 8-dimensional pattern space. One proceeds by generating a a representative tracks sample and; building up the covariance matrix . Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,. allows the study of the behavior of the coefficients fo",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Modifiability,variab,variables,". TPrincipal. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TPrincipal. class TPrincipal: public TNamed. ; >. Principal Components Analysis (PCA). The current implementation is based on the LINTRA package from CERNLIB; by R. Brun, H. Hansroul, and J. Kubler.; The class has been implemented by Christian Holm Christensen in August 2000. Introduction. In many applications of various fields of research, the treatment of; large amounts of data requires powerful techniques capable of rapid; data reduction and analysis. Usually, the quantities most; conveniently measured by the experimentalist, are not necessarily the; most significant for classification and analysis of the data. It is; then useful to have a way of selecting an optimal set of variables; necessary for the recognition process and reducing the dimensionality; of the problem, resulting in an easier classification procedure. This paper describes the implementation of one such method of; feature selection, namely the principal components analysis. This; multidimensional technique is well known in the field of pattern; recognition and and its use in Particle Physics has been documented; elsewhere (cf. H. Wind, Function Parameterization, CERN; 72-21). Overview. Suppose we have prototypes which are trajectories of particles,; passing through a spectrometer. If one measures the passage of the; particle at say 8 fixed planes, the trajectory is described by an; 8-component vector:. in 8-dimensional pattern space. One proceeds by generating a a representative tracks sample and; building up the covariance matrix . Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,. allows the study of the behavior of the coefficients fo",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Performance,perform,performs,"e. One proceeds by generating a a representative tracks sample and; building up the covariance matrix . Its eigenvectors and; eigenvalues are computed by standard methods, and thus a new basis is; obtained for the original 8-dimensional space the expansion of the; prototypes,. allows the study of the behavior of the coefficients for all; the tracks of the sample. The eigenvectors which are insignificant for; the trajectory description in the expansion will have their; corresponding coefficients close to zero for all the; prototypes. On one hand, a reduction of the dimensionality is then obtained by; omitting these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components (), thus providing; to the user all the means of understanding his data. Principal Components Method. Let's consider a sample of prototypes each being characterized by; variables. . Each prototype is a point, or a; column vector, in a -dimensional pattern space. (1). where each represents the particular value associated with the; -dimension. Those variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The Principal Components Method consists of applying a; linear transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; ident",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Security,access,accessible,"g these least significant vectors in the subsequent analysis. On the other hand, in the analysis of real data, these least; significant variables(?) can be used for the pattern; recognition problem of extracting the valid combinations of; coordinates describing a true trajectory from the set of all possible; wrong combinations. The program described here performs this principal components analysis; on a sample of data provided by the user. It computes the covariance; matrix, its eigenvalues ands corresponding eigenvectors and exhibits; the behavior of the principal components (), thus providing; to the user all the means of understanding his data. Principal Components Method. Let's consider a sample of prototypes each being characterized by; variables. . Each prototype is a point, or a; column vector, in a -dimensional pattern space. (1). where each represents the particular value associated with the; -dimension. Those variables are the quantities accessible to the; experimentalist, but are not necessarily the most significant for the; classification purpose. The Principal Components Method consists of applying a; linear transformation to the original variables. This; transformation is described by an orthogonal matrix and is equivalent; to a rotation of the original pattern space into a new set of; coordinate vectors, which hopefully provide easier feature; identification and dimensionality reduction. Let's define the covariance matrix:. (2). and the brackets indicate mean value over the sample of ; prototypes. This matrix is real, positive definite, symmetric, and will; have all its eigenvalues greater then zero. It will now be show that; among the family of all the complete orthonormal bases of the pattern; space, the base formed by the eigenvectors of the covariance matrix; and belonging to the largest eigenvalues, corresponds to the most; significant features of the description of the original prototypes. let the prototypes be expanded on into a set of basis vec",MatchSource.WIKI,root/html528/TPrincipal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPrincipal.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TTimeTTimer::GetAbsTime() const; const char*TTimer::GetCommand() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; TObject*TTimer::GetObject(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TTimeTTimer::GetTime() const; UInt_tTTimer::GetTimerID(); virtual const char*T",MatchSource.WIKI,root/html528/TProcessEventTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessEventTimer.html
Integrability,interface,interface,". TProcessEventTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TProcessEventTimer. class TProcessEventTimer: public TTimer. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TProcessEventTimer(Long_t delay); ~TProcessEventTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidTTimer::Add(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tTTimer::CheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, con",MatchSource.WIKI,root/html528/TProcessEventTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessEventTimer.html
Usability,simpl,simple,". TProcessEventTimer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TProcessEventTimer. class TProcessEventTimer: public TTimer. TSystem. Abstract base class defining a generic interface to the underlying; Operating System.; This is not an ABC in the strict sense of the (C++) word. For; every member function there is an implementation (often not more; than a call to AbstractMethod() which prints a warning saying; that the method should be overridden in a derived class), which; allows a simple partial implementation for new OS'es. Function Members (Methods); public:. TProcessEventTimer(Long_t delay); ~TProcessEventTimer(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidTTimer::Add(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; Bool_tTTimer::CheckTimer(const TTime& now); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, con",MatchSource.WIKI,root/html528/TProcessEventTimer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessEventTimer.html
Availability,error,error,"thod) const; static TProcessID*AddProcessID(); virtual voidTObject::AppendPad(Option_t* option = """"); static UInt_tAssignID(TObject* obj); virtual voidTObject::Browse(TBrowser* b); voidCheckInit(); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecrementCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; static UInt_tGetNProcessIDs(); static UInt_tGetObjectCount(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObjArray*GetObjects() const; static Bool_tTObject::GetObjectStat(); TObject*GetObjectWithID(UInt_t uid); virtual Option_t*TObject::GetOption() const; static TProcessID*GetPID(); static TObjArray*GetPIDs(); static TProcessID*GetProcessID(UShort_t pid); static TProces",MatchSource.WIKI,root/html528/TProcessID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessID.html
Security,access,accessible,"urce:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TProcessID. class TProcessID: public TNamed. TProcessID. A TProcessID identifies a ROOT job in a unique way in time and space.; The TProcessID title consists of a TUUID object which provides a globally; unique identifier (for more see TUUID.h). A TProcessID is automatically created by the TROOT constructor.; When a TFile contains referenced objects (see TRef), the TProcessID; object is written to the file.; If a file has been written in multiple sessions (same machine or not),; a TProcessID is written for each session.; These objects are used by the class TRef to uniquely identified; any TObject pointed by a TRef. When a referenced object is read from a file (its bit kIsReferenced is set),; this object is entered into the objects table of the corresponding TProcessID.; Each TFile has a list of TProcessIDs (see TFile::fProcessIDs) also; accessible via TProcessID::fgPIDs (for all files).; When this object is deleted, it is removed from the table via the cleanup; mechanism invoked by the TObject destructor. Each TProcessID has a table (TObjArray *fObjects) that keeps track; of all referenced objects. If a referenced object has a fUniqueID set,; a pointer to this unique object may be found via fObjects->At(fUniqueID).; In the same way, when a TRef::GetObject is called, GetObject uses; its own fUniqueID to find the pointer to the referenced object.; See TProcessID::GetObjectWithID and PutObjectWithID. When a referenced object is deleted, its slot in fObjects is set to null. See also TProcessUUID: a specialized TProcessID to manage the single list; of TUUIDs. Function Members (Methods); public:. TProcessID(); virtual~TProcessID(); voidTObject::AbstractMethod(const char* method) const; static TProcessID*AddProcessID(); virtual voidTObject::AppendPad(Option_t* option = """"); static UInt_tAssignID(TObject* obj); virt",MatchSource.WIKI,root/html528/TProcessID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessID.html
Availability,error,error,"Object::AppendPad(Option_t* option = """"); static UInt_tTProcessID::AssignID(TObject* obj); virtual voidTObject::Browse(TBrowser* b); voidTProcessID::CheckInit(); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidTProcessID::Cleanup(); virtual voidTProcessID::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTProcessID::DecrementCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObjString*FindUUID(UInt_t number) const; TBits*GetActive() const; Int_tTProcessID::GetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; static UInt_tTProcessID::GetNProcessIDs(); static UInt_tTProcessID::GetObjectCount(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObjArray*TProcessID::GetObjects() const; static Bool_tTObject::GetObjectStat(); TObject*TProcessID::GetObjectWithID(UInt_t uid); virtual Option_t*TObject::GetOptio",MatchSource.WIKI,root/html528/TProcessUUID.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProcessUUID.html
Availability,error,error,"tion = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(const char* namex, Double_t y); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(const char* namex, Double_t y, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z ",MatchSource.WIKI,root/html528/TProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile.html
Integrability,rout,routines,". TProfile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TProfile. class TProfile: public TH1D. Profile histograms are used to display the mean; value of Y and its RMS for each bin in X. Profile histograms are in many cases an; elegant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) s(J) = sqrt(E(J)/L(J)- h(J)**2); e(J) = s(J)/sqrt(L(J)). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); e(J) is computed from the average of the s(J) for all bins if the static function; TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*. */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name,",MatchSource.WIKI,root/html528/TProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile.html
Modifiability,variab,variable,"static Int_tTH1::fgBufferSize!default buffer size for automatic histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProfile(); Default constructor for Profile histograms*-*-*-; *-* ==========================================. ~TProfile(); Default destructor for Profile histograms*-*-*-; *-* =========================================. TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); Normal Constructor for Profile histograms*-*-*-*-; *-* ==========================================. The first five parameters are similar to TH1D::TH1D.; All values of y are accepted at filling time.; To fill a profile histogram, one must use TProfile::Fill function. Note that when filling the profile histogram the function Fill; checks if the variable y is betyween fYmin and fYmax.; If a minimum or maximum value is set for the Y scale before filling,; then all values below ymin or above ymax will be discarded.; Setting the minimum or maximum value for the Y scale before filling; has the same effect as calling the special TProfile constructor below; where ymin and ymax are specified. H(J) is printed as the channel contents. The errors displayed are s(J) if CHOPT='S'; (spread option), or e(J) if CHOPT=' ' (error on mean). See TProfile::BuildOptions for explanation of parameters. see also comments in the TH1 base class constructors. TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); -*Constructor for Profile histograms with variable bin size; *-* =========================================================. See TProfile::BuildOptions for more explanations on errors. see also comments in the TH1 base class constructors. TProfile(const char* name, const char",MatchSource.WIKI,root/html528/TProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile.html
Usability,simpl,simple,"legant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) s(J) = sqrt(E(J)/L(J)- h(J)**2); e(J) = s(J)/sqrt(L(J)). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); e(J) is computed from the average of the s(J) for all bins if the static function; TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour. Example of a profile histogram with its graphics output; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof->Fill(px,pz,1);; }; hprof->Draw();; }. /*. */. Function Members (Methods); public:. TProfile(); TProfile(const TProfile& profile); TProfile(const char* name, const char* title, Int_t nbinsx, const Float_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Option_t* option = """"); TProfile(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Double_t ylow, Double_t yup, Opt",MatchSource.WIKI,root/html528/TProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile.html
Availability,error,error,"tion = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z); virtual Int_tFill(Double_t x, const char* namey, Double_t z); virtual Int_tFill(const char* namex, Double_t y, Double_t z); virtual Int_tFill(const char* namex, const char* namey, Double_t z); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntim",MatchSource.WIKI,root/html528/TProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile2D.html
Integrability,rout,routines,". TProfile2D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TProfile2D. class TProfile2D: public TH2D. Profile2D histograms are used to display the mean; value of Z and its RMS for each cell in X,Y.; Profile2D histograms are in many cases an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J) = sum Z E(I,J) = sum Z; l(I,J) = sum l L(I,J) = sum l; h(I,J) = H(I,J)/L(I,J) s(I,J) = sqrt(E(I,J)/L(I,J)- h(I,J)**2); e(I,J) = s(I,J)/sqrt(L(I,J)). In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); e(I,J) is computed from the average of the s(I,J) for all cells.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. Example of a profile2D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }. Function Members (Methods); public:. TProfile2D(); TProfile2D(const TProfile2D& profile); TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbin",MatchSource.WIKI,root/html528/TProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile2D.html
Modifiability,variab,variable,"c histograms; static Bool_tTH1::fgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProfile2D(); Default constructor for Profile2D histograms*-*-*-; *-* ============================================. ~TProfile2D(); Default destructor for Profile2D histograms*-*-*-; *-* ===========================================. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Option_t* option = """"); Normal Constructor for Profile histograms*-*-*-*-; *-* ==========================================. The first eight parameters are similar to TH2D::TH2D.; All values of z are accepted at filling time.; To fill a profile2D histogram, one must use TProfile2D::Fill function. Note that when filling the profile histogram the function Fill; checks if the variable z is betyween fZmin and fZmax.; If a minimum or maximum value is set for the Z scale before filling,; then all values below zmin or above zmax will be discarded.; Setting the minimum or maximum value for the Z scale before filling; has the same effect as calling the special TProfile2D constructor below; where zmin and zmax are specified. H(I,J) is printed as the cell contents. The errors computed are s(I,J) if CHOPT='S'; (spread option), or e(I,J) if CHOPT=' ' (error on mean). See TProfile2D::BuildOptions for explanation of parameters. see other constructors below with all possible combinations of; fix and variable bin size like in TH2D. TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup, Option_t* option = """"); Create a 2-D Profile with variable bins in X and fix bins in Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, cons",MatchSource.WIKI,root/html528/TProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile2D.html
Usability,simpl,simple,"ses an; elegant replacement of three-dimensional histograms : the inter-relation of three; measured quantities X, Y and Z can always be visualized by a three-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Z is an unknown (but single-valued); approximate function of X,Y this function is displayed by a profile2D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J) = sum Z E(I,J) = sum Z; l(I,J) = sum l L(I,J) = sum l; h(I,J) = H(I,J)/L(I,J) s(I,J) = sqrt(E(I,J)/L(I,J)- h(I,J)**2); e(I,J) = s(I,J)/sqrt(L(I,J)). In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); e(I,J) is computed from the average of the s(I,J) for all cells.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. Example of a profile2D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; Float_t px, py, pz;; for ( Int_t i=0; i<25000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; hprof2d->Fill(px,py,pz,1);; }; hprof2d->Draw();; }. Function Members (Methods); public:. TProfile2D(); TProfile2D(const TProfile2D& profile); TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, Double_t ylow, Double_t yup, Option_t* option = """"); TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); TProfile2D(const char* name, const char* title, Int",MatchSource.WIKI,root/html528/TProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile2D.html
Availability,error,error,"tion = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(Double_t, Double_t, Double_t); virtual Int_tFill(const char*, const char*, const char*, Double_t); virtual Int_tFill(const char*, Double_t, const char*, Double_t); virtual Int_tFill(const char*, const char*, Double_t, Double_t); virtual Int_tFill(Double_t, const char*, const char*, Double_t); virtual Int_tFill(Double_t, const char*, Double_t, Double_t); virtual Int_tFill(Double_t, Double_t, const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t t); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); virtual voidTNamed::Fi",MatchSource.WIKI,root/html528/TProfile3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile3D.html
Integrability,rout,routines,". TProfile3D. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TProfile3D. class TProfile3D: public TH3D. Profile3D histograms are used to display the mean; value of T and its RMS for each cell in X,Y,Z.; Profile3D histograms are in many cases an; The inter-relation of three measured quantities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. TProfile3D(); TProfile3D(const TProfile3D& profile);",MatchSource.WIKI,root/html528/TProfile3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile3D.html
Modifiability,variab,variable,"w2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tTH1::fgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProfile3D(); Default constructor for Profile3D histograms*-*-*-; *-* ============================================. ~TProfile3D(); Default destructor for Profile3D histograms*-*-*-; *-* ===========================================. TProfile3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup, Option_t* option = """"); Normal Constructor for Profile histograms*-*-*-*-; *-* ==========================================. The first eleven parameters are similar to TH3D::TH3D.; All values of t are accepted at filling time.; To fill a profile3D histogram, one must use TProfile3D::Fill function. Note that when filling the profile histogram the function Fill; checks if the variable t is betyween fTmin and fTmax.; If a minimum or maximum value is set for the T scale before filling,; then all values below tmin or above tmax will be discarded.; Setting the minimum or maximum value for the T scale before filling; has the same effect as calling the special TProfile3D constructor below; where tmin and tmax are specified. H(I,J,K) is printed as the cell contents. The errors computed are s(I,J,K) if CHOPT='S'; (spread option), or e(I,J,K) if CHOPT=' ' (error on mean). See TProfile3D::BuildOptions for explanation of parameters. see other constructors below with all possible combinations of; fix and variable bin size like in TH3D. TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); Create a 3-D Profile with variable bins in X , Y and Z. void BuildOptions(Double_t tmin, Double_t tmax, Option_t* option); Set Profile3D",MatchSource.WIKI,root/html528/TProfile3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile3D.html
Usability,simpl,simple,"s are in many cases an; The inter-relation of three measured quantities X, Y, Z and T can always; be visualized by a four-dimensional histogram or scatter-plot;; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If T is an unknown (but single-valued); approximate function of X,Y,Z this function is displayed by a profile3D histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for cell I, J. 2; H(I,J,K) = sum T E(I,J,K) = sum T; l(I,J,K) = sum l L(I,J,K) = sum l; h(I,J,K) = H(I,J,K)/L(I,J,K) s(I,J,K) = sqrt(E(I,J,K)/L(I,J,K)- h(I,J,K)**2); e(I,J,K) = s(I,J,K)/sqrt(L(I,J,K)). In the special case where s(I,J,K) is zero (eg, case of 1 entry only in one cell); e(I,J,K) is computed from the average of the s(I,J,K) for all cells.; This simple/crude approximation was suggested in order to keep the cell; during a fit operation. Example of a profile3D histogram; {; TCanvas *c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; hprof3d = new TProfile3D(""hprof3d"",""Profile of pt versus px, py and pz"",40,-4,4,40,-4,4,40,0,20);; Double_t px, py, pz, pt;; TRandom3 r(0);; for ( Int_t i=0; i<25000; i++) {; r.Rannor(px,py);; pz = px*px + py*py;; pt = r.Landau(0,1);; hprof3d->Fill(px,py,pz,pt,1);; }; hprof3d->Draw();; }. NOTE: A TProfile3D is drawn as it was a simple TH3. Function Members (Methods); public:. TProfile3D(); TProfile3D(const TProfile3D& profile); TProfile3D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Int_t nbinsz, const Double_t* zbins, Option_t* option = """"); TProfile3D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Int_t nbinsz, Double_t zlow, Double_t zup, Option_t* option = """"); virtual~TProfile3D()",MatchSource.WIKI,root/html528/TProfile3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProfile3D.html
Availability,error,error,"onst char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytesRead() const; Int_tGetClientProtocol() const; const char*GetConfDir() const; const char*GetConfFile() const; Float_tGetCpuTime() const; const char*GetDataPoolUrl() const; virtual TFileCollection*GetDataSet(const char* dataset, const char* optStr = """"); TMap*GetDataSetQuota(const char* optStr = """"); v",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Deployability,configurat,configurations,"ique file systems; Bool_tfValidis this a valid proof object; TList*fWaitingSlavesstores a TPair of the slaves's TSocket and TMessage; TStringfWorkDircurrent work directory on remote servers; Int_tfWorkersToMergeCurrent total number of workers, which have not been yet assigned to any merger; static TPluginHandler*fgLogViewerLog dialog box plugin; static TList*fgProofEnvListList of TNameds defining environment. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. TProof(); Protected constructor to be used by classes deriving from TProof; (they have to call Init themselves and override StartSlaves; appropriately). This constructor simply closes any previous gProof and sets gProof; to this instance. void InitMembers(); Default initializations. ~TProof(); Clean up PROOF environment. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of ",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Energy Efficiency,monitor,monitor,,MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Integrability,message,messages,". TProof. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProof. class TProof: public TNamed, public TQObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProof(); voidTObject::AbstractMethod(const char* method) const; voidActivateWorker(const char* ord); voidAddChain(TChain* chain); Int_tAddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidAddEnvVar(const char* name, const char* value); voidAddFeedback(const char* name); Int_tAddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidAddInput(TObject* obj); voidAddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tArchive(Int_t query, const char* url); Int_tArchive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); voidcd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearD",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Modifiability,config,config,"nst TSlave* sl, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Bool_tCreateMerger(TSlave* sl, Int_t port); voidDeActivateAsyncInput(); Int_tDisablePackage(const char* package); Int_tDisablePackageOnClient(const char* package); Int_tDisablePackages(); Int_tExec(const char* cmd, TProof::ESlaves list, Bool_t plusMaster); voidFinalizationDone(); Int_tFindNextFreeMerger(); TSlave*FindSlave(TSocket* s) const; voidFindUniqueSlaves(); Int_tGetActiveMergersCount(); static TList*GetDataSetSrvMaps(const TString& srvmaps); TList*GetListOfBadSlaves() const; TList*GetListOfInactiveSlaves() const; TList*GetListOfSlaves() const; TList*GetListOfUniqueSlaves() const; Int_tGetNumberOfActiveSlaves() const; Int_tGetNumberOfBadSlaves() const; Int_tGetNumberOfInactiveSlaves() const; Int_tGetNumberOfSlaves() const; Int_tGetNumberOfUniqueSlaves() const; Int_tGetQueryReference(Int_t qry, TString& ref); Int_tGoParallel(Int_t nodes, Bool_t accept = kFALSE, Bool_t random = kFALSE); Int_tHandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); voidHandleSubmerger(TMessage* mess, TSlave* sl); voidInterrupt(TProof::EUrgent type, TProof::ESlaves list = kActive); voidInterruptCurrentMonitor(); Bool_tIsEndMaster() const; Bool_tIsSync() const; Int_tLoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Int_tLoadPackageOnClient(const char* package, TList* loadopts = 0); voidMarkBad(TSlave* wrk, const char* reason = 0); voidMarkBad(TSocket* s, const char* reason = 0); voidModifyWorkerLists(const char* ord, Bool_t add); voidNotifyLogMsg(const char* msg, const char* sfx = ""\n""); voidoperator=(const TProof&); voidParseConfigField(const char* config); Int_tPing(TProof::ESlaves list); voidPrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1.",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Performance,load,loadopts,"st char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Safety,abort,abort,"oof::EQueryMode mode); voidSetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidShowData(); voidShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* optStr = """"); voidShowEnabledPackages(Bool_t all = kFALSE); voidShowFeedback() const; voidShowLog(Int_t qry = -1); voidShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidShowMissingFiles(TQueryResult* qr = 0); voidShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidShowParameters(const char* wildcard = ""PROOF_*"") const; voidShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidStartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTouch(); Int_tUploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tUploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tUseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Security,validat,validated,,MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Testability,log,loglevel," TProof(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProof(); voidTObject::AbstractMethod(const char* method) const; voidActivateWorker(const char* ord); voidAddChain(TChain* chain); Int_tAddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidAddEnvVar(const char* name, const char* value); voidAddFeedback(const char* name); Int_tAddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidAddInput(TObject* obj); voidAddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tArchive(Int_t query, const char* url); Int_tArchive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidBrowse(TBrowser* b); voidcd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const char* file = 0); voidClearData(UInt_t what = kUnregistered, const char* dsname = 0); virtual voidClearD",MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Usability,feedback,feedback,,MatchSource.WIKI,root/html528/TProof.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProof.html
Availability,error,error," const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTTree::DropBaskets(); virtual voidTTree::DropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tTChain::Fill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTTree::Fit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tTTree::FlushBaskets() const; virtual const char*TChain::GetAlias(const char* aliasName) const; virtual Long64_tTTree::GetAutoFlush() const; virtual Long64_tTTree::GetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*TTree::GetBr",MatchSource.WIKI,root/html528/TProofChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofChain.html
Deployability,update,updateExisting,"UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTChain::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTChain::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* enlist, Option_t*); virtual voidTChain::SetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolor); virtual voidTAttLine::SetLineStyle(Style_t lstyle); virtual voidTAttLine::SetLineWidth(Width_t lwidth); virtual voidTChain::SetMakeClass(Int_t make); virtual voidTAttMarker::SetMarkerAttributes()MENU ; virtual voidTAttMa",MatchSource.WIKI,root/html528/TProofChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofChain.html
Modifiability,variab,variables,"in::fProofChain! chain proxy when going to be processed by PROOF; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; TDSet*fSetTDSet; TList*TChain::fStatus-> List of active/inactive branches (TChainElement, owned); Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TTree*TChain::fTree! Pointer to current tree (Note: We do *not* own this tree.); TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tTChain::fTreeNumber! Current Tree number in fTreeOffset table; Long64_t*TChain::fTreeOffset[fTreeOffsetLen] Array of variables; Int_tTChain::fTreeOffsetLenCurrent size of fTreeOffset array; Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch style; static Long64_tTTree::fgMaxTreeSizeMaximum size of a file containg a Tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofChain(); Crates a new PROOF chain proxy. TProofChain(TChain* chain, Bool_t gettreeheader); Crates a new PROOF chain proxy containing the files from the chain. TProofChain(TDSet* dset, Bool_t gettreeheader); Creates a new PROOF chain proxy containing the files from the dset. ~TProofChain(); Destructor. void Browse(TBrowser* b); Forwards the execution to the dummy tree header.; See TTree::Browse(). Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Forwards the execution to the TD",MatchSource.WIKI,root/html528/TProofChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofChain.html
Performance,cache,cachesize,"mula); virtual voidTChain::SetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTChain::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTChain::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidSetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTChain::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* enlist, Option_t*); virtual voidTChain::SetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribu",MatchSource.WIKI,root/html528/TProofChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofChain.html
Usability,undo,undo,"lassname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 1); virtual TBranch*TTree::BranchRef(); virtual TBranch*TTree::Bronch(const char* name, const char* classname, void* addobj, Int_t bufsize = 32000, Int_t splitlevel = 99); virtual voidBrowse(TBrowser* b); virtual Int_tTTree::BuildIndex(const char* majorname, const char* minorname = ""0""); TStreamerInfo*TTree::BuildStreamerInfo(TClass* cl, void* pointer = 0, Bool_t canOptimize = kTRUE); virtual voidTChain::CanDeleteRefs(Bool_t flag = kTRUE); virtual TFile*TTree::ChangeFile(TFile* file); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TTree*TTree::CloneTree(Long64_t nentries = -1, Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConnectProof(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTTree::CopyAddresses(TTree*, Bool_t undo = kFALSE); virtual Long64_tTTree::CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); virtual TTree*TTree::CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual TBasket*TTree::CreateBasket(TBranch*); virtual voidTChain::CreatePackets(); Int_tDebug() const; virtual voidTTree::Delete(Option_t* option = """")MENU ; virtual voidTChain::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virt",MatchSource.WIKI,root/html528/TProofChain.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofChain.html
Availability,error,error,"); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*TProof::GetDataSet",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Integrability,message,messages,". TProofCondor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofCondor. class TProofCondor: public TProof. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the slave servers, it keeps track of how many slaves are; running, it keeps track of the slaves running status, it broadcasts; messages to all slaves, it collects results, etc. Function Members (Methods); public:. TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofCondor(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof:",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Modifiability,config,config,"t; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMonitor*TProof::fAllMonitormonitor activity on all valid slave sockets; TList*TProof::fAvailablePackageslist of available packages; TList*TProof::fBadSlavesdead slaves (subset of all slaves); Long64_tTProof::fBytesReadynumber of bytes staged; Int_tTProof::fCollectTimeoutTimeout for (some) collect actions; TStringTProof::fConfDirdirectory containing cluster config information; TStringTProof::fConfFilefile containing config information; TStringTProof::fDataPoolUrldefault data pool entry point URL; Bool_tTProof::fDataReadytrue if data is ready to be analyzed; Bool_tTProof::fDynamicStartupare the workers started dynamically?; TList*TProof::fEnabledPackageslist of enabled packages; TStringTProof::fImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Performance,load,loadopts," const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Safety,abort,abort,"amed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Testability,log,loglevel," TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofCondor(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidTProof:",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Usability,resume,resume,"ons to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TCondor*fCondorproxy for our Condor pool; TTimer*fTimertimer for delayed Condor COD suspend. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofCondor(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Start proof using condor. ~TProofCondor(); Clean up Condor PROOF environment. Bool_t StartSlaves(Bool_t ); Setup Condor workers using dynamic information. void SetActive(Bool_t active); Suspend or resume PROOF via Condor. TString GetJobAd(); Get job Ad. void SetActive(); { TProof::SetActive(); }. » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofCondor.h 27171 2009-01-16 16:04:00Z ganis $ » Last generated: 2010-10-06 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofCondor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofCondor.html
Testability,log,logging,". TProofDebug. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofDebug. class TProofDebug. TProofDebug. Detailed logging / debug scheme. Function Members (Methods); public:. TProofDebug(); TProofDebug(const TProofDebug&); ~TProofDebug(); TProofDebug&operator=(const TProofDebug&). Data Members; public:. enum EProofDebugMask { kNone; kPacketizer; kLoop; kSelector; kOutput; kInput; kGlobal; kPackage; kFeedback; kCondor; kDraw; kAsyn; kCache; kCollect; kDataset; kSubmerger; kAll; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Maarten Ballintijn 19/6/2002 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofDebug.h 31505 2009-12-02 13:20:06Z brun $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofDebug.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDebug.html
Availability,error,error," -1, Int_t remid = -1, Int_t status = kIdle, TProof* p = 0); virtual~TProofDesc(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLocalId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TProof*GetProof() const; Int_tGetRemoteId() const; Int_tGetStatus() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUrl() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html528/TProofDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDesc.html
Energy Efficiency,monitor,monitor,". TProofDesc. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofDesc. class TProofDesc: public TNamed. TProofMgr. The PROOF manager interacts with the PROOF server coordinator to; create or destroy a PROOF session, attach to or detach from; existing one, and to monitor any client activity on the cluster.; At most one manager instance per server is allowed. Function Members (Methods); public:. TProofDesc(const char* tag = 0, const char* alias = 0, const char* url = 0, Int_t id = -1, Int_t remid = -1, Int_t status = kIdle, TProof* p = 0); virtual~TProofDesc(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* ",MatchSource.WIKI,root/html528/TProofDesc.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDesc.html
Availability,avail,available,". TProofDraw. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofDraw. class TProofDraw: public TSelector. TProofDraw. Implement Tree drawing using PROOF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TOb",MatchSource.WIKI,root/html528/TProofDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDraw.html
Modifiability,variab,variability,"nst. protected:. virtual voidClearFormula(); virtual Bool_tCompileVariables(); virtual voidDefVar(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tProcessSingle(Long64_t, Int_t); voidSetCanvas(const char* objname); voidSetDrawAtt(TObject* o); voidSetError(const char* sub, const char* mesg). Data Members; public:. enum { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfDimensionDimension of the current expression; TStringfInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. Bool_t ProcessSingle(Long64_t , Int_t ); Processe",MatchSource.WIKI,root/html528/TProofDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDraw.html
Performance,load,loaded,"; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfDimensionDimension of the current expression; TStringfInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fT",MatchSource.WIKI,root/html528/TProofDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDraw.html
Safety,avoid,avoid,"t of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofDraw.h 30068 2009-09-08 15:19:38Z ganis $ » Last generated: 2010-10-05 21:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDraw.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawEntryList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawEntryList.html
Modifiability,variab,variability,"voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TEntryList*fElist; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDrawEntryList(); class destructor. void Init(TTree* ); See TProofDraw::Init(). void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t entry, Double_t w, ",MatchSource.WIKI,root/html528/TProofDrawEntryList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawEntryList.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawEventList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawEventList.html
Modifiability,variab,variability,"level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TEventList*fElistevent list; TList*fEventListsa list of EventLists; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDrawEventList(); Destructor. void Init(TTree* ); See TProofDraw::Init(). void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t ",MatchSource.WIKI,root/html528/TProofDrawEventList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawEventList.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawGraph.html
Modifiability,variab,variability,"l voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TGraph*fGraph; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(TTree* tree); See TProofDraw::Init(). void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t entry, Double_t w, const Double_t* v); Fills the graph with",MatchSource.WIKI,root/html528/TProofDrawGraph.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawGraph.html
Availability,error,error,"nst char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawHist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawHist.html
Modifiability,variab,variability,"st char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). private:. voidDefVar1D(); voidDefVar2D(); voidDefVar3D(). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TH1*fHistogram; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Begin1D(TTree* t); Initialization for 1D Histogram. void Begin2D(TTree* t); Initialization for 2D histogram. void Begin3D(TTree* t); Initialization for 3D histogram. void Begin(T",MatchSource.WIKI,root/html528/TProofDrawHist.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawHist.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawListOfGraphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawListOfGraphs.html
Modifiability,variab,variability," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t>*fPoints; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t entry, Double_t w, const Double_t* v); Fills the",MatchSource.WIKI,root/html528/TProofDrawListOfGraphs.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawListOfGraphs.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawListOfPolyMarkers3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawListOfPolyMarkers3D.html
Modifiability,variab,variability," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t>*fPoints; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t entry, Double_t w, const Double_t* v); Fi",MatchSource.WIKI,root/html528/TProofDrawListOfPolyMarkers3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawListOfPolyMarkers3D.html
Availability,error,error,"why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTProofDraw::Begin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawPolyMarker3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawPolyMarker3D.html
Modifiability,variab,variability," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TPolyMarker3D*fPolyMarker3D; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(TTree* tree); See TProofDraw::Init(). void SlaveBegin(TTree* ); See TProofDraw::SlaveBegin(). void DoFill(Long64_t entry, Double_t w, const Double_t* v)",MatchSource.WIKI,root/html528/TProofDrawPolyMarker3D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawPolyMarker3D.html
Availability,error,error,"nst char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawProfile.html
Modifiability,variab,variability," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TProfile*fProfile; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(TTree* ); See TProofDraw::Init(). void DefVar(); Define relevant variables. void Begin(TTree* t); See TProofDraw::Begin(). void SlaveBegin(TTree* ); See TProofDra",MatchSource.WIKI,root/html528/TProofDrawProfile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawProfile.html
Availability,error,error,"nst char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root/html528/TProofDrawProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawProfile2D.html
Modifiability,variab,variability," virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidDoFill(Long64_t entry, Double_t w, const Double_t* v); voidTObject::MakeZombie(); virtual Bool_tTProofDraw::ProcessSingle(Long64_t, Int_t); voidTProofDraw::SetCanvas(const char* objname); voidTProofDraw::SetDrawAtt(TObject* o); voidTProofDraw::SetError(const char* sub, const char* mesg). Data Members; public:. enum TProofDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTProofDraw::fDimensionDimension of the current expression; TStringTProofDraw::fInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TProofDraw::fManager; Int_tTProofDraw::fMultiplicityIndicator of the variability of the size of entries; Bool_tTProofDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TProfile2D*fProfile; TTreeFormula*TProofDraw::fSelectPointer to selection formula; TStringTProofDraw::fSelection; TStatus*TProofDraw::fStatus; Long64_tTSelector::fStatusselector status; TTree*TProofDraw::fTree; TTreeDrawArgsParserTProofDraw::fTreeDrawArgsParser; TTreeFormula*TProofDraw::fVar[4]Pointer to variable formula. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(TTree* ); See TProofDraw::Init(). void DefVar(); Define relevant variables. void Begin(TTree* t); See TProofDraw::Begin(). void SlaveBegin(TTree* ); See TProofD",MatchSource.WIKI,root/html528/TProofDrawProfile2D.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofDrawProfile2D.html
Availability,error,error,"onst; virtual voidTObject::AppendPad(Option_t* option = """"); static voidAutoBinFunc(TString& key, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Axis_t xmin, Axis_t xmax); virtual Int_tFindGoodLimits(TH1* h, Axis_t xmin, Axis_t xmax, Axis_t ymin, Axis_t ymax); virtual Int_tFindGoodLimits(TH1* h, Axis_t xmin, Axis_t xmax, Axis_t ymin, Axis_t ymax, Axis_t zmin, Axis_t zmax); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static THLimitsFinder*THLimitsFinder::GetLimitsFinder(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption",MatchSource.WIKI,root/html528/TProofLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLimitsFinder.html
Integrability,synchroniz,synchronize,". TProofLimitsFinder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofLimitsFinder. class TProofLimitsFinder: public THLimitsFinder. TProofLimitsFinder. Class to find nice axis limits and synchronize them between workers. Function Members (Methods); public:. TProofLimitsFinder(); TProofLimitsFinder(const TProofLimitsFinder&); virtual~TProofLimitsFinder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static voidAutoBinFunc(TString& key, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindGoodLimits(TH1* h, Axis_t xmin, Axis_t xmax); virtual Int_tFindGoodLimits(TH1* h, Axis_t xmin, Axis_t xmax, Axis_t ymin, Axis_t ymax); virtual In",MatchSource.WIKI,root/html528/TProofLimitsFinder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLimitsFinder.html
Availability,error,error,"); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*GetDataSet(const char* uri, co",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Deployability,configurat,configurations,"e first worker; Int_tfNWorkersNumber of workers; TQueryResultManager*fQMgrQuery-result manager; TStringfQueryDirDirectory containing query results and status; TProofLockPath*fQueryLockQuery dir locker; TStringfSandboxPROOF sandbox root dir; TServerSocket*fServSockServer socket to accept call backs; TStringfSockPathUNIX socket path for communication with workers; static Int_tfgWrksMaxMax number of workers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); Create a PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). Masterurl is of; the form: [proof[s]://]host[:port]. Conffile is the name of the config; file describing the remote PROOF cluster (this argument alows you to; describe different cluster configurations).; The default is proof.conf. Confdir is the directory where the config; file and other PROOF related files are (like motd and noproof files).; Loglevel is the log level (default = 1). User specified custom config; files will be first looked for in $HOME/.conffile. Int_t Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); Start the PROOF environment. Starting PROOF involves either connecting; to a master server, which in turn will start a set of slave servers, or; directly starting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. ~TProofLite(); Destructor. Int_t GetNumberOfWorkers(const char* url = 0); Static method to determine the number of workers giving priority to users request.; Otherwise",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Integrability,protocol,protocol,"t; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMonitor*TProof::fAllMonitormonitor activity on all valid slave sockets; TList*TProof::fAvailablePackageslist of available packages; TList*TProof::fBadSlavesdead slaves (subset of all slaves); Long64_tTProof::fBytesReadynumber of bytes staged; Int_tTProof::fCollectTimeoutTimeout for (some) collect actions; TStringTProof::fConfDirdirectory containing cluster config information; TStringTProof::fConfFilefile containing config information; TStringTProof::fDataPoolUrldefault data pool entry point URL; Bool_tTProof::fDataReadytrue if data is ready to be analyzed; Bool_tTProof::fDynamicStartupare the workers started dynamically?; TList*TProof::fEnabledPackageslist of enabled packages; TStringTProof::fImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDi",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Modifiability,config,config,"t; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMonitor*TProof::fAllMonitormonitor activity on all valid slave sockets; TList*TProof::fAvailablePackageslist of available packages; TList*TProof::fBadSlavesdead slaves (subset of all slaves); Long64_tTProof::fBytesReadynumber of bytes staged; Int_tTProof::fCollectTimeoutTimeout for (some) collect actions; TStringTProof::fConfDirdirectory containing cluster config information; TStringTProof::fConfFilefile containing config information; TStringTProof::fDataPoolUrldefault data pool entry point URL; Bool_tTProof::fDataReadytrue if data is ready to be analyzed; Bool_tTProof::fDynamicStartupare the workers started dynamically?; TList*TProof::fEnabledPackageslist of enabled packages; TStringTProof::fImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. private:. TStringfCacheDirDirectory containing cache of user files; TProofLockPath*fCacheLockCache dir locker; TStringfDataSetDi",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Performance,load,loadopts," const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtu",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Safety,abort,abort,"ol_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidShowDataSets(const char* uri = """", const char* = 0); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tVerifyDataSet(const char* uri, const char* = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Testability,log,loglevel," TProofLite(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofLite(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_t* option = """"); virtual voidClearCache(const",MatchSource.WIKI,root/html528/TProofLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLite.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*GetListOfLogs() const; TList*TQObject::GetListOfSignals() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGrep(const",MatchSource.WIKI,root/html528/TProofLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLog.html
Testability,log,log,". TProofLog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofLog. class TProofLog: public TNamed, public TQObject. TProofLog. Implementation of the PROOF session log handler. Function Members (Methods); public:. TProofLog(const char* stag, const char* url, TProofMgr* mgr); virtual~TProofLog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQObject::Disconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(TQObject* sender, const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tTQObject::Disconnect(",MatchSource.WIKI,root/html528/TProofLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLog.html
Availability,error,error,"Log* logger); virtual~TProofLogElem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplay(Int_t from = 0, Int_t to = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TMacro*GetMacro() const; static Long64_tGetMaxTransferSize(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetRole(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGrep(const char* txt, TString& res, Int_t from = 0); virtual Bool_tTObject::HandleTimer(TT",MatchSource.WIKI,root/html528/TProofLogElem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLogElem.html
Testability,log,log,". TProofLogElem. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofLogElem. class TProofLogElem: public TNamed. TProofLog. Implementation of the PROOF session log handler. Function Members (Methods); public:. TProofLogElem(const TProofLogElem&); TProofLogElem(const char* ord, const char* url, TProofLog* logger); virtual~TProofLogElem(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisplay(Int_t from = 0, Int_t to = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() cons",MatchSource.WIKI,root/html528/TProofLogElem.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofLogElem.html
Availability,error,error,"nst char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TProofDesc*GetProofDesc(Int_t id); virtual TProofDesc*GetProofDesc(TProof* p); virtual In",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Energy Efficiency,monitor,monitor,". TProofMgr. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofMgr. class TProofMgr: public TNamed. TProofMgr. The PROOF manager interacts with the PROOF server coordinator to; create or destroy a PROOF session, attach to or detach from; existing one, and to monitor any client activity on the cluster.; At most one manager instance per server is allowed. Function Members (Methods); public:. TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* m",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Integrability,message,message,"ALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. TProof * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Int_t SendMsgToUsers(const char* , const char* = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the user to which to send the message: if; empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current; user.; Not supported. void ShowWorkers(); Show available workers. TProofDesc * GetProofDesc(Int_t id); Get TProofDesc instance corresponding to 'id'. TProofDesc * GetProofDesc(TProof* p); Get TProofDesc instance corresponding to TProof object 'p'. void DiscardSession(TProof* p); Discard TProofDesc of session 'p' from the internal list. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new remote session (master and associated workers). Bool_t MatchUrl(const char* url); Checks if 'url' refers t",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Modifiability,plugin,plugin," empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current; user.; Not supported. void ShowWorkers(); Show available workers. TProofDesc * GetProofDesc(Int_t id); Get TProofDesc instance corresponding to 'id'. TProofDesc * GetProofDesc(TProof* p); Get TProofDesc instance corresponding to TProof object 'p'. void DiscardSession(TProof* p); Discard TProofDesc of session 'p' from the internal list. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new remote session (master and associated workers). Bool_t MatchUrl(const char* url); Checks if 'url' refers to the same 'user@host:port' entity as the URL; in memory. TList * GetListOfManagers(); Extract pointers to PROOF managers from TROOT::fProofs. TProofMgr * Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); Static method returning the appropriate TProofMgr object using; the plugin manager. TProofMgr_t GetXProofMgrHook(); Get the constructor hook fro TXProofMgr.; We do this without the plugin manager because it blocks the; CINT mutex breaking the parallel startup. void SetTXProofMgrHook(TProofMgr_t pmh); Set hook to TXProofMgr ctor. TProofMgr(const TProofMgr& ). TProofMgr& operator=(const TProofMgr& ). TProofMgr(); { }. Bool_t IsLite() const; { return (fServType == kProofLite); }. Bool_t IsProofd() const; { return (fServType == kProofd); }. Bool_t IsValid() const; { return kTRUE; }. void SetInvalid(); { }. Int_t GetRemoteProtocol() const; { return fRemoteProtocol; }. TProofLog * GetSessionLogs(Int_t = 0, const char* = 0, const char* = ""-v \""| SvcMsg\""""); { return (TProofLog *)0; }. const char * GetUrl(); { return fUrl.GetUrl(); }. TObjString * ReadBuffer(const char* , Long64_t , Int_t ); { return (TObjString *)0; }. TObjString * ReadBuffer(const char* , const char* ); { return (TO",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Security,access,accessible,"ent. ~TProofMgr(); Destroy a TProofMgr instance. TProof * AttachSession(Int_t , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. The boolena 'gui' should be kTRUE when invoked from the GUI. TProof * AttachSession(TProofDesc* , Bool_t = kFALSE); Dummy version provided for completeness. Just returns a pointer to; existing session 'id' (as shown by TProof::QuerySessions) or 0 if 'id' is; not valid. void DetachSession(Int_t , Option_t* = """"); Detach session with 'id' from its proofserv. The 'id' is the number; shown by QuerySessions. The correspondent TProof object is deleted.; If id == 0 all the known sessions are detached.; Option opt=""S"" or ""s"" forces session shutdown. void DetachSession(TProof* , Option_t* = """"); Detach session 'p' from its proofserv. The instance 'p' is invalidated; and should be deleted by the caller. TList * QuerySessions(Option_t* opt = ""S""); Get list of sessions accessible to this manager. Int_t SendMsgToUsers(const char* , const char* = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the user to which to send the message: if; empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. Int_t Reset(Bool_t hard = kFALSE, const char* usr = 0); Send a cleanup request for the sessions associated with the current; user.; Not supported. void ShowWorkers(); Show available workers. TProofDesc * GetProofDesc(Int_t id); Get TProofDesc instance corresponding to 'id'. TProofDesc * GetProofDesc(TProof* p); Get TProofDesc instance corresponding to TProof object 'p'. void DiscardSession(TProof* p); Discard TProofDesc of session 'p' from the internal list. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new remote session (",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Testability,log,loglevel," TProofMgr(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgr(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char*, const char* = 0, const char* = 0); static TProofMgr*Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidDiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* m",MatchSource.WIKI,root/html528/TProofMgr.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgr.html
Availability,error,error,"pare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTProofMgr::Find(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTProofMgr::GetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TProofDesc*TProofMgr::GetProofDesc(Int_t id); virtual TP",MatchSource.WIKI,root/html528/TProofMgrLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgrLite.html
Testability,log,loglevel," TProofMgrLite(const char* url, Int_t loglevel = -1, const char* alias = """"); virtual~TProofMgrLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TProof*TProofMgr::AttachSession(Int_t, Bool_t = kFALSE); virtual TProof*TProofMgr::AttachSession(TProofDesc*, Bool_t = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* p",MatchSource.WIKI,root/html528/TProofMgrLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofMgrLite.html
Availability,error,error,"fNodeInfo& nodeInfo); virtual~TProofNodeInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssign(const TProofNodeInfo& n); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TString&GetConfig() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TString&GetId() const; const TString&GetImage() const; const TString&GetMsd() const; virtual const char*TObject::GetName() const; const TString&GetNodeName() const; TProofNodeInfo::ENodeTypeGetNodeType() const; static TProofNodeInfo::ENodeTypeGetNodeType(const TString& type); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOrdinal() const; Int_tGetP",MatchSource.WIKI,root/html528/TProofNodeInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofNodeInfo.html
Availability,error,error,"te, const char* dsname = 0); virtual~TProofOutputFile(); voidTObject::AbstractMethod(const char* method) const; Int_tAdoptFile(TFile* f); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetDir(Bool_t raw = kFALSE) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFileCollection*GetFileCollection(); TFileMerger*GetFileMerger(Bool_t local = kFALSE); const char*GetFileName() const; virtual const char*TObject::GetIconName() const; const char*GetLocalHost() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOptionsAnchor() const; const char*GetOutputFileName() co",MatchSource.WIKI,root/html528/TProofOutputFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofOutputFile.html
Integrability,message,message,"' local: copy locally the files before merging (implies 'M'); 'D' dataset: create a TFileCollection; 'R' register: dataset run with dataset registration; 'O' overwrite: force dataset replacement during registration; 'V' verify: verify the registered dataset; Special 'option' values for backward compatibility:; """" equivalent to ""M""; ""LOCAL"" equivalent to ""ML"" or ""L"". void Init(const char* path, const char* dsname); Initializer. Called by all constructors. ~TProofOutputFile(); Main destructor. void SetFileName(const char* name); Set the file name. void SetOutputFileName(const char* name); Set the name of the output file; in the form of an Url. TFile* OpenFile(const char* opt); Open the file using the unique temporary name. Int_t AdoptFile(TFile* f); Adopt a file already open.; Return 0 if OK, -1 in case of failure. Long64_t Merge(TCollection* list); Merge objects from the list into this object. void Print(Option_t* option = """") const; Dump the class content. void NotifyError(const char* errmsg); Notify error message. void AddFile(TFileMerger* merger, const char* path); Add file to merger, checking the result. void Unlink(const char* path); Unlink path. TFileCollection * GetFileCollection(); Get instance of the file collection to be used in 'dataset' mode. TFileMerger * GetFileMerger(Bool_t local = kFALSE); Get instance of the file merger to be used in 'merge' mode. TProofOutputFile(const TProofOutputFile& ). TProofOutputFile& operator=(const TProofOutputFile& ). void SetDir(const char* dir); { fDir = dir; }. void SetWorkerOrdinal(const char* ordinal); { fWorkerOrdinal = ordinal; }. TProofOutputFile(); { }. const char * GetDir(Bool_t raw = kFALSE) const; { return (raw) ? fRawDir : fDir; }. const char * GetFileName() const; { return fFileName; }. const char * GetLocalHost() const; { return fLocalHost; }. const char * GetOptionsAnchor() const; { return fOptionsAnchor; }. const char * GetOutputFileName() const; { return fOutputFileName; }. const char * GetWorkerOrdinal() ",MatchSource.WIKI,root/html528/TProofOutputFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofOutputFile.html
Modifiability,sandbox,sandbox,"(TFileMerger* merger, const char* path); voidInit(const char* path, const char* dsname); voidNotifyError(const char* errmsg); TProofOutputFile&operator=(const TProofOutputFile&); voidSetDir(const char* dir); voidSetFileName(const char* name); voidSetWorkerOrdinal(const char* ordinal); voidUnlink(const char* path). Data Members; public:. enum ERunType { kMerge; kDataset; };; enum ETypeOpt { kRemote; kLocal; kCreate; kRegister; kOverwrite; kVerify; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TFileCollection*fDataSetInstance of the file collection in 'dataset' mode; TStringfDirname of the directory to be exported; TStringfFileName; Bool_tfIsLocalkTRUE if the file is in the sandbox; TStringfLocalHostHost where the file was created; Bool_tfMerged; TFileMerger*fMergerInstance of the file merger in 'merge' mode; TStringfOptionsAnchoroptions and anchor string including delimiters, e.g. ""?myopts#myanchor""; TStringfOutputFileName; TStringfRawDirname of the local directory where to create the file; TProofOutputFile::ERunTypefRunTypeType of run (see enum ERunType); UInt_tfTypeOptOption (see enum ETypeOpt); TStringfWorkerOrdinal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputFile(const char* path, TProofOutputFile::ERunType type, UInt_t opt = kRemote, const char* dsname = 0); Main constructor. TProofOutputFile(const char* path, const char* option = ""M"", const char* dsname = 0); Constructor with the old signature, kept for convenience and backard compatibility.; Options:; 'M' merge: finally merge the created files; 'L' local: copy locally the files before merging (implies 'M'); 'D' dataset: create a TFileCollection; 'R' ",MatchSource.WIKI,root/html528/TProofOutputFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofOutputFile.html
Testability,sandbox,sandbox,"(TFileMerger* merger, const char* path); voidInit(const char* path, const char* dsname); voidNotifyError(const char* errmsg); TProofOutputFile&operator=(const TProofOutputFile&); voidSetDir(const char* dir); voidSetFileName(const char* name); voidSetWorkerOrdinal(const char* ordinal); voidUnlink(const char* path). Data Members; public:. enum ERunType { kMerge; kDataset; };; enum ETypeOpt { kRemote; kLocal; kCreate; kRegister; kOverwrite; kVerify; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TFileCollection*fDataSetInstance of the file collection in 'dataset' mode; TStringfDirname of the directory to be exported; TStringfFileName; Bool_tfIsLocalkTRUE if the file is in the sandbox; TStringfLocalHostHost where the file was created; Bool_tfMerged; TFileMerger*fMergerInstance of the file merger in 'merge' mode; TStringfOptionsAnchoroptions and anchor string including delimiters, e.g. ""?myopts#myanchor""; TStringfOutputFileName; TStringfRawDirname of the local directory where to create the file; TProofOutputFile::ERunTypefRunTypeType of run (see enum ERunType); UInt_tfTypeOptOption (see enum ETypeOpt); TStringfWorkerOrdinal. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofOutputFile(const char* path, TProofOutputFile::ERunType type, UInt_t opt = kRemote, const char* dsname = 0); Main constructor. TProofOutputFile(const char* path, const char* option = ""M"", const char* dsname = 0); Constructor with the old signature, kept for convenience and backard compatibility.; Options:; 'M' merge: finally merge the created files; 'L' local: copy locally the files before merging (implies 'M'); 'D' dataset: create a TFileCollection; 'R' ",MatchSource.WIKI,root/html528/TProofOutputFile.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofOutputFile.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; voidFeedBackCanvas(const char* name, Bool_t create); virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetCacheSize(); virtual TQueryResult*GetCurrentQuery() const; virtual Int_tGetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusGetExitStatus() const; virtual const char*TObject::GetIconName() const;",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Integrability,depend,dependency,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(co",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Performance,cache,cache,"pFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the learning phase. void * GetSender(); { return this; }. TVirtualPacketizer * GetPacketizer() const; { return 0; }. TList * GetInputList() const; { return fInput; }. TList * GetListOfResults() const; { return fQueryResults; }. TQueryResult * GetCurrentQuery() const; { return fQuery; }. void SetMaxDrawQueries(Int_t max); { fMaxDrawQueries = max; }. void RestorePreviousQuery(); { fQuery = fPreviousQuery; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). Bool_t IsClient() const; { return kFALSE; }. EExitStatus GetExitStatus() const; { return fExitStatus; }. Long64_t GetEventsProcessed() const; { return fProgressStatus->GetEntries(); }. void AddEventsProcessed(Long64_t",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Safety,abort,abort,"oat_t mbrti)SIGNAL ; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tReinitSelector(TQueryResult* qr); virtual voidRemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidRestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidSetCurrentQuery(TQueryResult* q); virtual voidSetDispatchTimer(Bool_t on = kTRUE); virtual voidSetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidSetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcessing(Bool_t on = kTRUE); virtual voidSetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopFeedback(); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidUpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Security,access,accessed,"inalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(co",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Usability,feedback,feedback,"; Remove all query result instances referenced 'ref' from; the list of results. TQueryResult * GetQueryResult(const char* ref); Get query result instances referenced 'ref' from; the list of results. void SetCurrentQuery(TQueryResult* q); Set current query and save previous value. void AddInput(TObject* inp); Add object to input list. void ClearInput(); Clear input list. TObject * GetOutput(const char* name) const; Get output object by name. TList * GetOutputList() const; Get output list. Int_t ReinitSelector(TQueryResult* qr); Reinitialize fSelector using the selector files in the query result.; Needed when Finalize is called after a Process execution for the same; selector name. Int_t AddOutputObject(TObject* obj); Incorporate output object (may not be used in this class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in",MatchSource.WIKI,root/html528/TProofPlayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayer.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayerRemote::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProof",MatchSource.WIKI,root/html528/TProofPlayerLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerLite.html
Safety,abort,abort,"t* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofPlayerLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerLite.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayer::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayer::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayer::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const;",MatchSource.WIKI,root/html528/TProofPlayerLocal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerLocal.html
Safety,abort,abort,"esult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofPlayerLocal.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerLocal.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFeedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tFinalize(TQueryResult* qr); virtual Long64_tFinalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const; virtual TVirtualProofPlayer::EExitStatusT",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Energy Efficiency,consumption,consumption,"bers:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Integrability,message,message,"ck signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of fe",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Performance,optimiz,optimizing,"bers:; find the mapping of data members to otuput list entries in the output list; and apply it. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE). Long64_t Finalize(TQueryResult* qr); Finalize the results of a query already processed. Bool_t SendSelector(const char* selector_file); Send the selector file(s) to master or worker nodes. void MergeOutput(); Merge objects in output the lists. void Progress(Long64_t total, Long64_t processed); Progress signal. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Progress signal. void Progress(TProofProgressInfo* pi); Progress signal. void Feedback(TList* objs); Feedback signal. void StopProcess(Bool_t abort, Int_t timeout = -1); Stop process after this event. Int_t AddOutputObject(TObject* obj); Incorporate the received object 'obj' into the output list fOutput.; The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' optimizing the memory; consumption.; Returns -1 in case of error, 1 if the object has been merged into another; one (so that its ownership has not been taken and can be deleted), and 0; otherwise. void RedirectOutput(Bool_t on = kTRUE); Control output redirection to TProof::fLogFileW. void AddOutput(TList* out); Incorporate the content of the received output list 'out' into the final; output list fOutput. The latter is created if not existing.; This method short cuts 'StoreOutput + MergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is ",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Safety,abort,abort,"TRUE); virtual Int_tTProofPlayer::ReinitSelector(TQueryResult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStoreFeedback(TObject* slave, TList* out); virtual voidStoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Usability,feedback,feedback,"ergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root/html528/TProofPlayerRemote.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayer::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayer::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayer::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEventsProcessed() const;",MatchSource.WIKI,root/html528/TProofPlayerSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html
Deployability,update,updates,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofPlayerSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html
Safety,abort,abort,"esult* qr); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayer::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayer::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayer::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayer::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofPlayerSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html
Usability,feedback,feedback,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofPlayerSlave.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTProofPlayerRemote::Feedback(TList* objs)SIGNAL ; voidTProofPlayer::FeedBackCanvas(const char* name, Bool_t create); virtual Long64_tTProofPlayerRemote::Finalize(TQueryResult* qr); virtual Long64_tTProofPlayerRemote::Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTProofPlayer::GetCacheSize(); virtual TQueryResult*TProofPlayer::GetCurrentQuery() const; virtual Int_tTProofPlayer::GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tTProofPlayer::GetEvents",MatchSource.WIKI,root/html528/TProofPlayerSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html
Integrability,message,messages,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofPlayerSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html
Safety,abort,abort,"); virtual voidTProofPlayer::RemoveQueryResult(const char* ref); voidTObject::ResetBit(UInt_t f); virtual voidTProofPlayer::RestorePreviousQuery(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTProofPlayer::SetCurrentQuery(TQueryResult* q); virtual voidTProofPlayer::SetDispatchTimer(Bool_t on = kTRUE); virtual voidTProofPlayer::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTProofPlayerRemote::SetInitTime(); virtual voidTProofPlayer::SetMaxDrawQueries(Int_t max); static voidTObject::SetObjectStat(Bool_t stat); voidTProofPlayer::SetProcessing(Bool_t on = kTRUE); virtual voidTProofPlayer::SetStopTimer(Bool_t on = kTRUE, Bool_t abort = kFALSE, Int_t timeout = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTProofPlayerRemote::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidTProofPlayerRemote::StoreFeedback(TObject* slave, TList* out); virtual voidTProofPlayerRemote::StoreOutput(TList* out); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTProofPlayer::UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t buf",MatchSource.WIKI,root/html528/TProofPlayerSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html
Usability,feedback,feedback,"lockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. Bool_tfReturnFeedback; TArrayIfSlaveActW; TArrayL64fSlaveBytesRead; TArrayFfSlaveEffS; TArrayFfSlaveEvtRti; TArrayFfSlaveInitTime; TArrayFfSlaveMBRti; TArrayFfSlaveProcTime; TArrayL64fSlaveProgress; TArrayIfSlaveTotS; TArrayL64fSlaveTotals; TListfSlaves. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF. Runs on super master.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void Progress(TSlave* sl, Long64_t total, Long64_t processed); Report progress. void Progress(TSlave* sl, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress. void Progress(TSlave* sl, TProofProgressInfo* pi); Progress signal. Bool_t HandleTimer(TTimer* timer); Send progress and feedback to client. void SetupFeedback(); Setup reporting of feedback objects and progress messages. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* sl, Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProofPlayerSuperMaster(TProof* proof = 0); { }. virtual ~TProofPlayerSuperMaster(); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofPlayerSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofPlayerSuperMaster.html
Deployability,update,update," virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntries; TGTextEntry*fEntry; TGLabel*fEstim; Int_tfFiles; TGLabel*fFilesEvents; Long64_tfFirst; TGLabel*fInit; Float_tfInitTime; Bool_tfKeep; TGCheckButton*fKeepToggle; TGTextButton*fLog; Bool_tfLogQuery; TGCheckButton*fLogQueryToggle; TProofProgressLog*fLogWindowtransient frame for logs; TGraph*fMBRtGraph; TGTextButton*fMemPlot; TProofProgressMemoryPlot*fMemWindowtransient frame for memory plots; Long64_tfPrevProcessed; Long64_tfPrevTotal; Float_tfProcTime; TGLabel*fProcessed; TProof*fProof; TGLabel*fRate; TGraph*fRateGraph; TGTextButton*fRatePlot; TNtuple*fRatePoints; Int_tfRightInfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThresh",MatchSource.WIKI,root/html528/TProofProgressDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html
Safety,abort,aborted,"g. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGrap",MatchSource.WIKI,root/html528/TProofProgressDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html
Testability,log,logs," virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog window; TGraph*fEffSGraph; TTimefEndTime; Long64_tfEntries; TGTextEntry*fEntry; TGLabel*fEstim; Int_tfFiles; TGLabel*fFilesEvents; Long64_tfFirst; TGLabel*fInit; Float_tfInitTime; Bool_tfKeep; TGCheckButton*fKeepToggle; TGTextButton*fLog; Bool_tfLogQuery; TGCheckButton*fLogQueryToggle; TProofProgressLog*fLogWindowtransient frame for logs; TGraph*fMBRtGraph; TGTextButton*fMemPlot; TProofProgressMemoryPlot*fMemWindowtransient frame for memory plots; Long64_tfPrevProcessed; Long64_tfPrevTotal; Float_tfProcTime; TGLabel*fProcessed; TProof*fProof; TGLabel*fRate; TGraph*fRateGraph; TGTextButton*fRatePlot; TNtuple*fRatePoints; Int_tfRightInfo; Int_tfSVNRev; TGLabel*fSelector; TStringfSessionUrl; TGCheckButton*fSmoothSpeedouse smooth speedometer update; TGSpeedo*fSpeedospeedometer; Bool_tfSpeedoEnabledwhether to enable the speedometer; TTimefStartTime; TProofProgressDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThresh",MatchSource.WIKI,root/html528/TProofProgressDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html
Usability,progress bar,progress bar,". TProofProgressDialog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressDialog. class TProofProgressDialog. TProofProgressDialog. This class provides a query progress bar. Function Members (Methods); public:. TProofProgressDialog(const TProofProgressDialog&); TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); virtual~TProofProgressDialog(); static TClass*Class(); voidCloseWindow(); voidDisableAsyn(); voidDoAbort(); voidDoAsyn(); voidDoClose(); voidDoEnableSpeedo(); voidDoKeep(Bool_t on); voidDoLog(); voidDoMemoryPlot(); voidDoPlotRateGraph(); voidDoSetLogQuery(Bool_t on); voidDoStop(); voidIndicateStop(Bool_t aborted); virtual TClass*IsA() const; voidLogMessage(const char* msg, Bool_t all); TProofProgressDialog&operator=(const TProofProgressDialog&); voidProgress(Long64_t total, Long64_t processed); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); voidProgress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); voidResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidToggleOdometerInfos(); voidToggleThreshold(). private:. Float_tAdjustBytes(Float_t mbs, TString& sf). Data Members; public:. enum EQueryStatus { kRunning; kDone; kStopped; kAborted; kIncomplete; };. private:. TGTextButton*fAbort; TGraph*fActWGraph; TGTextButton*fAsyn; Double_tfAvgMBRate; Double_tfAvgRate; TGProgressBar*fBarprogress bar; TGTextButton*fClose; TGTransientFrame*fDialogtransient frame, main dialog wind",MatchSource.WIKI,root/html528/TProofProgressDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html
Availability,error,error,"); virtual~TProofProgressInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root/html528/TProofProgressInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressInfo.html
Energy Efficiency,allocate,allocated,"s(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tfActWorkersNumebr of workers still active; Long64_tfBytesReadNumber of bytes read; Float_tfEffSessionsNumber of effective sessions running on the machines allocated to this session; Float_tfEvtRateIInstantaneous event rate; Float_tfInitTimeTime for initialization; Float_tfMBRateIInstantaneous byte read rate; Float_tfProcTimeTime for processing; Long64_tfProcessedNumber of events processed; Int_tfTotSessionsNumebr of PROOF sessions running currently on the clusters; Long64_tfTotalTotal number of events to process. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressInfo(Long64_t tot = 0, Long64_t proc = 0, Long64_t bytes = 0, Float_t initt = -1., Float_t proct = -1., Float_t evts = -1., Float_t mbs = -1., Int_t actw = 0, Int_t tsess = 0, Float_t esess = 0.); { }. virtual ~TProofProgressInfo(); { }. TProofInterruptHandler& operator=(const TProofProgressInfo& ). » Author: Fons Rademakers 13/02/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProof.h 37396 2010-12-08 13:12:00Z rdm $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please",MatchSource.WIKI,root/html528/TProofProgressInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressInfo.html
Integrability,message,messages,". TProofProgressInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofProgressInfo. class TProofProgressInfo: public TObject. TProof. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the worker servers, it keeps track of how many workers are; running, it keeps track of the workers running status, it broadcasts; messages to all workers, it collects results, etc. Function Members (Methods); public:. TProofProgressInfo(const TProofProgressInfo&); TProofProgressInfo(Long64_t tot = 0, Long64_t proc = 0, Long64_t bytes = 0, Float_t initt = -1., Float_t proct = -1., Float_t evts = -1., Float_t mbs = -1., Int_t actw = 0, Int_t tsess = 0, Float_t esess = 0.); virtual~TProofProgressInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, c",MatchSource.WIKI,root/html528/TProofProgressInfo.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressInfo.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TProofProgressLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html
Integrability,message,messages,"llLinesdisplay all lines button; TGSplitButton*fAllWorkersdisplay all workers button; TGTextButton*fCloseclose button; TProofProgressDialog*fDialogowner dialog; TGTextEntry*fFileNamefile to save to; Bool_tfFullText0 - when grep was called; TGTextButton*fGrepButtongrep button; TGTextEntry*fGrepTexttext to grep for in the logs; TGNumberEntry*fLinesFromstarting line; TGNumberEntry*fLinesToending line; TGListBox*fLogListlist of workers; TGTextButton*fLogNewdisplay logs button; TProofLog*fProofLogthe log; TGCheckButton*fRawLinesdisplay raw lines button; TGTextButton*fSavesave button; TGNumberEntry*fSessNumrelative index of the session to get; Int_tfSessionIdx; TStringfSessionUrl; TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the",MatchSource.WIKI,root/html528/TProofProgressLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html
Testability,log,logs,". TProofProgressLog. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TProofProgressLog. class TProofProgressLog: public TGTransientFrame. TProofProgressLog. Dialog used to display Proof session logs from the Proof progress; dialog.; It uses TProofMgr::GetSessionLogs() mechanism internally. Function Members (Methods); public:. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); virtual~TProofProgressLog(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddBuffer(const char* buffer); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuildLogList(Bool_t create = kFALSE); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidClear(Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList",MatchSource.WIKI,root/html528/TProofProgressLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html
Usability,clear,clear," TGTextView*fTexttext widget; Int_tfTextTypeType of retrieval; TGTextButton*fUrlButtonrebuild button; TGTextEntry*fUrlTexturl to connect to; TGVerticalFrame*fVworkersVertical frame. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display the logs. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressLog.h 32203 2010-02-03 18:47:34Z ganis $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofProgressLog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressLog.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TProofProgressMemoryPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html
Energy Efficiency,consumption,consumption,"c Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressMemoryPlot.h 28564 2009-05-12 11:00:21Z ganis $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofProgressMemoryPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html
Testability,log,logs,"l_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003",MatchSource.WIKI,root/html528/TProofProgressMemoryPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html
Usability,clear,clear,"c Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TProofProgressMemoryPlot.h 28564 2009-05-12 11:00:21Z ganis $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofProgressMemoryPlot.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressMemoryPlot.html
Availability,error,error,"dCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0); ~TProofProgressStatus(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytesRead() const; Double_tGetCPUTime() const; Double_tGetCurrentRate() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries() const; virtual const char*TObject::GetIconName() const; Double_tGetLastUpdate() const; Double_tGetLearnTime() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetProcTime() const; Double_tGetRate() const; Long64_tGetReadCalls() const; virtual const char*TObject::GetTitle() const; virtu",MatchSource.WIKI,root/html528/TProofProgressStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressStatus.html
Usability,learn,learnTime,"oid* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofProgressStatus&operator+=(const TProofProgressStatus& st); TProofProgressStatusoperator-(TProofProgressStatus& st); TProofProgressStatus&operator-=(const TProofProgressStatus& st); TProofProgressStatus&operator=(const TProofProgressStatus&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidReset(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetBytesRead(Long64_t bytesRead); voidSetCPUTime(Double_t procTime); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetEntries(Long64_t entries); voidSetLastEntries(Long64_t entries); voidSetLastProcTime(Double_t procTime); voidSetLastUpdate(Double_t updtTime = 0); voidSetLearnTime(Double_t learnTime); static voidTObject::SetObjectStat(Bool_t stat); voidSetProcTime(Double_t procTime); voidSetReadCalls(Long64_t readCalls); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root/html528/TProofProgressStatus.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofProgressStatus.html
Availability,error,error,"TProofQueryResult(const TProofQueryResult&); virtual~TProofQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTQueryResult::Browse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTQueryResult::GetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTQueryResult::GetEndTime() const; Long64_tTQueryResult::GetEntries() const; Long64_tTQueryResult::GetFirst() const; virtual const char*TObject::GetIconName() const; Float_tTQueryResult::GetInitTime() const; TList*TQueryResult::GetInputList(); TObject*TQueryResult::GetInputObject(const char* classname) const; const char*TQueryResult::GetLibList() const; TMacro*TQueryResult::GetLogFile() const; virtual const char*TNamed::GetName() const; Int_tTQueryResult::Ge",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Energy Efficiency,adapt,adapted,". TProofQueryResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofQueryResult. class TProofQueryResult: public TQueryResult. TProofQueryResult. TQueryResult version adapted to PROOF neeeds. Function Members (Methods); public:. TProofQueryResult(); TProofQueryResult(const TProofQueryResult&); virtual~TProofQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTQueryResult::Browse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTQueryResult::GetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTQueryResult::GetEnd",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Integrability,message,messages,"en archived; Long64_tTQueryResult::fBytesnumber of bytes processed; Bool_tTQueryResult::fDrawtrue if draw action query; TDatimeTQueryResult::fEndtime when processing ended; Long64_tTQueryResult::fEntriesnumber of entries processed; Bool_tTQueryResult::fFinalizedwhether Terminate has been run; Long64_tTQueryResult::fFirstfirst entry processed; Float_tTQueryResult::fInitTimeInitialization time (seconds) (millisec precision); TList*TQueryResult::fInputListinput list; contains also data sets, entry list, ...; TStringTQueryResult::fLibListblank-separated list of libs loaded at fStart; TMacro*TQueryResult::fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tTQueryResult::fNumWrksNumber of workers at start; TStringTQueryResult::fOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*TQueryResult::fOutputListoutput list; TStringTQueryResult::fParListcolon-separated list of PAR loaded at fStart; Float_tTQueryResult::fProcTimeProcessing time (seconds) (millisec precision); TStringTQueryResult::fResultFileURL of the file where results have been archived; TMacro*TQueryResult::fSelecHdrselector header file; TMacro*TQueryResult::fSelecImpselector implementation file; Int_tTQueryResult::fSeqNumquery unique sequential number; TDatimeTQueryResult::fStarttime when processing started; TQueryResult::EQueryStatusTQueryResult::fStatusquery status; TStringTNamed::fTitleobject title; Float_tTQueryResult::fUsedCPUreal CPU time used (seconds). private:. Int_tfStartLoglog file offset at start. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, TDSet* dset, const char* selec, TObject* elist = 0); Main constructor. void SetRunning(Int_t startlog, const char* par, Int_t nwrks); Call when running starts. TProofQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, TDSet* dset",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Modifiability,adapt,adapted,". TProofQueryResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofQueryResult. class TProofQueryResult: public TQueryResult. TProofQueryResult. TQueryResult version adapted to PROOF neeeds. Function Members (Methods); public:. TProofQueryResult(); TProofQueryResult(const TProofQueryResult&); virtual~TProofQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTQueryResult::Browse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTQueryResult::GetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTQueryResult::GetEnd",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Performance,load,loaded,"en archived; Long64_tTQueryResult::fBytesnumber of bytes processed; Bool_tTQueryResult::fDrawtrue if draw action query; TDatimeTQueryResult::fEndtime when processing ended; Long64_tTQueryResult::fEntriesnumber of entries processed; Bool_tTQueryResult::fFinalizedwhether Terminate has been run; Long64_tTQueryResult::fFirstfirst entry processed; Float_tTQueryResult::fInitTimeInitialization time (seconds) (millisec precision); TList*TQueryResult::fInputListinput list; contains also data sets, entry list, ...; TStringTQueryResult::fLibListblank-separated list of libs loaded at fStart; TMacro*TQueryResult::fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tTQueryResult::fNumWrksNumber of workers at start; TStringTQueryResult::fOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*TQueryResult::fOutputListoutput list; TStringTQueryResult::fParListcolon-separated list of PAR loaded at fStart; Float_tTQueryResult::fProcTimeProcessing time (seconds) (millisec precision); TStringTQueryResult::fResultFileURL of the file where results have been archived; TMacro*TQueryResult::fSelecHdrselector header file; TMacro*TQueryResult::fSelecImpselector implementation file; Int_tTQueryResult::fSeqNumquery unique sequential number; TDatimeTQueryResult::fStarttime when processing started; TQueryResult::EQueryStatusTQueryResult::fStatusquery status; TStringTNamed::fTitleobject title; Float_tTQueryResult::fUsedCPUreal CPU time used (seconds). private:. Int_tfStartLoglog file offset at start. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, TDSet* dset, const char* selec, TObject* elist = 0); Main constructor. void SetRunning(Int_t startlog, const char* par, Int_t nwrks); Call when running starts. TProofQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, TDSet* dset",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Testability,log,logline,"ed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidTQueryResult::AddInput(TObject* obj); voidTQueryResult::AddLogLine(const char* logline); TQueryResult*TQueryResult::CloneInfo(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidTQueryResult::SaveSelector(const char* selec); voidTQueryResult::SetArchived(const char* archfile); virtual voidTQueryResult::SetInputList(TList* in, Bool_t adopt = kTRUE); virtual voidTQueryResult::SetOutputList(TList* out, Bool_t adopt = kTRUE); virtual voidTQueryResult::SetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.). private:. TProofQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, TDSet* dset, const char* selec, TObject* elist = 0); virtual voidRecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); virtual voidSetFinalized(); voidSetResultFile(const char* rf); voidSetRunning(Int_t startlog, const char* par, Int_t nwrks). Data Members; public:. enum TQueryResult::EQueryStatus { kAborted; kSubmitted; kRunning; kStopped; kCompleted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnam",MatchSource.WIKI,root/html528/TProofQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofQueryResult.html
Availability,avail,available,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject:",MatchSource.WIKI,root/html528/TProofResources.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofResources.html
Modifiability,config,config,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject:",MatchSource.WIKI,root/html528/TProofResources.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofResources.html
Availability,error,error,"sStatic(const char* confDir, const char* fileName); virtual~TProofResourcesStatic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TStringGetFileName() const; virtual const char*TObject::GetIconName() const; virtual TProofNodeInfo*GetMaster(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TList*GetSubmasters(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual TList*GetWorkers(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual void",MatchSource.WIKI,root/html528/TProofResourcesStatic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofResourcesStatic.html
Integrability,interface,interface,". TProofResourcesStatic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResourcesStatic. class TProofResourcesStatic: public TProofResources. TProofResourcesStatic. Implementation of PROOF static resources.; The purpose of this class is to provide a standard interface to; static config files. It interprets Proof config files (proof.conf); and sorts the contents into TProofNodeInfo objects. Master info will; be placed in fMaster (of type TProofNodeInfo). Submaster info will; be put in fSubmasterList (a TList of TProofNodeInfo objects), while; workers (and condorworkers) will be placed in fWorkerList (a TList; of TProofNodeInfo objects). Function Members (Methods); public:. TProofResourcesStatic(); TProofResourcesStatic(const TProofResourcesStatic&); TProofResourcesStatic(const char* confDir, const char* fileName); virtual~TProofResourcesStatic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root/html528/TProofResourcesStatic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofResourcesStatic.html
Modifiability,config,config,". TProofResourcesStatic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResourcesStatic. class TProofResourcesStatic: public TProofResources. TProofResourcesStatic. Implementation of PROOF static resources.; The purpose of this class is to provide a standard interface to; static config files. It interprets Proof config files (proof.conf); and sorts the contents into TProofNodeInfo objects. Master info will; be placed in fMaster (of type TProofNodeInfo). Submaster info will; be put in fSubmasterList (a TList of TProofNodeInfo objects), while; workers (and condorworkers) will be placed in fWorkerList (a TList; of TProofNodeInfo objects). Function Members (Methods); public:. TProofResourcesStatic(); TProofResourcesStatic(const TProofResourcesStatic&); TProofResourcesStatic(const char* confDir, const char* fileName); virtual~TProofResourcesStatic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execut",MatchSource.WIKI,root/html528/TProofResourcesStatic.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofResourcesStatic.html
Availability,error,error," voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*GetCacheLock(); const char*GetConfDir() const; const char*GetConfFile() const; Float_tGetCpuTime() const; const char*GetDataDir() const; virtual Option_t*TObject::GetDrawOption() const",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Energy Efficiency,monitor,monitoring,"number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageLockpackage dir locker; TVirtualProofPlayer*fPlayeractual player; TStringfPrefixPrefix identifying the node; TProof*fProofPROOF talking to slave servers; Int_tfProtocolprotocol version number; TQueryResultManager*fQMgrQuery-result manager; TMutex*fQMtxTo protect async msg queue; TStringfQueryDirdirectory containing query results and status; TProofLockPath*fQueryLockquery dir locker; Int_tfQuerySeqNumsequential number of the current or last query; TList*fQueuedMsglist of messages waiting to be processed; Float_tfRealTimereal time spent executing commands; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TReaperTimer*fReaperTimerTimer used to control children state; Bool_tfSendLogToMasterOn workers, controls logs sending to master; TStringfServiceservice we are running, either ""proofserv"" or ""proofslave""; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the server session; TShutdownTimer*fShutdownTimerTimer used to shutdown out-of-control sessions; TSocket*fSocketsocket connection to client; TStringfTopSessionTagtag for the global session; Int_tfTotSessionsTotal number of PROOF sessions on the cluster ; TStringfUseruser as which we run; TList*fWaitingQuerieslist of TProofQueryResult waiting to be processed; TStringfWorkDirdirectory containing all proof related info; static FILE*fgErrorHandlerFileFile where to log; static Int_tfgLogToSysLog>0 sent to syslog too; static Float_tfgMemHWMThreshold fraction of max for warning and finer monitoring; static Float_tfgMemStopFraction of max for stop processing; static Int_tfgRecursiveKeep track of recursive inputs during processing; static Long_tfgResMemMaxHard limit on the resident memory checked; static TStringfgSysLogEntitylogging entity (<user>:<group>); static TStringfgSysLogServicename of the syslog service (eg: proofm-0, proofw-0.",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Integrability,depend,depending,". TProofServ. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofServ. class TProofServ: public TApplication. TProofServ. TProofServ is the PROOF server. It can act either as the master; server or as a slave server, depending on its startup arguments. It; receives and handles message coming from the client or from the; master server. Function Members (Methods); public:. TProofServ(Int_t* argc, char** argv, FILE* flog = 0); virtual~TProofServ(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Modifiability,config,config,,MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Performance,cache,cache,,MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Safety,abort,abort,"har* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*GetCacheLock(); const char*GetConfDir() const; const char*Get",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Security,authenticat,authentication,"y from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRem",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Testability,sandbox,sandbox,nt_tfCompressMsgCompression level for messages; TStopwatchfComputemeasures time spend processing a packet; TStringfConfDirdirectory containing cluster config information; TStringfConfFilefile containing config information; Float_tfCpuTimeCPU time spent executing commands; TStringfDataDirdirectory containing data files produced during queries; TStringfDataSetDirdirectory containing info about known data sets; TDataSetManager*fDataSetManagerdataset manager; Float_tfEffSessionsEffective Number of PROOF sessions on the assigned machines; TList*fEnabledPackageslist of enabled packages; Bool_tfEndMastertrue for a master in direct contact only with workers; THashList*fGlobalPackageDirListlist of directories containing global packages libs; TStringfGroupgroup the user belongs to; Int_tfGroupIdslave unique id in the active slave group; Int_tfGroupPrioritypriority of group the user belongs to (0 - 100); Int_tfGroupSizesize of the active slave group; Long64_tfHWMBoxSizeHigh-Water-Mark on the sandbox size; Bool_tfIdleTRUE if idle; TIdleTOTimer*fIdleTOTimerTimer used to control children state; TStringfImageimage name of the session; Int_tfInflateFactorFactor in 1/1000 to inflate the CPU time; TFileHandler*fInputHandlerInput socket handler; Bool_tfInterruptif true macro execution will be stopped; TStopwatchfLatencymeasures latency of packet requests; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; Int_tfLogLeveldebug logging level; Bool_tfMasterServtrue if we are a master server; Long64_tfMaxBoxSizeMax size of the sandbox; Int_tfMaxQueriesMax number of queries fully kept; Int_tfMergedWorkersNumber of workers merged; TMonitor*fMergingMonitorMonitor for merging sockets; TServerSocket*fMergingSocketSocket used for merging outputs if submerger; Long64_tfMsgSizeHWMHigh-Water-Mark on the size of messages with results; Int_tfNcmdcommand history number; TStringfOrdinalslave ordinal number; TStringfPackageDirdirectory containing packages and user libs; TProofLockPath*fPackageL,MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Usability,resume,resume,"st char*TObject::GetName() const; TDSetElement*GetNextPacket(Long64_t totalEntries = -1); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetOptions(Int_t* argc, char** argv); const char*GetOrdinal() const; const char*GetPackageDir() const; const char*GetPrefix() const; TProof*GetProof() const; Int_tGetProtocol() const; Int_tGetQuerySeqNum() const; Float_tGetRealTime() const; static Long_tGetResMemMax(); const char*GetService() const; const char*GetSessionDir() const; const char*GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*GetSocket() const; virtual const char*TObject::GetTitle() const; Int_tGetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; static Long_tGetVirtMemMax(); const char*GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidHandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidHandleSocketInput(); virtual Int_tHandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::InitializeGraphics(); TObjArray*TApplication::InputFiles() const; virtual voidTObject::Ins",MatchSource.WIKI,root/html528/TProofServ.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServ.html
Availability,error,error,"t char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTProofServ::EnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*TProofServ::GetCacheLock(); const char*TProofServ::GetConfDir() const; const char*TProofServ::GetConfFile() const; Float_tTProofServ::GetCpuTime() c",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Integrability,message,messages,". TProofServLite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofServLite. class TProofServLite: public TProofServ. TProofServLite. TProofServLite is the version of the PROOF worker server for local; running. The client starts directly the desired number of these; workers; the master and daemons are eliminated, optimizing the number; of messages exchanged and created / destroyed. Function Members (Methods); public:. TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); virtual~TProofServLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connec",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Performance,optimiz,optimizing,". TProofServLite. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofServLite. class TProofServLite: public TProofServ. TProofServLite. TProofServLite is the version of the PROOF worker server for local; running. The client starts directly the desired number of these; workers; the master and daemons are eliminated, optimizing the number; of messages exchanged and created / destroyed. Function Members (Methods); public:. TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); virtual~TProofServLite(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connec",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Safety,abort,abort,"ct::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTProofServ::EnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidTProofServ::ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTProofServ::FlushLogFile(); TObject*TProofServ::Get(const char* namecycle); Int_tTProofServ::GetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*TProofServ::GetCacheLock(",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Testability,log,logo,"amed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TProofServLite.h 33637 2010-05-28 13:13:05Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Usability,resume,resume,":GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTProofServ::GetOptions(Int_t* argc, char** argv); const char*TProofServ::GetOrdinal() const; const char*TProofServ::GetPackageDir() const; const char*TProofServ::GetPrefix() const; TProof*TProofServ::GetProof() const; Int_tTProofServ::GetProtocol() const; Int_tTProofServ::GetQuerySeqNum() const; Float_tTProofServ::GetRealTime() const; const char*TProofServ::GetService() const; const char*TProofServ::GetSessionDir() const; const char*TProofServ::GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*TProofServ::GetSocket() const; virtual const char*TObject::GetTitle() const; Int_tTProofServ::GetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*TProofServ::GetUser() const; Long_tTProofServ::GetVirtMemHWM() const; const char*TProofServ::GetWorkDir() const; virtual TProofServ::EQueryActionTProofServ::GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidTProofServ::HandleException(Int_t sig); virtual voidHandleFork(TMessage* mess); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidTProofServ::HandleSocketInput(); virtual Int_tTProofServ::HandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidTProofServ::HandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::In",MatchSource.WIKI,root/html528/TProofServLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofServLite.html
Availability,error,error,"); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*TProof::GetDataSet",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Integrability,message,messages,". TProofSuperMaster. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofSuperMaster. class TProofSuperMaster: public TProof. TProofSuperMaster. This class controls a Parallel ROOT Facility, PROOF, cluster.; It fires the slave servers, it keeps track of how many slaves are; running, it keeps track of the slaves running status, it broadcasts; messages to all slaves, it collects results, etc. Function Members (Methods); public:. TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofSuperMaster(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Modifiability,config,config,"t; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TMonitor*TProof::fAllMonitormonitor activity on all valid slave sockets; TList*TProof::fAvailablePackageslist of available packages; TList*TProof::fBadSlavesdead slaves (subset of all slaves); Long64_tTProof::fBytesReadynumber of bytes staged; Int_tTProof::fCollectTimeoutTimeout for (some) collect actions; TStringTProof::fConfDirdirectory containing cluster config information; TStringTProof::fConfFilefile containing config information; TStringTProof::fDataPoolUrldefault data pool entry point URL; Bool_tTProof::fDataReadytrue if data is ready to be analyzed; Bool_tTProof::fDynamicStartupare the workers started dynamically?; TList*TProof::fEnabledPackageslist of enabled packages; TStringTProof::fImagemaster's image name; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TProofMgr*TProof::fManagermanager to which this session belongs (if any); Bool_tTProof::fMasterServtrue if we are a master server; TStringTNamed::fNameobject identifier; Int_tTProof::fProtocolremote PROOF server protocol version number; TProof::EQueryModeTProof::fQueryModedefault query mode; TList*TProof::fRunningDSetsTemporary datasets used for async running; TProofMgr::EServTypeTProof::fServTypetype of server: proofd, XrdProofd; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TList*TProof::fSlaveslist of all slave servers as in config file; TStringTNamed::fTitleobject title; Long64_tTProof::fTotalBytesnumber of bytes to be analyzed; TUrlTProof::fUrlUrl of the master; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TSemaphore*TProof::fgSemaphoresemaphore to control no of parallel startup threads. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofSuperMaster(const char* masteru",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Performance,load,loadopts," const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) ",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Safety,abort,abort,"amed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidTProof::ShowData(); voidTProof::ShowDataSet(const char* dataset = """", const char* opt = ""M""); virtual voidTProof::ShowDataSetCache(const char* dataset = 0); voidTProof::ShowDataSetQuota(Option_t* opt = 0); virtual voidTProof::ShowDataSets(const char* uri = """", const char* optStr = """"); voidTProof::ShowEnabledPackages(Bool_t all = kFALSE); voidTProof::ShowFeedback() const; voidTProof::ShowLog(Int_t qry = -1); voidTProof::ShowLog(const char* queryref); virtual voidShowMembers(TMemberInspector& insp); voidTProof::ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); voidTProof::ShowParameters(const char* wildcard = ""PROOF_*"") const; voidTProof::ShowQueries(Option_t* opt = """"); virtual Int_tTNamed::Sizeof() const; voidTProof::StartupMessage(const char* msg, Bool_t status, Int_t done, Int_t total)SIGNAL ; voidTProof::StopProcess(Bool_t abort, Int_t timeout = -1); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; voidTProof::Touch(); Int_tTProof::UploadDataSet(const char* dataset, TList* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSet(const char* dataset, const char* files, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadDataSetFromFile(const char* dataset, const char* file, const char* dest = 0, Int_t opt = kAskUser, TList* skippedFiles = 0); Int_tTProof::UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); virtual voidTObject::UseCurrentStyle(); Bool_tTProof::UseDynamicStartup() const; virtual Int_tTProof::VerifyDataSet(const char* dataset, const char* optStr = """"); virtual voidTObject::Warning(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Testability,log,loglevel," TProofSuperMaster(const char* masterurl, const char* conffile = kPROOF_ConfFile, const char* confdir = kPROOF_ConfDir, Int_t loglevel = 0, const char* alias = 0, TProofMgr* mgr = 0); virtual~TProofSuperMaster(); voidTObject::AbstractMethod(const char* method) const; voidTProof::ActivateWorker(const char* ord); voidTProof::AddChain(TChain* chain); Int_tTProof::AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); static voidTProof::AddEnvVar(const char* name, const char* value); voidTProof::AddFeedback(const char* name); Int_tTProof::AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); voidTProof::AddInput(TObject* obj); voidTProof::AddInputData(TObject* obj, Bool_t push = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTProof::Archive(Int_t query, const char* url); Int_tTProof::Archive(const char* queryref, const char* url = 0); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTProof::Browse(TBrowser* b); voidTProof::cd(Int_t id = -1); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tTProof::CleanupSession(const char* sessiontag); virtual voidTNamed::Clear(Option_",MatchSource.WIKI,root/html528/TProofSuperMaster.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html
Availability,error,error,":Point3D_t>&); virtual~TProofVectorContainer<TProofDrawListOfGraphs::Point3D_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vector<TProofDrawListOfGraphs::Point3D_t>*GetVector() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(cons",MatchSource.WIKI,root/html528/TProofVectorContainer_TProofDrawListOfGraphs__Point3D_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofVectorContainer_TProofDrawListOfGraphs__Point3D_t_.html
Availability,error,error,"D_t>&); virtual~TProofVectorContainer<TProofDrawListOfPolyMarkers3D::Point4D_t>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; vector<TProofDrawListOfPolyMarkers3D::Point4D_t>*GetVector() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::In",MatchSource.WIKI,root/html528/TProofVectorContainer_TProofDrawListOfPolyMarkers3D__Point4D_t_.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TProofVectorContainer_TProofDrawListOfPolyMarkers3D__Point4D_t_.html
Availability,error,error,"voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UChar_tTServerSocket::GetAcceptOptions(); UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionLevel() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressTServerSocket::GetLocalInetAddress(); virtual Int_tTServerSocket::GetL",MatchSource.WIKI,root/html528/TPServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPServerSocket.html
Integrability,protocol,protocol,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. Int_tfTcpWindowSizesize of tcp window (for window scaling). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a parallel server socket object on a specified port. Set reus",MatchSource.WIKI,root/html528/TPServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPServerSocket.html
Performance,perform,performs,". TPServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPServerSocket. class TPServerSocket: public TServerSocket. TPServerSocket. This class implements parallel server sockets. A parallel server; socket waits for requests to come in over the network. It performs; some operation based on that request and then possibly returns a; full duplex parallel socket to the requester. The actual work is; done via the TSystem class (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TPServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TPServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TPServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = kSrvNoAuth); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Opt",MatchSource.WIKI,root/html528/TPServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPServerSocket.html
Safety,timeout,timeout,"tor new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTServerSocket::Recv(TMessage*&); virtual Int_tTServerSocket::Recv(Int_t&, Int_t&); virtual Int_tTServerSocket::Recv(char*, Int_t); virtual Int_tTServerSocket::Recv(char*, Int_t, Int_t&); virtual Int_tTServerSocket::RecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tTServerSocket::Send(const TMessage&); virtual Int_tTServerSocket::Send(Int_t); virtual Int_tTServerSocket::Send(Int_t, Int_t); virtual Int_tTServerSocket::Send(const char*, Int_t = kMESS_STRING); virtual Int_tTServerSocket::SendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tTServerSocket::SendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidTServerSocket::SetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); v",MatchSource.WIKI,root/html528/TPServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPServerSocket.html
Security,authenticat,authentication,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. Int_tfTcpWindowSizesize of tcp window (for window scaling). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a parallel server socket object on a specified port. Set reus",MatchSource.WIKI,root/html528/TPServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPServerSocket.html
Availability,error,error," virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionLevel() const; virtual Int_tGetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tTSocket::GetLocalPort(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root/html528/TPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPSocket.html
Integrability,protocol,protocol,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. Int_t*fReadBytesLeftbytes left to read for specified socket; TMonitor*fReadMonitormonitor read from parallel sockets; char**fReadPtrpointer to read buffer for specified socket; Int_tfSizenumber of parallel sockets; TSocket**fSocketsarray of parallel sockets; Int_t*fWriteBytesLeftbytes left to write for specified socket; TMonito",MatchSource.WIKI,root/html528/TPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPSocket.html
Performance,latency,latency,". TPSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TPSocket. class TPSocket: public TSocket. TPSocket. This class implements parallel client sockets. A parallel socket is; an endpoint for communication between two machines. It is parallel; because several TSockets are open at the same time to the same; destination. This especially speeds up communication over Big Fat; Pipes (i.e. high bandwidth, high latency WAN connections). Function Members (Methods); public:. TPSocket(TInetAddress address, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(TInetAddress address, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, const char* service, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, Int_t tcpwindowsize = -1); TPSocket(const char* host, Int_t port, Int_t size, TSocket* sock); virtual~TPSocket(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtua",MatchSource.WIKI,root/html528/TPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPSocket.html
Safety,timeout,timeout,"id* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*& mess); virtual Int_tRecv(Int_t& status, Int_t& kind); virtual Int_tRecv(char* mess, Int_t max); virtual Int_tRecv(char* mess, Int_t max, Int_t& kind); virtual Int_tRecvRaw(void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage& mess); virtual Int_tSend(Int_t kind); virtual Int_tSend(Int_t status, Int_t kind); virtual Int_tSend(const char* mess, Int_t kind = kMESS_STRING); virtual Int_tTSocket::SendObject(const TObject* obj, Int_t kind = kMESS_OBJECT); virtual Int_tSendRaw(const void* buffer, Int_t length, ESendRecvOptions opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tSetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed",MatchSource.WIKI,root/html528/TPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPSocket.html
Security,authenticat,authentication,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. Int_t*fReadBytesLeftbytes left to read for specified socket; TMonitor*fReadMonitormonitor read from parallel sockets; char**fReadPtrpointer to read buffer for specified socket; Int_tfSizenumber of parallel sockets; TSocket**fSocketsarray of parallel sockets; Int_t*fWriteBytesLeftbytes left to write for specified socket; TMonito",MatchSource.WIKI,root/html528/TPSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPSocket.html
Availability,error,error,"voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; PyObject*Dispatch(); PyObject*Dispatch(const char* param); PyObject*Dispatch(Double_t param); PyObject*Dispatch(Long_t param); PyObject*Dispatch(Long64_t param); PyObject*DispatchVA(const char* format); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TPyDispatcher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPyDispatcher.html
Deployability,install,install,". TPyDispatcher. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPyDispatcher. class TPyDispatcher: public TObject. Python callback dispatcher. The TPyDispatcher class acts as a functor that can be used for TFn's and GUIs; to install callbacks from CINT. Function Members (Methods); public:. TPyDispatcher(PyObject* callable); TPyDispatcher(const TPyDispatcher&); virtual~TPyDispatcher(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; PyObject*Dispatch(); PyObject*Dispatch(const char* param); PyObject*Dispatch(Double_t param); PyObject*Dispatch(Long_t param); PyObject*Dispatch(Long64_t param); PyObject*DispatchVA(const char* format); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual ",MatchSource.WIKI,root/html528/TPyDispatcher.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPyDispatcher.html
Integrability,wrap,wrapper,". TPyMultiGenFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPyMultiGenFunction. class TPyMultiGenFunction: public ROOT::Math::IBaseFunctionMultiDim. Python wrapper for Fit functions. Function Members (Methods); public:. TPyMultiGenFunction(PyObject* self = 0); virtual~TPyMultiGenFunction(); static TClass*Class(); virtual TPyMultiGenFunction*Clone() const; virtual doubleDoEval(const double* x) const; virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TPyMultiGenFunction(const TPyMultiGenFunction& src); TPyMultiGenFunction&operator=(const TPyMultiGenFunction&). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGenFunction(PyObject* self = 0); Construct a TPyMultiGenFunction derived with <self> as the underlying. ~TPyMultiGenFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. TPyMultiGenFunction(PyObject* self = 0); ctor/dtor, and assignment. TPyMultiGenFunction* Clone() const; Math::IMultiGenFunction implementation. { return new TPyMultiGenFunction( fPySelf ); }. TPyMultiGenFunction& operator=(const TPyMultiGenFunction& ); { return *this; }. » Last changed: Mon Nov 29 18:57:56 2010 » Last generated: 2010-11-29 18:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TPyMultiGenFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPyMultiGenFunction.html
Integrability,wrap,wrapper,". TPyMultiGradFunction. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPyMultiGradFunction. class TPyMultiGradFunction: public ROOT::Math::IGradientFunctionMultiDim. Python wrapper for Fit functions. Function Members (Methods); public:. TPyMultiGradFunction(PyObject* self = 0); virtual~TPyMultiGradFunction(); static TClass*Class(); virtual TPyMultiGradFunction*Clone() const; doubleROOT::Math::IGradientMultiDim::Derivative(const double* x, unsigned int icoord = 0) const; virtual doubleDoDerivative(const double* x, unsigned int icoord) const; virtual doubleDoEval(const double* x) const; virtual voidFdF(const double* x, double& f, double* df) const; virtual voidGradient(const double* x, double* grad) const; virtual TClass*IsA() const; virtual unsigned intNDim() const; doubleROOT::Math::IBaseFunctionMultiDim::operator()(const double* x) const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TPyMultiGradFunction(const TPyMultiGradFunction& src); TPyMultiGradFunction&operator=(const TPyMultiGradFunction&). Data Members; private:. PyObject*fPySelf! actual python object. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyMultiGradFunction(PyObject* self = 0); Construct a TPyMultiGradFunction derived with <self> as the underlying. ~TPyMultiGradFunction(); Destructor. Only deref if still holding on to Py_None (circular otherwise). unsigned int NDim() const; Simply forward the call to python self. double DoEval(const double* x) const; Simply forward the call to python self. void Gradient(const double* x, double* grad) const; Simply forward the call to python self. void FdF(const double* x, double& f, double* df) const; Simply forward the call to python self. double DoDer",MatchSource.WIKI,root/html528/TPyMultiGradFunction.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPyMultiGradFunction.html
Availability,error,error,"r* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree = 0); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*TSelector::GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual const char*TObject::GetTitle() con",MatchSource.WIKI,root/html528/TPySelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPySelector.html
Availability,error,error,,MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Deployability,install,install,". TPythia6. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA6; » TPythia6. class TPythia6: public TGenerator. TPythia6. TPythia is an interface class to F77 version of Pythia 6.2; To use this class you must install a version of pythia6.; see the installation instructions at; http://root.cern.ch/root/Install.html. CERNLIB event generators, written by T.Sjostrand.; For the details about these generators look at Pythia/Jetset manual:. PPP Y Y TTTTT H H III A JJJJ EEEE TTTTT SSS EEEE TTTTT; P P Y Y T H H I A A J E T S E T; PPP Y T HHHHH I AAAAA J EEE T SSS EEE T; P Y T H H I A A J J E T S E T; P Y T H H III A A JJ EEEE T SSS EEEE T. *......* Welcome to the Lund Monte Carlo!; !!; *::::::!!::::::::::::::* This is PYTHIA version 5.720; *::::::::!!::::::::::::::::* Last date of change: 29 Nov 1995; !!; *:::::::::!!:::::::::::::::::* This is JETSET version 7.408; *::::::::!!::::::::::::::::*! Last date of change: 23 Aug 1995; *::::::!!::::::::::::::* !!; !! *:::!!:::::::::::* !! Main author:; !! !* -><- * !! Torbjorn Sjostrand; !! !! !! Dept. of theoretical physics 2; !! !! !! University of Lund; !! !! Solvegatan 14A; !! ep !! S-223 62 Lund, Sweden; !! !! phone: +46 - 46 - 222 48 16; !! pp !! E-mail: torbjorn@thep.lu.se; e+e-; !! !! Copyright Torbjorn Sjostrand; !! and CERN, Geneva 1993. The latest program versions and documentation is found on WWW address; http://thep.lu.se/tf2/staff/torbjorn/Welcome.html. When you cite these programs, priority should always be given to the; latest published description. Currently this is; T. Sjostrand, Computer Physics Commun. 82 (1994) 74.; The most recent long description (unpublished) is; T. Sjostrand, LU TP 95-20 and CERN-TH.7112/93 (revised August 1995).; Also remember that the programs, to a large extent, represent original; physics research. Other pu",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Energy Efficiency,energy,energy,"led by the GenerateEvent method. If the event generator does; not use the HEPEVT common block, This routine has to be overloaded by; the subclasses.; The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles.; The default action is to store only the stable particles (ISTHEP = 1); This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. void Initialize(const char* frame, const char* beam, const char* target, float win); Calls PyInit with the same parameters after performing some checking,; sets correct title. This method should preferably be called instead of PyInit.; PURPOSE: to initialize the generation procedure.; ARGUMENTS: See documentation for details.; frame: - specifies the frame of the experiment:; ""CMS"",""FIXT"",""USER"",""FOUR"",""FIVE"",""NONE""; beam,; target: - beam and target particles (with additionaly cahrges, tildes or ""bar"":; e,nu_e,mu,nu_mu,tau,nu_tau,gamma,pi,n,p,Lambda,Sigma,Xi,Omega,; pomeron,reggeon; win: - related to energy system:; for frame==""CMS"" - total energy of system; for frame==""FIXT"" - momentum of beam particle; for frame==""USER"" - dummy - see documentation. void Pyinit(char* frame, char* beam, char* target, double wint); Calls Pyinit with the same parameters after performing some checking,; sets correct title. This method should preferably be called instead of PyInit.; PURPOSE: to initialize the generation procedure.; ARGUMENTS: See documentation for details.; frame: - specifies the frame of the experiment:; ""CMS"",""FIXT"",""USER"",""FOUR"",""FIVE"",""NONE""; beam,; target: - beam and target particles (with additionaly charges,; tildes or ""bar"":; e,nu_e,mu,nu_mu,tau,nu_tau,gamma,pi,n,p,Lambda,Sigma,Xi,Omega,; pomeron,reggeon; win: - related to energy system:; for frame==""CMS"" - total energy of system; for frame==""FIXT"" - momentum of beam particle; for frame==""USER"" - dummy - see documentation. int Pycomp(int kf); interface with fortran",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Integrability,interface,interface,". TPythia6. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA6; » TPythia6. class TPythia6: public TGenerator. TPythia6. TPythia is an interface class to F77 version of Pythia 6.2; To use this class you must install a version of pythia6.; see the installation instructions at; http://root.cern.ch/root/Install.html. CERNLIB event generators, written by T.Sjostrand.; For the details about these generators look at Pythia/Jetset manual:. PPP Y Y TTTTT H H III A JJJJ EEEE TTTTT SSS EEEE TTTTT; P P Y Y T H H I A A J E T S E T; PPP Y T HHHHH I AAAAA J EEE T SSS EEE T; P Y T H H I A A J J E T S E T; P Y T H H III A A JJ EEEE T SSS EEEE T. *......* Welcome to the Lund Monte Carlo!; !!; *::::::!!::::::::::::::* This is PYTHIA version 5.720; *::::::::!!::::::::::::::::* Last date of change: 29 Nov 1995; !!; *:::::::::!!:::::::::::::::::* This is JETSET version 7.408; *::::::::!!::::::::::::::::*! Last date of change: 23 Aug 1995; *::::::!!::::::::::::::* !!; !! *:::!!:::::::::::* !! Main author:; !! !* -><- * !! Torbjorn Sjostrand; !! !! !! Dept. of theoretical physics 2; !! !! !! University of Lund; !! !! Solvegatan 14A; !! ep !! S-223 62 Lund, Sweden; !! !! phone: +46 - 46 - 222 48 16; !! pp !! E-mail: torbjorn@thep.lu.se; e+e-; !! !! Copyright Torbjorn Sjostrand; !! and CERN, Geneva 1993. The latest program versions and documentation is found on WWW address; http://thep.lu.se/tf2/staff/torbjorn/Welcome.html. When you cite these programs, priority should always be given to the; latest published description. Currently this is; T. Sjostrand, Computer Physics Commun. 82 (1994) 74.; The most recent long description (unpublished) is; T. Sjostrand, LU TP 95-20 and CERN-TH.7112/93 (revised August 1995).; Also remember that the programs, to a large extent, represent original; physics research. Other pu",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Modifiability,variab,variable,"*fPydat2; Pydat3_t*fPydat3; Pydat4_t*fPydat4; Pydatr_t*fPydatr; Pyint1_t*fPyint1; Pyint2_t*fPyint2; Pyint3_t*fPyint3; Pyint4_t*fPyint4; Pyint5_t*fPyint5; Pyint6_t*fPyint6; Pyint7_t*fPyint7; Pyint8_t*fPyint8; Pyint9_t*fPyint9; Pyints_t*fPyints; Pyjets_t*fPyjets; Pymssm_t*fPymssm; Pypars_t*fPypars; Pyssmt_t*fPyssmt; Pysubs_t*fPysubs; Bool_tTGenerator::fShowNeutrons!display neutrons if true; TStringTNamed::fTitleobject title; static TPythia6*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia6(); TPythia6 constructor: creates a TClonesArray in which it will store all; particles. Note that there may be only one functional TPythia6 object; at a time, so it's not use to create more than one instance of it. TPythia6(const TPythia6& ); { }. ~TPythia6(); Destroys the object, deletes and disposes all TMCParticles currently on list. TPythia6* Instance(); model of automatic memory cleanup suggested by Jim Kowalkovski:; destructor for local static variable `cleaner' is always called in the end; of the job thus deleting the only TPythia6 instance. void GenerateEvent(); generate event and copy the information from /HEPEVT/ to fPrimaries. void OpenFortranFile(int lun, char* name); interface with fortran i/o. void CloseFortranFile(int lun); interface with fortran i/o. TObjArray * ImportParticles(Option_t* option = """"); Fills TObjArray fParticles list with particles from common LUJETS; Old contents of a list are cleared. This function should be called after; any change in common LUJETS, however GetParticles() method calls it; automatically - user don't need to care about it. In case you make a call; to LuExec() you must call this method yourself to transfer new data from; common LUJETS to the fParticles list. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"); Default primary creation method. It reads the /HEPEVT/ common block which; has been filled by the GenerateEvent method. If the event generator does; ",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Performance,perform,performing,"ed. This function should be called after; any change in common LUJETS, however GetParticles() method calls it; automatically - user don't need to care about it. In case you make a call; to LuExec() you must call this method yourself to transfer new data from; common LUJETS to the fParticles list. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"); Default primary creation method. It reads the /HEPEVT/ common block which; has been filled by the GenerateEvent method. If the event generator does; not use the HEPEVT common block, This routine has to be overloaded by; the subclasses.; The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles.; The default action is to store only the stable particles (ISTHEP = 1); This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. void Initialize(const char* frame, const char* beam, const char* target, float win); Calls PyInit with the same parameters after performing some checking,; sets correct title. This method should preferably be called instead of PyInit.; PURPOSE: to initialize the generation procedure.; ARGUMENTS: See documentation for details.; frame: - specifies the frame of the experiment:; ""CMS"",""FIXT"",""USER"",""FOUR"",""FIVE"",""NONE""; beam,; target: - beam and target particles (with additionaly cahrges, tildes or ""bar"":; e,nu_e,mu,nu_mu,tau,nu_tau,gamma,pi,n,p,Lambda,Sigma,Xi,Omega,; pomeron,reggeon; win: - related to energy system:; for frame==""CMS"" - total energy of system; for frame==""FIXT"" - momentum of beam particle; for frame==""USER"" - dummy - see documentation. void Pyinit(char* frame, char* beam, char* target, double wint); Calls Pyinit with the same parameters after performing some checking,; sets correct title. This method should preferably be called instead of PyInit.; PURPOSE: to initialize the generation procedure.; ARGUMENTS: See documentation for details.; frame: - specifies",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Security,access,accessors,"ne pychge. void Py1ent(Int_t line, Int_t kf, Double_t pe, Double_t theta, Double_t phi); Add one entry to the event record, i.e. either a parton or a; particle. IP: normally line number for the parton/particle. There are two; exceptions:. If IP = 0: line number 1 is used and PYEXEC is called.; If IP < 0: line -IP is used, with status code K(-IP,2)=2; rather than 1; thus a parton system may be built; up by filling all but the last parton of the; system with IP < 0.; KF: parton/particle flavour code (PDG code); PE: parton/particle energy. If PE is smaller than the mass,; the parton/particle is taken to be at rest.; THETA:; PHI: polar and azimuthal angle for the momentum vector of the; parton/particle. void SetupTest(); Exemplary setup of Pythia parameters:; Switches on processes 102,123,124 (Higgs generation) and switches off; interactions, fragmentation, ISR, FSR... TPythia6& operator=(const TPythia6& ). Pyjets_t* GetPyjets(); ****** accessors; FORTRAN indexing in accessing the arrays,; indices start from 1 !!!!!; ****** access to PYTHIA6 common-blocks; ****** /PYJETS. { return fPyjets; }. int GetN(); { return fPyjets->N; }. int GetNPAD(); { return fPyjets->NPAD; }. int GetK(int ip, int i); { return fPyjets->K[i-1][ip-1]; }. double GetP(int ip, int i); { return fPyjets->P[i-1][ip-1]; }. double GetV(int ip, int i); { return fPyjets->V[i-1][ip-1]; }. void SetN(int n); { fPyjets->N = n; }. void SetNPAD(int n); { fPyjets->NPAD = n; }. void SetK(int ip, int i, int k); { fPyjets->K[i-1][ip-1] = k; }. void SetP(int ip, int i, double p); { fPyjets->P[i-1][ip-1] = p; }. void SetV(int ip, int i, double v); { fPyjets->V[i-1][ip-1] = v; }. Pydat1_t* GetPydat1(); ****** /PYDAT1. { return fPydat1; }. int GetMSTU(int i); { return fPydat1->MSTU[i-1]; }. double GetPARU(int i); { return fPydat1->PARU[i-1]; }. int GetMSTJ(int i); { return fPydat1->MSTJ[i-1]; }. double GetPARJ(int i); { return fPydat1->PARJ[i-1]; }. void SetMSTU(int i, int m); { fPydat1->MSTU[i-1] = m; }. void SetPARU(i",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Usability,clear,cleared,"fTitleobject title; static TPythia6*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia6(); TPythia6 constructor: creates a TClonesArray in which it will store all; particles. Note that there may be only one functional TPythia6 object; at a time, so it's not use to create more than one instance of it. TPythia6(const TPythia6& ); { }. ~TPythia6(); Destroys the object, deletes and disposes all TMCParticles currently on list. TPythia6* Instance(); model of automatic memory cleanup suggested by Jim Kowalkovski:; destructor for local static variable `cleaner' is always called in the end; of the job thus deleting the only TPythia6 instance. void GenerateEvent(); generate event and copy the information from /HEPEVT/ to fPrimaries. void OpenFortranFile(int lun, char* name); interface with fortran i/o. void CloseFortranFile(int lun); interface with fortran i/o. TObjArray * ImportParticles(Option_t* option = """"); Fills TObjArray fParticles list with particles from common LUJETS; Old contents of a list are cleared. This function should be called after; any change in common LUJETS, however GetParticles() method calls it; automatically - user don't need to care about it. In case you make a call; to LuExec() you must call this method yourself to transfer new data from; common LUJETS to the fParticles list. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"); Default primary creation method. It reads the /HEPEVT/ common block which; has been filled by the GenerateEvent method. If the event generator does; not use the HEPEVT common block, This routine has to be overloaded by; the subclasses.; The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles.; The default action is to store only the stable particles (ISTHEP = 1); This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. void Initiali",MatchSource.WIKI,root/html528/TPythia6.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6.html
Availability,error,error,"er&); virtual~TPythia6Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); voidForceParticleDecay(Int_t particle, Int_t product, Int_t mult); voidForceParticleDecay(Int_t particle, Int_t* products, Int_t* mult, Int_t npart); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; ",MatchSource.WIKI,root/html528/TPythia6Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html
Energy Efficiency,charge,charge,"PDG code). void ReadDecayTable(); Read in particle data from an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. void WriteDecayTable(); write particle data to an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. Users can use this function to make an initial decay list file,; which then can be edited by hand, and re-loaded into the decayer; using ReadDecayTable. The file syntax is. particle_list : partcle_data; | particle_list particle_data; ;; particle_data : particle_info; | particle_info '\n' decay_list; ;; particle_info : See below; ;; decay_list : decay_entry; | decay_list decay_entry; ;; decay_entry : See below. The particle_info consists of 13 fields:. PDG code int; Name string; Anti-particle name string if there's no anti-particle,; then this field must be the; empty string; Electic charge int in units of |e|/3; Color charge int in units of quark color charges; Have anti-particle int 1 of there's an anti-particle; to this particle, or 0; otherwise; Mass float in units of GeV; Resonance width float; Max broadning float; Lifetime float; MWID int ??? (some sort of flag); Decay int 1 if it decays. 0 otherwise. The format to write these entries in are. "" %9 %-16s %-16s%3d%3d%3d%12.5f%12.5f%12.5f%13.gf%3d%d\n"". The decay_entry consists of 8 fields:. On/Off int 1 for on, -1 for off; Matrix element type int; Branching ratio float; Product 1 int PDG code of decay product 1; Product 2 int PDG code of decay product 2; Product 3 int PDG code of decay product 3; Product 4 int PDG code of decay product 4; Product 5 int PDG code of decay product 5. The format for these lines are. "" %5d%5d%12.5f%10d%10d%10d%10d%10d\n"". Int_t CountProducts(Int_t channel, Int_t particle); Count number of decay products. void ForceHadronicD(); Force golden D decay modes. void ForceParticleDecay(Int_t particle, Int_t product, Int_t mult). Force decay of particle into products with multipli",MatchSource.WIKI,root/html528/TPythia6Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html
Integrability,interface,interface,". TPythia6Decayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA6; » TPythia6Decayer. class TPythia6Decayer: public TVirtualMCDecayer. TPythia6Decayer. This implements the TVirtualMCDecayer interface. The TPythia6; singleton object is used to decay particles. Note, that since this; class modifies common blocks (global variables) it is defined as a; singleton. Function Members (Methods); public:. TPythia6Decayer(); TPythia6Decayer(const TPythia6Decayer&); virtual~TPythia6Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root/html528/TPythia6Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html
Modifiability,variab,variables,". TPythia6Decayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA6; » TPythia6Decayer. class TPythia6Decayer: public TVirtualMCDecayer. TPythia6Decayer. This implements the TVirtualMCDecayer interface. The TPythia6; singleton object is used to decay particles. Note, that since this; class modifies common blocks (global variables) it is defined as a; singleton. Function Members (Methods); public:. TPythia6Decayer(); TPythia6Decayer(const TPythia6Decayer&); virtual~TPythia6Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const;",MatchSource.WIKI,root/html528/TPythia6Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html
Performance,load,loaded,"ia6Decayer(); Constructor. void Init(); Initialize the decayer. void Decay(Int_t idpart, TLorentzVector* p); Decay a particle of type IDPART (PDG code) and momentum P. Int_t ImportParticles(TClonesArray* particles); Get the decay products into the passed PARTICLES TClonesArray of; TParticles. void SetForceDecay(Int_t type); Force a particular decay type. void ForceDecay(); Force a particle decay mode. Float_t GetPartialBranchingRatio(Int_t ipart); Get the partial branching ratio for a particle of type IPART (a; PDG code). Float_t GetLifetime(Int_t kf); Get the life-time of a particle of type KF (a PDG code). void ReadDecayTable(); Read in particle data from an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. void WriteDecayTable(); write particle data to an ASCII file. The file name must; previously have been set using the member function; SetDecayTableFile. Users can use this function to make an initial decay list file,; which then can be edited by hand, and re-loaded into the decayer; using ReadDecayTable. The file syntax is. particle_list : partcle_data; | particle_list particle_data; ;; particle_data : particle_info; | particle_info '\n' decay_list; ;; particle_info : See below; ;; decay_list : decay_entry; | decay_list decay_entry; ;; decay_entry : See below. The particle_info consists of 13 fields:. PDG code int; Name string; Anti-particle name string if there's no anti-particle,; then this field must be the; empty string; Electic charge int in units of |e|/3; Color charge int in units of quark color charges; Have anti-particle int 1 of there's an anti-particle; to this particle, or 0; otherwise; Mass float in units of GeV; Resonance width float; Max broadning float; Lifetime float; MWID int ??? (some sort of flag); Decay int 1 if it decays. 0 otherwise. The format to write these entries in are. "" %9 %-16s %-16s%3d%3d%3d%12.5f%12.5f%12.5f%13.gf%3d%d\n"". The decay_entry consists of 8 fields:. On/Off int 1 for",MatchSource.WIKI,root/html528/TPythia6Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia6Decayer.html
Availability,avail,available,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
Deployability,release,released,"l: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S. Mrenna and P. Skands, arXiv:0710.3820 | |; | | | |; | | The main physics reference is the 'PYTHIA 6.4 Physics and Manual', | |; | | T. Sjostrand, S. Mrenna and P. Skands, JHEP05 (2006) 026 [hep-ph/0603175]. | |; | | | |; | | An archive of program versions and documentation is found on the web: | |; | | http://www.thep.lu.se/~torbjorn/Pythia.html | |; | | | |; | | This program is released under the GNU General Public Licence version 2. | |; | | Please respect the MCnet Guidelines for Event Generator Authors and Users. | |; | | | |; | | Disclaimer: this program comes without any guarantees. | |; | | Beware of errors and use common sense when interpreting results. | |; | | | |; | | Copyright (C) 2007 Torbjorn Sjostrand | |; | | | |; | | | |; | *------------------------------------------------------------------------------* |; | |; *------------------------------------------------------------------------------------*. Function Members (Methods); public:. TPythia8(); TPythia8(const char* xmlDir); TPythia8(const TPythia8&); virtual~TPythia8(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const;",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
Integrability,interface,interface,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root/html528/TPythia8.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8.html
Availability,error,error,"cayer&); virtual~TPythia8Decayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t pdg, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceDecay(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Float_tGetLifetime(Int_t kf); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Float_tGetPartialBranchingRatio(Int_t ipart); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual Int_tImpo",MatchSource.WIKI,root/html528/TPythia8Decayer.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPythia8Decayer.html
Availability,avail,available,"); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test w",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
Modifiability,variab,variables,"TPython. class TPython. Python interpreter access. The TPython class allows for access to python objects from CINT. The current; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived types, as well; as ObjectProxy_CheckExact for ObjectProxy's only); and it allows conversions; of void* to an ObjectProxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObj",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
Performance,load,load,"oxy and vice versa. Function Members (Methods); public:. TPython(); TPython(const TPython&); virtual~TPython(); static Bool_tBind(TObject* object, const char* label); static TClass*Class(); static const TPyReturnEval(const char* expr); static Bool_tExec(const char* cmd); static voidExecScript(const char* name, int argc = 0, const char** argv = 0); virtual TClass*IsA() const; static voidLoadMacro(const char* name); static void*ObjectProxy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". v",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
Security,access,access,". TPython. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » BINDINGS; » PYROOT; » TPython. class TPython. Python interpreter access. The TPython class allows for access to python objects from CINT. The current; functionality is only basic: ROOT objects and builtin types can freely cross; the boundary between the two interpreters, python objects can be instantiated; and their methods can be called. All other cross-coding is based on strings; that are run on the python interpreter. Examples:. $ cat MyPyClass.py; print 'creating class MyPyClass ... '. class MyPyClass:; def __init__( self ):; print 'in MyPyClass.__init__'. def gime( self, what ):; return what. $ root -l; // Execute a string of python code.; root [0] TPython::Exec( ""print \'Hello World!\'"" );; Hello World!. // Create a TBrowser on the python side, and transfer it back and forth.; // Note the required explicit (void*) cast!; root [1] TBrowser* b = (void*)TPython::Eval( ""ROOT.TBrowser()"" );; root [2] TPython::Bind( b, ""b"" );; root [3] b == (void*) TPython::Eval( ""b"" ); (int)1. // Builtin variables can cross-over by using implicit casts.; root [4] int i = TPython::Eval( ""1 + 1"" );; root [5] i; (int)2. // Load a python module with a class definition, and use it.; root [6] TPython::LoadMacro( ""MyPyClass.py"" );; creating class MyPyClass ...; root [7] MyPyClass m;; in MyPyClass.__init__; root [8] char* s = m.gime( ""aap"" );; root [9] s; (char* 0x41ee7754)""aap"". It is possible to switch between interpreters by calling ""TPython::Prompt()""; on the CINT side, while returning with ^D (EOF). State is preserved between; successive switches. The API part provides (direct) C++ access to the bindings functionality of; PyROOT. It allows verifying that you deal with a PyROOT python object in the; first place (ObjectProxy_Check for ObjectProxy and any derived typ",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
Testability,test,test,"xy_AsVoidPtr(PyObject* pyobject); static Bool_tObjectProxy_Check(PyObject* pyobject); static Bool_tObjectProxy_CheckExact(PyObject* pyobject); static PyObject*ObjectProxy_FromVoidPtr(void* addr, const char* classname); TPython&operator=(const TPython&); static voidPrompt(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. static Bool_tInitialize(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t Initialize(); Private initialization method: setup the python interpreter and load the; ROOT module. void LoadMacro(const char* name); Execute the give python script as if it were a macro (effectively an; execfile in __main__), and create CINT equivalents for any newly available; python classes. void ExecScript(const char* name, int argc = 0, const char** argv = 0); Execute a python stand-alone script, with argv CLI arguments. example of use:; const char* argv[] = { ""1"", ""2"", ""3"" };; TPython::ExecScript( ""test.py"", sizeof(argv)/sizeof(argv[0]), argv );. Bool_t Exec(const char* cmd); Execute a python statement (e.g. ""import ROOT""). const TPyReturn Eval(const char* expr); Evaluate a python expression (e.g. ""ROOT.TBrowser()""). Caution: do not hold on to the return value: either store it in a builtin; type (implicit casting will work), or in a pointer to a ROOT object (explicit; casting to a void* is required). Bool_t Bind(TObject* object, const char* label); Bind a ROOT object with, at the python side, the name ""label"". void Prompt(); Enter an interactive python session (exit with ^D). State is preserved; between successive calls. Bool_t ObjectProxy_Check(PyObject* pyobject); Test whether the type of the given pyobject is of ObjectProxy type or any; derived type. Bool_t ObjectProxy_CheckExact(PyObject* pyobject); Test whether the type of the given pyobject is ObjectProxy type. void* ObjectProxy_AsVoidPtr(PyObject* pyobject); Extract the object pointer ",MatchSource.WIKI,root/html528/TPython.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TPython.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
Performance,load,load," line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh). Data Members; public:. enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfCustomizedflag for customized canvas implimentation. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQApplication(); Used by Dictionary(). TQApplication(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0); Create the root application and load the graphic libraries. ~TQApplication(); Delete ROOT application environment. void LoadGraphicsLibs(); Here we overload the LoadGraphicsLibs() function.; This function now just instantiates a QRootGuiFactory; object and redirect the global pointer gGuiFactory to point; to it. void SetCustomized(); Set the custom flag. » Author: Denis Bertini, M. Al-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQApplication.html
Availability,error,error,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = ",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
Energy Efficiency,power,powerfull," class charts. ROOT; » CORE; » BASE; » TQClass. class TQClass: public TQObject, public TClass. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQClass(const char* name, Version_t cversion, const type_info& info, TVirtualIsAProxy* isa, ShowMembersFunc_t showmembers, const char* dfil = 0, const char* ifil = 0, Int_t dl = 0, Int_t il = 0); virtual~TQClass(); voidTObject::AbstractMethod(const char* method) const; static voidTClass::AddClass(TClass* cl); voidTClass::AddImplFile(const char* filename, int line); voidTClass::AddInstance(Bool_t heap = kFALSE); voidTClass::AddRef(TClassRef* ref); static Bool_tTClass::AddRule(const char* rule); voidTClass::AdoptMemberStreamer(const char* name, TMemberStreamer* strm); voidTClass::AdoptReferenceProxy(TVirtualRefProxy* proxy); voidTClass::AdoptSchemaRules(ROOT::TSchemaRuleSet* rules); voidTClass::AdoptStreamer(TClassStreamer* strm); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bo",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
Performance,load,load,"rams, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* datamember) const; Long_tTClass::GetDataMemberOffset(const char* membername) const; Short_tTClass::GetDeclFileLine() const; const char*TClass::GetDeclFileName() const; ROOT::DelFunc_tTClass::GetDelete() const; ROOT::DelArrFunc_tTClass::GetDeleteArray() const; ROOT::DesFunc_tTClass::GetDestructor() const; static VoidFuncPtr_tTClass::GetDict(const char* cnam",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
Security,checksum,checksum,"nal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*TClass::EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* base); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(UInt_t code = 0) const; static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetConte",MatchSource.WIKI,root/html528/TQClass.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQClass.html
Availability,down,downwards,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Deployability,update,update,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, ",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Modifiability,inherit,inheritied,"st of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo actions. More complicated commands might want to override this function. Bool_t IsSetter() const; Returns kTRUE is command if Redo is the same as Undo function; and is the setter action. By default, all functions with names like ""SetXXX"" or ""setXXX""; considered as setters. Another type of setters are Move, Resize operations. More complicated commands might want to override this function. void SetArgs(Int_t narg, ...); Set do/redo and undo parameters. The format is; SetArgs(number_of_params, redo_params, undo_params). Example:; move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position. void SetRedoArgs(Int_t narg, ...); Set redo parameters. The format is; SetRedoArgs",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Performance,perform,performing,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* o",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Testability,log,logical,"TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)),; one needs to call TQCommand::SetUndoArgs(1, character) from; inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);. void Delete(Option_t* option = """"); If ""opt"" is not zero delete every merged command which option string is; equal to ""opt"". If ""opt"" is zero - delete all merged commands. Bool_t CanMerge(TQCommand* c) const; Two commands can be merged if they can be composed into; a single command (Macro command). To allow merging commands user might override this function. void Merge(TQCommand* c); Add command to the list of merged commands.; This make it possible to group complex actions together so an end user; can undo and redo them with one command. Execution of TQUndoManager::Undo(),; TQUndoManager::Redo() methods only invokes the top level command as a whole. Merge method is analogous to logical join operation. Note: Merge method invokes redo action. void Add(TObject* obj, Option_t* opt); Add command to the list of merged commands. Option string can contain substrings:; ""compress"" - try to compress input command; ""radd"" - execute redo action of input command; ""uadd"" - execute undo action of input command. Bool_t CanCompress(TQCommand* c) const; By default, commands can be compressed if they are:. - equal; - setter commands. More complicated commands might want to override this function. void Compress(TQCommand* c); Compress command. Compression is analogous to arithmetic ""addition operation"". Note:; - The compressed command will be deleted.; - Execution Compress method invokes Redo action with new redo arguments; inheritied from compressed command. More complicated commands might want to override this function. Bool_t IsEqual(const TObject* obj) const; Equal comparison. The commands are equal if they are; applied to the same object and have the same Redo/Undo action",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Usability,undo,undo,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root/html528/TQCommand.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQCommand.html
Availability,error,error,"Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteMethod(); voidExecuteMethod(Long_t param); voidExecuteMethod(Long64_t param); voidExecuteMethod(Double_t param); voidExecuteMethod(const char* params); voidExecuteMethod(Int_t nargs, va_list va); voidExecuteMethod(Long_t* params, Int_t nparam = -1); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); const char*GetClassName() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
Integrability,interface,interface,"* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
Modifiability,variab,variable,"ame, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class and with method == funcname. TQConnection(const TQConnection& con); Copy constructor. Ignore connections to this TQConnections. ~TQConnection(); TQConnection dtor.; - remove this connection from all signal lists; - we do not delete fSlot if it has other connections,; TQSlot::fCounter > 0 . const char * GetName() const; Returns name of connection (aka name of slot). void Destroyed(); Signal Destroyed tells that connection is destroyed. void ls(Option_t* option = """") const; List TQConnection full method name and list all signals; connected to this connection. void PrintCollectionHeader(Option_t* option) const; Print TQConnection full method name and print all; signals connected to this connection. void ExecuteMethod(); Apply slot-method to the fReceiver object without arguments. void ExecuteMethod(Int_t nargs, va_list va); Apply slot-method to the fReceiver object with; variable argument list. void ExecuteMethod(Long_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long64_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Double_t param); Apply slot-method to the fReceiver object with; single argument value. void ExecuteMethod(Long_t* params, Int_t nparam = -1); Apply slot-method to the fReceiver object with variable; number of argument values. void ExecuteMethod(const char* params); Apply slot-method to the fReceiver object and; with string parameter. void * GetReceiver() const; { return fReceiver; }. const char * GetClassName() const; { return fClassName; }. » Author: Valeriy Onuchin & Fons Rademakers 15/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQConnection.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatica",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
Performance,cache,cache,"* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TStringfClassNameclass name of the receiver; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TStringTCollection::fNamename of the collection; void*fReceiverptr to object to which slot is applied; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; TQSlot*fSlotslot-method calling interface; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQConnection(); Default constructor. TQConnection(TClass* cl, void* receiver, const char* method_name); TQConnection ctor.; cl != 0 - connection to object == receiver of class == cl; and method == method_name; cl == 0 - connection to function with name == method_name. TQConnection(const char* class_name, void* receiver, const char* method_name); TQConnection ctor.; Creates connection to method of class specified by name,; it could be interpreted class",MatchSource.WIKI,root/html528/TQConnection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQConnection.html
Availability,error,error,"tMethod(const char* method) const; voidAddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAction(const char* filename, char* action) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const QIconSet*GetIcon(const char* filename) const; const QIconSet*GetIcon(const TSystemFile* filename); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; Bool_tGetType(const char* filename, char* type) const; virtual UInt_tTObject::GetUniqueID() const; virtu",MatchSource.WIKI,root/html528/TQMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQMimeTypes.html
Performance,cache,cache,"irtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TQMime*Find(const char* filename) const; static const QPixmap&IconProvider(const QFileInfo&); voidTObject::MakeZombie(). private:. TQMimeTypes(const TQMimeTypes&); voidoperator=(const TQMimeTypes&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfChangedtrue if file has changed; TStringfFilenamefile name of mime type file; TStringfIconPaththe path to the icon directory; TOrdCollection*fListlist of mime types; static QFileIconProvider*fgDefaultProviderDefault provider of the system icons;. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IconProvider(const QFileInfo& ). TQMimeTypes(const char* iconPath, const char* file); Create a mime type cache. Read the mime types file ""filename"" and; built a list of mime types. ~TQMimeTypes(); Delete mime type pool. TQMime * Find(const char* filename) const; Given a filename find the matching mime type object. const QIcon * GetIcon(const char* filename) const; Return icon belonging to mime type of filename. const QIcon * GetIcon(const TSystemFile* filename); Return icon belonging to mime type of TSystemFile extension. const QIcon * AddType(const TSystemFile* filename). Bool_t GetAction(const char* filename, char* action) const; Return in action the mime action string belonging to filename. Bool_t GetType(const char* filename, char* type) const; Return in type the mime type belonging to filename. void Print(Option_t* option = """") const; Print list of mime types. void SaveMimes(); Save mime types in user's mime type file. void AddType(const char* type, const char* pat, const char* icon, const char* sicon, const char* action); Add a mime type to the list ",MatchSource.WIKI,root/html528/TQMimeTypes.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQMimeTypes.html
Availability,error,error,"c Bool_tConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual void*GetSender(); virtual const char*GetSenderClassName() const. private:. TQObject(const TQObject& tqo); TQObject&operator=(const TQObject& tqo). Data Members; protected:. TList*fListOfConnections! list of connections to this object; TList*fListOfSignals! list of signals from this object; Bool_tfSignalsBlocked! flag used for suppression of signals; static Bool_tfgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name i",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
Energy Efficiency,power,powerfull,"unction members; data members; class charts. ROOT; » CORE; » BASE; » TQObject. class TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQObject(); virtual~TQObject(); static Bool_tAreAllSignalsBlocked(); Bool_tAreSignalsBlocked() const; static Bool_tBlockAllSignals(Bool_t b); Bool_tBlockSignals(Bool_t b); virtual voidChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidCollectClassSignalLists(TList& list, TClass* cls); Bool_tConnect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tConnect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidConnected(const char*); virtual voidDestroyed()SIGNAL ; Bool_tDisconnect(const char* signal = 0, void* receiver = 0, const char* slot = 0); static Bool_tDisconnect(TQObject* sender, ",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
Modifiability,variab,variable," time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals, this increase the time; for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed last when signal_name is emitted.; Signal name is not compressed. Bool_t HasConnection(const char* signal_name) const; Return true if there is any object connected to this signal.; Only checks for object signals. Int_t NumberOfSignals() const; Return number of signals for this object.; Only checks for object signals. Int_t NumberOfConnections() const; Return number of connections for this object. void Emit(const char* signal); Acitvate signal without args.; Example:; theButton->Emit(""Clicked()"");. void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; Example:; theButton->EmitVA(""Clicked(int,float)"", 2, id, fid). void EmitVA(const char* signal, Int_t nargs, va_list va); Activate signal with variable argument list.; For internal use and for var arg EmitVA() in RQ_OBJECT.h. void Emit(const char* signal, Long_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Clicked(int)"",id). void Emit(const char* signal, Long64_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Progress(Long64_t)"",processed). void Emit(const char* signal, Double_t param); Activate signal with single parameter.; Example:; theButton->Emit(""Scale(float)"",factor). void Emit(const char* signal, const char* params); Activate signal with parameter text string.; Example:; myObject->Emit(""Error(char*)"",""Fatal error"");. void Emit(const char* signal, Long_t* paramArr); Emit a signal with a varying number of arguments,; paramArr is an array of the parameters.; Note: any para",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
Performance,perform,performed,"ool_tfgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Checking of consitency of sender/receiver methods/arguments.; Returns -1 on error, otherwise number or arguments of signal function.; Static method. TQObject(); TQObject Constructor.; Comment:; - In order to minimize memory allocation fListOfSignals and; fListOfConnections are allocated only if it is neccesary; - When fListOfSignals/fListOfConnections are empty they will; be deleted. ~TQObject(); TQObject Destructor.; - delete all connections and signal list. TList * GetListOfClassSignals() const; Returns pointer to list of signals of this class. void CollectClassSignalLists(TList& list, TClass* cls); Collect class signal lists from class cls and all its; base-classes. The recursive traversal is not performed for classes not; deriving from TQClass. void HighPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the first in the fListOfSignals, this decreases; the time for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed first when signal_name is emitted.; Signal name is not compressed. void LowPriority(const char* signal_name, const char* slot_name = 0); 1. If slot_name = 0 => makes signal defined by the signal_name; to be the last in the fListOfSignals, this increase the time; for lookup.; 2. If slot_name != 0 => makes slot defined by the slot_name; to be executed last when signal_name is emitted.; Signal name is not compressed. Bool_t HasConnection(const char* signal_name) const; Return true if there is any object connected to this signal.; Only checks for object signals. Int_t NumberOfSignals() const; Return number of signals for this object.; Only checks for object signals. ",MatchSource.WIKI,root/html528/TQObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObject.html
Energy Efficiency,power,powerfull,"embers; class charts. ROOT; » CORE; » BASE; » TQObjSender. class TQObjSender: public TQObject. This is the ROOT implementation of the Qt object communication; mechanism (see also http://www.troll.no/qt/metaobjects.html). Signals and slots are used for communication between objects.; When an object has changed in some way that might be interesting; for the outside world, it emits a signal to tell whoever is; listening. All slots that are connected to this signal will be; activated (called). It is even possible to connect a signal; directly to another signal (this will emit the second signal; immediately whenever the first is emitted.) There is no limitation; on the number of slots that can be connected to a signal.; The slots will be activated in the order they were connected; to the signal. This mechanism allows objects to be easily reused,; because the object that emits a signal does not need to know; to which objects the signals are connected.; Together, signals and slots make up a powerfull component; programming mechanism. This implementation is provided by; Valeriy Onuchin (onuchin@sirius.ihep.su). Function Members (Methods); public:. TQObjSender(); virtual~TQObjSender(); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQOb",MatchSource.WIKI,root/html528/TQObjSender.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQObjSender.html
Availability,avail,available,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
Modifiability,variab,variables,"sgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidRandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDfBavector of equality constraint; TVectorDfCloBound; TVectorDfCloIndex; TVectorDfCupBoundInequality constraints; TVectorDfCupIndex; TVectorDfGlinear part of Objective function; Int_tfMy; Int_tfMz; Int_tfNx; TVectorDfXloBound; TVectorDfXloIndex; TVectorDfXupBoundBounds on variables; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound); Randomly choose x and its boundaries. TQpDataBase & operator=(const TQpDataBase& source); Assignment operator. virtual ~TQpDataBase(); {}. void PutQIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void PutAIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void PutCIntoAt(TMatrixDBase& M, Int_t row, Int_t col). void Qmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x). void Amult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x). void Cmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x).",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
Performance,perform,performing,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root/html528/TQpDataBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataBase.html
Availability,error,error," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html528/TQpDataDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataDens.html
Modifiability,variab,variables," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidTQpDataBase::RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDTQpDataBase::fBavector of equality constraint; TVectorDTQpDataBase::fCloBound; TVectorDTQpDataBase::fCloIndex; TVectorDTQpDataBase::fCupBoundInequality constraints; TVectorDTQpDataBase::fCupIndex; TVectorDTQpDataBase::fGlinear part of Objective function; Int_tTQpDataBase::fMy; Int_tTQpDataBase::fMz; Int_tTQpDataBase::fNx; TVectorDTQpDataBase::fXloBound; TVectorDTQpDataBase::fXloIndex; TVectorDTQpDataBase::fXupBoundBounds on variables; TVectorDTQpDataBase::fXupIndex. protected:. TMatrixDfAEquality constraints; TMatrixDfCInequality constraints; TMatrixDSymfQQuadratic part of Objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpDataDens(Int_t nx, Int_t my, Int_t mz); Constructor. TQpDataDens(TVectorD& c, TMatrixDSym& Q, TVectorD& xlow, TVectorD& ixlow, TVectorD& xupp, TVectorD& ixupp, TMatrixD& A, TVectorD& bA, TMatrixD& C, TVectorD& clow, TVectorD& iclow, TVectorD& cupp, TVectorD& icupp); Constructor. TQpDataDens(const TQpDataDens& another); Copy constructor. void Qmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); calculate y = beta*y + alpha*(fQ*x). void Amult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); calculate y",MatchSource.WIKI,root/html528/TQpDataDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataDens.html
Availability,error,error," char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TVectorD&TQpDataBase::GetBa(); virtual voidGetDiagonalOfQ(TVectorD& dQ); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TVectorD&TQpDataBase::GetG(); virtual const char*TObject::GetIconName() const; virtual TVectorD&TQpDataBase::GetiSlowerBound(); virtual TVectorD&TQpDataBase::GetiSupperBound(); virtual TVectorD&TQpDataBase::GetiXlowerBound(); virtual TVectorD&TQpDataBase::GetiXupperBound(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root/html528/TQpDataSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataSparse.html
Modifiability,variab,variables," 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); static voidTQpDataBase::RandomlyChooseBoundedVariables(TVectorD& x, TVectorD& dualx, TVectorD& blx, TVectorD& ixlow, TVectorD& bux, TVectorD& ixupp, Double_t& ix, Double_t percentLowerOnly, Double_t percentUpperOnly, Double_t percentBound). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDTQpDataBase::fBavector of equality constraint; TVectorDTQpDataBase::fCloBound; TVectorDTQpDataBase::fCloIndex; TVectorDTQpDataBase::fCupBoundInequality constraints; TVectorDTQpDataBase::fCupIndex; TVectorDTQpDataBase::fGlinear part of Objective function; Int_tTQpDataBase::fMy; Int_tTQpDataBase::fMz; Int_tTQpDataBase::fNx; TVectorDTQpDataBase::fXloBound; TVectorDTQpDataBase::fXloIndex; TVectorDTQpDataBase::fXupBoundBounds on variables; TVectorDTQpDataBase::fXupIndex. protected:. TMatrixDSparsefAEquality constraints; TMatrixDSparsefCInequality constraints; TMatrixDSparsefQquadratic part of Objective function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpDataSparse(Int_t nx, Int_t my, Int_t mz); Constructor. TQpDataSparse(TVectorD& c, TMatrixDSparse& Q, TVectorD& xlow, TVectorD& ixlow, TVectorD& xupp, TVectorD& ixupp, TMatrixDSparse& A, TVectorD& bA, TMatrixDSparse& C, TVectorD& clow, TVectorD& iclow, TVectorD& cupp, TVectorD& icupp); Constructor. TQpDataSparse(const TQpDataSparse& another); Copy constructor. void SetNonZeros(Int_t nnzQ, Int_t nnzA, Int_t nnzC); Allocate space for the appropriate number of non-zeros in the matrices. void Qmult(Double_t beta, TVectorD",MatchSource.WIKI,root/html528/TQpDataSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpDataSparse.html
Availability,avail,available,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char*",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
Integrability,rout,routine,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD&",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
Modifiability,variab,variables,"ie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middl",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
Performance,perform,performed,"tusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TVectorDfCloIndex; TVectorDfCupIndex; TVectorDfDdtemporary storage vectors; TVectorDfDq; TQpProbBase*fFactory; Int_tfMclo; Int_tfMcup; Int_tfMy; Int_tfMz; TVectorDfNomegaInvstores a critical diagonal matrix as a vector; Int_tfNxdimensions of the vectors in the general QP formulation; Int_tfNxlo; Int_tfNxupdimensions of the upper and lower bound vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD&",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
Safety,recover,recovers,"und vectors; TVectorDfRhsright-hand side of the system; TVectorDfXloIndex; TVectorDfXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. The; actual factorization is performed by a routine specific to either the sparse; or dense case. void ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); Computes the diagonal matrices in the augmented system from the current set of variables. void Solve(TQpDataBase* prob, TQpVar* vars, TQpResidual* resids, TQpVar* step); Solves the system for a given set of residuals. Assembles the right-hand side appropriate; to the matrix factored in factor, solves the system using the factorization produced there,; partitions the solution vector into step components, then recovers the step components; eliminated during the block elimination that produced the augmented system form . void SolveXYZS(TVectorD& stepx, TVectorD& stepy, TVectorD& stepz, TVectorD& steps, TVectorD& ztemp, TQpDataBase* data); Assemble right-hand side of augmented system and call SolveCompressed to solve it. void JoinRHS(TVectorD& rhs, TVectorD& rhs1, TVectorD& rhs2, TVectorD& rhs3); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& vars1, TVectorD& vars2, TVectorD& vars3, TVectorD& vars); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. TQpLinSolverBase & operator=(const TQpLinSolverBase& source); Assignment",MatchSource.WIKI,root/html528/TQpLinSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html
Availability,error,error,"virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html528/TQpLinSolverDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverDens.html
Availability,error,error,"virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTQpLinSolverBase::ComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root/html528/TQpLinSolverSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpLinSolverSparse.html
Availability,avail,available,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root/html528/TQpProbBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbBase.html
Availability,error,error,"robDens& another); TQpProbDens(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbDens(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TQpProbDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbDens.html
Modifiability,variab,variables,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tTQpProbBase::fMynumber of rows in A and b; Int_tTQpProbBase::fMznumber of rows in C; Int_tTQpProbBase::fNxnumber of elements in x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpProbDens(Int_t nx, Int_t my, Int_t mz); Constructor. TQpProbDens(const TQpProbDens& another); Copy constructor. TQpDataBase * MakeData(Double_t* c, Double_t* Q, Double_t* xlo, Bool_t* ixlo, Double_t* xup, Bool_t* ixup, Double_t* A, Double_t* bA, Double_t* C, Double_t* clo, Bool_t* iclo, Double_t* cup, Bool_t* icup); Setup the data. TQpDataBase * MakeData(TVectorD& c, TMatrixDBase& Q_in, TVectorD& xlo, TVectorD& ixlo, TVectorD& xup, TVectorD& ixup, TMatrixDBase& A_in, TVectorD& bA, TMatrixDBase& C_in, TVectorD& clo, TVectorD& iclo, TVectorD& cup, TVectorD& icup); Setup the data. TQpResidual* MakeResiduals(const TQpDataBase* data); Setup the residuals. TQpVar* MakeVariables(const TQpDataBase* data); Setup the variables. TQpLinSolverBase* MakeLinSys(const TQpDataBase* data); Setup the linear solver. void JoinRHS(TVectorD& rhs_in, TVectorD& rhs1_in, TVectorD& rhs2_in, TVectorD& rhs3_in); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& x_in, TVectorD& y_in, TVectorD& z_in, TVectorD& vars_in); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. void MakeRandomData(TQpDataDens*& data, TQpVar*& soln, Int_t nnzQ, Int_t nnzA, Int_t nnzC); Create a random QP problem. TQpProbDens & operator=(const TQpProbDens& source); Assignment operator. TQpProbDens(); {}. virtual ~TQpProbDens(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, R",MatchSource.WIKI,root/html528/TQpProbDens.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbDens.html
Availability,error,error,"rse& another); TQpProbSparse(Int_t nx, Int_t my, Int_t mz); virtual~TQpProbSparse(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TQpProbSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbSparse.html
Modifiability,variab,variables,"leanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. Int_tTQpProbBase::fMynumber of rows in A and b; Int_tTQpProbBase::fMznumber of rows in C; Int_tTQpProbBase::fNxnumber of elements in x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpProbSparse(Int_t nx, Int_t my, Int_t mz); Constructor. TQpProbSparse(const TQpProbSparse& another); Copy constructor. TQpDataBase * MakeData(Double_t *c, Int_t nnzQ,Int_t *irowQ,Int_t *icolQ,Double_t *Q, Double_t *xlo,Bool_t *ixlo, Double_t *xup,Bool_t *ixup, Int_t nnzA,Int_t *irowA,Int_t *icolA,Double_t *A, Double_t *bA, Int_t nnzC,Int_t *irowC,Int_t *icolC,Double_t *C, Double_t *clo,Bool_t *iclo, Double_t *cup,Bool_t *icup); Setup the data. TQpResidual* MakeResiduals(const TQpDataBase* data); Setup the residuals. TQpVar* MakeVariables(const TQpDataBase* data); Setup the variables. TQpLinSolverBase* MakeLinSys(const TQpDataBase* data); Setup the linear solver. void JoinRHS(TVectorD& rhs_in, TVectorD& rhs1_in, TVectorD& rhs2_in, TVectorD& rhs3_in); Assembles a single vector object from three given vectors .; rhs_out (output) final joined vector; rhs1_in (input) first part of rhs; rhs2_in (input) middle part of rhs; rhs3_in (input) last part of rhs . void SeparateVars(TVectorD& x_in, TVectorD& y_in, TVectorD& z_in, TVectorD& vars_in); Extracts three component vectors from a given aggregated vector.; vars_in (input) aggregated vector; x_in (output) first part of vars; y_in (output) middle part of vars; z_in (output) last part of vars. void MakeRandomData(TQpDataSparse*& data, TQpVar*& soln, Int_t nnzQ, Int_t nnzA, Int_t nnzC); Create a random QP problem. TQpProbSparse & operator=(const TQpProbSparse& source); Assignment operator. TQpProbSparse(); {}. virtual ~TQpProbSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 19",MatchSource.WIKI,root/html528/TQpProbSparse.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpProbSparse.html
Availability,error,error,"t; voidAdd_r3_xz_alpha(TQpVar* vars, Double_t alpha); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCalcResids(TQpDataBase* problem, TQpVar* vars); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClear_r1r2(); voidClear_r3(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetDualityGap(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetResidualNorm(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bo",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
Modifiability,variab,variable,"unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TVectorDfRA; TVectorDfRC; TVectorDfRQ; TVectorDfRgamma; TVectorDfRlambda; TVectorDfRphi; TVectorDfRpi; TVectorDfRt; TVectorDfRu; TVectorDfRv; TVectorDfRw; TVectorDfRz. protected:. TVectorDfCloIndex; TVectorDfCupIndex; Double_tfDualityGapA quantity that measures progress toward feasibility. In terms; Double_tfMclo; Double_tfMcup; Int_tfMy; Int_tfMz; Int_tfNx; Double_tfNxlo; Double_tfNxup; Double_tfResidualNormThe norm of the residuals, ommiting the complementariy conditions; TVectorDfXloIndex; TVectorDfXupIndex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpResidual(); Constructor. TQpResidual(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); Constructor. TQpResidual(const TQpResidual& another); Copy constructor. void CalcResids(TQpDataBase* problem, TQpVar* vars); Calculate residuals, their norms, and duality complementarity gap,; given a problem and variable set. void Add_r3_xz_alpha(TQpVar* vars, Double_t alpha); Modify the ""complementarity"" component of the residuals, by adding the pairwise; products of the complementary variables plus a constant alpha to this term. void Set_r3_xz_alpha(TQpVar* vars, Double_t alpha); Set the ""complementarity"" component of the residuals to the pairwise products of; the complementary variables plus a constant alpha . void Clear_r3(); set the complementarity component of the residuals to 0. void Clear_r1r2(); set the noncomplementarity components of the residual (the terms arising from; the linear equalities in the KKT conditions) to 0. void Project_r3(Double_t rmin, Double_t rmax); Perform the projection operation required by Gondzio algorithm: replace each; component r3_i of the complementarity component of the residuals by r3p_i-r3_i,; where r3p_i is the projection of r3_i onto the box [rmin, rmax]. Then if the; resulting value is l",MatchSource.WIKI,root/html528/TQpResidual.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpResidual.html
Availability,avail,available,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
Energy Efficiency,monitor,monitoring,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
Integrability,rout,routine,"b, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t a",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
Modifiability,variab,variables,"alues of residual norm obtained on all iterations to date; TQpLinSolverBase*fSys. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TQpSolverBase(); Deconstructor. void Start(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Implements a default starting-point heuristic. While interior-point theory; places fairly loose restrictions on the choice of starting point, the choice; of heuristic can significantly affect the robustness and efficiency of the; algorithm. void DefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Default starting point. void SteveStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Starting point algoritm according to Stephen Wright. void DumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); Alternative starting point heuristic: sets the ""complementary"" variables to a large; positive value (based on the norm of the problem data) and the remaining variables; to zero . Double_t FinalStepLength(TQpVar* iterate, TQpVar* step); Implements a version of Mehrotra starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & oper",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
Performance,perform,perform,"starting point heuristic,; modified to ensure identical steps in the primal and dual variables. void DoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); Monitor progress / convergence aat each interior-point iteration. Int_t DoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Tests for termination. Unless the user supplies a specific termination; routine, this method calls another method defaultStatus, which returns; a code indicating the current convergence status. Int_t DefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); Default status method. TQpSolverBase & operator=(const TQpSolverBase& source); Assignment operator. Int_t Solve(TQpDataBase* prob, TQpVar* iterate, TQpResidual* resids); alternative starting point heuristic: sets the; ""complementary"" variables to a large positive value; (based on the norm of the problem data) and the; remaining variables to zero. void DefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); perform monitor operation at each interior-point iteration. TQpLinSolverBase * GetLinearSystem(); default method for checking status. May be replaced; by a user-defined method. { return fSys; }. void SetMuTol(Double_t m); { fMutol = m; }. Double_t GetMuTol(); { return fMutol; }. void SetArTol(Double_t ar); { fArtol = ar; }. Double_t GetArTol(); { return fArtol; }. Double_t DataNorm(); { return fDnorm; }. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpSolverBase.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQpSolverBase.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html
Availability,error,error,"w_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); virtual~TQpVar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFindBlocking(TQpVar* step, Double_t& primalValue, Double_t& primalStep, Double_t& dualValue, Double_t& dualStep, Int_t& firstOrSecond); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Double_tGetMu(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* time",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
Modifiability,variab,variables,". TQpVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpVar. class TQpVar: public TObject. Class containing the variables for the general QP formulation. Function Members (Methods); public:. TQpVar(); TQpVar(const TQpVar& another); TQpVar(Int_t nx, Int_t my, Int_t mz, TVectorD& ixlow, TVectorD& ixupp, TVectorD& iclow, TVectorD& icupp); TQpVar(TVectorD& x_in, TVectorD& s_in, TVectorD& y_in, TVectorD& z_in, TVectorD& v_in, TVectorD& gamma_in, TVectorD& w_in, TVectorD& phi_in, TVectorD& t_in, TVectorD& lambda_in, TVectorD& u_in, TVectorD& pi_in, TVectorD& ixlow_in, TVectorD& ixupp_in, TVectorD& iclow_in, TVectorD& icupp_in); virtual~TQpVar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double",MatchSource.WIKI,root/html528/TQpVar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQpVar.html
Availability,error,error,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQRootApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootApplication.html
Deployability,release,release,"eMoveEvent(QMouseEvent* e); virtual voidmousePressEvent(QMouseEvent* e); virtual voidmouseReleaseEvent(QMouseEvent* e); virtual voidpaintEvent(QPaintEvent* e); virtual voidresizeEvent(QResizeEvent* e). private:. TQRootCanvas(const TQRootCanvas&); TQRootCanvas&operator=(const TQRootCanvas&). Data Members; protected:. TCanvas*fCanvasRoot Canvas; TQCanvasMenu*fContextMenuQt Context menu for this canvas; Bool_tfIsCanvasOwnedOwnership flag; Bool_tfNeedResizeResize flag; QWidget*fParent; QWidget*fTabWinparent widgets; Int_tfWidWindows Id of the Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
Integrability,wrap,wrapper,"bWinparent widgets; Int_tfWidWindows Id of the Canvas. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootCanvas(QWidget* parent = 0, const char* name = 0, TCanvas* c = 0); set defaults. TQRootCanvas(QWidget* parent, QWidget* tabWin, const char* name = 0, TCanvas* c = 0); set defaults. void mouseMoveEvent(QMouseEvent* e); Handle mouse move event. void mousePressEvent(QMouseEvent* e); Handle mouse button press event. void mouseReleaseEvent(QMouseEvent* e); Handle mouse button release event. void mouseDoubleClickEvent(QMouseEvent* e); Handle mouse double click event. void resizeEvent(QResizeEvent* e); Call QWidget resize and inform the ROOT Canvas. void paintEvent(QPaintEvent* e); Handle paint event of Qt. void leaveEvent(QEvent* e); Handle leave event. void dragEnterEvent(QDragEnterEvent* e); Entering a drag event. void dropEvent(QDropEvent* Event); Start a drop, for now only histogram objects can be drwon by droping. void cd(Int_t subpadnumber = 0); Just a wrapper. void Browse(TBrowser* b); Just a wrapper. void Clear(Option_t* option = """"); Just a wrapper. void Close(Option_t* option = """"); Just a wrapper. void Draw(Option_t* option = """"); Just a wrapper. TObject * DrawClone(Option_t* option = """"); Just a wrapper. TObject * DrawClonePad(); Just a wrapper. void EditorBar(); Just a wrapper. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); just a wrapper. void FeedbackMode(Bool_t set); just a wrapper. void Flush(); just a wrapper. void UseCurrentStyle(); just a wrapper. void ForceUpdate(); just a wrapper. const char * GetDISPLAY(); just a wrapper. TContextMenu * GetContextMenu(); just a wrapper. Int_t GetDoubleBuffer(); just a wrapper. Int_t GetEvent(); just a wrapper. Int_t GetEventX(); just a wrapper. Int_t GetEventY(); just a wrapper. Color_t GetHighLightColor(); just a wrapper. TVirtualPad * GetPadSave(); just a wrapper. TObject * GetSelected(); just a wrapper. Option_t * GetSelectedOpt(); just a wrapper. TVirtual",MatchSource.WIKI,root/html528/TQRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootCanvas.html
Availability,error,error,"teCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*TRootGuiFactory::CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*TRootGuiFactory::CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TQRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQRootGuiFactory.html
Modifiability,variab,variable,"Instantiate the Qt system within ROOT environment. Instantiate the Qt package by createing Qapplication object if any. Function Members (Methods); public:. TQtApplication(); TQtApplication(const char* appClassName, int& argc, char** argv); virtual~TQtApplication(); static TClass*Class(); static TQtApplication*GetQtApplication(); virtual TClass*IsA() const; static boolIsThisGuiThread(); static Int_tQtVersion(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static boolTerminate(). private:. TQtApplication(const TQtApplication&); voidCreateGUIThread(int& argc, char** argv); static voidCreateQApplication(int& argc, char** argv, bool GUIenabled); voidoperator=(const TQtApplication&). Data Members; protected:. static TQtApplication*fgQtApplication. private:. TQtApplicationThread*fGUIThread. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQtApplication(const char* appClassName, int& argc, char** argv). ~TQtApplication(). { }. void CreateQApplication(int& argc, char** argv, bool GUIenabled); Initialize the Qt package; Check the QT_BATCH environment variable to disactivate Qt GUI mode. void CreateGUIThread(int& argc, char** argv); Create GUI thread to Qt event loop. TQtApplication * GetQtApplication(). {return fgQtApplication;}. bool Terminate(); Terminate GUI thread. Int_t QtVersion(); The Qt version the package was compiled with. bool IsThisGuiThread(); Check whether the current thread belongs the GUI. void operator=(const TQtApplication& ). TQtApplication(const TQtApplication& ). TQtApplication(); {}. » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TQtApplication.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQtApplication.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtApplication.html
Deployability,install,installEventFilter,". TQtClientFilter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TQtClientFilter. class TQtClientFilter: public QObject. QtClientFilter provides QOject event filter to map Qt and ROOT events; (see: http://doc.trolltech.com/4.3/qobject.html#installEventFilter ). Function Members (Methods); public:. TQtClientFilter(); virtual~TQtClientFilter(); voidAppendButtonGrab(TQtClientWidget*); static TClass*Class(); static TQtClientWidget*GetButtonGrabber(); static TQtClientWidget*GetPointerGrabber(); static voidGrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); virtual TClass*IsA() const; static TQtPointerGrabber*PointerGrabber(); voidRemoveButtonGrab(QObject*); static voidSetButtonGrabber(TQtClientWidget* grabber); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidAddKeyEvent(const int& event, TQtClientWidget* widget); booleventFilter(QObject* o, QEvent* e); static Bool_tIsGrabSelected(UInt_t selectEventMask); TQtEventQueue*Queue(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Clas",MatchSource.WIKI,root/html528/TQtClientFilter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html
Performance,queue,queue,"(); voidRestoreLostGrabbing(Event_t& event); static Bool_tSelectGrab(Event_t& event, UInt_t selectEventMask, int& me); voidSetKeyGrabber(TQtClientWidget* grabber); voidUnSetKeyGrabber(TQtClientWidget* grabber). private:. TQtClientFilter(const TQtClientFilter&); voidoperator=(const TQtClientFilter&). Data Members; protected:. UInt_tfInputEventMask; TQtClientWidget*fKeyGrabber; TQtNextEventMessage*fNotifyClient; TQtEventQueue*fRootEventQueue; static TQtClientWidget*fgActiveGrabber; static TQtClientWidget*fgButtonGrabber; static QCursor*fgGrabPointerCursor; static UInt_tfgGrabPointerEventMask; static Bool_tfgGrabPointerOwner; static TQtPointerGrabber*fgGrabber; static TQtClientWidget*fgPointerGrabber. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t IsGrabSelected(UInt_t selectEventMask); return the selection by ""grabButton"" / ""grabPointer"". ~TQtClientFilter(). void AddKeyEvent(const int& event, TQtClientWidget* widget); Map and and to the ROOT event queue Qt KeyBoard event mapped to the ROOT Event_t; For ""dest"" widget. bool SelectGrab(Event_t& event, UInt_t selectEventMask, int& me); Select Event: -- 04.12.2005 --. bool eventFilter(QObject* o, QEvent* e); Dispatch The Qt event from event queue to Event_t structure; Not all of the event fields are valid for each event type,; except fType and fWindow. void GrabPointer(TQtClientWidget* grabber, UInt_t evmask, Window_t confine, QCursor* cursor, Bool_t grab = kTRUE, Bool_t owner_events = kTRUE); Set the X11 style active grabbing for ROOT TG widgets. TQtPointerGrabber * PointerGrabber(); { return fgGrabber; }. TQtClientWidget * GetPointerGrabber(); { return fgPointerGrabber; }. TQtClientWidget * GetButtonGrabber(); { return fgButtonGrabber; }. void SetButtonGrabber(TQtClientWidget* grabber); { fgButtonGrabber = grabber; }. void AppendButtonGrab(TQtClientWidget* ); { fButtonGrabList.append(widget); }. void RemoveButtonGrab(QObject* ). TQtEventQueue * Queue(). void operator=(co",MatchSource.WIKI,root/html528/TQtClientFilter.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientFilter.html
Availability,mask,mask,", UInt_t modifier = kAnyModifier, int insert = kInsert); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUnSetButtonMask(bool dtor = false); voidUnSetKeyMask(Int_t keycode = 0, UInt_t modifier = kAnyModifier). protected:. TQtClientWidget(TQtClientGuard* guard, int* parent = 0, const char* name = 0, int f = 0); virtual voidpaintEvent(QPaintEvent*); voidSetCanvasWidget(TQtWidget* widget). private:. TQtClientWidget(const TQtClientWidget&); voidoperator=(const TQtClientWidget&). Data Members; public:. enum { kRemove; kTestKey; kInsert; };. protected:. EMouseButtonfButton; TQtWidget*fCanvasWidget; boolfDeleteNotify; QColor*fEraseColorColor to paint widget background with our PainEvent; QPixmap*fErasePixmappixmap to paint widget background with our PainEvent; QCursor*fGrabButtonCursor; UInt_tfGrabButtonMaskmodifier button mask for TVirtualX::GrabButton; UInt_tfGrabEventButtonMaskinput event mask for TVirtualX::GrabButton; UInt_tfGrabEventPointerMaskinput event mask for TVirtualX::GrabPointer; QCursor*fGrabPointerCursor; TQtClientGuard*fGuard; boolfIsClosing; TGWindow*fMyRootWindowback pointer to the host window object; QCursor*fNormalPointerCursor; Bool_tfPointerOwner; UInt_tfSaveSelectInputMaskTo save dutinr the grabbing the selectInput; UInt_tfSelectEventMaskinput mask for SelectInput. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; bool DeleteNotify(). {return fDeleteNotify; }. TQtWidget * GetCanvasWidget() const. { return fCanvasWidget;}. bool IsClosing(). { return fIsClosing; }. UInt_t IsEventSelected(UInt_t evmask) const. void SetCursor(). void SetCursor(Cursor_t crsr). void SetClosing(bool flag = kTRUE). { fIsClosing = flag;}. void SetDeleteNotify(bool flag = true). {fDeleteNotify = flag;}. void SetAttributeEventMask(UInt_t evmask). { SelectInput (evmask);}. void SetButtonEventMask(UInt_t evmask, Cursor_t crsr = 0). { fGrabEventButtonMask = evmask; fGr",MatchSource.WIKI,root/html528/TQtClientWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtClientWidget.html
Availability,error,error,"ar* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* ",MatchSource.WIKI,root/html528/TQtRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtRootGuiFactory.html
Deployability,release,released,"s properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is moved. void mouseMoveEvent(QMouseEvent* ); Map the Qt mouse move pointer event to the ROOT TCanvas events; kMouseMotion = 51,; kButton1Motion = 21, kButton2Motion = 22, kButton3Motion = 23, kKeyPress = 24. void mouseReleaseEvent(QMouseEvent* ); Map the Qt mouse button release event to the ROOT TCanvas events; kButton1Up = 11, kButton2Up = 12, kButton3Up = 13. void mouseDoubleClickEvent(QMouseEvent* ); Map the Qt mouse double click button event to the ROOT TCanvas events; kButton1Double = 61, kButton2Double = 62, kButton3Double = 63. void keyPressEvent(QKeyEvent* ); Map the Qt key press event to the ROOT TCanvas events; kKeyDown = 4. void keyReleaseEvent(QKeyEvent* ); Map the Qt key release event to the ROOT TCanvas events; kKeyUp = 14. void enterEvent(QEvent* ); Map the Qt mouse enters widget event to the ROOT TCanvas events; kMouseEnter = 52. void leaveEvent(QEvent* ); Map the Qt mouse",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Integrability,interface,interface,". TQtWidget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » QT; » TQtWidget. class TQtWidget: public QWidget. TQtWidget is a QWidget with the QPixmap double buffer; It is designed to back the ROOT TCanvasImp class interface and it can be used; as a regular Qt Widget to create Qt-based GUI with the embedded TCanvas objects. This widget can be used as a Qt ""custom widget""; to build a custom GUI interfaces with Qt Designer. The class emits the Qt signals and has Qt public slots. Public slots: (Qt). virtual void cd(); // make the associated TCanvas the current one (shortcut to TCanvas::cd()); virtual void cd(int subpadnumber); // as above - shortcut to Canvas::cd(int subpadnumber); void Disconnect(); // disconnect the QWidget from the ROOT TCanvas (used in the class dtor); void Refresh(); // force the associated TCanvas::Update to be called; virtual bool Save(const QString &fileName) const; // Save the widget image with some ppixmap file; virtual bool Save(const char *fileName) const;; virtual bool Save(const QString &fileName,const char *format,int quality=60) const;; virtual bool Save(const char *fileName,const char *format,int quality=60) const;. signals (Qt). CanvasPainted(); // Signal the TCanvas has been painted onto the screen; Saved(bool ok); // Signal the TCanvas has been saved into the file; RootEventProcessed(TObject *selected, unsigned int event, TCanvas *c);; // Signal the Qt mouse/keyboard event has been process by ROOT; // This ""signal"" is emitted by the enabled mouse events only.; // See: EnableSignalEvents; // --- DisableSignalEvents. public methods:; The methods below define whether the TQtWidget object emits ""RootEventProcessed"" Qt signals; (By default no RootEventProcessed Qt signal is emitted ); void EnableSignalEvents (UInt_t f); void DisableSignalEvents(UInt_t f),; where f ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Performance,perform,performance," * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent* ); Map the Qt mouse press button event to the ROOT TCanvas events; Mouse events occur when a mouse button is pressed or released inside; a widget or when the mouse cursor is move",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Safety,avoid,avoid,"* Canvas(const TCanvas* canvas); static: return the TQtWidget backend for TCanvas *canvas object. TQtWidget * Canvas(Int_t id); static: return TQtWidget by TCanvas id. TApplication * InitRint(Bool_t prompt = kFALSE, const char* appClassName = ""QtRint"", int* argc = 0, char** argv = 0, void* options = 0, int numOptions = 0, Bool_t noLogo = kTRUE). Instantiate ROOT from within Qt application if needed; Return the TRint pointer; Most parametrs are passed to TRint class ctor. Bool_t prompt = kTRUE; Instantiate ROOT with ROOT command prompt; kFALSE; No ROOT prompt. The default for Qt GUI applications. The prompt option can be defined via ROOT parameter file "".rootrc""; .rootrc:; . . .; Gui.Prompt yes. void Erase(); Erases the entire widget and its double buffer. void cd(); [slot] to make this embedded canvas the current one. void cd(int subpadnumber); [slot] to make this embedded canvas / pad the current one. void Disconnect(); [slot] Disconnect the Qt widget from TCanvas object before deleting; to avoid the dead lock; one has to set CanvasID = 0 to disconnect things properly. void Refresh(); [slot] to allow Qt signal refreshing the ROOT TCanvas if needed; use the permanent single shot timer to eliminate; the redundand refreshing for the sake of the performance. void SetCanvas(TCanvas* c); remember my host TCanvas and adopt its name. customEvent(QEvent* ); The custom response to the special WIN32 events; These events are not present with X11 systems. void contextMenuEvent(QContextMenuEvent* ); The custom response to the Qt QContextMenuEvent; Map QContextMenuEvent to the ROOT kButton3Down = 3 event. void focusInEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""in""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void focusOutEvent(QFocusEvent* ); The custom response to the Qt QFocusEvent ""out""; this imposes an extra protection to avoid TObject interaction with; mouse event accidently. void mousePressEvent(QMouseEvent",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Security,access,access," as a result of repaint() or update(), or because the widget; was obscured and has now been uncovered, or for many other reasons. void SetSizeHint(const QSize& size); sets the preferred size of the widget. QSize sizeHint() const; returns the preferred size of the widget. QSize minimumSizeHint() const; returns the smallest size the widget can have. QSizePolicy sizePolicy() const; returns a QSizePolicy; a value describing the space requirements. void EmitTestedSignal(). void SetBit(UInt_t f, Bool_t set); Set or unset the user status bits as specified in f. TQtWidgetBuffer & SetBuffer(); Create (if needed) and return the buffer. QPixmap * GetOffScreenBuffer() const; return the current widget buffer;. TCanvas * GetCanvas() const. { return fCanvas; }. const TQtWidgetBuffer * GetBuffer() const. bool PaintingActive() const. void SetRootID(QWidget* wrapper). { fWrapper = wrapper;}. QWidget * GetRootID() const. { return fWrapper;}. Int_t GetEvent() const. Proxy methods to access the TCanvas selected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t f); { fBits ^= f & kBitMask; }. TQtCanvasPainter * CanvasDecorator(); { return fCanvasDecorator; }. void SetCanvasDecorator(TQ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Testability,test,test,"ected TObject; and last processed event. { return GetCanvas()->GetEvent(); }. Int_t GetEventX() const. { return GetCanvas()->GetEventX(); }. Int_t GetEventY() const. { return GetCanvas()->GetEventY(); }. TObject * GetSelected() const. { return GetCanvas()->GetSelected(); }. Int_t GetSelectedX() const. { return GetCanvas()->GetSelectedX(); }. Int_t GetSelectedY() const. { return GetCanvas()->GetSelectedY(); }. TVirtualPad * GetSelectedPad() const. { return GetCanvas()->GetSelectedPad(); }. UInt_t GetAllBits() const; ----- bit manipulation. { return fBits; }. void SetAllBits(UInt_t f); { fBits = f; }. void SetBit(UInt_t f); { fBits |= f & kBitMask; }. void ResetBit(UInt_t f); { fBits &= ~(f & kBitMask); }. Bool_t TestBit(UInt_t f) const; { return (Bool_t) ((fBits & f) != 0); }. Int_t TestBits(UInt_t f) const; { return (Int_t) (fBits & f); }. void InvertBit(UInt_t f); { fBits ^= f & kBitMask; }. TQtCanvasPainter * CanvasDecorator(); { return fCanvasDecorator; }. void SetCanvasDecorator(TQtCanvasPainter* decorator); { fCanvasDecorator = decorator;}. void EnableSignalEvents(UInt_t f); { SetBit (f); }. void DisableSignalEvents(UInt_t f); { ResetBit(f); }. Bool_t IsSignalEventEnabled(UInt_t f) const; { return TestBit (f); }. void EmitSignal(UInt_t f); {if (IsSignalEventEnabled(f)) EmitTestedSignal();}. void SetIgnoreLeaveEnter(int ignore = 1); { fIgnoreLeaveEnter = ignore; }. void operator=(const TQtWidget& ); ----- Private bits, clients can only test but not change them. void ResetCanvas(); { fCanvas = 0;}. bool IsDoubleBuffered() const; { return fDoubleBufferOn; }. void EmitCanvasPainted(); { emit CanvasPainted(); }. » Author: Valeri Fine 21/01/2002 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/qt:$Id: TQtWidget.h 33707 2010-06-02 06:27:34Z brun $ » Last generated: 2010-10-05 11:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TQtWidget.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQtWidget.html
Availability,error,error,"eryDescription(); TQueryDescription(const TQueryDescription&); ~TQueryDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TQueryDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryDescription.html
Availability,error,error," TQueryResult(); TQueryResult(const TQueryResult&); virtual~TQueryResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tGetBytes() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetEndTime() const; Long64_tGetEntries() const; Long64_tGetFirst() const; virtual const char*TObject::Get",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Deployability,update,update," Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances. The header is searched for in the same directory; of the implementation file. void RecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); End of query settings. void SetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.); Set processing info. void AddLogLine(const char* logline); Fill log file. void AddInput(TObject* obj); Add obj to the input list. void SetArchived(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQ",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Integrability,message,messages,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Performance,load,loaded,"CannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tfFinalizedwhether Terminate has been run; Long64_tfFirstfirst entry processed; Float_tfInitTimeInitialization time (seconds) (millisec precision); TList*fInputListinput list; contains also data sets, entry list, ...; TStringfLibListblank-separated list of libs loaded at fStart; TMacro*fLogFilefile with log messages from the query; TStringTNamed::fNameobject identifier; Int_tfNumWrksNumber of workers at start; TStringfOptionsprocessing options + aclic mode (<opt>#<aclic_mode>); TList*fOutputListoutput list; TStringfParListcolon-separated list of PAR loaded at fStart; Float_tfProcTimeProcessing time (seconds) (millisec precision); TStringfResultFileURL of the file where results have been archived; TMacro*fSelecHdrselector header file; TMacro*fSelecImpselector implementation file; Int_tfSeqNumquery unique sequential number; TDatimefStarttime when processing started; TQueryResult::EQueryStatusfStatusquery status; TStringTNamed::fTitleobject title; Float_tfUsedCPUreal CPU time used (seconds). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); Main constructor. ~TQueryResult(); Destructor. TQueryResult * CloneInfo(); Return an instance of TQueryResult containing only the local; info fields, i.e. no outputlist, liblist, dset, selectors, etc..; Used for fast retrieve of information about existing queries; and their status. void SaveSelector(const char* selec); Save the selector header and implementation into the dedicated; TMacro instances.",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Security,access,access,"d(const char* archfile); Set (or update) query in archived state. void Print(Option_t* opt = """") const; Print query content. Use opt = ""F"" for a full listing. void Browse(TBrowser* b = 0); To support browsing of the results. void SetInputList(TList* in, Bool_t adopt = kTRUE); Set / change the input list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fInputList will always be owner of its objects. void SetOutputList(TList* out, Bool_t adopt = kTRUE); Set / change the output list.; The flag 'adopt' determines whether the list is adopted (default); or cloned. If adopted, object ownership is transferred to this object.; The internal fOutputList will always be owner of its objects. Bool_t Matches(const char* ref); Return TRUE if reference ref matches. TObject * GetInputObject(const char* classname) const; Return first instance of class 'classname' in the input list.; Usefull to access TDSet, TEventList, ... TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec). void SetFinalized(); { fFinalized = kTRUE; }. TQueryResult(); { }. Int_t GetSeqNum() const; { return fSeqNum; }. EQueryStatus GetStatus() const; { return fStatus; }. TDatime GetStartTime() const; { return fStart; }. TDatime GetEndTime() const; { return fEnd; }. const char * GetOptions() const; { return fOptions; }. TList * GetInputList(); { return fInputList; }. Long64_t GetEntries() const; { return fEntries; }. Long64_t GetFirst() const; { return fFirst; }. Long64_t GetBytes() const; { return fBytes; }. Float_t GetUsedCPU() const; { return fUsedCPU; }. TMacro * GetLogFile() const; { return fLogFile; }. TMacro * GetSelecHdr() const; { return fSelecHdr; }. TMacro * GetSelecImp() const; { return fSelecImp; }. const char * GetLibList() const; { return fLibList; }. const char * GetParList() const; { return fParList; }. TList * GetOutputList(); { return fOu",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Testability,log,logline,"idTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TQueryResult(Int_t seqnum, const char* opt, TList* inlist, Long64_t entries, Long64_t first, const char* selec); voidAddInput(TObject* obj); voidAddLogLine(const char* logline); TQueryResult*CloneInfo(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); virtual voidRecordEnd(TQueryResult::EQueryStatus status, TList* outlist = 0); voidSaveSelector(const char* selec); voidSetArchived(const char* archfile); virtual voidSetFinalized(); virtual voidSetInputList(TList* in, Bool_t adopt = kTRUE); virtual voidSetOutputList(TList* out, Bool_t adopt = kTRUE); virtual voidSetProcessInfo(Long64_t ent, Float_t cpu = 0., Long64_t siz = -1, Float_t inittime = 0., Float_t proctime = 0.). Data Members; public:. enum EQueryStatus { kAborted; kSubmitted; kRunning; kStopped; kCompleted; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tfArchivedwhether the query has been archived; Long64_tfBytesnumber of bytes processed; Bool_tfDrawtrue if draw action query; TDatimefEndtime when processing ended; Long64_tfEntriesnumber of entries processed; Bool_tf",MatchSource.WIKI,root/html528/TQueryResult.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResult.html
Availability,error,error,"d) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetCpuTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Float_tGetRealTime(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; void",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
Integrability,depend,dependent,"ning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. voidAddLogFile(TProofQueryResult* pq). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TStopwatchfComputemeasures time spend processing a query on the master; Int_tfDrawQueriesnumber of draw queries processed; Int_tfKeptQueriesnumber of queries fully in memory and in dir; TProofLockPath*fLockdir locker; FILE*fLogFilelog file; TList*fPreviousQuerieslist of TProofQueryResult objects from previous sections; TList*fQuerieslist of TProofQueryResult objects; TStringfQueryDirdirectory containing query results and status; Int_tfSeqNumsequential number of last processed query; TStringfSessionDirdirectory containing session dependent files; TStringfSessionTagtag for the session. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void AddLogFile(TProofQueryResult* pq). TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0). const char * QueryDir() const; { return fQueryDir.Data(); }. Int_t SeqNum() const; { return fSeqNum; }. Int_t DrawQueries() const; { return fDrawQueries; }. Int_t KeptQueries() const; { return fKeptQueries; }. TList * Queries() const; { return fQueries; }. TList * PreviousQueries() const; { return fPreviousQueries; }. void IncrementSeqNum(); { fSeqNum++; }. void IncrementDrawQueries(); { fDrawQueries++; }. Int_t ApplyMaxQueries(Int_t mxq). Int_t CleanupQ",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
Testability,log,logfile," TQueryResultManager(const TQueryResultManager&); TQueryResultManager(const char* qdir, const char* stag, const char* sdir, TProofLockPath* lck, FILE* logfile = 0); virtual~TQueryResultManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tApplyMaxQueries(Int_t mxq); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; Int_tCleanupQueriesDir(); Int_tCleanupSession(const char* sessiontag); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Int_tDrawQueries() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFinalizeQuery(TProofQueryResult* pq, TProof* proof, TVirtualProofPlayer* player); virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root/html528/TQueryResultManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQueryResultManager.html
Availability,down,downwards,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
Deployability,update,update,"t; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::Ab",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
Performance,perform,performing,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(T",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
Testability,log,logging,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
Usability,undo,undo,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root/html528/TQUndoManager.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TQUndoManager.html
Availability,error,error,,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
Energy Efficiency,charge,charge,TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
Modifiability,variab,variable,iption; function members; data members; class charts. ROOT; » TEST; » Track. class Track: public TObject. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //N,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
Performance,perform,performance,"he first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of this track; Double32_t fVertex[3]; //Track vertex position; Int_t fNpoint; //Number of points for this track; Short_t fValid; //Validity criterion; Int_t fNsp; //Number of points for this track with a special value; Double32_t *fPointValue; //[fNsp] a special quantity for some point.; TBits fTriggerBits; //Bits triggered by this track. An example of a batch program to use the Event/Track classes is given; in this directory: MainEvent.; Look also in the same directory at the following macros:; - eventa.C an example how to read the tree; - eventb.C how to read events conditionally. During the processing of the event (optionally) also a large number; of histograms can be filled. The creation and handling of the; histograms is taken care of by the HistogramManager class. Note: This version of the class Event (see EventMT.h and EventMT.cxx; for an alternative) uses static variables to improve performance (by; reducing the number of memory allocations). Consequently, only one; instance of the class Event should be in use at a time (a 2nd instance; would share the array of Tracks with the first instance). Function Members (Methods); public:. Track(); Track(const Track& orig); Track(Float_t random); virtual~Track(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject:",MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
Usability,simpl,simple,. Track. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TEST; » Track. class Track: public TObject. Event and Track classes. The Event class is a naive/simple example of an event structure.; public:; char fType[20];; char *fEventName; //run+event number in character format; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Double32_t fTemperature;; Int_t fMeasures[10];; Double32_t fMatrix[4][4];; Double32_t *fClosestDistance; //[fNvertex] indexed array!; EventHeader fEvtHdr;; TClonesArray *fTracks;; TRefArray *fHighPt; //array of High Pt tracks only; TRefArray *fMuons; //array of Muon tracks only; TRef fLastTrack; //pointer to last track; TRef fHistoWeb; //EXEC:GetHistoWeb reference to an histogram in a TWebFile; TH1F *fH;; TBits fTriggerBits; //Bits triggered by this event. The EventHeader class has 3 data members (integers):; public:; Int_t fEvtNum;; Int_t fRun;; Int_t fDate;. The Event data member fTracks is a pointer to a TClonesArray.; It is an array of a variable number of tracks per event.; Each element of the array is an object of class Track with the members:; private:; Float_t fPx; //X component of the momentum; Float_t fPy; //Y component of the momentum; Float_t fPz; //Z component of the momentum; Float_t fRandom; //A random track quantity; Float_t fMass2; //The mass square of this particle; Float_t fBx; //X intercept at the vertex; Float_t fBy; //Y intercept at the vertex; Float_t fMeanCharge; //Mean charge deposition of all hits of this track; Float_t fXfirst; //X coordinate of the first point; Float_t fXlast; //X coordinate of the last point; Float_t fYfirst; //Y coordinate of the first point; Float_t fYlast; //Y coordinate of the last point; Float_t fZfirst; //Z coordinate of the first point; Float_t fZlast; //Z coordinate of the last point; Double32_t fCharge; //Charge of th,MatchSource.WIKI,root/html528/Track.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/Track.html
Availability,error,error,"t* option = """"); virtual Int_tBinomial(Int_t ntot, Double_t prob); virtual Double_tBreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidCircle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tExp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tGetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); v",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Deployability,continuous,continuous,"242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Energy Efficiency,power,powerful,"lowing table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau.......",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Integrability,rout,routine,"ermann and G. Derflinger (1990):; The ACR Method for generating normal random variables,; OR Spektrum 12 (1990), 181-185. Implementation taken from; UNURAN (c) 2000 W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien. UInt_t Integer(UInt_t imax); returns a random integer on [ 0, imax-1 ]. Double_t Landau(Double_t mean = 0, Double_t sigma = 1); Generate a random number following a Landau distribution; with mpv(most probable value) and sigma; Use function landau_quantile(x,sigma) which provides; the inverse of the landau cumulative distribution; landau_quantile has been converted from CERNLIB ranlan(G110). Int_t Poisson(Double_t mean); Generates a random integer N according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). Use a different procedure according to the mean value.; The algorithm is the same used by CLHEP; For lower value (mean < 25) use the rejection method based on; the exponential; For higher values use a rejection method comparing with a Lorentzian; distribution, as suggested by several authors; This routine since is returning 32 bits integer will not work for values larger than 2*10**9; One should then use the Trandom::PoissonD for such large values. Double_t PoissonD(Double_t mean); Generates a random number according to a Poisson law.; Prob(N) = exp(-mean)*mean^N/Factorial(N). This function is a variant of TRandom::Poisson returning a double; instead of an integer. void Rannor(Float_t& a, Float_t& b); Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. void Rannor(Double_t& a, Double_t& b); Return 2 numbers distributed following a gaussian with mean=0 and sigma=1. void ReadRandom(const char* filename). Reads saved random generator status from filename. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Based on the BSD Unix (Rand) Linear congrential generator; Produces uniformly-distributed floating points between 0 and 1.; Identical sequence on all machines of >= 32 bits.; Periodicity = ",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Modifiability,flexible,flexible,"242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Testability,test,testrandom,"distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDistrCont(f1));; double r = u.Sample();. The techniques of using directly a TF1,2 or 3 function is powerful and; can be used to generate numbers in the defined range of the function.; Getting a number from a TF1,2,3 function is also quite fast.; UNURAN is a powerful and flexible tool which containes various methods for; generate random numbers for continuous distributions of one and multi-dimension.; It requires some set-up (initialization) phase and can be very fast when the distribution; parameters are not changed for every call. The following table shows some timings (in nanosecond/call); for basic functions, TF1 functions and using UNURAN obtained running; the tutorial math/testrandom.C; Numbers have been obtained on an Intel Xeon Quad-core Harpertown (E5410) 2.33 GHz running; Linux SLC4 64 bit and compiled with gcc 3.4. Distribution nanoseconds/call; TRandom TRandom1 TRandom2 TRandom3; Rndm.............. 5.000 105.000 7.000 10.000; RndmArray......... 4.000 104.000 6.000 9.000; Gaus.............. 36.000 180.000 40.000 48.000; Rannor............ 118.000 220.000 120.000 124.000; Landau............ 22.000 123.000 26.000 31.000; Exponential....... 93.000 198.000 98.000 104.000; Binomial(5,0.5)... 30.000 548.000 46.000 65.000; Binomial(15,0.5).. 75.000 1615.000 125.000 178.000; Poisson(3)........ 96.000 494.000 109.000 125.000; Poisson(10)....... 138.000 1236.000 165.000 203.000; Poisson(70)....... 818.000 1195.000 835.000 844.000; Poisson(100)...... 837.000 1218.000 849.000 864.000; GausTF1........... 83.000 180.000 87.000 88.000; LandauTF1......... 80.000 180.000 83.000 86.000; GausUNURAN..",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Usability,simpl,simple,". TRandom. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom. class TRandom: public TNamed. TRandom. basic Random number generator class (periodicity = 10**9).; Note that this is a very simple generator (linear congruential); which is known to have defects (the lower random bits are correlated); and therefore should NOT be used in any statistical study.; One should use instead TRandom1, TRandom2 or TRandom3.; TRandom3, is based on the ""Mersenne Twister generator"", and is the recommended one,; since it has good random proprieties (period of about 10**6000 ) and it is fast.; TRandom1, based on the RANLUX algorithm, has mathematically proven random proprieties; and a period of about 10**171. It is however slower than the others.; TRandom2, is based on the Tausworthe generator of L'Ecuyer, and it has the advantage; of being fast and using only 3 words (of 32 bits) for the state. The period is 10**26. The following table shows some timings (in nanoseconds/call); for the random numbers obtained using an Intel Pentium 3.0 GHz running Linux; and using the gcc 3.2.3 compiler. TRandom 34 ns/call (BAD Generator); TRandom1 242 ns/call; TRandom2 37 ns/call; TRandom3 45 ns/call. The following basic Random distributions are provided:. -Exp(tau); -Integer(imax); -Gaus(mean,sigma); -Rndm(); -Uniform(x1); -Landau(mpv,sigma); -Poisson(mean); -Binomial(ntot,prob). Random numbers distributed according to 1-d, 2-d or 3-d distributions. contained in TF1, TF2 or TF3 objects.; For example, to get a random number distributed following abs(sin(x)/x)*sqrt(x); you can do :; TF1 *f1 = new TF1(""f1"",""abs(sin(x)/x)*sqrt(x)"",0,10);; double r = f1->GetRandom();; or you can use the UNURAN package. You need in this case to initialize UNURAN; to the function you would like to generate.; TUnuran u;; u.Init(TUnuranDi",MatchSource.WIKI,root/html528/TRandom.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom.html
Availability,error,error,"t_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLuxury() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; static voidGetTableSeeds(UInt_t* seeds, Int_t index); const UInt_t*GetTheSeeds() c",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
Integrability,rout,routine,"tual voidTRandom::WriteRandom(const char* filename). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random n",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
Testability,test,tests,"n, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Float_tfCarry; Int_tfCount24; Float_tfFloatSeedTable[24]; Int_tfIlag; const Int_tfIntModulus; Int_tfJlag; Int_tfLuxury; const Double_tfMantissaBit12; const Double_tfMantissaBit24; TStringTNamed::fNameobject identifier; Int_tfNskip; UInt_tTRandom::fSeedRandom number generator seed; const UInt_t*fTheSeeds; TStringTNamed::fTitleobject title; static Int_tfgMaxIndex; static Int_tfgNumEngines. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom1(UInt_t seed, Int_t lux = 3); Luxury level is set in the same way as the original FORTRAN routine.; level 0 (p=24): equivalent to the original RCARRY of Marsaglia; and Zaman, very long period, but fails many tests.; level 1 (p=48): considerable improvement in quality over level 0,; now passes the gap test, but still fails spectral test.; level 2 (p=97): passes all known tests, but theoretically still; defective.; level 3 (p=223): DEFAULT VALUE. Any theoretically possible; correlations have very small chance of being observed.; level 4 (p=389): highest possible luxury, all 24 bits chaotic. TRandom1(); default constructor. TRandom1(Int_t rowIndex, Int_t colIndex, Int_t lux); constructor. ~TRandom1(); destructor. void GetTableSeeds(UInt_t* seeds, Int_t index); static function returning the table of seeds. Double_t Rndm(Int_t i = 0); return a random number in ]0,1]. void RndmArray(Int_t size, Float_t* vect); return an array of random numbers in ]0,1]. void RndmArray(Int_t size, Double_t* vect); return an array of random numbers in ]0,1]. void SetSeeds(const UInt_t* seeds, Int_t lux = 3); set seeds. void SetSeed2(UInt_t seed, Int_t lux = 3); T",MatchSource.WIKI,root/html528/TRandom1.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom1.html
Availability,avail,available,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. TRandom2(UInt_t seed = 1); TRandom2(const TRandom2&); virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root/html528/TRandom2.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom2.html
Availability,error,error,"t_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Double_tTRandom::Exp(Double_t tau); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tTRandom::Gaus(Double_t mean = 0, Double_t sigma = 1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual UInt_tTRandom::GetSeed() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Ha",MatchSource.WIKI,root/html528/TRandom3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom3.html
Deployability,upgrade,upgraded,"kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; UInt_tTRandom::fSeedRandom number generator seed; TStringTNamed::fTitleobject title. private:. Int_tfCount624; UInt_tfMt[624]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRandom3(UInt_t seed = 4357); default constructor*-*-*-*-; If seed is 0, the seed is automatically computed via a TUUID object.; In this case the seed is guaranteed to be unique in space and time. ~TRandom3(); default destructor*-*-*-*-; *-* ==================. Double_t Rndm(Int_t i = 0); Machine independent random number generator.; Produces uniformly-distributed floating points in ]0,1]; Method: Mersenne Twistor. void RndmArray(Int_t n, Float_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void RndmArray(Int_t n, Double_t* array); Return an array of n random numbers uniformly distributed in ]0,1]. void SetSeed(UInt_t seed = 0); Set the random generator sequence; if seed is 0 (default value) a TUUID is generated and used to fill; the first 8 integers of the seed array.; In this case the seed is guaranteed to be unique in space and time.; Use upgraded seeding procedure to fix a known problem when seeding with values; with many zero in the bit pattern (like 2**28).; see http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html. void Streamer(TBuffer& b); Stream an object of class TRandom3. TRandom3(UInt_t seed = 4357). » Author: Peter Malzacher 31/08/99 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/mathcore:$Id: TRandom3.h 22866 2008-03-27 15:32:50Z rdm $ » Last generated: 2010-12-10 21:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRandom3.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRandom3.html
Availability,error,error,"DataMember* datamember); virtual~TRealData(); voidTObject::AbstractMethod(const char* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDataMember*GetDataMember() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TMemberStreamer*GetStreamer() const; Long_tGetThisOffset() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* metho",MatchSource.WIKI,root/html528/TRealData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRealData.html
Modifiability,inherit,inherits,". TRealData. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TRealData. class TRealData: public TObject. The TRealData class manages the effective list of all data members; for a given class. For example for an object of class TLine that inherits; from TObject and TAttLine, the TRealData object for a line contains the; complete list of all data members of the 3 classes. The list of TRealData members in TClass is built when functions like; object.Inspect or object.DrawClass are called. Function Members (Methods); public:. TRealData(); TRealData(const char* name, Long_t offset, TDataMember* datamember); virtual~TRealData(); voidTObject::AbstractMethod(const char* method) const; voidAdoptStreamer(TMemberStreamer* p); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root/html528/TRealData.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRealData.html
Availability,error,error," TRecCmdEvent(); TRecCmdEvent(const TRecCmdEvent&); ~TRecCmdEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject",MatchSource.WIKI,root/html528/TRecCmdEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecCmdEvent.html
Availability,avail,available,"er->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
Integrability,interface,interface,". TRecEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecEvent. class TRecEvent: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
Testability,log,logfile,"class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecEvent. class TRecEvent: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. ~TRecEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opt",MatchSource.WIKI,root/html528/TRecEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecEvent.html
Availability,error,error,,MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
Integrability,interface,interface,". TRecExtraEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecExtraEvent. class TRecExtraEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is n",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
Testability,log,logfile,"ption; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecExtraEvent. class TRecExtraEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecExtraEvent(); TRecExtraEvent(const TRecExtraEvent&); ~TRecExtraEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root/html528/TRecExtraEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecExtraEvent.html
Availability,error,error,"const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TTimeTRecEvent::GetTime() const; virtual const char*TObject::GetTitle() const; virtual TRecEvent::ERecEventTypeGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
Integrability,interface,interface,". TRecGuiEvent. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecGuiEvent. class TRecGuiEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; ",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
Security,expose,exposes,"ror(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EConfigureNotifyType { kCNMove; kCNResize; kCNMoveResize; kCNFilter; };; enum ERootAtoms { kWM_DELETE_WINDOW; kROOT_MESSAGE; };; enum TRecEvent::ERecEventType { kCmdEvent; kGuiEvent; kExtraEvent; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. UInt_tfCodeKey or button code; Int_tfCountIf non-zero, at least this many more exposes; Int_tfFormatNext fields only used by kClientMessageEvent; Handle_tfHandleGeneral resource handle (used for atoms or windows); UInt_tfHeightHeight of exposed area; Window_tfMaskedIf non-zero, event recorded in HandleMaskEvent(); Bool_tfSendEventTrue if event came from SendEvent; UInt_tfStateKey or button mask; Time_tfTimeTime event occured in ms; EGEventTypefTypeType of event (see EGEventType); Long_tfUser[5]5 longs can be used by client message events; UInt_tfWidthWidth of exposed area; Window_tfWindowWindow ID which reported event is relative to; Int_tfXPointer x coordinate in event window; Int_tfXRootx coordinate relative to root; Int_tfYPointer y coordinate in event window; Int_tfYRooty coordinate relative to root. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ReplayEvent(Bool_t showMouseCursor = kTRUE); Replays stored GUI event. Event_t * CreateEvent(TRecGuiEvent* ge); Converts TRecGuiEvent type to Event_t type. ERecEventType GetType() const; Returns what kind of event it stores. » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comme",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
Testability,log,logfile,"scription; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecGuiEvent. class TRecGuiEvent: public TRecEvent. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecGuiEvent(); TRecGuiEvent(const TRecGuiEvent&); ~TRecGuiEvent(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Event_t*CreateEvent(TRecGuiEvent* ge); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual vo",MatchSource.WIKI,root/html528/TRecGuiEvent.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecGuiEvent.html
Availability,error,error,"t TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TRecorder::ERecorderStateGetState() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Boo",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
Integrability,interface,interface,". TRecorder. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorder. class TRecorder: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that cas",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
Testability,log,logfile,"class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorder. class TRecorder: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecorder(); TRecorder(const TRecorder&); TRecorder(const char* filename, Option_t* option = ""READ""); virtual~TRecorder(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser*); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual void",MatchSource.WIKI,root/html528/TRecorder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorder.html
Usability,pause,paused,". TRecorderPaused. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderPaused. class TRecorderPaused: public TRecorderState. Represents state of TRecorder when paused. Function Members (Methods); public:. TRecorderPaused(const TRecorderPaused&); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidTRecorderState::ListCmd(const char*); virtual voidTRecorderState::ListGui(const char*); TRecorderPaused&operator=(const TRecorderPaused&); virtual voidTRecorderState::Pause(TRecorder*); virtual voidTRecorderState::PrevCanvases(const char*, Option_t*); virtual Bool_tTRecorderState::Replay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder* r); virtual voidResume(TRecorder* r); virtual voidShowMembers(TMemberInspector& insp); virtual voidTRecorderState::Start(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidTRecorderState::Stop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TRecorderPaused(TRecorderReplaying* state); voidTRecorderState::ChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). private:. (unknown)(). Data Members; private:. TRecorderReplaying*fReplayingStateReplaying that is paused. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderPaused(TRecorderReplaying* state); Rememeber the recorder state that is paused. void Resume(TRecorder* r); Continues replaying. void ReplayStop(TRecorder* r); Replaying is cancelled. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderPaused(TRecorderReplaying* state). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last ch",MatchSource.WIKI,root/html528/TRecorderPaused.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderPaused.html
Energy Efficiency,allocate,allocated,"ed extra events (PaveLabels and Texts); TFile*fFileROOT file to store recorded events in; Bool_tfFilterEventPaveSpecial flag to filter events during the pave recording; Window_t*fFilteredIdsOnly when GUI for recorer is used: IDs of windows that creates that GUI.; Int_tfFilteredIdsCountOnly when GUI for recorder is used: Count of windows in GUI recorder; TRecGuiEvent*fGuiEventThe newest GUI event to be stored in TTree; TTree*fGuiTreeTTree with recorded GUI events; TTimer*fMouseTimerTimer used for recording mouse position; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered ROOT windows.; TTimer*fTimerTimer used for recording; ULong64_tfWinThe newest registered window to be stored in TTree; TTree*fWinTreeTTree with registered windows. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderRecording(TRecorder* r, const char* filename, Option_t* option, Window_t* w, Int_t winCount); Initializes TRecorderRecording for recording; What is allocated here is deleted in destructor. Bool_t StartRecording(); Connects appropriate signals and slots in order to gain all registered; windows and processed events in ROOT and then starts recording. void Stop(TRecorder* r, Bool_t guiCommand); Disconnects all slots and stopps recording. void RegisterWindow(Window_t w); This method is called when RegisteredWindow(Window_t) is emitted from; TGClient. void RecordCmdEvent(const char* line); Records commandline event (text and time) ans saves the previous; commandline event; This 1 event delay in saving ensures that the last commandline events; 'TRecorder::Stop' will be not stored. void RecordGuiEvent(Event_t* e, Window_t wid); Records GUI Event_t *e different from kConfigureNotify (they are; recorded in TRecorderRecording::RecordGuiCNEvent). It is called via signal-slot when an event is processed in; TGClient::HandleEvent(Event_t *event); or in TGClient::HandleMaskEve",MatchSource.WIKI,root/html528/TRecorderRecording.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderRecording.html
Energy Efficiency,allocate,allocated,"of GUI events that have been replayed; TMutex*fMutex; TRecEvent*fNextEventThe next event that is going to be replayed (GUI event or commandline); TTimefPreviousEventTimeExecution time of the previously replayed event.; TRecorder*fRecorderReference to recorder (owner of this state) is kept in order to switch; Int_tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent()",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
Testability,log,log,"tfRegWinCounterCounter of registered windows when replaying; Bool_tfShowMouseCursorSpecifies if mouse cursor should be also replayed; TTimer*fTimerTimer used for replaying; Bool_tfWaitingForWindowSignalizes that we wait for a window to be registered in order; ULong64_tfWinWindow ID being currenty mapped; TTree*fWinTreeTTree with recorded windows (=registered during recording); Int_tfWinTreeEntriesNumber of registered windows during _recording_; TList*fWindowListList of TRecWinPair objects. Mapping of window IDs is stored here. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRecorderReplaying(const char* filename); Allocates all necessary data structures used for replaying; What is allocated here is deleted in destructor. Bool_t Initialize(TRecorder* r, Bool_t showMouseCursor, TRecorder::EReplayModes mode); Initialization of data structures for replaying.; Start of replaying. Return value:; - kTRUE = everything is OK and replaying has begun; - kFALSE = non existing or invalid log file, replaying has not started. void RegisterWindow(Window_t w); Creates mapping for the newly registered window w and adds this; mapping to fWindowList. Called by signal whenever a new window is registered during replaying. The new window ID is mapped to the old one with the same number in the; list of registered windows.; It means that 1st new window is mapped to the 1st original,; 2nd to the 2nd, Nth new to the Nth original. Bool_t RemapWindowReferences(); All references to the old windows (IDs) in fNextEvent are replaced by; new ones according to the mappings in fWindowList. Bool_t FilterEvent(TRecGuiEvent* e). Bool_t PrepareNextEvent(); Finds the next event in log file to replay and sets it to fNextEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must fir",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
Usability,pause,paused,"xtEvent. Reads both from CmdTree and GuiTree and chooses that event that becomes; earlier; - fCmdTreeCounter determines actual position in fCmdTree; - fGuiTreeCounter determines actual position in fCmdTree. If GUI event should be replayed, we must first make sure that there is; appropriate mapping for this event. RETURN VALUE:; kFALSE = there is no event to be replayed; kTRUE = there is still at least one event to be replayed. Cases:; - fNextEvent = 0 => We are waiting for the appropriate; window to be registered; - fNextEvent != 0 => fNextEvent can be replayed (windows are; ready). Bool_t CanOverlap(); ButtonPress and ButtonRelease must be sometimes replayed more times; Example: pressing of a button opens small window and user chooses; something from that window (color); Window must be opened while user is choosing. void ReplayRealtime(); Replays the next event. It is called when fTimer times out.; Every time fTimer is set again to time equal to time difference between; current two events being replayed. It can happen that execution of an event lasts different time during the; recording and during the replaying.; If fTimer times out too early and the previous event has not been yet; replayed, it is usually postponed in order; to keep events execution in the right order.; The excpetions are determined by TRecorderReplaying::CanOverlap(). void Pause(TRecorder* r); Pauses replaying. void ReplayStop(TRecorder* r); Cancels replaying. void Continue(); Continues previously paused replaying. TRecorder::ERecorderState GetState() const; Gets current state of recorder. TRecorderReplaying(const char* filename). » Author: Katerina Opocenska 11/09/2008 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TRecorder.h 35206 2010-09-08 14:01:27Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRecorderReplaying.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderReplaying.html
Availability,avail,available,"er->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virtual voidStop(TRecorder*, Bool_t); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidChangeState(TRecorder* r, TRecorderState* s, Bool_t deletePreviousState). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void ChangeState(TRecorderState *newstate, Bool_t deletePreviousState = kTRU",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
Integrability,interface,interface,". TRecorderState. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderState. class TRecorderState. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to ",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
Testability,log,logfile,"ons:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecorderState. class TRecorderState. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TRecorderState(); static TClass*Class(); virtual TRecorder::ERecorderStateGetState() const; virtual TClass*IsA() const; virtual voidListCmd(const char*); virtual voidListGui(const char*); TRecorderState&operator=(const TRecorderState&); virtual voidPause(TRecorder*); virtual voidPrevCanvases(const char*, Option_t*); virtual Bool_tReplay(TRecorder*, const char*, Bool_t, TRecorder::EReplayModes); virtual voidReplayStop(TRecorder*); virtual voidResume(TRecorder*); virtual voidShowMembers(TMemberInspector& insp); virtual voidStart(TRecorder*, const char*, Option_t*, Window_t*, Int_t); virt",MatchSource.WIKI,root/html528/TRecorderState.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecorderState.html
Availability,error,error,"Pair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
Integrability,interface,interface,". TRecWinPair. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecWinPair. class TRecWinPair: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In th",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
Testability,log,logfile,"s description; function members; data members; class charts. ROOT; » GUI; » RECORDER; » TRecWinPair. class TRecWinPair: public TObject. ROOT EVENT RECORDING SYSTEM. TRecorder class provides interface for recording and replaying; events in ROOT.; Recorded events are:; - Commands typed by user in commandline ('new TCanvas'); - GUI events (mouse movement, button clicks, ...). All the recorded events from one session are stored in one TFile; and can be replayed again anytime. Recording. 1] To start recording. TRecorder r(const char *filename, ""NEW""); TRecorder r(const char *filename, ""RECREATE""). or:. TRecorder *recorder = new TRecorder;; recorder->Start(const char *filename, ...). -filename Name of ROOT file in which to save; recorded events. 2] To stop recording. recorder->Stop(). IMPORTANT:; State capturing is part of recording. It means that if you want to; record events for some object (window), creation of this object; must be also recorded. Example:. t = new TRecorder(); // Create a new recorder; t->Start(""logfile.root""); // ! Start recording first. c = new TCanvas(); // ! Then, create an object; c->Dump(); // Work with that object. t->Stop(); // Stop recording. It is strongly recommended to start recording with empty ROOT; environment, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows dur",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
Usability,pause,pause,"t, at least with no previously created ROOT GUI.; This ensures that only events for well known windows are stored.; Events for windows, which were not created during recording,; cannot be replayed. Replaying. 1] To start replaying. TRecorder r(const char *filename); TRecorder r(const char *filename, ""READ""). or:. TRecorder *recorder = new TRecorder;; recorder->Replay(const char *filename,; Bool_t showMouseCursor = kTRUE);. -filename A name of file with recorded events; previously created with TRecorder::Start. -showMouseCursor If kTRUE, mouse cursor is replayed as well.; In that case it is not recommended to use mouse; during replaying. In general, it is not recommended to use mouse to change positions; and states of ROOT windows during replaying. IMPORTANT:; The state of ROOT environment before replaying of some events; must be exactly the same as before recording them.; Therefore it is strongly recommended to start both recording; and replaying with empty ROOT environment. 2] To pause replaying. recorder->Pause(). Replaying is stopped until recorder->Resume() is called. 3] To resume paused replaying. recorder->Resume(). Resumes previously stopped replaying. 4] To stop replaying before its end. recorder->Stop(). Function Members (Methods); public:. TRecWinPair(const TRecWinPair&); TRecWinPair(Window_t key, Window_t value); ~TRecWinPair(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass()",MatchSource.WIKI,root/html528/TRecWinPair.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRecWinPair.html
Safety,safe,safe,". TRedirectOutputGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRedirectOutputGuard. class TRedirectOutputGuard. TRedirectOutputGuard. This class provides output redirection to a file in a guaranteed; exception safe way. Use like this:; {; TRedirectOutputGuard guard(filelog, mode);; ... // do something; }; when guard goes out of scope output is automatically redirected to; the standard units in the TRedirectOutputGuard destructor.; The exception mechanism takes care of calling the dtors; of local objects so it is exception safe.; The 'mode' options follow the fopen write modes convention; default; is ""a"". Function Members (Methods); public:. TRedirectOutputGuard(const TRedirectOutputGuard&); TRedirectOutputGuard(const char* fout, const char* mode = ""a""); virtual~TRedirectOutputGuard(); static TClass*Class(); virtual TClass*IsA() const; TRedirectOutputGuard&operator=(const TRedirectOutputGuard&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRedirectOutputGuard(const char* fout, const char* mode = ""a""); { gSystem->RedirectOutput(fout, mode); }. virtual ~TRedirectOutputGuard(); { gSystem->RedirectOutput(0); }. » Author: G. Ganis 10/10/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRedirectOutputGuard.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRedirectOutputGuard.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRedirectOutputGuard.html
Availability,error,error," obj); TRef(const TRef& ref); virtual~TRef(); voidTObject::AbstractMethod(const char* method) const; static Int_tAddExec(const char* name); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static TObjArray*GetListOfExecs(); virtual const char*TObject::GetName() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TProcessID*GetPID() const; static TObject*GetStaticObject(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual void",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Deployability,update,updated,"t only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to the value; stored in the TObjArray of TFile::fProcessIDs (fProcessIDs[pidf]).; The pidf is stored in the bits 24->31 of the fUniqueID of the TR",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Integrability,depend,dependencies,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The ",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Performance,load,load,"med to be the name of a TExec object.; When a file is connected, the dictionary of the classes on the file; is read in memory (see TFile::ReadStreamerInfo). When the TStreamerElement; object is read, a TExec object is automatically created with the name; specified after the keywork ""EXEC:"" in case a TExec with a same name does; not already exist.; The action to be executed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the int",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Safety,avoid,avoid,". TRef. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRef. class TRef: public TObject. TRef. Persistent Reference link to a TObject; A TRef is a lightweight object pointing to any TObject.; This object can be used instead of normal C++ pointers in case; - the referenced object R and the pointer P are not written to the same file; - P is read before R; - R and P are written to different Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The ",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Security,access,access,"ed via this TExec can be specified with:; - a call to the TExec constructor, if the constructor is called before; opening the file.; - a call to TExec::SetAction at any time.; One can compute a pointer to an existing TExec with a name with:; TExec *myExec = gROOT->GetExec(execName);; myExec->SetAction(actionCommand); where; - actionCommand is a string containing a CINT instruction. Examples:; myExec->SetAction(""LoadHits()"");; myExec->SetAction("".x script.C"");. When a TRef is dereferenced via TRef::GetObject, its TExec will be; automatically executed. In the function/script being executed, one or more; of the following actions can be executed:; - load a file containing the referenced object. This function typically; looks in the file catalog (GRID).; - compute a pointer to the referenced object and communicate this pointer; back to the calling function TRef::GetObject via:; TRef::SetStaticObject(object).; When the TExec is called, it has access to the dereferencing TRef; by calling GetStaticObject() (TRef::GetObject() sets fgObject to ""this""; before the call to TExec). This can be useful for accessing the TRef's; fUniqueID.; As soon as an object is returned to GetObject, the fUniqueID of the TRef is set; to the fUniqueID of the referenced object. At the next call to GetObject,; the pointer stored in fPid:fObjects[fUniqueID] will be returned directly. An example of action on demand is shown in $ROOTSYS/test/Event.h with; the member:; TRef fWebHistogram; //EXEC:GetWebHistogram; When calling fWebHistogram.GetObject(), the function GetObject; will automatically invoke a script GetWebHistogram.C via the interpreter.; An example of a GetWebHistogram.C script is shown below; void GetWebHistogram() {; TFile *f= TFile::Open(""http://root.cern.ch/files/pippa.root"");; f->cd(""DM/CJ"");; TH1 *h6 = (TH1*)gDirectory->Get(""h6"");; h6->SetDirectory(0);; delete f;; TRef::SetStaticObject(h6);; }; In the above example, a call to fWebHistogram.GetObject() executes the; script with the funct",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Testability,test,test,"; corresponding to pidf. WARNING1: If MyClass is the class of the referenced object, The TObject; part of MyClass must be Streamed. One should not; call MyClass::Class()->IgnoreTObjectStreamer(). WARNING2: A TRef cannot point to another TRef. ObjectNumber. When an object is referenced (see TRef assignement operator or TRefArray::Add); a unique identifier is computed and stored in both the fUniqueID of the; referenced and referencing object. This uniqueID is computed by incrementing; by one the static global in TProcessID::fgNumber. fUniqueID is some sort of; serial object number in the current session. One can retrieve at any time; the current value of fgNumber by calling the static function TProcessID::GetObjectCount; or set this number via TProcessID::SetObjectCount.; To avoid a growing table of fObjects in TProcessID, in case, for example,; one processes many events in a loop, it might be necessary to reset the; ObjectNumber at the end of processing of one event. See an example; in $ROOTSYS/test/Event.cxx (look at function Build).; The value of ObjectNumber (say saveNumber=TProcessID::GetObjectCount()) may be; saved at the beginning of one event and reset to this original value; at the end of the event via TProcessID::SetObjectCount(saveNumber). These; actions may be stacked. Action on Demand. The normal behaviour of a TRef has been described above. In addition,; TRef supports also ""Actions on Demand"". It may happen that the object; referenced is not yet in memory, on a separate file or not yet computed.; In this case TRef is able to automatically execute an action:; - call to a compiled function (static function of member function); - call to an interpreted function; - execution of a CINT script. How to select this option?; In the definition of the TRef data member in the original class, do:; TRef fRef; //EXEC:execName. points to something; When the special keyword ""EXEC:"" is found in the comment field of the member,; the next string is assumed to be the name of",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Usability,simpl,simply,"ent Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to t",MatchSource.WIKI,root/html528/TRef.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRef.html
Availability,error,error,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = ",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
Integrability,message,message,"ay: public TSeqCollection. TRefArray. An array of references to TObjects. The array expands automatically; when objects are added (shrinking can be done by hand using Expand() ). The TRefArray can be filled with:; array.Add(obj); array.AddAt(obj,i); but not array[i] = obj !!!. The array elements can be retrieved with:; TObject *obj = array.At(i);. By default the TRefArray 'points' to the current process and can only; receive object that have been created in this process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = ",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
Testability,test,test," process.; To point the TRefArray to a different process do:; TRefArray array( processId );. For example, if 'obj' is an instance that was created in the different; process and you do:; TRefArray array( TProcessID::GetProcessWithUID( obj ) );; Then; array.Add(obj);; is correct (obj comes from the process the array is pointed to; while; TObject *nobj = new TObject;; array.Add(nobj);; is incorrect since 'nobj' was created in a different process than the; one the array is pointed to. In this case you will see error message:; Error in <TRefArray::AddAtAndExpand>: The object at 0x... is not; registered in the process the TRefArray point to; (pid = ProcessID../....). When a TRefArray is Streamed, only the pointer unique id is written,; not the referenced object. TRefArray may be assigned to different; branches of one Tree or several Trees.; The branch containing the TRefArray can be read before or after the; array (eg TClonesArray, STL vector,..) of the referenced objects. See an example in $ROOTSYS/test/Event.h. RESTRICTIONS when using TRefArray. - Elements in a TRefArray cannot point to a TFile or TDirectory.; - All elements of a TRefArray must be set in the same process,; In particular, one cannot modify some elements of the array in; a different process.; Use an array of TRef when one of the above restrictions is met. Function Members (Methods); public:. TRefArray(TProcessID* pid = 0); TRefArray(const TRefArray& a); TRefArray(Int_t s, TProcessID* pid); TRefArray(Int_t s, Int_t lowerBound = 0, TProcessID* pid = 0); virtual~TRefArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddAtAndExpand(TObject* obj, Int_t idx); virtual Int_tAddAtFree(TObject* obj); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual vo",MatchSource.WIKI,root/html528/TRefArray.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefArray.html
Availability,error,error,"wner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExpand(Int_t pid, Int_t newsize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(TBuffer& b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetN(Int_t pid) const; virtual const char*TObject::GetName() const; Int_tGetNumPIDs() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetOwner() const; TObject*GetParent(Int_t uid, TProcessID* context = 0) const; TObjArray*GetParents() const; static TRefTable*GetRefTable(); Int_tGetSize(Int_t pid) const",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
Energy Efficiency,allocate,allocated,"rIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumPIDs][fAllocSize] array of Parent IDs; TObjArray*fParentsarray of Parent objects (eg TTree branch) holding the referenced objects; vector<std::string>fProcessGUIDsUUIDs of TProcessIDs used in fParentIDs; Int_tfSizedummy for backward compatibility; UInt_tfUID!Current uid (set by TRef::GetObject); TProcessID*fUIDContext!TProcessID the current uid is referring to; static TRefTable*fgRefTablePointer to current TRefTable. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRefTable(); Default constructor for I/O. TRefTable(TObject* owner, Int_t size); Create a TRefTable with initial size. ~TRefTable(); Destructor. Int_t Add(Int_t uid, TProcessID* context = 0); Add a new uid to the table.; we add a new pair (uid,fparent) to the map; This function is called by TObject::Streamer or TStreamerInfo::WriteBuffer. Int_t AddInternalIdxForPID(TProcessID* procid); Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
Performance,load,loaded,". TRefTable. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TRefTable. class TRefTable: public TObject. A TRefTable maintains the association between a referenced object; and the parent object supporting this referenced object. The parent object is typically a branch of a TTree. For each object; referenced in a TTree entry, the corresponding entry in the TTree's; TBranchRef::fRefTable contains the index of the branch that; needs to be loaded to bring the object into memory. Persistency of a TRefTable is split into two parts:; * entry specific information is stored (read) by FillBuffer; (ReadBuffer). For each referenced object the object's fUniqueID; and the referencing TRef::fPID is stored (to allow the TRefTable; to autoload references created by different processes).; * non-entry specific, i.e. global information is stored (read) by; the Streamer function. This comprises all members marked as; persistent. As TObject::fUniqueID is only unique for a given TProcessID, a table; of unique IDs is kept for each used TProcessID. There is no natural; order of TProcessIDs, so TRefTable stores a vector of the TGUID of; all known TProcessIDs in fProcessGUIDs; the index of a TProcessID in; this vector defines the index of the auto-loading info in fParentIDs; for that TProcessID. The mapping of TProcessID* to index is cached; for quick non-persistent lookup. Function Members (Methods); public:. TRefTable(); TRefTable(const TRefTable&); TRefTable(TObject* owner, Int_t size); virtual~TRefTable(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Int_t uid, TProcessID* context = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """")",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
Usability,guid,guid,"ol_t stat); virtual Int_tSetParent(const TObject* parent, Int_t branchID); static voidSetRefTable(TRefTable* table); virtual voidSetUID(UInt_t uid, TProcessID* context = 0); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Int_tAddInternalIdxForPID(TProcessID* procid); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tExpandForIID(Int_t iid, Int_t newsize); voidExpandPIDs(Int_t numpids); Int_tFindPIDGUID(const char* guid) const; Int_tGetInternalIdxForPID(TProcessID* procid) const; Int_tGetInternalIdxForPID(Int_t pid) const; voidTObject::MakeZombie(). Data Members; public:. enum { kHaveWarnedReadingOld; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Int_t*fAllocSize![fNumPIDs] allocated size of array fParentIDs for each ProcessID; Int_tfDefaultSize!default size for a new PID array; vector<Int_t>fMapPIDtoInternal! cache of pid to index in fProcessGUIDs; Int_t*fN![fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID; Int_tfNumPIDs!number of known ProcessIDs; TObject*fOwnerObject owning this TRefTable; Int_tfParentID!current parent ID in fParents (latest call to SetParent); Int_t**fParentIDs![fNumP",MatchSource.WIKI,root/html528/TRefTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRefTable.html
Integrability,rout,routine,"piled pattern; TRegexp::EStatValfStatStatus; static const unsigned intfgMaxpatMax length of compiled pattern. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRegexp(const char* re, Bool_t wildcard = kFALSE); Create a regular expression from the input string. If wildcard is true; then the input string contains a wildcard expression (see MakeWildcard()). TRegexp(const TString& re); Create a regular expression from a TString. TRegexp(const TRegexp& re); Copy ctor. ~TRegexp(); Destructor. TRegexp& operator=(const TRegexp& re); Assignment operator. TRegexp& operator=(const char* re); Assignment operator taking a char* and assigning it to a regexp. TRegexp& operator=(const TString& re); Assignment operator taking a TString. void GenPattern(const char* re); Generate the regular expression pattern. void CopyPattern(const TRegexp& re); Copy the regular expression pattern. const char * MakeWildcard(const char* re); This routine transforms a wildcarding regular expression into; a general regular expression used for pattern matching.; When using wildcards the regular expression is assumed to be; preceded by a ""^"" (BOL) and terminated by a ""$"" (EOL). Also, all; ""*""'s and ""?""'s (closures) are assumed to be preceded by a ""."" (i.e. any; character, except ""/""'s) and all .'s are escaped (so *.ps is different; from *.eps). The special treatment of ""/"" allows the easy matching of; pathnames, e.g. ""*.root"" will match ""aap.root"", but not ""pipo/aap.root"". Ssiz_t Index(const TString& str, Ssiz_t* len, Ssiz_t start = 0) const; Find the first occurance of the regexp in string and return the position.; Len is length of the matched string and i is the offset at which the; matching should start. EStatVal Status(). » Author: Fons Rademakers 04/08/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TRegexp.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-29 11:48; This page has been automatically ge",MatchSource.WIKI,root/html528/TRegexp.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRegexp.html
Availability,error,error,"* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetClassName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetFileStat(FileStat_t* sbuf); virtual const char*TObject::GetIconName() const; const char*GetKeyClassName() const; const char*GetKeyObjectName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(T",MatchSource.WIKI,root/html528/TRemoteObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRemoteObject.html
Integrability,protocol,protocol,". TRemoteObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRemoteObject. class TRemoteObject: public TNamed. TRemoteObject. The TRemoteObject class provides protocol for browsing ROOT objects; from a remote ROOT session.; It contains informations on the real remote object as:; - Object Properties (i.e. file stat if the object is a TSystemFile); - Object Name; - Class Name; - TKey Object Name (if the remote object is a TKey); - TKey Class Name (if the remote object is a TKey); - Remote object address. Function Members (Methods); public:. TRemoteObject(); TRemoteObject(const TRemoteObject&); TRemoteObject(const char* name, const char* title, const char* classname); virtual~TRemoteObject(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); TList*Browse(); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(co",MatchSource.WIKI,root/html528/TRemoteObject.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRemoteObject.html
Availability,error,error,"ws(const TTable* srcTable, Long_t srcRow = 0, Long_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TGenericTable::iteratorTGenericTable::end(); TGenericTable::iteratorTGenericTable::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; static Int_tFindResponseLocation(TTableDescriptor& dsc); virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000",MatchSource.WIKI,root/html528/TResponseTable.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TResponseTable.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const char*TApplication::GetIdleCommand() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*T",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
Integrability,interface,interface,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
Modifiability,inherit,inheritance,"oteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the Process",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
Security,access,access,". TRint. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » RINT; » TRint. class TRint: public TApplication. Rint. Rint is the ROOT Interactive Interface. It allows interactive access; to the ROOT system via the CINT C/C++ interpreter. Function Members (Methods); public:. TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); virtual~TRint(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*TApplication::ApplicationName() const; static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; Int_tTApplication::Argc() const; char**TApplication::Argv() const; char*TApplication::Argv(Int_t index) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTApplication::ClearInputFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; static voidTApplication::CreateApplication(); ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
Testability,log,logon,"of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TStringfDefaultPromptdefault prompt: ""root [%d] ""; TFileHandler*fInputHandlerterminal input handler; Bool_tfInterruptif true macro execution will be stopped; Int_tfNcmdcommand history number; charfPrompt[64]interpreter prompt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRint(const char* appClassName, int* argc, char** argv, void* options = 0, int numOptions = 0, Bool_t noLogo = kFALSE); Create an application environment. The TRint environment provides an; interface to the WM manager functionality and eventloop via inheritance; of TApplication and in addition provides interactive access to; the CINT C++ interpreter via the command line. ~TRint(); Destructor. void ExecLogon(); Execute logon macro's. There are three levels of logon macros that; will be executed: the system logon etc/system.rootlogon.C, the global; user logon ~/.rootlogon.C and the local ./.rootlogon.C. For backward; compatibility also the logon macro as specified by the Rint.Logon; environment setting, by default ./rootlogon.C, will be executed.; No logon macros will be executed when the system is started with; the -n option. void Run(Bool_t retrn = kFALSE); Main application eventloop. First process files given on the command; line and then go into the main application event loop, unless the -q; command line option was specfied in which case the program terminates.; When retrun is true this method returns even when -q was specified. When QuitOpt is true and retrn is false, terminate the application with; an error code equal to either the ProcessLine error (if any) or the; return value of the command casted to a long. void PrintLogo(Bool_t lite = kFALSE); Print the ROOT logo on standard output. ",MatchSource.WIKI,root/html528/TRint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRint.html
Availability,robust,robust,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
Deployability,update,update," Int_t hh = 0); for the univariate case; estimates of location and scatter are returned in mean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
Modifiability,variab,variables,"both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is, when h or more; observations lie on a hyperplane. Then the algorithm still yields the MCD location T; and scatter matrix S, the latter being singular as it should be. From (T,S) the; program then computes the equation of the hyperplane. How can this algorithm be used?; In any case, when contamination of data is suspected, that might influence; the classical estimates.; Also, robust estimation of location and scatter is a tool to robustify; other multivariate techniques such as, for example, principal-component analysis; and discriminant analysis. Technical details of the algorithm:; 0.The default h = (n+nvariables+1)/2, but the user may choose any interger h with; (n+nvariables+1)/2<=h<=n. The program then reports the MCD's breakdown value; (n-h+1)/n. If you are sure that the dataset contains less than 25% contamination; which is usually the case, a good comp",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
Safety,detect,detected," viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers.; The algorithm also allows for exact fit situations - that is",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
Usability,clear,clear,"ean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the inverse of the covariance matrix; htotal points with smallest distances are included in the",MatchSource.WIKI,root/html528/TRobustEstimator.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html
Availability,error,error,"(const TRolke&); TRolke(Double_t CL = 0.9, Option_t* option = """"); virtual~TRolke(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); Double_tCalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; boolGetBounding() const; Double_tGetCL() const; boolGetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; boolGetLimits(Double_t& low, Double_t& high); boolGetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); boolGetLimitsQuantile(Double_t& low, Double_t& high, Int_t& out_x, Double_t integral = 0.5); Double_tGetLowerLimit(); virtual con",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
Integrability,interface,interface,"s gives the median limits; in repeated experiments. The returned out_x is the corresponding; (e.g. median) value of x.; No uncertainties are considered for the Poisson weights when calculating; the Poisson integral . bool GetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); get the upper and lower limits for the most likely outcome.; The returned out_x is the corresponding value of x; No uncertainties are considered for the Poisson weights when finding ML . bool GetCriticalNumber(Int_t& ncrit, Int_t maxtry = -1); get the value of x corresponding to rejection of the null hypothesis.; This means a lower limit >0 with the pre-specified Confidence Level.; Optionally give maxtry; the maximum value of x to try. Of not, or if; maxtry<0 an automatic mode is used. void SetSwitch(bool bnd); Deprecated name for SetBounding. void Print(Option_t* ) const; Dump internals. Print members. Double_t CalculateInterval(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m); Deprecated and error prone model selection interface.; It's use is trongly discouraged. 'mid' is the model ID (1 to 7).; This method is provided for backwards compatibility/developer use only. ; x : number of observed events in the experiment; y : number of observed events in background region; z : number of MC events observed; bm : estimate of the background; em : estimate of the efficiency; e : true efficiency (considered known); mid : internal model id (really, you should not use this method at all); sde : efficiency estimate's standard deviation; sdb : background estimate's standard deviation; tau : ratio parameter (read TRolke.cxx for details); b : background expectation value (considered known); m : number of MC events generated. void SetModelParameters(Int_t x, Int_t y, Int_t z, Double_t bm, Double_t em, Double_t e, Int_t mid, Double_t sde, Double_t sdb, Double_t tau, Double_t b, Int_t m). x : number of observed events in ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
Safety,detect,detection,". TRolke. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRolke. class TRolke: public TObject. TRolke. This class computes confidence intervals for the rate of a Poisson; process in the presence of uncertain background and/or efficiency. The treatment and the resulting limits are fully frequentist. The; limit calculations make use of the profile likelihood method. Author: Jan Conrad (CERN) 2004; Updated: Johan Lundberg (CERN) 2009. Copyright CERN 2004,2009 Jan.Conrad@cern.ch,; Johan.Lundberg@cern.ch. For a full list of methods and their syntax, and build instructions,; consult the header file TRolke.h. Examples/tutorials are found in the separate file Rolke.C. TRolke implements the following Models. The signal is always assumed to be Poisson, with the following; combinations of models of background and detection efficiency:. If unsure, first consider model 3, 4 or 5. 1: SetPoissonBkgBinomEff(x,y,z,tau,m). Background: Poisson; Efficiency: Binomial. when the background is simultaneously measured; from sidebands (or MC), and; the signal efficiency was determined from Monte Carlo. 2: SetPoissonBkgGaussEff(x,y,em,sde,tau). Background: Poisson; Efficiency: Gaussian. when the background is simultaneously measured; from sidebands (or MC), and; the efficiency is modeled as Gaussian. 3: SetGaussBkgGaussEff(x,bm,em,sde,sdb). Background: Gaussian; Efficiency: Gaussian. when background and efficiency can both be; modeled as Gaussian. 4: SetPoissonBkgKnownEff(x,y,tau,e). Background: Poisson; Efficiency: Known. when the background is simultaneously measured; from sidebands (or MC). 5: SetGaussBkgKnownEff(x,bm,sdb,e). Background: Gaussian; Efficiency: Known. when background is Gaussian. 6: SetKnownBkgBinomEff(x,z,b,m). Background: Known; Efficiency: Binomial. when signal efficiency was determined fr",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
Testability,log,logGamma," = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod6(Double_t mu, Double_t b, Double_t e, Int_t x, Int_t z, Int_t m); Profile Likelihood function for MODEL 6:; background known/ Efficiency binomial. Double_t EvalLikeMod7(Double_t mu, Int_t x, Double_t em, Double_t sde, Double_t b, Int_t what); Calculates the Profile Likelihood for MODEL 7:; background known/Efficiency Gauss; what = 1: Maximum likelihood estimate is returned; what = 2: Profile Likelihood of Maximum Likelihood estimate is returned.; what = 3: Profile Likelihood of Test hypothesis is returned; otherwise parameters as described in the beginning of the class). Double_t LikeMod7(Double_t mu, Double_t b, Double_t e, Int_t x, Double_t em, Double_t v); Profile Likelihood function for MODEL 6:; background known/ Efficiency gaussian. Double_t EvalPolynomial(Double_t x, const Int_t* coef, Int_t N); evaluate polynomial. Double_t EvalMonomial(Double_t x, const Int_t* coef, Int_t N); evaluate mononomial. Double_t LogFactorial(Int_t n); LogFactorial function (use the logGamma function via the relation Gamma(n+1) = n!. TRolke(Double_t CL = 0.9, Option_t* option = """"); Constructor. Double_t GetCL() const; Get and set the Confidence Level. void SetCL(Double_t CL). void SetCLSigmas(Double_t CLsigmas); Set the Confidence Level in terms of Sigmas. bool GetBounding() const; Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . void SetBounding(const bool bnd); Get the bounding mode flag. True activates bounded mode. Read; TRolke.cxx and the references therein for details. . » Last changed: Thu Sep 23 20:20:28 2010 » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
Usability,simpl,simple," true efficiency (considered known). void SetKnownBkgBinomEff(Int_t x, Int_t z, Int_t m, Double_t b); Model 6: Background - known, Efficiency - Binomial (x,z,m,b); x : number of observed events in the experiment; z : number of MC events observed; m : number of MC events generated; b : background expectation value (considered known). void SetKnownBkgGaussEff(Int_t x, Double_t em, Double_t sde, Double_t b); Model 7: Background - known, Efficiency - Gaussian (x,em,sde,b); x : number of observed events in the experiment; em : estimate of the efficiency; sde : efficiency estimate's standard deviation; b : background expectation value (considered known). bool GetLimits(Double_t& low, Double_t& high); Calculate and get the upper and lower limits for the pre-specified model. Double_t GetUpperLimit(); Calculate and get upper limit for the pre-specified model. Double_t GetLowerLimit(); Calculate and get lower limit for the pre-specified model. Double_t GetBackground(); Return a simple background value (estimate/truth) given the pre-specified model. bool GetSensitivity(Double_t& low, Double_t& high, Double_t pPrecision = 0.00001); get the upper and lower average limits based on the specified model.; No uncertainties are considered for the Poisson weights in the averaging sum. bool GetLimitsQuantile(Double_t& low, Double_t& high, Int_t& out_x, Double_t integral = 0.5); get the upper and lower limits for the outcome corresponding to; a given quantile.; For integral=0.5 this gives the median limits; in repeated experiments. The returned out_x is the corresponding; (e.g. median) value of x.; No uncertainties are considered for the Poisson weights when calculating; the Poisson integral . bool GetLimitsML(Double_t& low, Double_t& high, Int_t& out_x); get the upper and lower limits for the most likely outcome.; The returned out_x is the corresponding value of x; No uncertainties are considered for the Poisson weights when finding ML . bool GetCriticalNumber(Int_t& ncrit, Int_t maxtry ",MatchSource.WIKI,root/html528/TRolke.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRolke.html
Availability,error,error,"irtual voidTDirectory::Close(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; static Int_tConvertVersionCode2Int(Int_t code); static Int_tConvertVersionInt2Code(Int_t v); virtual voidTDirectory::Copy(TObject&) const; static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); static Int_tDecreaseDirLevel(); virtual voidTDirectory::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTDirectory::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplicat",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Deployability,release,release,mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSeqCollection*fTasksList of tasks; Int_tfTimerTimer flag; TStringTNamed::fTitleobject title; TCollection*fTypesList of data types definition; TUUIDTDirectory::fUUIDUnique identifier; TProcessUUID*fUUIDsPointer to TProcessID managing TUUIDs; TStringfVersionROOT version (from CMZ VERSQQ) ex 0.,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Integrability,message,message,is TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrupted; TList*TDirectory::fListList of objects in memory; TSeqCollection*fMappedFilesList of memory mapped files; TSeqCollection*fMessageHandlersList of message handlers; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tfMustCleanTrue if object destructor scans canvases; TStringTNamed::fNameobject identifier; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TPluginManager*fPluginManagerKeeps track of plugin library handlers; const TObject*fPrimitiveCurrently selected primitive; TSeqCollection*fProofsList of proof sessions; Bool_tfReadingObjectTrue while reading an object [Deprecated (will be removed in next release); TFolder*fRootFoldertop level folder //root; TSeqCollection*fSecContextsList of security contexts (TSecContext); TVirtualPad*fSelectPadCurrently selected pad; TSeqCollection*fSocketsList of network sockets; TSeqCollection*fSpecialsList of special objects; TSeqCollection*fStreamerInfoList of active StreamerInfo classes; TSeqCollection*fStylesList of styles; TStringfSvnBranchSubversion branch; TStringfSvnDateDate and time when make was run; Int_tfSvnRevisionSubversion revision number of built; TSe,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Modifiability,config,configure,ory::UnregisterContext(TDirectory::TContext* ctxt). private:. TROOT&operator=(const TROOT&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Performance,load,load,"t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*TDirectory::FindObjectAnyFile(const char*) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Safety,detect,detected,ory::UnregisterContext(TDirectory::TContext* ctxt). private:. TROOT&operator=(const TROOT&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fApplicationPointer to current application; Bool_tfBatchTrue if session without graphics; TList*fBrowsablesList of browsables; TSeqCollection*fBrowsersList of browsers; Int_tfBuiltDateDate of ROOT built; Int_tfBuiltTimeTime of ROOT built; TSeqCollection*fCanvasesList of canvases; TCollection*fClassGeneratorsList of user defined class generators;; TCollection*fClassesList of classes definition; TSeqCollection*fCleanupsList of recursiveRemove collections; TSeqCollection*fClipboardList of clipbard objects; TSeqCollection*fColorsList of colors; TStringfConfigFeaturesROOT ./configure detected build features; TStringfConfigOptionsROOT ./configure set build options; TDirectory::TContext*TDirectory::fContext!Pointer to a list of TContext object pointing to this TDirectory; TStringfCutClassNameName of default CutG class in graphics editor; TSeqCollection*fDataSetsList of data sets (TDSet or TChain); TStringfDefCanvasNameName of default canvas; Bool_tfEditHistogramsTrue if histograms can be edited with the mouse; Int_tfEditorModeCurrent Editor mode; Bool_tfEscapeTrue if ESC has been pressed; Bool_tfExecutingMacroTrue while executing a TMacro; TSeqCollection*fFilesList of files; Bool_tfForceStyleForce setting of current style when reading objects; Bool_tfFromPopUpTrue if command executed from a popup menu; TCollection*fFunctionsList of analytic functions; TSeqCollection*fGeometriesList of geometries; TCollection*fGlobalFunctionsList of global functions; TCollection*fGlobalsList of global variables; TInterpreter*fInterpreterCommand interpreter; Bool_tfInterruptTrue if macro should be interrup,MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Security,access,accessible,". TROOT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TROOT. class TROOT: public TDirectory. R O O T top level object description. The TROOT object is the entry point to the ROOT system.; The single instance of TROOT is accessible via the global gROOT.; Using the gROOT pointer one has access to basically every object; created in a ROOT based program. The TROOT object is essentially a; container of several lists pointing to the main ROOT objects. The following lists are accessible from gROOT object:; gROOT->GetListOfClasses; gROOT->GetListOfColors; gROOT->GetListOfTypes; gROOT->GetListOfGlobals; gROOT->GetListOfGlobalFunctions; gROOT->GetListOfFiles; gROOT->GetListOfMappedFiles; gROOT->GetListOfSockets; gROOT->GetListOfSecContexts; gROOT->GetListOfCanvases; gROOT->GetListOfStyles; gROOT->GetListOfFunctions; gROOT->GetListOfSpecials (for example graphical cuts); gROOT->GetListOfGeometries; gROOT->GetListOfBrowsers; gROOT->GetListOfCleanups; gROOT->GetListOfMessageHandlers. The TROOT class provides also many useful services:; - Get pointer to an object in any of the lists above; - Time utilities TROOT::Time. The ROOT object must be created as a static object. An example; of a main program creating an interactive version is shown below:. Example of a main program. #include ""TRint.h"". int main(int argc, char **argv); {; TRint *theApp = new TRint(""ROOT example"", &argc, argv);. // Init Intrinsics, build all windows, and enter event loop; theApp->Run();. return(0);; }; End of Main program. Function Members (Methods); public:. virtual~TROOT(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectory::Add(TObject* obj, Bool_t replace = kFALSE); voidAddClass(TClass* cl); voidAddClassGenerator(TClassGenerator* gen); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); sta",MatchSource.WIKI,root/html528/TROOT.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TROOT.html
Security,authenticat,authentication,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. TRootAuth(); TRootAuth(const TRootAuth&); virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootAuth(); { }. virtual ~TRootAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"). void ErrorMsg(const char* where, Int_t ecode = -1). const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootAuth.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootAuth.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootAuth.html
Availability,error,error,"ct::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Long_tExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGFrame*GetActFrame() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFra",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
Modifiability,plugin,plugins,"ND types; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCompositeFrame*fEditFrameFrame in ""Edit"" mode; Int_tfEditPosId of tab in ""Edit"" mode; Int_tfEditSubPosId of subtab in ""Edit"" mode; TGTab*fEditTabTab in ""Edit"" mode; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGHorizontalFrame*fH1Horizontal frame; TGHorizontalFrame*fH2Horizontal frame; TGHSplitter*fHSplitterHorizontal splitter; UInt_tTGFrame::fHeightframe height; TGHorizontalFrame*fHfHorizontal frame; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGLayoutHints*fLH0; TGLayoutHints*fLH1; TGLayoutHints*fLH2; TGLayoutHints*fLH3Layout hints, part 1; TGLayoutHints*fLH4; TGLayoutHints*fLH5; TGLayoutHints*fLH6; TGLayoutHints*fLH7Layout hints, part 2; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; UInt_tTGMainFrame::fMWMFuncsMWM functions; UInt_tTGMainFrame::fMWMInputMWM input modes; UInt_tTGMainFrame::fMWMValueMWM decoration hints; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; TGMenuBar*fMenuBarMain (owned) menu bar; TGPopupMenu*fMenuExecPlugin""Exec Plugin"" popup menu; TGPopupMenu*fMenuFile""File"" popup menu; TGHorizontalFrame*fMenuFrameShared menu frame; TGPopupMenu*fMenuHelp""Browser Help"" popup menu; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; Int_tTGCompositeFrame::fMustCleanupcleanup mode (see EFrameCleanup); TStringTGWindow::fNamename of the window used in SavePrimitive(); Int_tfNbInitPluginsNumber of initial plugins (from .",MatchSource.WIKI,root/html528/TRootBrowser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowser.html
Availability,error,error,"g_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecMacro(); virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
Deployability,update,update," it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void SetDefaults(const char* iconStyle = 0, const char* sortBy = 0); Set defaults depending on settings in the user's .rootrc. void SetViewMode(Int_t new_mode, Bool_t force = kFALSE); Set iconbox's view mode and update menu and toolbar buttons accordingly. void SetSortMode(Int_t new_mode); Set iconbox's sort mode and update menu radio buttons accordingly. void Search(); starts serach dialog. void HideTextEdit(); hide text edit. void BrowseTextFile(const char* file); browse text file. void ExecMacro(); executed browsed text macro. void InterruptMacro(); interrupt browsed macro execution. void ShowMacroButtons(Bool_t show = kTRUE); show/hide macro buttons. void SetStatusText(const char* txt, Int_t col); Set text in column col in status bar. TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); Interface method to the old browser. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Interface method to the old browser. void Iconify(); { }. void ResizeBrowser(); { }. void Show(); { MapRaised(); }. TGListTree * GetListTree",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
Integrability,depend,depending,"to the past. Bool_t HistoryForward(); go to the future. void DeleteListTreeItem(TGListTreeItem* item); delete list tree item, remove it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void SetDefaults(const char* iconStyle = 0, const char* sortBy = 0); Set defaults depending on settings in the user's .rootrc. void SetViewMode(Int_t new_mode, Bool_t force = kFALSE); Set iconbox's view mode and update menu and toolbar buttons accordingly. void SetSortMode(Int_t new_mode); Set iconbox's sort mode and update menu radio buttons accordingly. void Search(); starts serach dialog. void HideTextEdit(); hide text edit. void BrowseTextFile(const char* file); browse text file. void ExecMacro(); executed browsed text macro. void InterruptMacro(); interrupt browsed macro execution. void ShowMacroButtons(Bool_t show = kTRUE); show/hide macro buttons. void SetStatusText(const char* txt, Int_t col); Set text in column col in status bar. TBrowserImp * NewBrowser(TBrowser* b = 0, const char* title = ""ROOT Browser"", UInt_t width = 800, UInt_t height = 500, Option_t* opt = """"); Interface method to the old browser. TBrowserImp * NewBrowser(TBrowser* b, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt = """"); Interfac",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
Usability,clear,clear," ""history"". TGFileContainer * GetIconBox() const; returns pointer to fIconBox object. void ReallyDelete(); Really delete the browser and the this GUI. void CloseWindow(); In case window is closed via WM we get here. void DisplayTotal(Int_t total, Int_t selected); Display in statusbar total number of objects and number of; selected objects in IconBox. void DisplayDirectory(); Display current directory in second label, fLbl2. void ExecuteDefaultAction(TObject* obj); Execute default action for selected object (action is specified; in the $HOME/.root.mimes or $ROOTSYS/etc/root.mimes file.; Emits signal ""ExecuteDefaultAction(TObject*)"". Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. void Chdir(TGListTreeItem* item); Make object associated with item the current directory. void HighlightListLevel(); helper method to track history. void AddToHistory(TGListTreeItem* item); helper method to track history. void ClearHistory(); clear navigation history. Bool_t HistoryBackward(); go to the past. Bool_t HistoryForward(); go to the future. void DeleteListTreeItem(TGListTreeItem* item); delete list tree item, remove it from history. void ListTreeHighlight(TGListTreeItem* item); Open tree item and list in iconbox its contents. void ToSystemDirectory(const char* dirname); display directory. void SetDrawOption(Option_t* option = """"); sets drawing option. Option_t * GetDrawOption() const; returns drawing option. void DoubleClicked(TObject* obj); Emits signal when double clicking on icon. void Checked(TObject* obj, Bool_t check); Emits signal when double clicking on icon. void IconBoxAction(TObject* obj); Default action when double clicking on icon. void RecursiveRemove(TObject* obj); Recursively remove object from browser. void Refresh(Bool_t force = kFALSE); Refresh the browser contents. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void S",MatchSource.WIKI,root/html528/TRootBrowserLite.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootBrowserLite.html
Availability,error,error,"voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFitCanvas(); virtual voidForceUpdate(); virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; UInt_tGetCheight() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); UInt_tGetCwidth() const; static Pixel_tTGFrame::GetDefaultFrameBackground(); virtua",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Integrability,interface,interface,"bar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootCanvas(TCanvas* c = 0, const char* name = ""ROOT Canvas"", UInt_t width = 500, UInt_t height = 300); Create a basic ROOT canvas. TRootCanvas(TCanvas* c, const char* name, Int_t x, Int_t y, UInt_t width, UInt_t height); Create a basic ROOT canvas. void CreateCanvas(const char* name); Create the actual canvas. ~TRootCanvas(); Delete ROOT basic canvas. Order is significant. Delete in reverse; order of creation. void Close(); Called via TCanvasImp interface by TCanvas. void ReallyDelete(); Really delete the canvas and this GUI. void CloseWindow(); In case window is closed via WM we get here. UInt_t GetCwidth() const; Return width of canvas container. UInt_t GetCheight() const; Return height of canvas container. UInt_t GetWindowGeometry(Int_t& x, Int_t& y, UInt_t& w, UInt_t& h); Gets the size and position of the window containing the canvas. This; size includes the menubar and borders. void SetStatusText(const char* txt = 0, Int_t partidx = 0); Set text in status bar. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t parm2); Handle menu and other command generated by the user. Int_t InitWindow(); Called by TCanvas ctor to get window indetifier. void SetCanvasSize(UInt_t w, UInt_t h); Set size of canvas container. Units in pixels. void SetWindowPosition(Int_t x, Int_t y); Set canvas position (units in pixels). void SetWindowSize(UInt_t w, UInt_t h); Set size of canvas (units in pixels). void RaiseWindow(); Put canvas ",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Modifiability,config,configure,"how = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenu",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Performance,load,loaded,TGFrame::fgWhitePixel. private:. Bool_tfAutoFitwhen true canvas container keeps same size as canvas; Int_tfButtoncurrently pressed button; TRootContainer*fCanvasContainercontainer in canvas widget; Int_tfCanvasIDindex in fWindows array of TGX11; TGLayoutHints*fCanvasLayoutlayout for canvas widget; TGCanvas*fCanvasWindowcanvas widget; TGLayoutHints*fDockLayoutlayout hints for dockable frame widget; TGPopupMenu*fEditClearMenuclear cascade submenu; TGPopupMenu*fEditMenuedit menu; TVirtualPadEditor*fEditorpointer to currently loaded pad editor; TGCompositeFrame*fEditorFrameside frame for current pad editor; TGLayoutHints*fEditorLayoutlayout for editor frame; TGPopupMenu*fFileMenufile menu; TGPopupMenu*fFileSaveMenusave cascade submenu; TGPopupMenu*fHelpMenuhelp menu; TGHorizontal3DLine*fHorizontal1toolbar sepatator; TGLayoutHints*fHorizontal1Layoutlayout hints for separator; const TGPicture*fIconPicicon picture; TGCompositeFrame*fMainFramemain frame containing canvas and side frame; TGLayoutHints*fMainFrameLayoutlayout for main frame; TGMenuBar*fMenuBarmenubar; TGLayoutHints*fMenuBarHelpLayoutlayout hint for help menu in menubar; TGLayoutHints*fMenuBarItemLayoutlayout hints for menu in menubar; TGLayoutHints*fMenuBarLayoutmenubar layout hints; TGPopupMenu*fOptionMenuoption menu; TGStatusBar*fStatusBarstatusbar widget; TGLayoutHints*fStatusBarLayoutlayout hints for statusbar; TGToolBar*fToolBaricon button toolbar; TGLayoutHints*fToolBarLayoutlayout for toolbar widget; TGHorizontal3DLine*fToolBarSeptoolbar separator; TGDockableFrame*fToolDockdockable frame holding the toolbar; TGToolTip*fToolTiptooltip for object info; TGPopupMenu*fToolsMenutools menu; TGVertical3DLine*fVertical1toolbar vertical separator; TGLayoutHints*fVertical1Layoutlayout hints for separator; TGVertical3DLine*fVertical2toolbar vertical separator; TGLayoutHints*fVertical2Layoutlayout hints for separator; TGPopupMenu*fViewMenuview menu; TGPopupMenu*fViewWithMenuview with... cascade submenu. Class Charts,MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Security,expose,expose,"bar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(const TRootCanvas& ). TRootCanvas& operator=(const TRootCanvas& ). void ForceUpdate(); { Layout(); }. void Iconify(); { IconifyWindow(); }. void Show(); { MapRaised(); }. TGMenuBar * GetMenuBar() const; { return fMenuBar; }. TGLayoutHints * GetMenuBarItemLayout() const; { return fMenuBarItemLayout; }. TGStatusBar * GetStatusBar() const; { return fStatusBar; }. TGDockableFrame * GetToolDock() const; { return fToolDock; }. » Author: Fons Rademakers 15/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id:",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Usability,undo,undocking,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(cons",MatchSource.WIKI,root/html528/TRootCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootCanvas.html
Availability,down,downs,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
Integrability,interface,interface,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root/html528/TRootContextMenu.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; virtual TControlBarButton*TControlBarImp::GetClicked(); TGClient*TGObject::GetClient() const; virtual TControlBar*TControlBarImp::GetControlBar(); static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackgr",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
Integrability,interface,interface,". TRootControlBar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootControlBar. class TRootControlBar: public TGMainFrame, public TControlBarImp. TRootControlBar. This class provides an interface to the GUI dependent functions of; the TControlBar class. A control bar is a horizontal or vertical bar; with a number of buttons (text or picture buttons). Function Members (Methods); public:. TRootControlBar(TControlBar* c = 0, const char* title = ""ROOT Control Bar"", Int_t x = -999, Int_t y = -999); virtual~TRootControlBar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slo",MatchSource.WIKI,root/html528/TRootControlBar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootControlBar.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TRootDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootDialog.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetAutoFit() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TCanvas*GetCanvas() const; Int_tGetCanvasWindowId() const; TGClient*TGObject::GetClient() const; TGFrame*TGCanvas::GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCanvas::GetDefaultSize() const; virtual UInt_tTGFrame::Ge",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
Modifiability,config,configure," = 0, UInt_t w = 10, UInt_t h = 10, UInt_t options = kSunkenFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Create an TCanvas embedded in a TGFrame. A pointer to the TCanvas can; be obtained via the GetCanvas() member function. To embed a canvas; derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
Security,expose,expose,"derived from a TCanvas do the following:; TRootEmbeddedCanvas *embedded = new TRootEmbeddedCanvas(0, p, w, h);; [note name must be 0, not null string """"]; Int_t wid = embedded->GetCanvasWindowId();; TMyCanvas *myc = new TMyCanvas(""myname"", 10, 10, wid);; embedded->AdoptCanvas(myc);; [ the MyCanvas is adopted by the embedded canvas and will be; destroyed by it ]. ~TRootEmbeddedCanvas(); Delete embedded ROOT canvas. void AdoptCanvas(TCanvas* c); Canvas c is adopted from this embedded canvas. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t , Int_t , Atom_t action, Int_t , Int_t ); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void SavePrimitive(ostream& out, Option_t* option = """"); Save an embedded canvas as a C++ statement(s) on output stream out. TRootEmbeddedCanvas(const TRootEmbeddedCanvas& ). TRootEmbeddedCanvas& operator=(const TRootEmbeddedCanvas& ). TCanvas * GetCanvas() const; { return fCanvas; }. Int_t GetCanvasWindowId() const; { return fCWinId; }. Bool_t GetAutoFit() const; { return fAutoFit; }. void SetAutoFit(Bool_t fit = kTRUE); { fAutoFit = fit; }. » Author: Fons Rademakers 15/07/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: T",MatchSource.WIKI,root/html528/TRootEmbeddedCanvas.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootEmbeddedCanvas.html
Availability,error,error,"const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEraseStatusBar(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual TGFrame*ExecuteAction(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGMdiFrame*FindEditableMdiFrame(const TGWindow* win); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGuiBldAction*TGuiBuilder::GetAction() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static ULong_tGetBgnd(); static TGGC*GetBgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static",MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
Testability,test,tested,"C header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUIBUILDER; » TRootGuiBuilder. class TRootGuiBuilder: public TGuiBuilder, public TGMainFrame. TRootGuiBuilder. ROOT GUI Builder principles. With the GUI builder, we try to make the next step from WYSIWYG; to embedded editing concept - WYSIWYE (""what you see is what you edit"").; The ROOT GUI Builder allows modifying real GUI objects.; For example, one can edit the existing GUI application created by; $ROOTSYS/tutorials/gui/guitest.C.; GUI components can be added to a design area from a widget palette,; or can be borrowed from another application.; One can drag and and drop TCanvas's menu bar into the application.; GUI objects can be resized and dragged, copied and pasted.; ROOT GUI Builder allows changing the layout, snap to grid, change object's; layout order via the GUI Builder toolbar, or by options in the right-click; context menus.; A final design can be immediatly tested and used, or saved as a C++ macro.; For example, it's possible to rearrange buttons in control bar,; add separators etc. and continue to use a new fancy control bar in the; application. The following is a short description of the GUI Builder actions and key shortcuts:. o Press Ctrl-Double-Click to start/stop edit mode; o Press Double-Click to activate quick edit action (defined in root.mimes). Selection, grabbing, dropping. It is possible to select, drag any frame and drop it to any frame. o Click left mouse button or Ctrl-Click to select an object to edit.; o Press right mouse button to activate context menu; o Mutiple selection (grabbing):; - draw lasso and press Return key; - press Shift key and draw lasso; o Dropping:; - select frame and press Ctrl-Return key; o Changing layout order:; - select frame and use arrow keys to change layout order; o Alignment:; - draw lasso and press arrow keys (or Shift-Arrow key) to align frames. Key shortcuts. o Return - grab selected frames; o C",MatchSource.WIKI,root/html528/TRootGuiBuilder.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html
Availability,error,error,"nt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*TGuiFactory::CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root/html528/TRootGuiFactory.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootGuiFactory.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root/html528/TRootHelpDialog.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootHelpDialog.html
Availability,avail,available,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-10-29 07:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRootIOCtor.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootIOCtor.html
Availability,error,error,"ddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*TSecContext::GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeTSecContext::GetExpDate() const; const char*TSecContext::GetHost() const; virtual const char*TObject::GetIconName() const; const char*TSecContext::GetID() const; Int_tTSecContext::GetMethod() const; const char*TSecContext::GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tTSecContext::GetOffSet() const; virtual Option_t*TObject::GetOption() const; Int_tGetRSAKey() const; TList*TSecC",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
Security,secur,security,"ate:. Int_tfRSAKeyType of RSA key used. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1); Ctor for SecContext object.; User and host from url = user@host . ~TRootSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void DeActivate(Option_t* opt = ""CR""); Set OffSet to -1 and expiring Date to default; Remove from the list; If globus, cleanup local stuff; If Opt contains ""C"" or ""c"", ask for remote cleanup; If Opt contains ""R"" or ""r"", remove from the list; Default Opt=""CR"". Bool_t CleanupSecContext(Bool_t all); Ask remote client to cleanup security context 'ctx'; If 'all', all sec context with the same host as ctx; are cleaned. void Print(Option_t* option = ""F"") const; If opt is ""F"" (default) print object content.; If opt is ""<number>"" print in special form for calls within THostAuth; with cardinality <number>; If opt is ""S"" prints short in-line form for calls within TFTP,; TSlave, TProof ... const char * AsString(TString& out); Returns short string with relevant information about this; security context. TRootSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0, Int_t key = 1). Int_t GetRSAKey() const; { return fRSAKey; }. » Author: G. Ganis 08/07/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootSecContext.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-11-02 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please s",MatchSource.WIKI,root/html528/TRootSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRootSecContext.html
Availability,recover,recover,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Energy Efficiency,efficient,efficient," of quaternion is null, creates identity rotation; if quaternion is non-unit, creates rotation corresponding to the normalized (unit) quaternion. TRotation & Rotate(Double_t , const TVector3& ); rotate along an axis. TRotation & RotateX(Double_t ); rotate around x. TRotation & RotateY(Double_t ); rotate around y. TRotation & RotateZ(Double_t ); rotate around z. TRotation & RotateAxes(const TVector3& newX, const TVector3& newY, const TVector3& newZ); rotate axes. Double_t PhiX() const; return Phi. Double_t PhiY() const; return Phi. Double_t PhiZ() const; return Phi. Double_t ThetaX() const; return Phi. Double_t ThetaY() const; return Theta. Double_t ThetaZ() const; return Theta. void AngleAxis(Double_t& , TVector3& ) const; rotation defined by an angle and a vector. TRotation & SetXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by; doing the explicit rotations. This is slightly less efficient than; directly applying the rotation, but makes the code much clearer. My; presumption is that this code is not going to be a speed bottle neck. TRotation & SetYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. TRotation & RotateXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention. TRotation & RotateYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Integrability,rout,routines,"h::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis);. Rotation of local axes; Member function RotateAxes() adds a rotation of local axes to; the current rotation and returns the result:;   TVector3 newX(0,1,0);;   TVector3 newY(0,0,1);;   TVector3 newZ(1,0,0);;   a.RotateAxes(newX,newY,newZ);; Member functions ThetaX(), ThetaY(), ThetaZ(),; PhiX(), PhiY(),PhiZ() return azimuth and polar; angles of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotat",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Modifiability,variab,variable,"routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   | xx xy xz | | x |;   | y' | = | yx yy yz | | y |;   | z' |   | zx zy zz | | z |; e.g.:;   TVector3 v(1,1,1);;   v = r * v;; You can also use the Transform() member function or the operator; *= of the; TVector3 class:;   TVector3 v;;   TRotation r;;   v.Transform(r);;   v *= r;  //Attention v = r * v. Function Members (Methods); public:. TRotation(); TRotation(const TRotation&); T",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Safety,recover,recover,"of the rotated axes:;   Double_t tx,ty,tz,px,py,pz;;   tx= a.ThetaX();;   ...;   pz= a.PhiZ();. Setting The Rotations; The member function SetToIdentity() will set the rotation object ; to the identity (no rotation).; With a minor caveat, the Euler angles of the rotation may be set using ; SetXEulerAngles() or individually set with SetXPhi(), ; SetXTheta(), and SetXPsi(). These routines set the Euler ; angles using the X-convention which is defined by a rotation about the Z-axis,; about the new X-axis, and about the new Z-axis. This is the convention used; in Landau and Lifshitz, Goldstein and other common physics texts. The ; Y-convention euler angles can be set with SetYEulerAngles(),; SetYPhi(), SetYTheta(), and SetYPsi(). The caveat ; is that Euler angles usually define the rotation of the new coordinate system ; with respect to the original system, however, the TRotation class specifies ; the rotation of the object in the original system (an active rotation). To ; recover the usual Euler rotations (ie. rotate the system not the object), you ; must take the inverse of the rotation.; The member functions SetXAxis(), SetYAxis(), and ; SetZAxis() will create a rotation which rotates the requested axis; of the object to be parallel to a vector. If used with one argument, the ; rotation about that axis is arbitrary. If used with two arguments, the; second variable defines the XY, YZ, or ZX ; respectively. Inverse rotation;   TRotation a,b;;   ...;   b = a.Inverse();  // b is inverse of a, a is unchanged;   b = a.Invert();   // invert a and set b = a. Compound Rotations; The operator * has been implemented in a way that follows the ; mathematical notation of a product of the two matrices which describe the ; two consecutive rotations. Therefore the second rotation should be placed ; first:;   r = r2 * r1;. Rotation of TVector3; The TRotation class provides an operator * which allows to express; a rotation of a TVector3 analog to the mathematical notation;   | x' |   |",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Testability,test,test," xx  xy  xz |; | yx  yy  yz |; | zx  zy  zz |; It describes a so called active rotation, i.e. rotation of objects inside; a static system of coordinates. In case you want to rotate the frame and; want to know the coordinates of objects in the rotated system, you should; apply the inverse rotation to the objects. If you want to transform coordinates; from the rotated frame to the original frame you have to apply the direct; transformation.; A rotation around a specified axis means counterclockwise rotation around; the positive direction of the axis.;  . Declaration, Access, Comparisons;   TRotation r;    // r initialized as identity;   TRotation m(r); // m = r; There is no direct way to to set the matrix elements - to ensure that; a TRotation object always describes a real rotation. But you can get the; values by the member functions XX()..ZZ() or the (,); operator:;   Double_t xx = r.XX();     //  the; same as xx=r(0,0);            xx; = r(0,0);;   if (r==m) {...}          // test for equality;   if (r!=m) {..}           // test for inequality;   if (r.IsIdentity()) {...} // test for identity;  . Rotation around axes; The following matrices desrcibe counterclockwise rotations around coordinate; axes;         | 1   0      ; 0    |; Rx(a) = | 0 cos(a) -sin(a) |;         | 0 sin(a) cos(a) ; |;         | cos(a)  0 sin(a); |; Ry(a) = |   0     1   ; 0   |;         | -sin(a) 0 cos(a) |;         | cos(a) -sin(a) 0 |; Rz(a) = | sin(a) cos(a) 0 |;         |   0     ; 0     1 |; and are implemented as member functions RotateX(), RotateY(); and RotateZ():;   r.RotateX(TMath::Pi()); // rotation around the x-axis. Rotation around arbitary axis; The member function Rotate() allows to rotate around an arbitary vector; (not neccessary a unit one) and returns the result.;   r.Rotate(TMath::Pi()/3,TVector3(3,4,5));; It is possible to find a unit vector and an angle, which describe the; same rotation as the current one:;   Double_t angle;;   TVector3 axis;;   r.GetAngleAxis(angle,axis)",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Usability,clear,clearer," of quaternion is null, creates identity rotation; if quaternion is non-unit, creates rotation corresponding to the normalized (unit) quaternion. TRotation & Rotate(Double_t , const TVector3& ); rotate along an axis. TRotation & RotateX(Double_t ); rotate around x. TRotation & RotateY(Double_t ); rotate around y. TRotation & RotateZ(Double_t ); rotate around z. TRotation & RotateAxes(const TVector3& newX, const TVector3& newY, const TVector3& newZ); rotate axes. Double_t PhiX() const; return Phi. Double_t PhiY() const; return Phi. Double_t PhiZ() const; return Phi. Double_t ThetaX() const; return Phi. Double_t ThetaY() const; return Theta. Double_t ThetaZ() const; return Theta. void AngleAxis(Double_t& , TVector3& ) const; rotation defined by an angle and a vector. TRotation & SetXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention (Landau and Lifshitz, Goldstein, &c) by; doing the explicit rotations. This is slightly less efficient than; directly applying the rotation, but makes the code much clearer. My; presumption is that this code is not going to be a speed bottle neck. TRotation & SetYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. TRotation & RotateXEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the x-convention. TRotation & RotateYEulerAngles(Double_t phi, Double_t theta, Double_t psi); Rotate using the y-convention. void SetXPhi(Double_t ); set XPhi. void SetXTheta(Double_t ); set XTheta. void SetXPsi(Double_t ); set XPsi. void SetYPhi(Double_t ); set YPhi. void SetYTheta(Double_t ); set YTheta. void SetYPsi(Double_t ); set YPsi. Double_t GetXPhi(void); return phi angle. Double_t GetYPhi(void); return YPhi. Double_t GetXTheta(void); return XTheta. Double_t GetYTheta(void); return YTheta. Double_t GetXPsi(void); Get psi angle. Double_t GetYPsi(void); return YPsi. TRotation & SetXAxis(const TVector3& axis, const TVector3& xyPlane); set X axis. TRotation & SetXAxis",MatchSource.WIKI,root/html528/TRotation.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotation.html
Availability,error,error,"theta3, Double_t phi3); virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_t*GetGLMatrix(Double_t* rGLMatrix) const; virtual const char*TObject::GetIconName() const; virtual Double_t*GetMatrix(); virtual const char*TNamed::GetName() const; virtual Int_tGetNumber() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tGetPhi() const; virtual Double_tGetPsi() const; virtual Double_tGetTheta() const; virtual const char*TNamed::GetTitle() const; virtua",MatchSource.WIKI,root/html528/TRotMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotMatrix.html
Safety,detect,detector,". TRotMatrix. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TRotMatrix. class TRotMatrix: public TNamed. Manages a detector rotation matrix. See class TGeometry. Function Members (Methods); public:. TRotMatrix(); TRotMatrix(const TRotMatrix&); TRotMatrix(const char* name, const char* title, Double_t* matrix); TRotMatrix(const char* name, const char* title, Double_t theta, Double_t phi, Double_t psi); TRotMatrix(const char* name, const char* title, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TRotMatrix(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual ",MatchSource.WIKI,root/html528/TRotMatrix.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRotMatrix.html
Availability,error,error," TRWLock(); virtual~TRWLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
Modifiability,variab,variable,"ct::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; Int_tWriteLock(); Int_tWriteUnLock(). protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TRWLock(const TRWLock&); TRWLock&operator=(const TRWLock&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfLockFreerwlock condition variable; TMutexfMutexrwlock mutex; Int_tfReadersnumber of readers; Int_tfWritersnumber of writers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRWLock(); Create reader/write lock. Int_t ReadLock(); Obtain a reader lock. Returns always 0. Int_t ReadUnLock(); Unlock reader lock. Returns -1 if thread was not locked,; 0 if everything ok. Int_t WriteLock(); Obtain a writer lock. Returns always 0. Int_t WriteUnLock(); Unlock writer lock. Returns -1 if thread was not locked,; 0 if everything ok. TRWLock(const TRWLock& ). TRWLock& operator=(const TRWLock& ). virtual ~TRWLock(); { }. » Author: Fons Rademakers 04/01/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TRWLock.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
Security,access,accessed,". TRWLock. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TRWLock. class TRWLock: public TObject. TRWLock. This class implements a reader/writer lock. A rwlock allows; a resource to be accessed by multiple reader threads but only; one writer thread. Function Members (Methods); public:. TRWLock(); virtual~TRWLock(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px",MatchSource.WIKI,root/html528/TRWLock.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TRWLock.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTXMLParser::GetParseCode() const; const char*TXMLParser::GetParseCodeMessage(Int_t parseCode) const; Bool_tTXMLParser::GetReplaceEntities() const; Bool_tTXMLParser::GetStopOn",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
Energy Efficiency,efficient,efficient,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
Integrability,wrap,wraper,". TSAXParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TSAXParser. class TSAXParser: public TXMLParser. TSAXParser. TSAXParser is a subclass of TXMLParser, it is a wraper class to; libxml library. SAX (Simple API for XML) is an event based interface, which doesn't; maintain the DOM tree in memory, in other words, it's much more; efficient for large document. TSAXParserCallback contains a number of callback routines to the; parser in a xmlSAXHandler structure. The parser will then parse the; document and call the appropriate callback when certain conditions; occur. Function Members (Methods); public:. TSAXParser(); virtual~TSAXParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidConnectToHandler(const char* handle",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
Security,validat,validate,"itializeContext(); voidTObject::MakeZombie(); virtual voidTXMLParser::OnValidateError(const TString& message); virtual voidTXMLParser::OnValidateWarning(const TString& message); virtual voidTXMLParser::ReleaseUnderlying(); virtual voidTXMLParser::SetParseCode(Int_t code). private:. TSAXParser(const TSAXParser&); TSAXParser&operator=(const TSAXParser&); virtual Int_tParse(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. _xmlParserCtxt*TXMLParser::fContextparse the xml file; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTXMLParser::fParseCodeto keep track of the errorcodes; Bool_tTXMLParser::fReplaceEntitiesreplace entities; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Bool_tTXMLParser::fStopErrorstop when parse error occurs; Bool_tTXMLParser::fValidateto validate the parse context; TStringTXMLParser::fValidateErrorparse error; TStringTXMLParser::fValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. private:. _xmlSAXHandler*fSAXHandlerlibxml2 SAX handler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndE",MatchSource.WIKI,root/html528/TSAXParser.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSAXParser.html
Availability,error,error,"ddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; void*GetContext() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TDatimeGetExpDate() const; const char*GetHost() const; virtual const char*TObject::GetIconName() const; const char*GetID() const; Int_tGetMethod() const; const char*GetMethodName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffSet() const; virtual Option_t*TObject::GetOption() const; TList*GetSecContextCleanup() const; virtual const char*TObject::GetTitle() const; const char*GetToken() const; virtual UInt_tT",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
Security,secur,security,". TSecContext. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSecContext. class TSecContext: public TObject. TSecContext. Contains details about an established security context; Used by THostAuth. Function Members (Methods); public:. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); virtual~TSecContext(); voidTObject::AbstractMethod(const char* method) const; voidAddForCleanup(Int_t port, Int_t proto, Int_t type); virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*AsString(TString& out); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDeActivate(Option_t* opt = ""CR""); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, co",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
Testability,log,login,"t) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TSecContext(const TSecContext&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TSecContext&operator=(const TSecContext&). private:. voidCleanup(); virtual Bool_tCleanupSecContext(Bool_t all). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TList*fCleanupPoints to list with info for remote cleanup; void*fContextKrb5, Globus: ptr to specific sec context; TDatimefExpDateExpiring date (one sec precision); TStringfHostRemote host name; TStringfIDString identifying uniquely this context; Int_tfMethodAuthentication method used; TStringfMethodNameAuthentication method name; Int_tfOffSetoffset in remote host auth tab file (in bytes); TStringfTokenToken identifying this authentication; TStringfUserRemote login username. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext(const char* user, const char* host, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object. TSecContext(const char* url, Int_t meth, Int_t offset, const char* id, const char* token, TDatime expdate = kROOTTZERO, void* ctx = 0); Ctor for SecContext object.; User and host from url = user@host . TSecContext(const TSecContext& ); copy constructor. TSecContext& operator=(const TSecContext& ); assignement operator. ~TSecContext(); Dtor: delete (deActivate, local/remote cleanup, list removal); all what is still active. void Cleanup(); Cleanup what is still active. void DeActiva",MatchSource.WIKI,root/html528/TSecContext.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContext.html
Availability,error,error,"ecContextCleanup(Int_t port, Int_t proto, Int_t type); virtual~TSecContextCleanup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tGetPort() const; Int_tGetProtocol() const; virtual const char*TObject::GetTitle() const; Int_tGetType() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root/html528/TSecContextCleanup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContextCleanup.html
Security,secur,security,". TSecContextCleanup. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSecContextCleanup. class TSecContextCleanup: public TObject. TSecContext. Contains details about an established security context; Used by THostAuth. Function Members (Methods); public:. TSecContextCleanup(const TSecContextCleanup&); TSecContextCleanup(Int_t port, Int_t proto, Int_t type); virtual~TSecContextCleanup(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*T",MatchSource.WIKI,root/html528/TSecContextCleanup.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSecContextCleanup.html
Availability,error,error,"const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*GetOption() const; virtual TList*GetOutputList() const; static TSelector*GetSelector(const char* filename); virtual Long64_tGetStatus() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObjec",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
Performance,perform,performs,"o functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected events. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all events. When using PROOF Terminate() is call on; the client only. Typically one performs the fits on the produced; histograms or write the histograms to file in this method. WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call GetEntry(entry).; entry is always the local entry number in the current tree.; Assuming that fChain is the pointer to the TChain being processed,; use fChain->GetTree()->GetEntry(entry);. Function Members (Methods); public:. TSelector(); virtual~TSelector(); virtual voidAbort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) c",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
Safety,avoid,avoiding,"attached.; void TSelector::Begin(). This method is called before looping on the; events in the Tree. The user can create his histograms in this; function. When using PROOF Begin() is called on the client only.; Histogram creation should preferable be done in SlaveBegin() in; that case.; void TSelector::SlaveBegin(). This method is called on each PROOF; worker node. The user can create his histograms in this method.; In local mode this method is called on the client too. Bool_t TSelector::Notify(). This method is called at the first entry; of a new file in a chain. Bool_t TSelector::Process(Long64_t entry). This method is called; to process an event. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; Once the entry is in memory one can apply a selection and if the; event is selected histograms can be filled. Processing stops; when this function returns kFALSE. This function combines the; next two functions in one, avoiding to have to maintain state; in the class to communicate between these two functions.; See WARNING below about entry.; This method is used by PROOF.; Bool_t TSelector::ProcessCut(Long64_t entry). This method is called; before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::ProcessFill(Long64_t entry). This method is called; for all selected events. User fills histograms in this function.; This method is obsolete, use Process().; See WARNING below about entry.; void TSelector::SlaveTerminate(). This method is called at the end of; the loop on all PROOF worker nodes. In local mode this method is; called on the client too.; void TSelector::Terminate(). This method is called at the end of; the loop on all events. When using PROOF Terminate() is call on; the clie",MatchSource.WIKI,root/html528/TSelector.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelector.html
Availability,error,error,"onst char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(TSelector* iselector, ClassInfo_t* cl, Bool_t isowner = kTRUE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortGetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; virtual TClass*GetInterpretedClass() const; virtual TSelector*GetInterpretedSelector() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tGe",MatchSource.WIKI,root/html528/TSelectorCint.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorCint.html
Availability,error,error," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Int_tGetAction() const; virtual Bool_tGetCleanElist() const; virtual Int_tGetDimension() const; virtual Long64_tGetDrawFlag() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTSelector::GetEntry(Long64_t, Int_t = 0); virtual const char*TObject::GetIconName() const; Int_tGetMultiplicity() const; virtual const char*TObject::GetName() const; virtual Int_tGetNfill() const; TObject*GetObject() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); TH1*GetOldHistogram()",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
Energy Efficiency,allocate,allocated,"(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n); Set number of entries to estimate variable limits. void TakeAction(); Execute action for object obj fNfill times. void TakeEstimate(); Estimate limits for 1-D, 2-D or 3-D objects. void Terminate(); Called at the end of a loop on a TTree. TSelectorDraw(const TSelectorDraw& ). TSelectorDraw& operator=(const TSelectorDraw& ). Int_t GetAction() const; {return fAction;}. Bool_t GetCleanElist() const; {return fCleanElist;}. Int_t GetDimension() const; {return",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
Modifiability,variab,variability,"char* varexp = """", const char* selection = """"); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual voidInitArrays(Int_t newsize); voidTObject::MakeZombie(). private:. TSelectorDraw(const TSelectorDraw&); TSelectorDraw&operator=(const TSelectorDraw&). Data Members; public:. enum { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tfAction! Action type; Bool_tfCleanElisttrue if original Tree elist must be saved; Int_tfDimensionDimension of the current expression; Long64_tfDraw! Last entry loop number when object was drawn; Int_tfForceReadForce Read flag; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManagerPointer to the formula manager; Int_tfMultiplicityIndicator of the variability of the size of entries; Int_t*fNbins![fDimension] Number of bins per dimension; Int_tfNfill! Total number of histogram fills; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tfOldEstimatevalue of Tree fEstimate when selector is called; TH1*fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries; Long64_tTSelector::fStatusselector status; TTree*fTreePointer to current Tree; TObject*fTreeElistpointer to Tree Event list; Double_t**fVal![fSelectedRows][fDimension] Local buffer fo",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
Security,authoriz,authorized,"Dimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Complex case with multiplicity. void ProcessFillObject(Long64_t entry); Called in the entry loop for all entries accepted by Select.; Case where the only variable returns an object (or pointer to). void SetEstimate(Long64_t n)",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
Usability,simpl,simplest,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Call",MatchSource.WIKI,root/html528/TSelectorDraw.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html
Availability,error,error," char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree* tree); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEntry(Long64_t entry, Int_t getall = 0); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual const char*TSelector::GetOption() const; virtual TList*GetOutputList() const; virtual Long64_tGetSelectedRows() const; static TSelector*TSelector::GetSelector(const char* filename); virtual Long64_tTSelector::GetStatus() const; virtual cons",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
Modifiability,variab,variable,"l_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual Int_tVersion() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TTree*fChain! pointer to the analyzed TTree or TChain; TTreeFormula*fSelectPointer to selection formula; Bool_tfSelectMultipletrue if selection has a variable index; Long64_tfSelectedRowsNumber of selected entries. protected:. TSelector::EAbortTSelector::fAbortabort status; TList*TSelector::fInputlist of objects available during processing; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; Long64_tTSelector::fStatusselector status. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorEntries(TTree* tree = 0, const char* selection = 0). TSelectorEntries(const char* selection). virtual ~TSelectorEntries(). Int_t Version() const; { return 2; }. void Begin(TTree* tree). void SlaveBegin(TTree* tree). void Init(TTree* tree). Bool_t Notify(). Bool_t Process(Long64_t entry). Int_t GetEntry(Long64_t entry, Int_t getall = 0). Long64_t GetSelectedRows() const; { return fSelectedRows; }. void SetOption",MatchSource.WIKI,root/html528/TSelectorEntries.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorEntries.html
Availability,error,error,"voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTList::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTList::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TList::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t",MatchSource.WIKI,root/html528/TSelectorList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorList.html
Performance,cache,cache,":NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTCollection::PrintCollectionHeader(Option_t* option) const. private:. Bool_tCheckDuplicateName(TObject* obj); Bool_tUnsetDirectory(TObject* obj). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t UnsetDirectory(TObject* obj); If the class of obj has the SetDirectory(TDirectory*) method; call it to unset the directory assiciation. The objects in the; selector list or owned by the list and not by the directory that; was active when they were created. Returns true in case of success. Bool_t CheckDuplicateName(TObject* obj); Check for duplicate object names in the list. If an object with; the same name is added then the merge function will fail that will; look up objects in different output lists by name. Returns true; in case name is unique. void AddFirst(TObject* obj); Add at the start of the list. void AddFirst(TObject* obj, Option_t* opt); Add at the",MatchSource.WIKI,root/html528/TSelectorList.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorList.html
Availability,error,error,"TSelectorScalar(const char* name = """", Long64_t val = 0); virtual~TSelectorScalar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TParameter<Long64_t>::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long long&TParameter<Long64_t>::GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidInc(Long_t n = 1); virtual voidTObject::Info(const char* method,",MatchSource.WIKI,root/html528/TSelectorScalar.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSelectorScalar.html
Availability,error,error," TSemaphore(UInt_t initial = 1); virtual~TSemaphore(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
Integrability,synchroniz,synchronize,". TSemaphore. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TSemaphore. class TSemaphore: public TObject. TSemaphore. This class implements a counting semaphore. Use a semaphore; to synchronize threads. Function Members (Methods); public:. TSemaphore(UInt_t initial = 1); virtual~TSemaphore(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; sta",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
Modifiability,variab,variable,"har* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Int_tTryWait(); virtual voidTObject::UseCurrentStyle(); Int_tWait(Int_t millisec = 0); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TSemaphore.h 20882 2007-11-19 11:31:26Z rdm $ ",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
Safety,timeout,timeout,"ual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TSemaphore(const TSemaphore& s); TSemaphore&operator=(const TSemaphore& s). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. TConditionfCondsemaphore condition variable; TMutexfMutexsemaphare mutex; Int_tfValuecounter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSemaphore(UInt_t initial = 1); Create counting semaphore. Int_t Wait(Int_t millisec = 0); If semaphore value is > 0 then decrement it and carry on. If it's; already 0 then block. If millisec > 0, apply a relative timeout; of millisec milliseconds. Returns 0 in case of success, or mutex errno. Int_t TryWait(); If semaphore value is > 0 then decrement it and return 0. If it's; already 0 then return 1 or mutex errno. Int_t Post(); If any threads are blocked in Wait(), wake one of them up and; increment the value of the semaphore. Returns 0 in case of success, or; mutex errno. TSemaphore(const TSemaphore& s). TSemaphore& operator=(const TSemaphore& s). virtual ~TSemaphore(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id: TSemaphore.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSemaphore.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSemaphore.html
Availability,avail,available,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass(",MatchSource.WIKI,root/html528/TSeqCollection.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSeqCollection.html
Availability,error,error,"voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static UChar_tGetAcceptOptions(); UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionLevel() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressGetLocalInetAddress(); virtual Int_tGetLocalPort(); virtual const char*TNamed::GetNam",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
Integrability,protocol,protocol,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t b",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
Performance,perform,performs,". TServerSocket. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TServerSocket. class TServerSocket: public TSocket. TServerSocket. This class implements server sockets. A server socket waits for; requests to come in over the network. It performs some operation; based on that request and then possibly returns a full duplex socket; to the requester. The actual work is done via the TSystem class; (either TUnixSystem or TWinNTSystem). Function Members (Methods); public:. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); virtual~TServerSocket(); voidTObject::AbstractMethod(const char* method) const; virtual TSocket*Accept(UChar_t Opt = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidTSocket::Close(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObje",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
Safety,timeout,timeout,"ic voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual Int_tTSocket::Reconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tRecv(TMessage*&); virtual Int_tRecv(Int_t&, Int_t&); virtual Int_tRecv(char*, Int_t); virtual Int_tRecv(char*, Int_t, Int_t&); virtual Int_tRecvRaw(void*, Int_t, ESendRecvOptions = kDefault); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tTSocket::Select(Int_t interest = kRead, Long_t timeout = -1); virtual Int_tSend(const TMessage&); virtual Int_tSend(Int_t); virtual Int_tSend(Int_t, Int_t); virtual Int_tSend(const char*, Int_t = kMESS_STRING); virtual Int_tSendObject(const TObject*, Int_t = kMESS_OBJECT); virtual Int_tSendRaw(const void*, Int_t, ESendRecvOptions = kDefault); static voidSetAcceptOptions(UChar_t Opt); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTSocket::SetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual Int_tTSocket::SetOption(ESockOptions opt, Int_t val); voidTSocket::SetRemoteProtocol(Int_t rproto); voidTSocket::SetSecContext(TSecContext* ctx); voidTSocket::SetService(const char* service); voidTSocket::SetServType(Int_t st); virtual voidTNamed::SetT",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
Security,authenticat,authentication,"Read; kWrite; };; enum TSocket::EServiceType { kSOCKD; kROOTD; kPROOFD; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TInetAddressTSocket::fAddressremote internet address and port #; TBitsTSocket::fBitsInfobits array to mark TStreamerInfo classes already sent; UInt_tTSocket::fBytesRecvtotal bytes received over this socket; UInt_tTSocket::fBytesSenttotal bytes sent using this socket; Int_tTSocket::fCompresscompression level from 0 (not compressed); TTimeStampTSocket::fLastUsageTime stamp of last usage; TVirtualMutex*TSocket::fLastUsageMtxProtect last usage setting / reading; TInetAddressTSocket::fLocalAddresslocal internet address and port #; TStringTNamed::fNameobject identifier; Int_tTSocket::fRemoteProtocolprotocol of remote daemon; TSecContext*TSocket::fSecContextafter a successful Authenticate call; TSocket::EServiceTypeTSocket::fServTyperemote service type; TStringTSocket::fServicename of service (matches remote port #); Int_tTSocket::fSocketsocket descriptor; Int_tTSocket::fTcpWindowSizeTCP window size (default 65535);; TStringTNamed::fTitleobject title; TList*TSocket::fUUIDslist of TProcessIDs already sent through the socket; TStringTSocket::fUrlneeds this for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TSeqCollection*fSecContextsList of TSecContext with cleanup info; static UChar_tfgAcceptOptDefault accept options; static void*fgSrvAuthClupHook; static void*fgSrvAuthHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TServerSocket(const char* service, Bool_t reuse = kFALSE, Int_t b",MatchSource.WIKI,root/html528/TServerSocket.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TServerSocket.html
Availability,error,error,"cription(); TSessionDescription(const TSessionDescription&); ~TSessionDescription(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root/html528/TSessionDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionDescription.html
Usability,feedback,feedback,"t_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root/html528/TSessionDescription.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionDescription.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
Testability,log,log,"_t parm2); virtual voidTGFrame::SetBackgroundColor(Pixel_t back); virtual voidTGWindow::SetBackgroundPixmap(Pixmap_t pixmap); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTGCompositeFrame::SetCleanup(Int_t mode = kLocalCleanup); voidTGFrame::SetDNDSource(Bool_t onoff); voidTGFrame::SetDNDTarget(Bool_t onoff); virtual voidTGFrame::SetDragType(Int_t type); virtual voidTGFrame::SetDrawOption(Option_t* = """"); virtual voidTGFrame::SetDropType(Int_t type); static voidTObject::SetDtorOnly(void* obj); virtual voidTGCompositeFrame::SetEditable(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetEditDisabled(UInt_t on = 1); virtual voidTGFrame::SetForegroundColor(Pixel_t); voidTGFrame::SetFrameElement(TGFrameElement* fe); virtual voidTGFrame::SetHeight(UInt_t h); virtual voidTGCompositeFrame::SetLayoutBroken(Bool_t on = kTRUE); virtual voidTGCompositeFrame::SetLayoutManager(TGLayoutManager* l); voidSetLocal(Bool_t local = kTRUE); voidSetLogLevel(Int_t log); virtual voidTGCompositeFrame::SetMapSubwindows(Bool_t on); virtual voidTGFrame::SetMaxHeight(UInt_t h); virtual voidTGFrame::SetMaxWidth(UInt_t w); virtual voidTGFrame::SetMinHeight(UInt_t h); virtual voidTGFrame::SetMinWidth(UInt_t w); virtual voidTGWindow::SetName(const char* name); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTGFrame::SetSize(const TGDimension& s); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTGFrame::SetWidth(UInt_t w); virtual voidTGWindow::SetWindowName(const char* name = 0); virtual voidTGFrame::SetX(Int_t x); virtual voidTGFrame::SetY(Int_t y); virtual voidTGCompositeFrame::ShowFrame(TGFrame* f); virtual voidShowMembers(TMemberInspector& insp); voidShutdownSession(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tTGCompositeFrame::TranslateC",MatchSource.WIKI,root/html528/TSessionFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionFrame.html
Availability,error,error,"* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::GetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const;",MatchSource.WIKI,root/html528/TSessionInputFrame.html,root-project,root,v6-32-06,https://root.cern,https://root.cern/root/html528/TSessionInputFrame.html
