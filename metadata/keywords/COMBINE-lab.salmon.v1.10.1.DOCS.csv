quality_attribute,keyword,matched_word,sentence,source,filename,author,repo,version,wiki,url
Availability,avail,available," for clarifying the standards of acceptable; behavior and are expected to take appropriate and fair corrective action in; response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or; reject comments, commits, code, wiki edits, issues, and other contributions; that are not aligned to this Code of Conduct, or to ban temporarily or; permanently any contributor for other behaviors that they deem inappropriate,; threatening, offensive, or harmful. ## Scope. This Code of Conduct applies both within project spaces and in public spaces; when an individual is representing the project or its community. Examples of; representing a project or community include using an official project e-mail; address, posting via an official social media account, or acting as an appointed; representative at an online or offline event. Representation of a project may be; further defined and clarified by project maintainers. ## Enforcement. Instances of abusive, harassing, or otherwise unacceptable behavior may be; reported by contacting the project team at salmon_maintainers@gmail.com. All; complaints will be reviewed and investigated and will result in a response that; is deemed necessary and appropriate to the circumstances. The project team is; obligated to maintain confidentiality with regard to the reporter of an incident.; Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good; faith may face temporary or permanent repercussions as determined by other; members of the project's leadership. ## Attribution. This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,; available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html. [homepage]: https://www.contributor-covenant.org. For answers to common questions about this code of conduct, see; https://www.contributor-covenant.org/faq; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CODE_OF_CONDUCT.md
Energy Efficiency,adapt,adapted," for clarifying the standards of acceptable; behavior and are expected to take appropriate and fair corrective action in; response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or; reject comments, commits, code, wiki edits, issues, and other contributions; that are not aligned to this Code of Conduct, or to ban temporarily or; permanently any contributor for other behaviors that they deem inappropriate,; threatening, offensive, or harmful. ## Scope. This Code of Conduct applies both within project spaces and in public spaces; when an individual is representing the project or its community. Examples of; representing a project or community include using an official project e-mail; address, posting via an official social media account, or acting as an appointed; representative at an online or offline event. Representation of a project may be; further defined and clarified by project maintainers. ## Enforcement. Instances of abusive, harassing, or otherwise unacceptable behavior may be; reported by contacting the project team at salmon_maintainers@gmail.com. All; complaints will be reviewed and investigated and will result in a response that; is deemed necessary and appropriate to the circumstances. The project team is; obligated to maintain confidentiality with regard to the reporter of an incident.; Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good; faith may face temporary or permanent repercussions as determined by other; members of the project's leadership. ## Attribution. This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,; available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html. [homepage]: https://www.contributor-covenant.org. For answers to common questions about this code of conduct, see; https://www.contributor-covenant.org/faq; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CODE_OF_CONDUCT.md
Modifiability,adapt,adapted," for clarifying the standards of acceptable; behavior and are expected to take appropriate and fair corrective action in; response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or; reject comments, commits, code, wiki edits, issues, and other contributions; that are not aligned to this Code of Conduct, or to ban temporarily or; permanently any contributor for other behaviors that they deem inappropriate,; threatening, offensive, or harmful. ## Scope. This Code of Conduct applies both within project spaces and in public spaces; when an individual is representing the project or its community. Examples of; representing a project or community include using an official project e-mail; address, posting via an official social media account, or acting as an appointed; representative at an online or offline event. Representation of a project may be; further defined and clarified by project maintainers. ## Enforcement. Instances of abusive, harassing, or otherwise unacceptable behavior may be; reported by contacting the project team at salmon_maintainers@gmail.com. All; complaints will be reviewed and investigated and will result in a response that; is deemed necessary and appropriate to the circumstances. The project team is; obligated to maintain confidentiality with regard to the reporter of an incident.; Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good; faith may face temporary or permanent repercussions as determined by other; members of the project's leadership. ## Attribution. This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,; available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html. [homepage]: https://www.contributor-covenant.org. For answers to common questions about this code of conduct, see; https://www.contributor-covenant.org/faq; ",MatchSource.DOCS,CODE_OF_CONDUCT.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CODE_OF_CONDUCT.md
Security,attack,attacks,"ledge to making participation in our project and; our community a harassment-free experience for everyone, regardless of age, body; size, disability, ethnicity, sex characteristics, gender identity and expression,; level of experience, education, socio-economic status, nationality, personal; appearance, race, religion, or sexual identity and orientation. ## Our Standards. Examples of behavior that contributes to creating a positive environment; include:. * Focusing on what is best for the community; * Showing empathy towards other community members; * Being respectful of differing viewpoints and experiences; * Using welcoming and inclusive language; * Gracefully accepting constructive criticism. Examples of unacceptable behavior by participants include:. * Trolling, insulting/derogatory comments, and personal or political attacks; * Public or private harassment; * Publishing others' private information, such as a physical or electronic; address (or real name if they are choosing to use a pseudonym), without explicit permission (doxing); * The use of sexualized language or imagery and unwelcome sexual attention or; advances; * Other conduct which could reasonably be considered inappropriate in a; professional setting. ## Our Responsibilities. Project maintainers are responsible for clarifying the standards of acceptable; behavior and are expected to take appropriate and fair corrective action in; response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or; reject comments, commits, code, wiki edits, issues, and other contributions; that are not aligned to this Code of Conduct, or to ban temporarily or; permanently any contributor for other behaviors that they deem inappropriate,; threatening, offensive, or harmful. ## Scope. This Code of Conduct applies both within project spaces and in public spaces; when an individual is representing the project or its community. Examples of; representing a project o",MatchSource.DOCS,CODE_OF_CONDUCT.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CODE_OF_CONDUCT.md
Deployability,release,released,"## Contributing code. Any code that you contribute will be licensed under the GPLv3-license adopted by salmon. However, by contributing; code to this project, you also extend permission for your contribution to be re-licensed under the BSD 3-clause ; license (under which we anticipate Salmon will be released once existing GPL code can be removed). Code contributions should be made via pull requests. Please make all PRs to the _develop_ branch ; of the repository. PRs made to the _master_ branch may be rejected if they cannot be cleanly rebased ; on _develop_. Before you make a PR, please check that:. * Your PR describes the purpose of your commit. Is it fixing a bug, adding functionality, etc.?; * Commit messages have been made using [*conventional commits*](https://www.conventionalcommits.org/en/v1.0.0/) â€” please format all of your commit messages as such.; * Any non-obvious code is documented (we don't yet have formal documentation guidelines yet, so use common sense); ",MatchSource.DOCS,CONTRIBUTING.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CONTRIBUTING.md
Integrability,message,messages,"## Contributing code. Any code that you contribute will be licensed under the GPLv3-license adopted by salmon. However, by contributing; code to this project, you also extend permission for your contribution to be re-licensed under the BSD 3-clause ; license (under which we anticipate Salmon will be released once existing GPL code can be removed). Code contributions should be made via pull requests. Please make all PRs to the _develop_ branch ; of the repository. PRs made to the _master_ branch may be rejected if they cannot be cleanly rebased ; on _develop_. Before you make a PR, please check that:. * Your PR describes the purpose of your commit. Is it fixing a bug, adding functionality, etc.?; * Commit messages have been made using [*conventional commits*](https://www.conventionalcommits.org/en/v1.0.0/) â€” please format all of your commit messages as such.; * Any non-obvious code is documented (we don't yet have formal documentation guidelines yet, so use common sense); ",MatchSource.DOCS,CONTRIBUTING.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CONTRIBUTING.md
Modifiability,extend,extend,"## Contributing code. Any code that you contribute will be licensed under the GPLv3-license adopted by salmon. However, by contributing; code to this project, you also extend permission for your contribution to be re-licensed under the BSD 3-clause ; license (under which we anticipate Salmon will be released once existing GPL code can be removed). Code contributions should be made via pull requests. Please make all PRs to the _develop_ branch ; of the repository. PRs made to the _master_ branch may be rejected if they cannot be cleanly rebased ; on _develop_. Before you make a PR, please check that:. * Your PR describes the purpose of your commit. Is it fixing a bug, adding functionality, etc.?; * Commit messages have been made using [*conventional commits*](https://www.conventionalcommits.org/en/v1.0.0/) â€” please format all of your commit messages as such.; * Any non-obvious code is documented (we don't yet have formal documentation guidelines yet, so use common sense); ",MatchSource.DOCS,CONTRIBUTING.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CONTRIBUTING.md
Usability,guid,guidelines,"## Contributing code. Any code that you contribute will be licensed under the GPLv3-license adopted by salmon. However, by contributing; code to this project, you also extend permission for your contribution to be re-licensed under the BSD 3-clause ; license (under which we anticipate Salmon will be released once existing GPL code can be removed). Code contributions should be made via pull requests. Please make all PRs to the _develop_ branch ; of the repository. PRs made to the _master_ branch may be rejected if they cannot be cleanly rebased ; on _develop_. Before you make a PR, please check that:. * Your PR describes the purpose of your commit. Is it fixing a bug, adding functionality, etc.?; * Commit messages have been made using [*conventional commits*](https://www.conventionalcommits.org/en/v1.0.0/) â€” please format all of your commit messages as such.; * Any non-obvious code is documented (we don't yet have formal documentation guidelines yet, so use common sense); ",MatchSource.DOCS,CONTRIBUTING.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CONTRIBUTING.md
Availability,avail,available,"ment* (accurate but fast-to-compute proxies for traditional read alignments), and ; massively-parallel stochastic collapsed variational inference. The result is a versatile tool that fits nicely; into many different pipelines. For example, you can choose to make use of our *selective-alignment* algorithm by providing Salmon with raw sequencing reads, or, if it is more convenient, you can provide Salmon with regular alignments (e.g. an **unsorted** BAM file with alignments to the transcriptome produced with your favorite aligner), and it will use the same **wicked**-fast, state-of-the-art inference algorithm to estimate transcript-level abundances for your experiment. Give salmon a try! You can find the latest binary releases [here](https://github.com/COMBINE-lab/salmon/releases). The current version number of the master branch of Salmon can be found [**here**](http://combine-lab.github.io/salmon/version_info/latest). Documentation; ==============. The documentation for Salmon is available on [ReadTheDocs](http://readthedocs.org), check it out [here](http://salmon.readthedocs.org). Salmon is, and will continue to be, [freely and actively supported on a best-effort basis](https://oceangenomics.com/about/#open).; If you need industrial-grade technical support, please consider the options at [oceangenomics.com/contact](http://oceangenomics.com/contact). Decoy sequences in transcriptomes; =================================. tl;dr: fast is good but fast and accurate is better!; [Alignment and mapping methodology influence transcript abundance estimation](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02151-8), and accounting for the [accounting for fragments of unexpected origin can improve transcript quantification](https://www.biorxiv.org/content/10.1101/2021.01.17.426996v1). To this end, salmon provides the ability to index both the transcriptome as well as decoy seuqence that can be considered during mapping and quantification. The decoy sequence ac",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Deployability,install,install,"<img alt=""salmon logo"" src=""https://github.com/COMBINE-lab/salmon/raw/master/doc/salmon_logo.png"" width=""600"">. [![Documentation Status](https://readthedocs.org/projects/salmon/badge/?version=latest)](http://salmon.readthedocs.org/en/latest); [![install with bioconda](https://img.shields.io/badge/install%20with-bioconda-brightgreen.svg?style=flat-square)](http://bioconda.github.io/recipes/salmon/README.html); ![GitHub tag (latest SemVer)](https://img.shields.io/github/v/tag/combine-lab/salmon?style=flat-square). **Try out the new [alevin-fry](https://alevin-fry.readthedocs.io/en/latest/) framework for single-cell analysis; tutorials can be found [here](https://combine-lab.github.io/alevin-fry-tutorials/)!**. **Help guide the development of Salmon, [take our survey](https://docs.google.com/forms/d/e/1FAIpQLSeWhBNE_fA_0uVHvbAlAulDmfmowv7rAYla879DZpqCARyRTQ/viewform)**. What is Salmon?; ===============. Salmon is a **wicked**-fast program to produce a highly-accurate, transcript-level quantification estimates from ; RNA-seq data. Salmon achieves its accuracy and speed via a number of different innovations, including the ; use of *selective-alignment* (accurate but fast-to-compute proxies for traditional read alignments), and ; massively-parallel stochastic collapsed variational inference. The result is a versatile tool that fits nicely; into many different pipelines. For example, you can choose to make use of our *selective-alignment* algorithm by providing Salmon with raw sequencing reads, or, if it is more convenient, you can provide Salmon with regular alignments (e.g. an **unsorted** BAM file with alignments to the transcriptome produced with your favorite aligner), and it will use the same **wicked**-fast, state-of-the-art inference algorithm to estimate transcript-level abundances for your experiment. Give salmon a try! You can find the latest binary releases [here](https://github.com/COMBINE-lab/salmon/releases). The current version number of the master branch of",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Energy Efficiency,efficient,efficiently,").; If you need industrial-grade technical support, please consider the options at [oceangenomics.com/contact](http://oceangenomics.com/contact). Decoy sequences in transcriptomes; =================================. tl;dr: fast is good but fast and accurate is better!; [Alignment and mapping methodology influence transcript abundance estimation](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02151-8), and accounting for the [accounting for fragments of unexpected origin can improve transcript quantification](https://www.biorxiv.org/content/10.1101/2021.01.17.426996v1). To this end, salmon provides the ability to index both the transcriptome as well as decoy seuqence that can be considered during mapping and quantification. The decoy sequence accounts for reads that might otherwise be (spuriously) attributed to some annotated transcript. This [tutorial](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/) provides a step-by-step guide on how to efficiently index the reference transcriptome and genome to produce a decoy-aware index. Specifically, there are 3 possible ways in which the salmon index can be created:. * cDNA-only index : salmon_index - https://combine-lab.github.io/salmon/getting_started/. This method will result in the smallest index and require the least resources to build, but will be the most prone to possible spurious alignments. * SA mashmap index: salmon_partial_sa_index - (regions of genome that have high sequence similarity to the transcriptome) - Details can be found in [this README](https://github.com/COMBINE-lab/SalmonTools/blob/master/README.md) and using [this script](https://raw.githubusercontent.com/COMBINE-lab/SalmonTools/master/scripts/generateDecoyTranscriptome.sh). While running mashmap can require considerable resources, the resulting decoy files are fairly small. This will result in an index bigger than the cDNA-only index, but still mucch smaller than the full genome index below. It will conf",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Safety,avoid,avoiding," the most prone to possible spurious alignments. * SA mashmap index: salmon_partial_sa_index - (regions of genome that have high sequence similarity to the transcriptome) - Details can be found in [this README](https://github.com/COMBINE-lab/SalmonTools/blob/master/README.md) and using [this script](https://raw.githubusercontent.com/COMBINE-lab/SalmonTools/master/scripts/generateDecoyTranscriptome.sh). While running mashmap can require considerable resources, the resulting decoy files are fairly small. This will result in an index bigger than the cDNA-only index, but still mucch smaller than the full genome index below. It will confer many, though not all, of the benefits of using the entire genome as a decoy sequence. * SAF genome index: salmon_sa_index - (the full genome is used as decoy) - The tutorial for creating such an index can be found [here](https://combine-lab.github.io/alevin-tutorial/2019/selective-alignment/). This will result in the largest index, but likely does the best job in avoiding spurious alignments to annotated transcripts. . **Facing problems with Indexing?**, Check if anyone else already had this problem in the issues section or fill the index generation [request form](https://forms.gle/3baJc5SYrkSWb1z48). ### **NOTE**:; If you are generating an index to be used for single-cell or single-nucleus quantification with [alevin-fry](https://github.com/COMBINE-lab/alevin-fry), then we recommend you consider building a spliced+intron (_splici_) reference. This serves much of the purpose of a decoy-aware index when quantifying with alevin-fry, while also providing the capability to attribute splicing status to mapped fragments. More details about the _splici_ reference and the Unspliced/Spliced/Ambiguous quantification mode it enables can be found [here](https://combine-lab.github.io/alevin-fry-tutorials/2021/improving-txome-specificity/). Chat live about Salmon; ======================. You can chat with the Salmon developers and other users via Gi",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Testability,log,logo,"<img alt=""salmon logo"" src=""https://github.com/COMBINE-lab/salmon/raw/master/doc/salmon_logo.png"" width=""600"">. [![Documentation Status](https://readthedocs.org/projects/salmon/badge/?version=latest)](http://salmon.readthedocs.org/en/latest); [![install with bioconda](https://img.shields.io/badge/install%20with-bioconda-brightgreen.svg?style=flat-square)](http://bioconda.github.io/recipes/salmon/README.html); ![GitHub tag (latest SemVer)](https://img.shields.io/github/v/tag/combine-lab/salmon?style=flat-square). **Try out the new [alevin-fry](https://alevin-fry.readthedocs.io/en/latest/) framework for single-cell analysis; tutorials can be found [here](https://combine-lab.github.io/alevin-fry-tutorials/)!**. **Help guide the development of Salmon, [take our survey](https://docs.google.com/forms/d/e/1FAIpQLSeWhBNE_fA_0uVHvbAlAulDmfmowv7rAYla879DZpqCARyRTQ/viewform)**. What is Salmon?; ===============. Salmon is a **wicked**-fast program to produce a highly-accurate, transcript-level quantification estimates from ; RNA-seq data. Salmon achieves its accuracy and speed via a number of different innovations, including the ; use of *selective-alignment* (accurate but fast-to-compute proxies for traditional read alignments), and ; massively-parallel stochastic collapsed variational inference. The result is a versatile tool that fits nicely; into many different pipelines. For example, you can choose to make use of our *selective-alignment* algorithm by providing Salmon with raw sequencing reads, or, if it is more convenient, you can provide Salmon with regular alignments (e.g. an **unsorted** BAM file with alignments to the transcriptome produced with your favorite aligner), and it will use the same **wicked**-fast, state-of-the-art inference algorithm to estimate transcript-level abundances for your experiment. Give salmon a try! You can find the latest binary releases [here](https://github.com/COMBINE-lab/salmon/releases). The current version number of the master branch of",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Usability,guid,guide,"<img alt=""salmon logo"" src=""https://github.com/COMBINE-lab/salmon/raw/master/doc/salmon_logo.png"" width=""600"">. [![Documentation Status](https://readthedocs.org/projects/salmon/badge/?version=latest)](http://salmon.readthedocs.org/en/latest); [![install with bioconda](https://img.shields.io/badge/install%20with-bioconda-brightgreen.svg?style=flat-square)](http://bioconda.github.io/recipes/salmon/README.html); ![GitHub tag (latest SemVer)](https://img.shields.io/github/v/tag/combine-lab/salmon?style=flat-square). **Try out the new [alevin-fry](https://alevin-fry.readthedocs.io/en/latest/) framework for single-cell analysis; tutorials can be found [here](https://combine-lab.github.io/alevin-fry-tutorials/)!**. **Help guide the development of Salmon, [take our survey](https://docs.google.com/forms/d/e/1FAIpQLSeWhBNE_fA_0uVHvbAlAulDmfmowv7rAYla879DZpqCARyRTQ/viewform)**. What is Salmon?; ===============. Salmon is a **wicked**-fast program to produce a highly-accurate, transcript-level quantification estimates from ; RNA-seq data. Salmon achieves its accuracy and speed via a number of different innovations, including the ; use of *selective-alignment* (accurate but fast-to-compute proxies for traditional read alignments), and ; massively-parallel stochastic collapsed variational inference. The result is a versatile tool that fits nicely; into many different pipelines. For example, you can choose to make use of our *selective-alignment* algorithm by providing Salmon with raw sequencing reads, or, if it is more convenient, you can provide Salmon with regular alignments (e.g. an **unsorted** BAM file with alignments to the transcriptome produced with your favorite aligner), and it will use the same **wicked**-fast, state-of-the-art inference algorithm to estimate transcript-level abundances for your experiment. Give salmon a try! You can find the latest binary releases [here](https://github.com/COMBINE-lab/salmon/releases). The current version number of the master branch of",MatchSource.DOCS,README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/README.md
Usability,simpl,simply,"Transcript Index Format; =======================. The sorted list (array) is the structure used by our program; to count the k-mers from the reads and it relies on a transcript; index. The index is (currently) simply a sorted array containing; all of the kmers, in encoded (uint64_t) numeric order, that were; seen in the trancsripts. The file format is as follows. ````; kmer_len[uint32_t]; num_kmers[uint32_t]; k_1[uint_64t] . . . k_{num_kmers}[uint64_t]; ````",MatchSource.DOCS,doc/FileFormats.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/FileFormats.md
Deployability,release,release,"# Steps to prepare a release of salmon; -----. 1. Tag corresponding commit of pufferfish so that it can be stably pulled in for source builds.; 2. Alter `fetchPufferfish.sh` to fetch the corresponding tagged version (and update the sha256 sum).; 3. Bump salmon version in `include/SalmonConfig.hpp`, then rebuild and run the `bump_version.sh` script.; 4. Ensure that everything builds cleanly on Linux (taken care of by CI) and OSX.; 5. Merge the develop branch changes into master.; 6. Tag the salmon release with a new version number.; 7. Update the docker tag and build an image for docker hub.; 8. Bump the Bioconda version and build a new Bioconda release.; 9. Add release notes for the tagged master version.; 10. Upload the pre-compiled linux binary (from the CI server) to GitHub.; 11. Place a new version file on the website and update the old one.; 12. (not technically part of release) Reset the relevant changes (steps 1,2) on the develop branch so they now point to a non-tagged pufferfish.; ",MatchSource.DOCS,doc/steps_to_prepare_release.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/steps_to_prepare_release.md
Testability,test,test,# How to run unit test; ```; ./run.sh <PATH to a new Salmon Binary containg Alevin>; ```; # Contents of unit_test_data.tar.gz. * *alevin*; * __alevin.log__: logs of a run of salmon with the test data ; * __counts.mat__: Cell(row)xGene(Column) counts ; * __eq_classes.txt__: Global eqClass ; * *cell* ; * __cell__eq_classes.txt__: EqClass for one Cell ; * __quant.sf__: Abundance of one cell . * *src-py*; * __get_correlation.py__: python script to get correlation of one cell; ,MatchSource.DOCS,tests/README.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/tests/README.md
Availability,down,downloaded,"---; name: Bug report; about: Create a report to help us improve. ---. **Is the bug primarily related to salmon (bulk mode) or alevin (single-cell mode)?**. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Steps and data to reproduce the behavior:. Specifically, please provide at least the following information:. * Which version of salmon was used?; * How was salmon installed (compiled, downloaded executable, through bioconda)?; * Which reference (e.g. transcriptome) was used?; * Which read files were used?; * Which which program options were used?. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**; If applicable, add screenshots or terminal output to help explain your problem. **Desktop (please complete the following information):**; - OS: [e.g. Ubuntu Linux, OSX]; - Version [ If you are on OSX, the output of `sw_vers`. If you are on linux the output of `uname -a` and `lsb_release -a`]. **Additional context**; Add any other context about the problem here.; ",MatchSource.DOCS,.github/ISSUE_TEMPLATE/bug_report.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/.github/ISSUE_TEMPLATE/bug_report.md
Deployability,install,installed,"---; name: Bug report; about: Create a report to help us improve. ---. **Is the bug primarily related to salmon (bulk mode) or alevin (single-cell mode)?**. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Steps and data to reproduce the behavior:. Specifically, please provide at least the following information:. * Which version of salmon was used?; * How was salmon installed (compiled, downloaded executable, through bioconda)?; * Which reference (e.g. transcriptome) was used?; * Which read files were used?; * Which which program options were used?. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**; If applicable, add screenshots or terminal output to help explain your problem. **Desktop (please complete the following information):**; - OS: [e.g. Ubuntu Linux, OSX]; - Version [ If you are on OSX, the output of `sw_vers`. If you are on linux the output of `uname -a` and `lsb_release -a`]. **Additional context**; Add any other context about the problem here.; ",MatchSource.DOCS,.github/ISSUE_TEMPLATE/bug_report.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/.github/ISSUE_TEMPLATE/bug_report.md
Usability,clear,clear,"---; name: Bug report; about: Create a report to help us improve. ---. **Is the bug primarily related to salmon (bulk mode) or alevin (single-cell mode)?**. **Describe the bug**; A clear and concise description of what the bug is. **To Reproduce**; Steps and data to reproduce the behavior:. Specifically, please provide at least the following information:. * Which version of salmon was used?; * How was salmon installed (compiled, downloaded executable, through bioconda)?; * Which reference (e.g. transcriptome) was used?; * Which read files were used?; * Which which program options were used?. **Expected behavior**; A clear and concise description of what you expected to happen. **Screenshots**; If applicable, add screenshots or terminal output to help explain your problem. **Desktop (please complete the following information):**; - OS: [e.g. Ubuntu Linux, OSX]; - Version [ If you are on OSX, the output of `sw_vers`. If you are on linux the output of `uname -a` and `lsb_release -a`]. **Additional context**; Add any other context about the problem here.; ",MatchSource.DOCS,.github/ISSUE_TEMPLATE/bug_report.md,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/.github/ISSUE_TEMPLATE/bug_report.md
Availability,error,errors,"n and analysis of 3' tagged-end single-cell sequencing data. Currently alevin supports the following single-cell protocols:. 1. Drop-seq; 2. 10x-Chromium v1/2/3; 3. inDropV2; 4. CELSeq 1/2; 5. Quartz-Seq2; 6. sci-RNA-seq3. Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools). Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated. Using Alevin; ------------. Alevin requires the following minimal set of necessary input parameters (generally providing the flags *in that order* is recommended):. * ``-l``: library type (same as salmon), we recommend using `ISR` for both Drop-seq and 10x-v2 chemistry.; * ``-1``: CB+UMI file(s), alevin requires the path to the *FASTQ* file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-2` flag.; * ``-2``: Read-sequence file(s), alevin requires the path to the *FASTQ* file containing raw read-sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the ",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Deployability,integrat,integrated,"Alevin; ================. Alevin is a tool --- integrated with the salmon software --- that introduces a family of algorithms for quantification and analysis of 3' tagged-end single-cell sequencing data. Currently alevin supports the following single-cell protocols:. 1. Drop-seq; 2. 10x-Chromium v1/2/3; 3. inDropV2; 4. CELSeq 1/2; 5. Quartz-Seq2; 6. sci-RNA-seq3. Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools). Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated. Using Alevin; ------------. Alevin requires the following minimal set of necessary input parameters (generally providing the flags *in that order* is recommended):. * ``-l``: library type (same as salmon), we recommend using `ISR` for both Drop-seq and 10x-v2 chemistry.; * ``-1``: CB+UMI file(s), alevin requires the path to the *FASTQ* file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-2` flag.; * ``-2``: Read-sequence file(s), alevin requires the path to the *FASTQ* file containing raw ",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Energy Efficiency,adapt,adaptor,"mines what fraction of the maximum; score ``s`` a mapping must achieve to be potentially retained. For a minimum score fraction of ``f``, only; mappings with a score > ``f * s`` will be kept. Mappings with lower scores will be considered as low-quality,; and will be discarded. It is worth noting that mapping validation uses extension alignment. This means that the read need not; map end-to-end. Instead, the score of the mapping will be the position along the alignment with the; highest score. This is the score which must reach the fraction threshold for the read to be considered; as valid. Single-cell protocol specific notes; ------------------------------------. In cases where single-cell protocol supports variable length cellbarcodes, alevin adds nucleotide padding to make the lengths uniform.; Furthermore, the padding scheme ensures that there are no collisions added in the process. The padding scheme is as follows:. 1. sci-RNA-seq3: The barcode is composed of 9-10 bp hairpin adaptor and 10 bp reverse transcription index making it 19-20 bp long. If the bacode is 20 bp long, alevin adds *A* and it adds *AC* if it is 19 bp long. Thus, the length of barcode in the output is 21 bp.; 2. inDropV2: 8-11 bp barcode1 along with 8 bp barcode2 makes up the barcode. For barcode lengths of 16, 17, 18, and 19 bp, alevin adds *AAAC*, *AAG*, *AT*, and *A* respectively. Thus, the length of barcode in the output is 20 bp. Furthermore, the position of barcode1 is dependent on finding exact match of sequence ``w1``. If exact match is not found, a search for ``w1`` is performed allowing a maximum hamming distance 2 b/w ``w1`` and read2 substring of w1 length within the required bounds; the first match is returned. . Output; ------. Typical 10x experiment can range form hundreds to tens of thousand of cells -- resulting in huge size of the count-matrices. Traditionally single-cell tools dumps the Cell-v-Gene count matrix in various formats. Although, this itself is an open area of res",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Integrability,integrat,integrated,"Alevin; ================. Alevin is a tool --- integrated with the salmon software --- that introduces a family of algorithms for quantification and analysis of 3' tagged-end single-cell sequencing data. Currently alevin supports the following single-cell protocols:. 1. Drop-seq; 2. 10x-Chromium v1/2/3; 3. inDropV2; 4. CELSeq 1/2; 5. Quartz-Seq2; 6. sci-RNA-seq3. Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools). Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated. Using Alevin; ------------. Alevin requires the following minimal set of necessary input parameters (generally providing the flags *in that order* is recommended):. * ``-l``: library type (same as salmon), we recommend using `ISR` for both Drop-seq and 10x-v2 chemistry.; * ``-1``: CB+UMI file(s), alevin requires the path to the *FASTQ* file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-2` flag.; * ``-2``: Read-sequence file(s), alevin requires the path to the *FASTQ* file containing raw ",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Modifiability,variab,variable,".; It matters only when ``--validateMappings`` has been passed to Salmon. The maximum; possible score for a fragment is ``ms = read_len * ma`` (or ``ms = (left_read_len + right_read_len) * ma``; for paired-end reads). The argument to ``--minScoreFraction`` determines what fraction of the maximum; score ``s`` a mapping must achieve to be potentially retained. For a minimum score fraction of ``f``, only; mappings with a score > ``f * s`` will be kept. Mappings with lower scores will be considered as low-quality,; and will be discarded. It is worth noting that mapping validation uses extension alignment. This means that the read need not; map end-to-end. Instead, the score of the mapping will be the position along the alignment with the; highest score. This is the score which must reach the fraction threshold for the read to be considered; as valid. Single-cell protocol specific notes; ------------------------------------. In cases where single-cell protocol supports variable length cellbarcodes, alevin adds nucleotide padding to make the lengths uniform.; Furthermore, the padding scheme ensures that there are no collisions added in the process. The padding scheme is as follows:. 1. sci-RNA-seq3: The barcode is composed of 9-10 bp hairpin adaptor and 10 bp reverse transcription index making it 19-20 bp long. If the bacode is 20 bp long, alevin adds *A* and it adds *AC* if it is 19 bp long. Thus, the length of barcode in the output is 21 bp.; 2. inDropV2: 8-11 bp barcode1 along with 8 bp barcode2 makes up the barcode. For barcode lengths of 16, 17, 18, and 19 bp, alevin adds *AAAC*, *AAG*, *AT*, and *A* respectively. Thus, the length of barcode in the output is 20 bp. Furthermore, the position of barcode1 is dependent on finding exact match of sequence ``w1``. If exact match is not found, a search for ``w1`` is performed allowing a maximum hamming distance 2 b/w ``w1`` and read2 substring of w1 length within the required bounds; the first match is returned. . Output; ---",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Performance,perform,performs,"n and analysis of 3' tagged-end single-cell sequencing data. Currently alevin supports the following single-cell protocols:. 1. Drop-seq; 2. 10x-Chromium v1/2/3; 3. inDropV2; 4. CELSeq 1/2; 5. Quartz-Seq2; 6. sci-RNA-seq3. Alevin works under the same indexing scheme (as salmon) for the reference, and consumes the set of FASTA/Q files(s) containing the Cellular Barcode(CB) + Unique Molecule identifier (UMI) in one read file and the read sequence in the other. Given just the transcriptome and the raw read files, alevin generates a cell-by-gene count matrix (in a fraction of the time compared to other tools). Alevin works in two phases. In the first phase it quickly parses the read file containing the CB and UMI information to generate the frequency distribution of all the observed CBs, and creates a lightweight data-structure for fast-look up and correction of the CB. In the second round, alevin utilizes the read-sequences contained in the files to map the reads to the transcriptome, identify potential PCR/sequencing errors in the UMIs, and performs hybrid de-duplication while accounting for UMI collisions. Finally, a post-abundance estimation CB whitelisting procedure is done and a cell-by-gene count matrix is generated. Using Alevin; ------------. Alevin requires the following minimal set of necessary input parameters (generally providing the flags *in that order* is recommended):. * ``-l``: library type (same as salmon), we recommend using `ISR` for both Drop-seq and 10x-v2 chemistry.; * ``-1``: CB+UMI file(s), alevin requires the path to the *FASTQ* file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-2` flag.; * ``-2``: Read-sequence file(s), alevin requires the path to the *FASTQ* file containing raw read-sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the ",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Safety,detect,detection," the user.; The particularly important ones are explained here, but you can always run; ``salmon alevin -h`` to see them all. """"""""""""""""""""""""""""""""""""""""""""""""""""; ``-p`` / ``--numThreads``; """""""""""""""""""""""""""""""""""""""""""""""""""". The number of threads that will be used for quantification. Alevin is designed to work; well with many threads, so, if you have a sufficient number of processors, larger; values here can speed up the run substantially. In our testing we found that usually 10 threads gives the best time-memory trade-off. .. note:: Default number of threads. 	The default behavior is for Alevin to probe the number of available hardware threads and to use this number.; Thus, if you want to use fewer threads (e.g., if you are running multiple; instances of Salmon simultaneously), you will likely want to set this option explicitly in ; accordance with the desired per-process resource usage.; ; """"""""""""""""""""""""; ``--whitelist``; """""""""""""""""""""""". This is an optional argument, where user can explicitly specify the whitelist CB to use for cell detection and CB sequence correction. If not given, alevin generates its own set of putative CBs. .. note:: Not 10x 737k whitelist. This flag does not use the technologically defined whitelisted cellular barcodes provided by 10x, instead it's a per experiment level list of subsampled cellular barcodes that need to quantified for consistency with other tools for example an input would be a file generated by cellranger with the name `barcodes.tsv` (uncompressed). """"""""""""""""""""""""; ``--noQuant``; """""""""""""""""""""""". Generally used in parallel with ``--dumpfq``. If Alevin is passed the ``--noQuant`` option, the pipeline will stop before starting the mapping. The general use-case is when we only need to concatenate the CB on the read-id of the second file and break the execution afterwards. """"""""""""""""""""""""; ``--noDedup``; """""""""""""""""""""""". If Alevin is passed the ``--noDedup`` option, the pipeline only performs CB correction, maps the read-sequences to the transcriptome generat",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Security,expose,exposes,"``lib_B`` are ``lib_B_cb.fq`` and ``lib_B_read.fq``, respectively. The following are both valid; ways to input these reads to alevin::. > salmon alevin -l ISR -1 lib_A_cb.fq lib_B_cb.fq -2 lib_A_read.fq lib_B_read.fq . Similarly, both of these approaches can be adopted if the files are gzipped as well::. > salmon alevin -l ISR -1 lib_A_cb.fq.gz lib_B_cb.fq.gz -2 lib_A_read.fq.gz lib_B_read.fq.gz. .. note:: Don't provide data through input stream; To keep the time-memory trade-off within acceptable bounds, alevin performs multiple passes over the Cellular; Barcode file. Alevin goes through the barcode file once by itself, and then goes through both the barcode and ; read files in unison to assign reads to cells using the initial barcode mapping. Since the pipe or the input ; stream can't be reset to read from the beginning again, alevin can't read in the barcodes, and might crash. Description of important options; --------------------------------. Alevin exposes a number of useful optional command-line parameters to the user.; The particularly important ones are explained here, but you can always run; ``salmon alevin -h`` to see them all. """"""""""""""""""""""""""""""""""""""""""""""""""""; ``-p`` / ``--numThreads``; """""""""""""""""""""""""""""""""""""""""""""""""""". The number of threads that will be used for quantification. Alevin is designed to work; well with many threads, so, if you have a sufficient number of processors, larger; values here can speed up the run substantially. In our testing we found that usually 10 threads gives the best time-memory trade-off. .. note:: Default number of threads. 	The default behavior is for Alevin to probe the number of available hardware threads and to use this number.; Thus, if you want to use fewer threads (e.g., if you are running multiple; instances of Salmon simultaneously), you will likely want to set this option explicitly in ; accordance with the desired per-process resource usage.; ; """"""""""""""""""""""""; ``--whitelist``; """""""""""""""""""""""". This is an optional argument, where ",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Testability,test,testing,"pe (same as salmon), we recommend using `ISR` for both Drop-seq and 10x-v2 chemistry.; * ``-1``: CB+UMI file(s), alevin requires the path to the *FASTQ* file containing CB+UMI raw sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-2` flag.; * ``-2``: Read-sequence file(s), alevin requires the path to the *FASTQ* file containing raw read-sequences to be given under this command line flag. Alevin also supports parsing of data from multiple files as long as the order is the same as in `-1` flag.; * ``--dropseq / --chromium / --chromiumV3``: the protocol, this flag tells the type of single-cell protocol of the input sequencing-library.; * ``-i``: index, file containing the salmon index of the reference transcriptome, as generated by `salmon index` command.; * ``-p``: number of threads, the number of threads which can be used by alevin to perform the quantification, by default alevin utilizes *all* the available threads in the system, although we recommend using ~10 threads which in our testing gave the best memory-time trade-off.; * ``-o``: output, path to folder where the output gene-count matrix (along with other meta-data) would be dumped.; * ``--tgMap``: transcript to gene map file, a tsv (tab-separated) file --- with *no header*, containing two columns mapping of each transcript present in the reference to the corresponding gene (the first column is a transcript and the second is the corresponding gene). Once all the above requirement are satisfied, alevin can be run using the following command::. > salmon alevin -l ISR -1 cb.fastq.gz -2 reads.fastq.gz --chromium -i salmon_index_directory -p 10 -o alevin_output --tgMap txp2gene.tsv. Providing multiple read files to Alevin; ------------. Often, a single library may be split into multiple FASTA/Q files. Also, sometimes one may wish; to quantify multiple replicates or samples together, treating them as if they are one lib",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Usability,learn,learn,"te inferential replicates of the experiemnt, `--numCellBootstraps` has to be paired with `--dumpFeatures` which generates a file with name `quants_boot_mat.gz`. The output format is the same as `quants_mat.gz` and we fit the 3D cube of the cell-inference-gene counts in 2D as follows: if an experiment has C cells, G genes and N inferential replicates; alevin output file `quants_boot_mat.gz` would contain C*N rows and G columns while, starting from the top, the first N rows would represent first cell and it's N inferential replicate. For more information on importing and using inferential replicates for single-cell data in generating accurate differential expression analysis, check out `tximport <https://github.com/mikelove/tximport>`_ and our `Swish <https://www.biorxiv.org/content/10.1101/561084v2>`_ paper. """"""""""""""""""""""""""""""""""""""""""""; ``--debug``; """"""""""""""""""""""""""""""""""""""""""""; Alevin peforms intelligent white-listing downstream of the quantification pipeline and has to make some assumptions like chosing a fraction of reads to learn low confidence CB and in turn might erroneously exit -- if the data results in no mapped or deduplicated reads to a CB in low confidence region. The problem doesnâ€™t happen when provided with external whitelist but if there is an error and the user is aware of this being just a warning, the error can be skipped by running Alevin with this flag. """"""""""""""""""""""""""""""""""""""""""""; ``--minScoreFraction``; """""""""""""""""""""""""""""""""""""""""""". This value controls the minimum allowed score for a mapping to be considered valid.; It matters only when ``--validateMappings`` has been passed to Salmon. The maximum; possible score for a fragment is ``ms = read_len * ma`` (or ``ms = (left_read_len + right_read_len) * ma``; for paired-end reads). The argument to ``--minScoreFraction`` determines what fraction of the maximum; score ``s`` a mapping must achieve to be potentially retained. For a minimum score fraction of ``f``, only; mappings with a score > ``f * s`` will be kept. Mappings",MatchSource.DOCS,doc/source/alevin.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/alevin.rst
Availability,avail,available,"Requirements; ============. Binary Releases; ---------------. Pre-compiled binaries of the latest release of Salmon for a number different; platforms are available available under the `Releases tab; <https://github.com/COMBINE-lab/salmon/releases>`_ of Salmon's `GitHub; repository <https://github.com/COMBINE-lab/salmon>`_. You should be able to; get started quickly by finding a binary from the list that is compatible with; your platform. Additionally, you can obtain a Docker image of the latest version; from DockerHub using:. ::. > docker pull combinelab/salmon; . Requirements for Building from Source; -------------------------------------. * A C++11 conformant compiler (currently tested with GCC>=4.7 and Clang>=3.4); * CMake_. Salmon uses the CMake build system to check, fetch and install; dependencies, and to compile and install Salmon. CMake is available for all; major platforms (though Salmon is currently unsupported on Windows.); ; Installation; ============. After downloading the Salmon source distribution and unpacking it, change into the top-level directory:. ::. > cd salmon. Then, create and out-of-source build directory and change into it:. ::. > mkdir build; > cd build. Salmon makes extensive use of Boost_. We recommend installing the most; recent version (1.55) systemwide if possible. If Boost is not installed on your; system, the build process will fetch, compile and install it locally. However,; if you already have a recent version of Boost available on your system, it make; sense to tell the build system to use that. If you have Boost installed you can tell CMake where to look for it. Likewise,; if you already have `Intel's Threading Building Blocks; <http://threadingbuildingblocks.org/>`_ library installed, you can tell CMake; where it is as well. The flags for CMake are as follows:. * -DFETCH_BOOST=TRUE -- If you don't have Boost installed (or have an older; version of it), you can provide the FETCH_BOOST flag instead of the; BOOST_ROOT variable, whi",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Deployability,release,release,"Requirements; ============. Binary Releases; ---------------. Pre-compiled binaries of the latest release of Salmon for a number different; platforms are available available under the `Releases tab; <https://github.com/COMBINE-lab/salmon/releases>`_ of Salmon's `GitHub; repository <https://github.com/COMBINE-lab/salmon>`_. You should be able to; get started quickly by finding a binary from the list that is compatible with; your platform. Additionally, you can obtain a Docker image of the latest version; from DockerHub using:. ::. > docker pull combinelab/salmon; . Requirements for Building from Source; -------------------------------------. * A C++11 conformant compiler (currently tested with GCC>=4.7 and Clang>=3.4); * CMake_. Salmon uses the CMake build system to check, fetch and install; dependencies, and to compile and install Salmon. CMake is available for all; major platforms (though Salmon is currently unsupported on Windows.); ; Installation; ============. After downloading the Salmon source distribution and unpacking it, change into the top-level directory:. ::. > cd salmon. Then, create and out-of-source build directory and change into it:. ::. > mkdir build; > cd build. Salmon makes extensive use of Boost_. We recommend installing the most; recent version (1.55) systemwide if possible. If Boost is not installed on your; system, the build process will fetch, compile and install it locally. However,; if you already have a recent version of Boost available on your system, it make; sense to tell the build system to use that. If you have Boost installed you can tell CMake where to look for it. Likewise,; if you already have `Intel's Threading Building Blocks; <http://threadingbuildingblocks.org/>`_ library installed, you can tell CMake; where it is as well. The flags for CMake are as follows:. * -DFETCH_BOOST=TRUE -- If you don't have Boost installed (or have an older; version of it), you can provide the FETCH_BOOST flag instead of the; BOOST_ROOT variable, whi",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Integrability,depend,dependencies,"Requirements; ============. Binary Releases; ---------------. Pre-compiled binaries of the latest release of Salmon for a number different; platforms are available available under the `Releases tab; <https://github.com/COMBINE-lab/salmon/releases>`_ of Salmon's `GitHub; repository <https://github.com/COMBINE-lab/salmon>`_. You should be able to; get started quickly by finding a binary from the list that is compatible with; your platform. Additionally, you can obtain a Docker image of the latest version; from DockerHub using:. ::. > docker pull combinelab/salmon; . Requirements for Building from Source; -------------------------------------. * A C++11 conformant compiler (currently tested with GCC>=4.7 and Clang>=3.4); * CMake_. Salmon uses the CMake build system to check, fetch and install; dependencies, and to compile and install Salmon. CMake is available for all; major platforms (though Salmon is currently unsupported on Windows.); ; Installation; ============. After downloading the Salmon source distribution and unpacking it, change into the top-level directory:. ::. > cd salmon. Then, create and out-of-source build directory and change into it:. ::. > mkdir build; > cd build. Salmon makes extensive use of Boost_. We recommend installing the most; recent version (1.55) systemwide if possible. If Boost is not installed on your; system, the build process will fetch, compile and install it locally. However,; if you already have a recent version of Boost available on your system, it make; sense to tell the build system to use that. If you have Boost installed you can tell CMake where to look for it. Likewise,; if you already have `Intel's Threading Building Blocks; <http://threadingbuildingblocks.org/>`_ library installed, you can tell CMake; where it is as well. The flags for CMake are as follows:. * -DFETCH_BOOST=TRUE -- If you don't have Boost installed (or have an older; version of it), you can provide the FETCH_BOOST flag instead of the; BOOST_ROOT variable, whi",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Modifiability,variab,variable,"ows.); ; Installation; ============. After downloading the Salmon source distribution and unpacking it, change into the top-level directory:. ::. > cd salmon. Then, create and out-of-source build directory and change into it:. ::. > mkdir build; > cd build. Salmon makes extensive use of Boost_. We recommend installing the most; recent version (1.55) systemwide if possible. If Boost is not installed on your; system, the build process will fetch, compile and install it locally. However,; if you already have a recent version of Boost available on your system, it make; sense to tell the build system to use that. If you have Boost installed you can tell CMake where to look for it. Likewise,; if you already have `Intel's Threading Building Blocks; <http://threadingbuildingblocks.org/>`_ library installed, you can tell CMake; where it is as well. The flags for CMake are as follows:. * -DFETCH_BOOST=TRUE -- If you don't have Boost installed (or have an older; version of it), you can provide the FETCH_BOOST flag instead of the; BOOST_ROOT variable, which will cause CMake to fetch and build Boost locally. * -DBOOST_ROOT=<boostdir> -- Tells CMake where an existing installtion of Boost; resides, and looks for the appropritate version in <boostdir>. This is the; top-level directory where Boost is installed (e.g. /opt/local). * -DTBB_INSTALL_DIR=<tbbroot> -- Tells CMake where an existing installation of; Intel's TBB is installed (<tbbroot>), and looks for the apropriate headers; and libraries there. This is the top-level directory where TBB is installed; (e.g. /opt/local). * -DCMAKE_INSTALL_PREFIX=<install_dir> -- <install_dir> is the directory to; which you wish Salmon to be installed. If you don't specify this option,; it will be installed locally in the top-level directory (i.e. the directory; directly above ""build""). There are a number of other libraries upon which Salmon depends, but CMake ; should fetch these for you automatically. Setting the appropriate flags, you can the",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Testability,test,tested,"Requirements; ============. Binary Releases; ---------------. Pre-compiled binaries of the latest release of Salmon for a number different; platforms are available available under the `Releases tab; <https://github.com/COMBINE-lab/salmon/releases>`_ of Salmon's `GitHub; repository <https://github.com/COMBINE-lab/salmon>`_. You should be able to; get started quickly by finding a binary from the list that is compatible with; your platform. Additionally, you can obtain a Docker image of the latest version; from DockerHub using:. ::. > docker pull combinelab/salmon; . Requirements for Building from Source; -------------------------------------. * A C++11 conformant compiler (currently tested with GCC>=4.7 and Clang>=3.4); * CMake_. Salmon uses the CMake build system to check, fetch and install; dependencies, and to compile and install Salmon. CMake is available for all; major platforms (though Salmon is currently unsupported on Windows.); ; Installation; ============. After downloading the Salmon source distribution and unpacking it, change into the top-level directory:. ::. > cd salmon. Then, create and out-of-source build directory and change into it:. ::. > mkdir build; > cd build. Salmon makes extensive use of Boost_. We recommend installing the most; recent version (1.55) systemwide if possible. If Boost is not installed on your; system, the build process will fetch, compile and install it locally. However,; if you already have a recent version of Boost available on your system, it make; sense to tell the build system to use that. If you have Boost installed you can tell CMake where to look for it. Likewise,; if you already have `Intel's Threading Building Blocks; <http://threadingbuildingblocks.org/>`_ library installed, you can tell CMake; where it is as well. The flags for CMake are as follows:. * -DFETCH_BOOST=TRUE -- If you don't have Boost installed (or have an older; version of it), you can provide the FETCH_BOOST flag instead of the; BOOST_ROOT variable, whi",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Usability,simpl,simple,"tate version in <boostdir>. This is the; top-level directory where Boost is installed (e.g. /opt/local). * -DTBB_INSTALL_DIR=<tbbroot> -- Tells CMake where an existing installation of; Intel's TBB is installed (<tbbroot>), and looks for the apropriate headers; and libraries there. This is the top-level directory where TBB is installed; (e.g. /opt/local). * -DCMAKE_INSTALL_PREFIX=<install_dir> -- <install_dir> is the directory to; which you wish Salmon to be installed. If you don't specify this option,; it will be installed locally in the top-level directory (i.e. the directory; directly above ""build""). There are a number of other libraries upon which Salmon depends, but CMake ; should fetch these for you automatically. Setting the appropriate flags, you can then run the CMake configure step as; follows:. ::; ; > cmake [FLAGS] .. The above command is the cmake configuration step, which *should* complain if; anything goes wrong. Next, you have to run the build step. Depending on what; libraries need to be fetched and installed, this could take a while; (specifically if the installation needs to install Boost). To start the build,; just run make. ::. > make. If the build is successful, the appropriate executables and libraries should be; created. There are two points to note about the build process. First, if the; build system is downloading and compiling boost, you may see a large number of; warnings during compilation; these are normal. Second, note that CMake has; colored output by default, and the steps which create or link libraries are; printed in red. This is the color chosen by CMake for linking messages, and; does not denote an error in the build process. ; ; Finally, after everything is built, the libraries and executable can be; installed with:. ::; ; > make install. You can test the installation by running. ::. > make test. This should run a simple test and tell you if it succeeded or not. .. _CMake : http://www.cmake.org ; .. _Boost: http://www.boost.org; ",MatchSource.DOCS,doc/source/building.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/building.rst
Availability,down,downstream,"ear in the following order:. +------+--------+-----------------+----+----------+; | Name | Length | EffectiveLength |TPM | NumReads |; +------+--------+-----------------+----+----------+. Each subsequent row describes a single quantification record. The columns have; the following interpretation. * **Name** --- ; This is the name of the target transcript provided in the input transcript database (FASTA file). . * **Length** ---; This is the length of the target transcript in nucleotides. * **EffectiveLength** ---; This is the computed *effective* length of the target transcript. It takes into account ; all factors being modeled that will effect the probability of sampling fragments from; this transcript, including the fragment length distribution and sequence-specific and ; gc-fragment bias (if they are being modeled). * **TPM** ---; This is salmon's estimate of the relative abundance of this transcript in units of Transcripts Per Million (TPM).; TPM is the recommended relative abundance measure to use for downstream analysis. . * **NumReads** --- ; This is salmon's estimate of the number of reads mapping to each transcript that was quantified. It is an ""estimate"" ; insofar as it is the expected number of reads that have originated from each transcript given the structure of the uniquely ; mapping and multi-mapping reads and the relative abundance estimates for each transcript. Command Information File; ------------------------. In the top-level quantification directory, there will be a file called ``cmd_info.json``. This is a; JSON format file that records the main command line parameters with which Salmon was invoked for the ; run that produced the output in this directory. Auxiliary Files; ---------------. The top-level quantification directory will contain an auxiliary directory called ``aux_info`` (unless ; the auxiliary directory name was overridden via the command line). This directory will have a number; of files (and subfolders) depending on how salmon was i",MatchSource.DOCS,doc/source/file_formats.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/file_formats.rst
Integrability,depend,depending,"; TPM is the recommended relative abundance measure to use for downstream analysis. . * **NumReads** --- ; This is salmon's estimate of the number of reads mapping to each transcript that was quantified. It is an ""estimate"" ; insofar as it is the expected number of reads that have originated from each transcript given the structure of the uniquely ; mapping and multi-mapping reads and the relative abundance estimates for each transcript. Command Information File; ------------------------. In the top-level quantification directory, there will be a file called ``cmd_info.json``. This is a; JSON format file that records the main command line parameters with which Salmon was invoked for the ; run that produced the output in this directory. Auxiliary Files; ---------------. The top-level quantification directory will contain an auxiliary directory called ``aux_info`` (unless ; the auxiliary directory name was overridden via the command line). This directory will have a number; of files (and subfolders) depending on how salmon was invoked. """"""""""""""""""""""""""""""""; Meta information; """""""""""""""""""""""""""""""". The auxiliary directory will contain a JSON format file called; ``meta_info.json`` which contains meta information about the run,; including stats such as the number of observed and mapped fragments,; details of the bias modeling etc. If Salmon was run with automatic; inference of the library type (i.e. ``--libType A``), then one; particularly important piece of information contained in this file is; the inferred library type. Most of the information recorded in this; file should be self-descriptive. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""; Unique and ambiguous count file; """""""""""""""""""""""""""""""""""""""""""""""""""""""""""""". The auxiliary directory also contains 2-column tab-separated file called; ``ambig_info.tsv``. This file contains information about the number of; uniquely-mapping reads as well as the total number of ambiguously-mapping reads; for each transcript. This file is provided mostly for explorator",MatchSource.DOCS,doc/source/file_formats.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/file_formats.rst
Testability,log,logarithmic," length of the sub-context exceed the order of the; model at that position) contain a 0. This array can be re-shaped; into a matrix of the appropriate size. Finally, the file contains the marginalized 0:sup:`th`-order; probabilities (i.e. the probability of each nucleotide at each; position in the context). This is stored as a 4-by-context length; matrix. As before, this entry begins with two signed integers that; give the number of rows and columns, followed by an array of doubles; giving the marginal probabilities. The rows are in lexicographic; order. """"""""""""""""""""""""""""""""""""""""""""; Fragment-GC bias files; """""""""""""""""""""""""""""""""""""""""""". If Salmon was run with fragment-GC bias correction enabled, the; auxiliary directory will contain two files named ``expected_gc.gz``; and ``observed_gc.gz``. These are gzipped binary files containing,; respectively, the expected and observed fragment-GC content curves.; These files both have the same form. They consist of a 32-bit signed; int, *dtype* which specifies if the values to follow are in; logarithmic space or not. Then, the file contains two signed integers; of type ``std::ptrdiff`` which give the number of rows and columns of; the matrix to follow. Finally, there is an array of *nrow* by *ncol*; doubles. Each row corresponds to a conditional fragment GC; distribution, and the number of columns is the number of bins in the; learned (or expected) fragment-GC distribution. .. _eq-class-file:. """"""""""""""""""""""""""""""""""""""""""""; Equivalence class file; """""""""""""""""""""""""""""""""""""""""""". If salmon was run with the ``--dumpEq`` option, then a file called ``eq_classes.txt``; will exist in the auxiliary directory. The format of that file is as follows:. ::; ; N (num transcripts); M (num equiv classes); tn_1; tn_2; ...; tn_N; eq_1_size t_11 t_12 ... count; eq_2_size t_21 t_22 ... count. ; That is, the file begins with a line that contains the number of; transcripts (say N) then a line that contains the number of; equivalence classes (say M). It is then followed by N",MatchSource.DOCS,doc/source/file_formats.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/file_formats.rst
Usability,learn,learned,"criptome in more than one way may contribute to multiple library; type counts. **Note**: This file is currently not generated when Salmon; is run in alignment-based mode. """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Fragment length distribution; """""""""""""""""""""""""""""""""""""""""""""""""""""""". The auxiliary directory will contain a file called ``fld.gz``. This; file contains an approximation of the observed fragment length; distribution. It is a gzipped, binary file containing integer counts.; The number of (signed, 32-bit) integers (with machine-native; endianness) is equal to the number of bins in the fragment length; distribution (1,001 by default --- for fragments ranging in length; from 0 to 1,000 nucleotides). """"""""""""""""""""""""""""""""""""""""""""""""""""""""; Sequence-specific bias files; """""""""""""""""""""""""""""""""""""""""""""""""""""""". If sequence-specific bias modeling was enabled, there will be 4 files; in the auxiliary directory named ``obs5_seq.gz``, ``obs3_seq.gz``,; ``exp5_seq.gz``, ``exp5_seq.gz``. These encode the parameters of the; VLMM that were learned for the 5' and 3' fragment ends. Each file; is a gzipped, binary file with the same format. It begins with 3 32-bit signed integers which record the length of the; context (window around the read start / end) that is modeled, follwed; by the length of the context that is to the left of the read and the; length of the context that is to the right of the read. Next, the file contains 3 arrays of 32-bit signed integers (each of which; have a length of equal to the context length recorded above). The first; records the order of the VLMM used at each position, the second records; the *shifts* and the *widths* required to extract each sub-context --- these; are implementation details. Next, the file contains a matrix that encodes all VLMM probabilities.; This starts with two signed integers of type ``std::ptrdiff_t``. This; is a platform-specific type, but on most 64-bit systems should; correspond to a 64-bit signed integer. These numbers denote the number of; rows (*nrow*) and",MatchSource.DOCS,doc/source/file_formats.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/file_formats.rst
Energy Efficiency,adapt,adapt,".. Sailfish documentation master file, created by; sphinx-quickstart on Tue Jul 15 17:48:43 2014.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. Welcome to Salmon's documentation!; =============================================. Contents:. .. toctree::; :maxdepth: 2; ; building.rst; salmon.rst; alevin.rst; file_formats.rst; library_type.rst. Indices and tables; ==================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`. ",MatchSource.DOCS,doc/source/index.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/index.rst
Modifiability,adapt,adapt,".. Sailfish documentation master file, created by; sphinx-quickstart on Tue Jul 15 17:48:43 2014.; You can adapt this file completely to your liking, but it should at least; contain the root `toctree` directive. Welcome to Salmon's documentation!; =============================================. Contents:. .. toctree::; :maxdepth: 2; ; building.rst; salmon.rst; alevin.rst; file_formats.rst; library_type.rst. Indices and tables; ==================. * :ref:`genindex`; * :ref:`modindex`; * :ref:`search`. ",MatchSource.DOCS,doc/source/index.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/index.rst
Integrability,protocol,protocols,".. _FragLibType:. Fragment Library Types; ======================. There are numerous library preparation protocols for RNA-seq that result in; sequencing reads with different characteristics. For example, reads can be; single end (only one side of a fragment is recorded as a read) or paired-end; (reads are generated from both ends of a fragment). Further, the sequencing; reads themselves may be unstranded or strand-specific. Finally, paired-end; protocols will have a specified relative orientation. To characterize the; various different typs of sequencing libraries, we've created a miniature; ""language"" that allows for the succinct description of the many different types; of possible fragment libraries. For paired-end reads, the possible; orientations, along with a graphical description of what they mean, are; illustrated below:. .. image:: ReadLibraryIllustration.png. The library type string consists of three parts: the relative orientation of; the reads, the strandedness of the library, and the directionality of the; reads. The first part of the library string (relative orientation) is only provided if; the library is paired-end. The possible options are:. ::. I = inward; O = outward; M = matching. The second part of the read library string specifies whether the protocol is; stranded or unstranded; the options are:. ::. S = stranded; U = unstranded. If the protocol is unstranded, then we're done. The final part of the library; string specifies the strand from which the read originates in a strand-specific; protocol â€” it is only provided if the library is stranded (i.e. if the; library format string is of the form S). The possible values are:. ::. F = read 1 (or single-end read) comes from the forward strand; R = read 1 (or single-end read) comes from the reverse strand. So, for example, if you wanted to specify a fragment library of strand-specific; paired-end reads, oriented toward each other, where read 1 comes from the; forward strand and read 2 comes from the r",MatchSource.DOCS,doc/source/library_type.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/library_type.rst
Usability,simpl,simpler,"unstranded. If the protocol is unstranded, then we're done. The final part of the library; string specifies the strand from which the read originates in a strand-specific; protocol â€” it is only provided if the library is stranded (i.e. if the; library format string is of the form S). The possible values are:. ::. F = read 1 (or single-end read) comes from the forward strand; R = read 1 (or single-end read) comes from the reverse strand. So, for example, if you wanted to specify a fragment library of strand-specific; paired-end reads, oriented toward each other, where read 1 comes from the; forward strand and read 2 comes from the reverse strand, you would specify ``-l; ISF`` on the command line. This designates that the library being processed has; the type ""ISF"" meaning, **I**\ nward (the relative orientation), **S**\ tranded; (the protocol is strand-specific), **F**\ orward (read 1 comes from the forward; strand). The single end library strings are a bit simpler than their pair-end counter; parts, since there is no relative orientation of which to speak. Thus, the; only possible library format types for single-end reads are ``U`` (for; unstranded), ``SF`` (for strand-specific reads coming from the forward strand); and ``SR`` (for strand-specific reads coming from the reverse strand). A few more examples of some library format strings and their interpretations are:. ::. IU (an unstranded paired-end library where the reads face each other). ::. SF (a stranded single-end protocol where the reads come from the forward strand). ::. OSR (a stranded paired-end protocol where the reads face away from each other,; read1 comes from reverse strand and read2 comes from the forward strand). .. note:: Correspondence to TopHat library types . The popular `TopHat <http://ccb.jhu.edu/software/tophat/index.shtml>`_ RNA-seq ; read aligner has a different convention for specifying the format of the library.; Below is a table that provides the corresponding sailfish/salmon library form",MatchSource.DOCS,doc/source/library_type.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/library_type.rst
Availability,avail,available,"Salmon; ===============. Salmon is a tool for **wicked-fast** transcript quantification from RNA-seq; data. It requires a set of target transcripts (either from a reference or; *de-novo* assembly) to quantify. All you need to run Salmon is a FASTA file; containing your reference transcripts and a (set of) FASTA/FASTQ file(s); containing your reads. Optionally, Salmon can make use of pre-computed; alignments (in the form of a SAM/BAM file) to the transcripts rather than the; raw reads. The **mapping**-based mode of Salmon runs in two phases; indexing and; quantification. The indexing step is independent of the reads, and only needs to; be run once for a particular set of reference transcripts. The quantification; step, obviously, is specific to the set of RNA-seq reads and is thus run more; frequently. For a more complete description of all available options in Salmon,; see below. .. note:: Selective alignment. Selective alignment, first introduced by the ``--validateMappings`` flag; in salmon, and now the default mapping strategy (in version 1.0.0; forward), is a major feature enhancement introduced in recent versions of; salmon. When salmon is run with selective alignment, it adopts a; considerably more sensitive scheme that we have developed for finding the; potential mapping loci of a read, and score potential mapping loci using; the chaining algorithm introduced in minimap2 [#minimap2]_. It scores and; validates these mappings using the score-only, SIMD, dynamic programming; algorithm of ksw2 [#ksw2]_. Finally, we recommend using selective; alignment with a *decoy-aware* transcriptome, to mitigate potential; spurious mapping of reads that actually arise from some unannotated; genomic locus that is sequence-similar to an annotated transcriptome. The; selective-alignment algorithm, the use of a decoy-aware transcriptome, and; the influence of running salmon with different mapping and alignment; strategies is covered in detail in the paper `Alignment and mapping met",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Deployability,release,release,"4-bytes per; nucleotide. While this extra memory usage should normally be minor,; it can nonetheless be controlled with the ``--reduceGCMemory`` option.; This option replaces the per-nucleotide GC count with a rank-select; capable bit vector, reducing the memory overhead from 4-bytes per; nucleotide to ~1.25 bits, while being only marginally slower). """"""""""""""""""""""""""""""""""""""""""; ``--posBias``; """""""""""""""""""""""""""""""""""""""""". Passing the ``--posBias`` flag to Salmon will enable modeling of a; position-specific fragment start distribution. This is meant to model; non-uniform coverage biases that are sometimes present in RNA-seq data; (e.g. 5' or 3' positional bias). Currently, a small and fixed number; of models are learned for different length classes of transcripts, as; is done in Roberts et al. [#roberts]_. *Note*: The positional bias; model is relatively new, and is still undergoing testing. It replaces; the previous `--useFSPD` option, which is now deprecated. This; feature should be considered as *experimental* in the current release. """"""""""""""""""""""""""""""""""""""""""""""""""""""""""; ``--biasSpeedSamp``; """""""""""""""""""""""""""""""""""""""""""""""""""""""""". When evaluating the bias models (the GC-fragment model specifically),; Salmon must consider the probability of generating a fragment of every; possible length (with a non-trivial probability) from every position; on every transcript. This results in a process that is quadratic in; the length of the transcriptome --- though each evaluation itself is; efficient and the process is highly parallelized. It is possible to speed this process up by a multiplicative factor by; considering only every *i*:sup:`th` fragment length, and interpolating; the intermediate results. The ``--biasSpeedSamp`` option allows the; user to set this sampling factor. Larger values speed up effective; length correction, but may decrease the fidelity of bias modeling.; However, reasonably small values (e.g. 10 or less) should have only a; minor effect on the computed effective lengths, and can c",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Energy Efficiency,allocate,allocate," ""at random"". This means, for example, that alignments should ; **not** be sorted by target or position. If your reads or alignments ; do not appear in a random order with respect to the target transcripts,; please randomize / shuffle them before performing quantification with ; Salmon. .. note:: Number of Threads. The number of threads that Salmon can effectively make use of depends ; upon the mode in which it is being run. In alignment-based mode, the; main bottleneck is in parsing and decompressing the input BAM file.; We make use of the `Staden IO <http://sourceforge.net/projects/staden/files/io_lib/>`_ ; library for SAM/BAM/CRAM I/O (CRAM is, in theory, supported, but has not been; thoroughly tested). This means that multiple threads can be effectively used; to aid in BAM decompression. However, we find that throwing more than a ; few threads at file decompression does not result in increased processing; speed. Thus, alignment-based Salmon will only ever allocate up to 4 threads; to file decompression, with the rest being allocated to quantification.; If these threads are starved, they will sleep (the quantification threads ; do not busy wait), but there is a point beyond which allocating more threads; will not speed up alignment-based quantification. We find that allocating ; 8 --- 12 threads results in the maximum speed, threads allocated above this; limit will likely spend most of their time idle / sleeping. For quasi-mapping-based Salmon, the story is somewhat different.; Generally, performance continues to improve as more threads are made; available. This is because the determination of the potential mapping; locations of each read is, generally, the slowest step in; quasi-mapping-based quantification. Since this process is; trivially parallelizable (and well-parallelized within Salmon), more; threads generally equates to faster quantification. However, there may; still be a limit to the return on invested threads, when Salmon can begin; to process fragmen",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Integrability,depend,depends,"_. Using Salmon; ------------. As mentioned above, there are two ""modes"" of operation for Salmon. The first,; requires you to build an index for the transcriptome, but then subsequently; processes reads directly. The second mode simply requires you to provide a; FASTA file of the transcriptome and a ``.sam`` or ``.bam`` file containing a; set of alignments. .. note:: Read / alignment order. Salmon, like eXpress [#express]_, uses a streaming inference method to perform ; transcript-level quantification. One of the fundamental assumptions ; of such inference methods is that observations (i.e. reads or alignments); are made ""at random"". This means, for example, that alignments should ; **not** be sorted by target or position. If your reads or alignments ; do not appear in a random order with respect to the target transcripts,; please randomize / shuffle them before performing quantification with ; Salmon. .. note:: Number of Threads. The number of threads that Salmon can effectively make use of depends ; upon the mode in which it is being run. In alignment-based mode, the; main bottleneck is in parsing and decompressing the input BAM file.; We make use of the `Staden IO <http://sourceforge.net/projects/staden/files/io_lib/>`_ ; library for SAM/BAM/CRAM I/O (CRAM is, in theory, supported, but has not been; thoroughly tested). This means that multiple threads can be effectively used; to aid in BAM decompression. However, we find that throwing more than a ; few threads at file decompression does not result in increased processing; speed. Thus, alignment-based Salmon will only ever allocate up to 4 threads; to file decompression, with the rest being allocated to quantification.; If these threads are starved, they will sleep (the quantification threads ; do not busy wait), but there is a point beyond which allocating more threads; will not speed up alignment-based quantification. We find that allocating ; 8 --- 12 threads results in the maximum speed, threads allocated abov",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Modifiability,enhance,enhancement,"ta. It requires a set of target transcripts (either from a reference or; *de-novo* assembly) to quantify. All you need to run Salmon is a FASTA file; containing your reference transcripts and a (set of) FASTA/FASTQ file(s); containing your reads. Optionally, Salmon can make use of pre-computed; alignments (in the form of a SAM/BAM file) to the transcripts rather than the; raw reads. The **mapping**-based mode of Salmon runs in two phases; indexing and; quantification. The indexing step is independent of the reads, and only needs to; be run once for a particular set of reference transcripts. The quantification; step, obviously, is specific to the set of RNA-seq reads and is thus run more; frequently. For a more complete description of all available options in Salmon,; see below. .. note:: Selective alignment. Selective alignment, first introduced by the ``--validateMappings`` flag; in salmon, and now the default mapping strategy (in version 1.0.0; forward), is a major feature enhancement introduced in recent versions of; salmon. When salmon is run with selective alignment, it adopts a; considerably more sensitive scheme that we have developed for finding the; potential mapping loci of a read, and score potential mapping loci using; the chaining algorithm introduced in minimap2 [#minimap2]_. It scores and; validates these mappings using the score-only, SIMD, dynamic programming; algorithm of ksw2 [#ksw2]_. Finally, we recommend using selective; alignment with a *decoy-aware* transcriptome, to mitigate potential; spurious mapping of reads that actually arise from some unannotated; genomic locus that is sequence-similar to an annotated transcriptome. The; selective-alignment algorithm, the use of a decoy-aware transcriptome, and; the influence of running salmon with different mapping and alignment; strategies is covered in detail in the paper `Alignment and mapping methodology influence transcript abundance estimation <https://genomebiology.biomedcentral.com/articles/10.",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Performance,perform,perform,"for the; purposes of quantification. . The **alignment**-based mode of Salmon does not require indexing. Rather, you can ; simply provide Salmon with a FASTA file of the transcripts and a SAM/BAM file; containing the alignments you wish to use for quantification. Salmon is, and will continue to be, `freely and actively supported on a best-effort basis <https://oceangenomics.com/about/#open>`_.; If you are in need of industrial-grade technical support, please consider the options at `oceangenomics.com/support <https://oceangenomics.com/support>`_. Using Salmon; ------------. As mentioned above, there are two ""modes"" of operation for Salmon. The first,; requires you to build an index for the transcriptome, but then subsequently; processes reads directly. The second mode simply requires you to provide a; FASTA file of the transcriptome and a ``.sam`` or ``.bam`` file containing a; set of alignments. .. note:: Read / alignment order. Salmon, like eXpress [#express]_, uses a streaming inference method to perform ; transcript-level quantification. One of the fundamental assumptions ; of such inference methods is that observations (i.e. reads or alignments); are made ""at random"". This means, for example, that alignments should ; **not** be sorted by target or position. If your reads or alignments ; do not appear in a random order with respect to the target transcripts,; please randomize / shuffle them before performing quantification with ; Salmon. .. note:: Number of Threads. The number of threads that Salmon can effectively make use of depends ; upon the mode in which it is being run. In alignment-based mode, the; main bottleneck is in parsing and decompressing the input BAM file.; We make use of the `Staden IO <http://sourceforge.net/projects/staden/files/io_lib/>`_ ; library for SAM/BAM/CRAM I/O (CRAM is, in theory, supported, but has not been; thoroughly tested). This means that multiple threads can be effectively used; to aid in BAM decompression. However, we find th",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Safety,avoid,avoids,"scriptomic alignments. Salmon expects that the alignment files provided are with respect to the; transcripts given in the corresponding FASTA file. That is, Salmon expects; that the reads have been aligned directly to the transcriptome (like RSEM,; eXpress, etc.) rather than to the genome (as does, e.g. Cufflinks). If you; have reads that have already been aligned to the genome, there are; currently 3 options for converting them for use with Salmon. First, you; could convert the SAM/BAM file to a FAST{A/Q} file and then use the; lightweight-alignment-based mode of Salmon described below. Second, given the converted; FASTA{A/Q} file, you could re-align these converted reads directly to the; transcripts with your favorite aligner and run Salmon in alignment-based; mode as described above. Third, you could use a tool like `sam-xlate <https://github.com/mozack/ubu/wiki>`_; to try and convert the genome-coordinate BAM files directly into transcript ; coordinates. This avoids the necessity of having to re-map the reads. However,; we have very limited experience with this tool so far. .. topic:: Multiple alignment files; ; If your alignments for the sample you want to quantify appear in multiple ; .bam/.sam files, then you can simply provide the Salmon ``-a`` parameter ; with a (space-separated) list of these files. Salmon will automatically ; read through these one after the other quantifying transcripts using the ; alignments contained therein. However, it is currently the case that these; separate files must (1) all be of the same library type and (2) all be; aligned with respect to the same reference (i.e. the @SQ records in the ; header sections must be identical). Description of some important options; -------------------------------------. Salmon exposes a number of useful optional command-line parameters to the user.; The particularly important ones are explained here, but you can always run; ``salmon quant -h`` to see them all. """"""""""""""""""""""""""""""""""""""""""""""""; ``--mimicBT",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Security,validat,validateMappings,"Salmon; ===============. Salmon is a tool for **wicked-fast** transcript quantification from RNA-seq; data. It requires a set of target transcripts (either from a reference or; *de-novo* assembly) to quantify. All you need to run Salmon is a FASTA file; containing your reference transcripts and a (set of) FASTA/FASTQ file(s); containing your reads. Optionally, Salmon can make use of pre-computed; alignments (in the form of a SAM/BAM file) to the transcripts rather than the; raw reads. The **mapping**-based mode of Salmon runs in two phases; indexing and; quantification. The indexing step is independent of the reads, and only needs to; be run once for a particular set of reference transcripts. The quantification; step, obviously, is specific to the set of RNA-seq reads and is thus run more; frequently. For a more complete description of all available options in Salmon,; see below. .. note:: Selective alignment. Selective alignment, first introduced by the ``--validateMappings`` flag; in salmon, and now the default mapping strategy (in version 1.0.0; forward), is a major feature enhancement introduced in recent versions of; salmon. When salmon is run with selective alignment, it adopts a; considerably more sensitive scheme that we have developed for finding the; potential mapping loci of a read, and score potential mapping loci using; the chaining algorithm introduced in minimap2 [#minimap2]_. It scores and; validates these mappings using the score-only, SIMD, dynamic programming; algorithm of ksw2 [#ksw2]_. Finally, we recommend using selective; alignment with a *decoy-aware* transcriptome, to mitigate potential; spurious mapping of reads that actually arise from some unannotated; genomic locus that is sequence-similar to an annotated transcriptome. The; selective-alignment algorithm, the use of a decoy-aware transcriptome, and; the influence of running salmon with different mapping and alignment; strategies is covered in detail in the paper `Alignment and mapping met",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Testability,test,tested,"of the transcriptome and a ``.sam`` or ``.bam`` file containing a; set of alignments. .. note:: Read / alignment order. Salmon, like eXpress [#express]_, uses a streaming inference method to perform ; transcript-level quantification. One of the fundamental assumptions ; of such inference methods is that observations (i.e. reads or alignments); are made ""at random"". This means, for example, that alignments should ; **not** be sorted by target or position. If your reads or alignments ; do not appear in a random order with respect to the target transcripts,; please randomize / shuffle them before performing quantification with ; Salmon. .. note:: Number of Threads. The number of threads that Salmon can effectively make use of depends ; upon the mode in which it is being run. In alignment-based mode, the; main bottleneck is in parsing and decompressing the input BAM file.; We make use of the `Staden IO <http://sourceforge.net/projects/staden/files/io_lib/>`_ ; library for SAM/BAM/CRAM I/O (CRAM is, in theory, supported, but has not been; thoroughly tested). This means that multiple threads can be effectively used; to aid in BAM decompression. However, we find that throwing more than a ; few threads at file decompression does not result in increased processing; speed. Thus, alignment-based Salmon will only ever allocate up to 4 threads; to file decompression, with the rest being allocated to quantification.; If these threads are starved, they will sleep (the quantification threads ; do not busy wait), but there is a point beyond which allocating more threads; will not speed up alignment-based quantification. We find that allocating ; 8 --- 12 threads results in the maximum speed, threads allocated above this; limit will likely spend most of their time idle / sleeping. For quasi-mapping-based Salmon, the story is somewhat different.; Generally, performance continues to improve as more threads are made; available. This is because the determination of the potential mapping; ",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Usability,simpl,simply," salmon with different mapping and alignment; strategies is covered in detail in the paper `Alignment and mapping methodology influence transcript abundance estimation <https://genomebiology.biomedcentral.com/articles/10.1186/s13059-020-02151-8>`_. The use of selective alignment implies the use of range factorization, as mapping; scores become very meaningful with this option. Selective alignment can; improve the accuracy, sometimes considerably, over the faster, but; less-precise mapping algorithm that was previously used. Also, there are a number of ; options and flags that allow the user to control details about how the scoring is ; carried out, including setting match, mismatch, and gap scores, and choosing the minimum ; score below which an alignment will be considered invalid, and therefore not used for the; purposes of quantification. . The **alignment**-based mode of Salmon does not require indexing. Rather, you can ; simply provide Salmon with a FASTA file of the transcripts and a SAM/BAM file; containing the alignments you wish to use for quantification. Salmon is, and will continue to be, `freely and actively supported on a best-effort basis <https://oceangenomics.com/about/#open>`_.; If you are in need of industrial-grade technical support, please consider the options at `oceangenomics.com/support <https://oceangenomics.com/support>`_. Using Salmon; ------------. As mentioned above, there are two ""modes"" of operation for Salmon. The first,; requires you to build an index for the transcriptome, but then subsequently; processes reads directly. The second mode simply requires you to provide a; FASTA file of the transcriptome and a ``.sam`` or ``.bam`` file containing a; set of alignments. .. note:: Read / alignment order. Salmon, like eXpress [#express]_, uses a streaming inference method to perform ; transcript-level quantification. One of the fundamental assumptions ; of such inference methods is that observations (i.e. reads or alignments); are made ""at r",MatchSource.DOCS,doc/source/salmon.rst,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/doc/source/salmon.rst
Availability,avail,available,"1""); list(APPEND TGT_WARN_FLAGS ""-Wno-deprecated-copy""); endif(). set(GCC TRUE). # Put complete static linking on hold for the time-being; # If we're not on OSX, make an attempt to compile everything statically; #if(NOT APPLE); #set(CMAKE_EXE_LINK_FLAGS ""-static""); set(PTHREAD_LIB ""pthread""); #endif(). # If we're on Linux (i.e. not OSX) and we're using; # gcc, then set the -static-libstdc++ flag; if(NOT APPLE); list(APPEND TGT_COMPILE_FLAGS -static-libstdc++); endif(). set(WARNING_IGNORE_FLAGS ""${WARNING_IGNORE_FLAGS} -Wno-unused-local-typedefs""); set(BOOST_TOOLSET ""gcc""); set(BOOST_CONFIGURE_TOOLSET ""--with-toolset=gcc""); set(BCXX_FLAGS ""${CXXSTDFLAG} ${SCHAR_FLAG}""); set(BOOST_EXTRA_FLAGS toolset=gcc cxxflags=${BCXX_FLAGS}); # Tentatively, we support clang now; elseif(""${CMAKE_CXX_COMPILER_ID}"" MATCHES ""Clang""); set(CLANG TRUE); # If we have libc++, then try and use it; include(CheckCXXCompilerFlag); check_cxx_compiler_flag(-stdlib=libc++ HAVE_LIBCPP); if(HAVE_LIBCPP); message(""It appears that you're compiling with clang and that libc++ is available, so I'll use that""); list(APPEND TGT_COMPILE_FLAGS -stdlib=libc++); set(BOOST_TOOLSET ""clang""); set(BOOST_CONFIGURE_TOOLSET ""--with-toolset=clang""); set(BCXX_FLAGS ""-stdlib=libc++ -DBOOST_HAS_INT128 ${SCHAR_FLAG}""); set(BOOST_EXTRA_FLAGS toolset=clang cxxflags=${BCXX_FLAGS} linkflags=""-stdlib=libc++""); # Otherwise, use libstdc++ (and make it static); else(); list(APPEND TGT_COMPILE_FLAGS -static-libstdc++); endif(); # There's currently a bug with clang-3.4 & Boost 1.55 -- this hack fixes it; # but we should do something better (does this break things if CPU doesn't; # have 128-bit support)?; list(APPEND TGT_COMPILE_FLAGS -DBOOST_HAS_INT128). if(APPLE); set(NON_APPLECLANG_LIBS """"); else(); set(PTHREAD_LIB ""pthread""); endif(); else(); message(FATAL_ERROR ""Your C++ compiler does not support C++14.""); endif(). if(DO_QUIET_MAKE); set(QUIET_MAKE ""--silent""); else(); set(QUIET_MAKE """"); endif(). ## TODO: Figure out how to det",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Deployability,install,install,"dif(). ## Prefer static to dynamic libraries; if(NOT USE_SHARED_LIBS); set(CMAKE_FIND_LIBRARY_SUFFIXES .a ${CMAKE_FIND_LIBRARY_SUFFIXES}); set(MALLOC_STATIC_BUILD_FLAG ""--enable-static""); endif(). include(CheckIPOSupported). set(THREADS_PREFER_PTHREAD_FLAG ON); find_package(Threads REQUIRED). set(ICU_LIBS """"); set(ICU_INC_DIRS """"). set(CMAKE_CXX_STANDARD 14); set(CMAKE_CXX_STANDARD_REQUIRED ON); set(CMAKE_CXX_EXTENSIONS OFF); set(CXXSTDFLAG ""-std=c++14""); set(GCCVERSION ""5.2""). if(CONDA_BUILD); message(""Building with CONDA_BUILD flag""); if(APPLE); # Do we require all these components? Any others?; find_package(ICU COMPONENTS data i18n io uc REQUIRED); if(ICU_FOUND); message(STATUS ""ICU_INCLUDE_DIRS = ${ICU_INCLUDE_DIRS}""); message(STATUS ""ICU_LIBRARIES = ${ICU_LIBRARIES}""); endif(); set(ICU_INC_DIRS ${ICU_INCLUDE_DIRS}); set(ICU_LIBS ${ICU_LIBRARIES}); endif(); endif(). set(BOOST_CXX_FLAGS ""${WARNING_IGNORE_FLAGS} ${CXXSTDFLAG}""); if(FETCH_BOOST); set(BOOST_CXX_FLAGS ""${BOOST_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}/external/install/include -L${CMAKE_CURRENT_SOURCE_DIR}/external/install/lib""); endif(). ##; # OSX is strange (some might say, stupid in this regard). Deal with it's quirkines here.; ##; if(APPLE); # To allow ourselves to build a dynamic library, we have to tell the compiler; # that, yes, the symbols will be around at runtime.; list(APPEND TGT_COMPILE_FLAGS ""-undefined dynamic_lookup;-Wno-unused-command-line-argument""); # set(LIBSALMON_LINKER_FLAGS ""-all_load""); # In order to ""think different"", we also have to use non-standard suffixes; # for our shared libraries; set(SHARED_LIB_EXTENSION ""dylib""); else(); # We're in sane linux world; set(SHARED_LIB_EXTENSION ""so""); set(LIBSALMON_LINKER_FLAGS """"); endif(). set( BOOST_EXTRA_FLAGS ""--layout=tagged"" ); ## this get's set differently below if we; ## are on clang & apple; set(NON_APPLECLANG_LIBS gomp). if(UNIX AND NOT APPLE); set(LIBRT rt); endif(). set(PTHREAD_LIB). ##; # Let us check the sha sum of our pacakge",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Integrability,message,message,"cmake_minimum_required(VERSION 3.15). if(DEFINED ENV{CC}); set(CC $ENV{CC}); else(); set(CC gcc); endif(); message(""CC: ${CC}""). set(CC_VERSION """"); if(${CC} MATCHES ^gcc-); string(REGEX REPLACE ""gcc-"" """" CC_VERSION ${CC}); endif(); message(""CC version: ${CC_VERSION}""). enable_testing(). project(Salmon). # detect host architecture ; if(NOT DEFINED USE_ARM); if(CMAKE_SYSTEM_PROCESSOR MATCHES ""^(aarch64.*|AARCH64.*|arm64.*|ARM64.*)""); message(""Detected 64-bit ARM host. Setting USE_ARM to true.""); set(USE_ARM TRUE); # set char to be signed; add_compile_options(-fsigned-char); set(SCHAR_FLAG ""-fsigned-char""); else(); message(""Detected non-ARM host. Setting USE_ARM to false.""); set(USE_ARM FALSE); set(SCHAR_FLAG """"); endif(); endif(). option(USE_SHARED_LIBS ""Use shared instead of static libraries"" OFF). # auto-populate version:; # from https://stackoverflow.com/questions/47066115/cmake-get-version-from-multi-line-text-file; file(READ ""current_version.txt"" ver). string(REGEX MATCH ""VERSION_MAJOR ([0-9]*)"" _ ${ver}); set(ver_major ${CMAKE_MATCH_1}). string(REGEX MATCH ""VERSION_MINOR ([0-9]*)"" _ ${ver}); set(ver_minor ${CMAKE_MATCH_1}). string(REGEX MATCH ""VERSION_PATCH ([0-9]*)"" _ ${ver}); set(ver_patch ${CMAKE_MATCH_1}). set(CPACK_PACKAGE_VERSION_MAJOR ${ver_major}); set(CPACK_PACKAGE_VERSION_MINOR ${ver_minor}); set(CPACK_PACKAGE_VERSION_PATCH ${ver_patch}). set(CPACK_PACKAGE_VERSION ""${ver_major}.${ver_minor}.${ver_patch}""); message(""version: ${CPACK_PACKAGE_VERSION}""). set(PROJECT_VERSION ${CPACK_PACKAGE_VERSION}); set(CPACK_GENERATOR ""TGZ""); set(CPACK_SOURCE_GENERATOR ""TGZ""); set(CPACK_PACKAGE_VENDOR ""University of Maryland""); set(CPACK_PACKAGE_DESCRIPTION_SUMMARY ""Salmon - Wicked-fast RNA-seq isoform quantification using selective alignment""); set(CPACK_PACKAGE_NAME; ""${CMAKE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}""); set(CPACK_SOURCE_PACKAGE_FILE_NAME; ""${CMAKE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MA",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Modifiability,variab,variable,"KE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}-Source""). set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ""${CMAKE_SOURCE_DIR}/cmake/Modules/""). # Set a default build type if none was specified; set(default_build_type ""Release""). if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES); message(STATUS ""Setting build type to '${default_build_type}' as none was specified.""); set(CMAKE_BUILD_TYPE ""${default_build_type}"" CACHE; STRING ""Choose the type of build."" FORCE); # Set the possible values of build type for cmake-gui; #set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS; # ""Debug"" ""Release""); endif(). message(STATUS ""CMAKE_BUILD_TYPE = ${CMAKE_BUILD_TYPE}""). ## Set the standard required compile flags; set(REMOVE_WARNING_FLAGS ""-Wno-unused-function;-Wno-unused-local-typedefs""); set(TGT_COMPILE_FLAGS ""${SCHAR_FLAG};-ftree-vectorize;-funroll-loops;-fPIC;-fomit-frame-pointer;-O3;-DNDEBUG;-DSTX_NO_STD_STRING_VIEW;-D__STDC_FORMAT_MACROS""); set(TGT_WARN_FLAGS ""-Wall;-Wno-unknown-pragmas;-Wno-reorder;-Wno-unused-variable;-Wreturn-type;-Werror=return-type;${REMOVE_WARNING_FLAGS}""); #set(CMAKE_C_FLAGS ""${CMAKE_C_FLAGS} -fsanitize=address""); #set(CMAKE_CXX_FLAGS ""${CMAKE_CXX_FLAGS} -fsanitize=address""). ###; # Sanitizers BEGIN; ###; if (ASAN_BUILD); list(APPEND TGT_COMPILE_FLAGS ""-fsanitize=address""); #list(APPEND TGT_COMPILE_FLAGS ""-fsanitize=undefined""); #set(CMAKE_LINK_FLAGS ""-fsanitize=address""); #list(APPEND CMAKE_LINK_FLAGS ""-fsanitize=undefined""); set(ASAN_LIB ""asan""); else(); set(ASAN_LIB """"); endif(); ###; # Sanitizers END; ###. if(APPLE); set(WARNING_IGNORE_FLAGS ""-Wno-deprecated-register""); list(APPEND TGT_WARN_FLAGS -Wno-deprecated-register); else(); set(WARNING_IGNORE_FLAGS """"); endif(). ## Prefer static to dynamic libraries; if(NOT USE_SHARED_LIBS); set(CMAKE_FIND_LIBRARY_SUFFIXES .a ${CMAKE_FIND_LIBRARY_SUFFIXES}); set(MALLOC_STATIC_BUILD_FLAG ""--enable-static""); endif(). include(CheckIPOSupported). se",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Safety,detect,detect,"cmake_minimum_required(VERSION 3.15). if(DEFINED ENV{CC}); set(CC $ENV{CC}); else(); set(CC gcc); endif(); message(""CC: ${CC}""). set(CC_VERSION """"); if(${CC} MATCHES ^gcc-); string(REGEX REPLACE ""gcc-"" """" CC_VERSION ${CC}); endif(); message(""CC version: ${CC_VERSION}""). enable_testing(). project(Salmon). # detect host architecture ; if(NOT DEFINED USE_ARM); if(CMAKE_SYSTEM_PROCESSOR MATCHES ""^(aarch64.*|AARCH64.*|arm64.*|ARM64.*)""); message(""Detected 64-bit ARM host. Setting USE_ARM to true.""); set(USE_ARM TRUE); # set char to be signed; add_compile_options(-fsigned-char); set(SCHAR_FLAG ""-fsigned-char""); else(); message(""Detected non-ARM host. Setting USE_ARM to false.""); set(USE_ARM FALSE); set(SCHAR_FLAG """"); endif(); endif(). option(USE_SHARED_LIBS ""Use shared instead of static libraries"" OFF). # auto-populate version:; # from https://stackoverflow.com/questions/47066115/cmake-get-version-from-multi-line-text-file; file(READ ""current_version.txt"" ver). string(REGEX MATCH ""VERSION_MAJOR ([0-9]*)"" _ ${ver}); set(ver_major ${CMAKE_MATCH_1}). string(REGEX MATCH ""VERSION_MINOR ([0-9]*)"" _ ${ver}); set(ver_minor ${CMAKE_MATCH_1}). string(REGEX MATCH ""VERSION_PATCH ([0-9]*)"" _ ${ver}); set(ver_patch ${CMAKE_MATCH_1}). set(CPACK_PACKAGE_VERSION_MAJOR ${ver_major}); set(CPACK_PACKAGE_VERSION_MINOR ${ver_minor}); set(CPACK_PACKAGE_VERSION_PATCH ${ver_patch}). set(CPACK_PACKAGE_VERSION ""${ver_major}.${ver_minor}.${ver_patch}""); message(""version: ${CPACK_PACKAGE_VERSION}""). set(PROJECT_VERSION ${CPACK_PACKAGE_VERSION}); set(CPACK_GENERATOR ""TGZ""); set(CPACK_SOURCE_GENERATOR ""TGZ""); set(CPACK_PACKAGE_VENDOR ""University of Maryland""); set(CPACK_PACKAGE_DESCRIPTION_SUMMARY ""Salmon - Wicked-fast RNA-seq isoform quantification using selective alignment""); set(CPACK_PACKAGE_NAME; ""${CMAKE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}""); set(CPACK_SOURCE_PACKAGE_FILE_NAME; ""${CMAKE_PROJECT_NAME}-${CPACK_PACKAGE_VERSION_MA",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Testability,test,tests,"if CPU doesn't; # have 128-bit support)?; list(APPEND TGT_COMPILE_FLAGS -DBOOST_HAS_INT128). if(APPLE); set(NON_APPLECLANG_LIBS """"); else(); set(PTHREAD_LIB ""pthread""); endif(); else(); message(FATAL_ERROR ""Your C++ compiler does not support C++14.""); endif(). if(DO_QUIET_MAKE); set(QUIET_MAKE ""--silent""); else(); set(QUIET_MAKE """"); endif(). ## TODO: Figure out how to detect this automatically; # If the ""assembler"" is too old, tell TBB not to compile; # with -mrtm; if(NO_RTM); set(TBB_CXXFLAGS ""-mno-rtm""); endif(). include(ExternalProject). if(CMAKE_BUILD_TYPE MATCHES Debug); message(""Making Debug build""); elseif(CMAKE_BUILD_TYPE MATCHES Release); message(""Making Release build""); else(); message(""Making Default build type""); endif(). ##; # Record this top-level path; ##; set(GAT_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}). # Have CMake tell us what it's doing; # set(CMAKE_VERBOSE_MAKEFILE true). ###; # check if numeric_limits<__int128_t> is defined; ###; try_compile(HAVE_INT128_NUMERIC_LIMITS ${CMAKE_BINARY_DIR} ; SOURCES ${GAT_SOURCE_DIR}/tests/compile_tests/int128_numeric_limits.cpp; CXX_STANDARD 14; CXX_STANDARD_REQUIRED ON ; ); if(HAVE_INT128_NUMERIC_LIMITS); message(""setting -DHAVE_NUMERIC_LIMITS128""); list(APPEND TGT_COMPILE_FLAGS ""-DHAVE_NUMERIC_LIMITS128""); else(); message(""not setting -DHAVE_NUMERIC_LIMITS128""); endif(). ###; #; # Grab pufferfish source --- DURING CONFIGURE TIME!; #; ####; if(NOT FETCHED_PUFFERFISH); exec_program(${CMAKE_CURRENT_SOURCE_DIR}/scripts/fetchPufferfish.sh RETURN_VALUE FETCH_PF_SCRIPT_RET); message(STATUS ""fetch PUFFERFISH exit code ${FETCH_PF_SCRIPT_RET}""); if(NOT (FETCH_PF_SCRIPT_RET EQUAL 0)); message(FATAL_ERROR ""Could not fetch pufferfish source [fetchPufferfish.sh returned exit code ${FETCH_PF_SCRIPT_RET}].""); endif(); set(FETCHED_PUFFERFISH TRUE CACHE BOOL ""Has pufferfish been fetched?"" FORCE); endif(). ##; # Super-secret override; ##; if( DEFINED CUSTOM_BOOST_PATH ); set(CMAKE_INCLUDE_PATH ${CUSTOM_BOOST_PATH} ${CMAKE_INCLUD",MatchSource.DOCS,CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/CMakeLists.txt
Availability,echo,echo,"l -add_rpath ${GAT_SOURCE_DIR}/external/install/lib ${GAT_SOURCE_DIR}/build/src/unitTests; # ); # endif(); #else(); # # related to complete static linking --- on hold ; # set (BOOST_THREAD_LIBRARY); #endif(). #if (APPLE); #	add_custom_command(TARGET salmon; #		POST_BUILD; #		COMMAND install_name_tool -add_rpath ${GAT_SOURCE_DIR}/external/install/lib salmon; #	COMMAND install_name_tool -add_rpath @executable_path/../lib salmon; #		); #endif(). ##### ======================================. IF(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT); SET(CMAKE_INSTALL_PREFIX; ""${GAT_SOURCE_DIR}"" CACHE PATH ""Default install prefix"" FORCE; ); ENDIF(CMAKE_INSTALL_PREFIX_INITIALIZED_TO_DEFAULT). set(INSTALL_LIB_DIR lib ); set(INSTALL_BIN_DIR bin ); set(INSTALL_INCLUDE_DIR include ). if(TBB_RECONFIGURE OR TBB_TARGET_EXISTED); #set(TBB_SOURCE_DIR $<TARGET_FILE:TBB::tbb>); #add_custom_target(genexdebug COMMAND ${CMAKE_COMMAND} -E echo ""$<TARGET_LINKER_FILE:TBB::tbb>""); get_target_property(TBB_LIB_INSTALL_NAME TBB::tbb IMPORTED_LOCATION_RELEASE); get_filename_component(TBB_LIB_INSTALL_DIR ${TBB_LIB_INSTALL_NAME} DIRECTORY); message(""TBB_LIB_INSTALL_DIR = ${TBB_LIB_INSTALL_DIR}""); file(GLOB TBB_FILES ${TBB_LIB_INSTALL_DIR}/libtbb*.${SHARED_LIB_EXTENSION}*); message(""TBBGLOBS = ${TBB_FILES}""). install(FILES ; ${TBB_FILES}; DESTINATION ${INSTALL_LIB_DIR}; ) ; #install(FILES ; # $<TARGET_FILE:TBB::tbbmalloc>; # DESTINATION ${INSTALL_LIB_DIR}; #); #install(DIRECTORY; # ${TBB_SOURCE_DIR}; # DESTINATION ${INSTALL_LIB_DIR}; #	 FILES_MATCHING PATTERN ""libtbb*.${SHARED_LIB_EXTENSION}*""; #); endif(). #install(DIRECTORY; # ${GAT_SOURCE_DIR}/external/install/lib/; # DESTINATION ${INSTALL_LIB_DIR}; #	 FILES_MATCHING PATTERN ""libtbb*.${SHARED_LIB_EXTENSION}*""; # ). # install(FILES ${Boost_LIBRARIES}; # 	 DESTINATION ${INSTALL_LIB_DIR}). install(TARGETS salmon salmon_core; RUNTIME DESTINATION bin; LIBRARY DESTINATION lib; ARCHIVE DESTINATION lib; ). add_custom_command(TARGET unitTests POST_BUILD; COMMAND ",MatchSource.DOCS,src/CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/src/CMakeLists.txt
Deployability,install,install,"if(${TBB_FOUND}); get_target_property(TBB_INCLUDE_DIRS TBB::tbb INTERFACE_INCLUDE_DIRECTORIES); endif(). include_directories(; ${GAT_SOURCE_DIR}/include; ${GAT_SOURCE_DIR}/include/eigen3; ${GAT_SOURCE_DIR}/external; ${GAT_SOURCE_DIR}/external/cereal/include; ${GAT_SOURCE_DIR}/external/install/include; ${ZLIB_INCLUDE_DIR}; ${TBB_INCLUDE_DIRS}; ${Boost_INCLUDE_DIRS}; ${GAT_SOURCE_DIR}/external/install/include; ${GAT_SOURCE_DIR}/external/install/include/pufferfish; ${GAT_SOURCE_DIR}/external/install/include/pufferfish/digestpp; ${LIB_GFF_INCLUDE_DIR}; #${GAT_SOURCE_DIR}/external/install/include/rapmap; #${GAT_SOURCE_DIR}/external/install/include/rapmap/digestpp; ${ICU_INC_DIRS}; ). set ( SALMON_MAIN_SRCS; EMUtils.cpp; CollapsedEMOptimizer.cpp; ## PUFF_INTEGRATION; CollapsedCellOptimizer.cpp; ##; CollapsedGibbsSampler.cpp; Salmon.cpp; BuildSalmonIndex.cpp; Graph.cpp; ## PUFF_INTEGRATION; DedupUMI.cpp; Alevin.cpp; AlevinHash.cpp; SalmonAlevin.cpp; WhiteList.cpp; ##; SalmonQuantify.cpp; FragmentLengthDistribution.cpp; FragmentStartPositionDistribution.cpp; # SequenceBiasModel.cpp; GZipWriter.cpp; SalmonQuantMerge.cpp; ProgramOptionsGenerator.cpp; ). set (SALMON_ALIGN_SRCS; FASTAParser.cpp; AlignmentModel.cpp; ONTAlignmentModel.cpp; AlignmentCommon.cpp; FragmentLengthDistribution.cpp; SalmonQuantifyAlignments.cpp; BAMUtils.cpp; ). set (ALEVIN_LIB_SRCS; edlib.cpp; SingleCellProtocols.cpp; AlevinUtils.cpp; ). set (SALMON_LIB_SRCS; ${GAT_SOURCE_DIR}/src/jellyfish/mer_dna.cc; backtrace.cc; xxhash.c; TranscriptGroup.cpp; EffectiveLengthStats.cpp; LibraryFormat.cpp; GenomicFeature.cpp; VersionChecker.cpp; SBModel.cpp; FastxParser.cpp; StadenUtils.cpp; SalmonUtils.cpp; DistributionUtils.cpp; SalmonExceptions.cpp; SalmonStringUtils.cpp; SimplePosBias.cpp; SGSmooth.cpp; ${GAT_SOURCE_DIR}/external/install/src/pufferfish/metro/metrohash64.cpp; ). # check if we know how to do IPO; check_ipo_supported(RESULT HAS_IPO). if (DEFINED NO_IPO); message(""NO_IPO = ${NO_IPO}""); else(); message(""",MatchSource.DOCS,src/CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/src/CMakeLists.txt
Integrability,message,message,"fy.cpp; FragmentLengthDistribution.cpp; FragmentStartPositionDistribution.cpp; # SequenceBiasModel.cpp; GZipWriter.cpp; SalmonQuantMerge.cpp; ProgramOptionsGenerator.cpp; ). set (SALMON_ALIGN_SRCS; FASTAParser.cpp; AlignmentModel.cpp; ONTAlignmentModel.cpp; AlignmentCommon.cpp; FragmentLengthDistribution.cpp; SalmonQuantifyAlignments.cpp; BAMUtils.cpp; ). set (ALEVIN_LIB_SRCS; edlib.cpp; SingleCellProtocols.cpp; AlevinUtils.cpp; ). set (SALMON_LIB_SRCS; ${GAT_SOURCE_DIR}/src/jellyfish/mer_dna.cc; backtrace.cc; xxhash.c; TranscriptGroup.cpp; EffectiveLengthStats.cpp; LibraryFormat.cpp; GenomicFeature.cpp; VersionChecker.cpp; SBModel.cpp; FastxParser.cpp; StadenUtils.cpp; SalmonUtils.cpp; DistributionUtils.cpp; SalmonExceptions.cpp; SalmonStringUtils.cpp; SimplePosBias.cpp; SGSmooth.cpp; ${GAT_SOURCE_DIR}/external/install/src/pufferfish/metro/metrohash64.cpp; ). # check if we know how to do IPO; check_ipo_supported(RESULT HAS_IPO). if (DEFINED NO_IPO); message(""NO_IPO = ${NO_IPO}""); else(); message(""NO_IPO = FALSE""); set(NO_IPO FALSE); endif(). if(HAS_IPO AND (NOT NO_IPO)); set_property(TARGET ksw2pp PROPERTY INTERPROCEDURAL_OPTIMIZATION True); endif(). set (UNIT_TESTS_ENTRY_SRCS; ${GAT_SOURCE_DIR}/tests/UnitTests.cpp; ). set (UNIT_TESTS_INDIVIDUAL_SRCS; ${GAT_SOURCE_DIR}/src/FragmentLengthDistribution.cpp; ${GAT_SOURCE_DIR}/external/install/src/pufferfish/rank9b.cpp; ${GAT_SOURCE_DIR}/tests/GCSampleTests.cpp; ${GAT_SOURCE_DIR}/tests/LibraryTypeTests.cpp; ). link_directories(; ${GAT_SOURCE_DIR}/lib; ${GAT_SOURCE_DIR}/external/install/lib; ${Boost_LIBRARY_DIRS}; ${TBB_LIBRARY_DIRS}; ${LAPACK_LIBRARY_DIR}; ${BLAS_LIBRARY_DIR}; ${LIB_GFF_LIBRARY_DIR}; ). message(""TBB_LIBRARIES = ${TBB_LIBRARIES}""). # Set the RPATH; if (NOT APPLE); set(CMAKE_INSTALL_RPATH ""$ORIGIN/../lib:$ORIGIN/../../lib:$ORIGIN/:$ORIGIN/../../external/install/lib""); set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE); else(); # use, i.e. do not skip the full RPATH for the build tree; set(CMAKE_SKIP_BUILD_RPATH FALS",MatchSource.DOCS,src/CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/src/CMakeLists.txt
Testability,test,tests,"STAParser.cpp; AlignmentModel.cpp; ONTAlignmentModel.cpp; AlignmentCommon.cpp; FragmentLengthDistribution.cpp; SalmonQuantifyAlignments.cpp; BAMUtils.cpp; ). set (ALEVIN_LIB_SRCS; edlib.cpp; SingleCellProtocols.cpp; AlevinUtils.cpp; ). set (SALMON_LIB_SRCS; ${GAT_SOURCE_DIR}/src/jellyfish/mer_dna.cc; backtrace.cc; xxhash.c; TranscriptGroup.cpp; EffectiveLengthStats.cpp; LibraryFormat.cpp; GenomicFeature.cpp; VersionChecker.cpp; SBModel.cpp; FastxParser.cpp; StadenUtils.cpp; SalmonUtils.cpp; DistributionUtils.cpp; SalmonExceptions.cpp; SalmonStringUtils.cpp; SimplePosBias.cpp; SGSmooth.cpp; ${GAT_SOURCE_DIR}/external/install/src/pufferfish/metro/metrohash64.cpp; ). # check if we know how to do IPO; check_ipo_supported(RESULT HAS_IPO). if (DEFINED NO_IPO); message(""NO_IPO = ${NO_IPO}""); else(); message(""NO_IPO = FALSE""); set(NO_IPO FALSE); endif(). if(HAS_IPO AND (NOT NO_IPO)); set_property(TARGET ksw2pp PROPERTY INTERPROCEDURAL_OPTIMIZATION True); endif(). set (UNIT_TESTS_ENTRY_SRCS; ${GAT_SOURCE_DIR}/tests/UnitTests.cpp; ). set (UNIT_TESTS_INDIVIDUAL_SRCS; ${GAT_SOURCE_DIR}/src/FragmentLengthDistribution.cpp; ${GAT_SOURCE_DIR}/external/install/src/pufferfish/rank9b.cpp; ${GAT_SOURCE_DIR}/tests/GCSampleTests.cpp; ${GAT_SOURCE_DIR}/tests/LibraryTypeTests.cpp; ). link_directories(; ${GAT_SOURCE_DIR}/lib; ${GAT_SOURCE_DIR}/external/install/lib; ${Boost_LIBRARY_DIRS}; ${TBB_LIBRARY_DIRS}; ${LAPACK_LIBRARY_DIR}; ${BLAS_LIBRARY_DIR}; ${LIB_GFF_LIBRARY_DIR}; ). message(""TBB_LIBRARIES = ${TBB_LIBRARIES}""). # Set the RPATH; if (NOT APPLE); set(CMAKE_INSTALL_RPATH ""$ORIGIN/../lib:$ORIGIN/../../lib:$ORIGIN/:$ORIGIN/../../external/install/lib""); set(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE); else(); # use, i.e. do not skip the full RPATH for the build tree; set(CMAKE_SKIP_BUILD_RPATH FALSE). # when building, don't use the install RPATH already; # (but later on when installing); set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE) . # the RPATH to be used when installing; set(CMAKE_INSTALL_RPATH ",MatchSource.DOCS,src/CMakeLists.txt,COMBINE-lab,salmon,v1.10.1,https://combine-lab.github.io/salmon,https://github.com/COMBINE-lab/salmon/tree/v1.10.1/src/CMakeLists.txt
